window.TILE_VERSION = { "ditu": { "normal": { "version": "088", "updateDate": "20250212" }, "satellite": { "version": "009", "updateDate": "20250212" }, "normalTraffic": { "version": "081", "updateDate": "20250212" }, "satelliteTraffic": { "version": "083", "updateDate": "20250212" }, "mapJS": { "version": "104", "updateDate": "20250212" }, "satelliteStreet": { "version": "083", "updateDate": "20250212" }, "earthVector": { "version": "001", "updateDate": "20250212" } }, "webapp": { "high_normal": { "version": "001", "updateDate": "20250212" }, "lower_normal": { "version": "002", "updateDate": "20250212" } }, "api_for_mobile": { "vector": { "version": "002", "updateDate": "20250212" }, "vectorIcon": { "version": "002", "updateDate": "20250212" } } }; window.MSV = { "mapstyle": { "version": "001", "updateDate": "20241224" } }; window.BMAP_AUTHENTIC_KEY = "1XjLLEhZhQNUzd93EjU5nOGQ";
(function (t) {
    "use strict"; function e(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function n(t, e) { return t(e = { exports: {} }, e.exports), e.exports } Object.values || (Object.values = function (t) { if (t !== Object(t)) throw new TypeError("Object.values called on a non-object"); var e, n = []; for (e in t) Object.prototype.hasOwnProperty.call(t, e) && n.push(t[e]); return n }), "function" != typeof Object.assign && Object.defineProperty(Object, "assign", { value: function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), n = 0; n < (arguments.length <= 1 ? 0 : arguments.length - 1); n++) { var r = n + 1 < 1 || arguments.length <= n + 1 ? void 0 : arguments[n + 1]; if (null != r) for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]) } return e }, writable: !0, configurable: !0 }); var r = n((function (t) { function e(n) { return t.exports = e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, t.exports.__esModule = !0, t.exports.default = t.exports, e(n) } t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports })), i = e(r), o = e(n((function (t) { function e(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } t.exports = function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), Object.defineProperty(t, "prototype", { writable: !1 }), t }, t.exports.__esModule = !0, t.exports.default = t.exports }))), a = e(n((function (t) { t.exports = function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }, t.exports.__esModule = !0, t.exports.default = t.exports }))), s = n((function (t) { function e(n, r) { return t.exports = e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t }, t.exports.__esModule = !0, t.exports.default = t.exports, e(n, r) } t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports })); e(s); var u, h, c = e(n((function (t) { t.exports = function (t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, s(t, e) }, t.exports.__esModule = !0, t.exports.default = t.exports }))), l = function (t, e) { var n = this; this.width = void 0, this.height = void 0, this.equals = function (t) { return t && n.width === t.width && n.height === t.height }, this.width = t || 0, this.height = e || 0 }, f = function () { function t(t, e) { this.lng = void 0, this.lat = void 0, this.lng = +t, this.lat = +e } return t.prototype.equals = function (t) { return t && this.lat === t.lat && this.lng === t.lng }, t }(), d = { REFRESH: "refresh", DATA_LOADED: "dataload", THUMB_LOADED: "thumb_loaded", SET_POV: "set_pov", POV_CHANGED: "pov_changed", POV_CHANGED_END: "pov_changed_end", ZOOM_CHANGED: "zoom_changed", SIZE_CHANGED: "size_changed", SET_ID: "set_id", SET_POSITION: "set_position", ID_CHANGED: "id_changed", POSITION_CHANGED: "position_changed", TOUCH_START: "touchstart", TOUCH_END: "touchend", CLICK: "click", DOUBLE_CLICK: "dblclick", LINK_CLICK: "link_click", OVERLAY_ADD: "overlay_add", OVERLAY_REMOVE: "overlay_remove", OVERLAYS_CLEAR: "overlays_clear", PANO_ERROR: "pano_error", LINK_VISIBLE_CHANGE: "links_visible_changed", DESTROY: "destroy", SCENE_CHANGE_END: "scene_change_end" }, p = { TYPE_INNER: "inter", TYPE_STREET: "street", RADIUS: 3e3, COLS: 16, ROWS: 8, TILE_MAX_ZOOM: 4, TILE_MIN_ZOOM: 1, MIN_PITCH: -90, MAX_PITCH: 90, MAX_ZOOM: 4, MIN_ZOOM: 1, TILE_BASE_URLS: ["//apisv0.bdimg.com/", "//apisv1.bdimg.com/"], TOPO_ARROW_TEXTURE: "//webmap0.bdimg.com/wolfman/static/pano/images/webgl/topo_arrow_06f0f2e.png", FISHEYE_DURATION: 1500, FISHEYE_DELAY: 2e3 }, v = (u = {}, h = (navigator.userAgent || "").toLowerCase(), u.isAndroid = h.includes("android"), u.isFirefox = h.includes("firefox"), u.isIos = /ip(hone|ad|od)/i.test(h), u.isWeixin = h.includes("micromessenger"), u.isWeibo = h.includes("weibo"), u.isWeChatOrWeiBo = u.isWeixin && u.isWeibo, u.isBaiduMap = h.includes("baidumap_"), u.isMobile = /android|webos|ip(hone|ad|od)|opera (mini|mobi|tablet)|iemobile|windows.+(phone|touch)|mobile|fennec|kindle (Fire)|Silk|maemo|blackberry|playbook; (touch|kbd)|Symbian(OS)|Ubuntu Touch/i.test(h), u.isPc = !u.isMobile, u), m = function (t) { for (var e = arguments.length <= 1 ? 0 : arguments.length - 1, n = 0; n < e; n++) { var r = n + 1 < 1 || arguments.length <= n + 1 ? void 0 : arguments[n + 1]; for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]) } return t }, g = function (t) { return t * Math.PI / 180 }, y = function (t) { return 180 * t / Math.PI }, _ = function (t) { return t - 360 * Math.floor(t / 360) }, x = function () { return Date.now() }; var b = function t() { var e = t; if ("boolean" == typeof e._supportWebGL) return e._supportWebGL; if (!window.WebGLRenderingContext) return e._supportWebGL = !1, !1; var n = null, r = document.createElement("canvas"); try { (n = r.getContext("webgl") || r.getContext("experimental-webgl")) && n instanceof WebGLRenderingContext && (e._supportWebGL = !0) } catch (t) { e._supportWebGL = !1 } return null === n && (e._supportWebGL = !1), e._supportWebGL }, M = function (t) { for (var e, n = Number.MAX_VALUE, r = -Number.MAX_VALUE, i = t.length - 1; i >= 0; i--)n > (e = t[i]) && (n = e), r < e && (r = e); return { min: n, max: r } }, w = { g: function (t) { return "string" == typeof t || t instanceof String ? document.getElementById(t) : t && t.nodeName && (1 === t.nodeType || 9 === t.nodeType) ? t : null }, show: function (t) { var e = w.g(t); return e && (e.style.display = ""), e }, hide: function (t) { var e = w.g(t); return e && (e.style.display = "none"), t }, create: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = document.createElement(t); for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && n.setAttribute(r, e[r]); return n }, getCurrentStyle: function (t) { return window.getComputedStyle(t, null) } }; function E() { var t, e, n = function (t, e) { var n, r, i = "eii", o = "dac", a = "hem", s = "llm", u = function (t, e) { return t + e }, h = "constructor", c = function (t, e) { return t(e) }, l = function (t, e) { return t + e }; function f(t, e) { for (var n = i; "mill" !== n;)switch (n) { case "llm": return c; case "eii": var r = t.length; n = o; break; case a: for (var u = 0; u < r; u++) { var h = e(t[u]); c.push(h) } n = s; break; case "dac": var c = []; n = a } } var d = decodeURIComponent; b = "de", r = l("fr", "o") + "m", n = l("Co", b); var p = function (t) { return u(t, "")[h][u(r, "Char") + n](t) }, v = function (t) { return f(t, (function (t) { return c(p, t) })) }, m = v.call(p, [39, 34, 37, 96, 60, 120, 97, 65, 98, 66, 99, 67, 100, 68, 101, 69, 102, 70, 103, 110, 109, 111, 112, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]), g = f([28782, 27702, 26416, 25167, 24183], (function (t) { return c(d, t) })), y = v.call(g, [22354, 22749, 24415, 23346, 22257, 22688, 24306, 25174, 23595, 25547, 22984, 25690, 22212, 27547, 21594, 27210, 23090, 29193, 22394, 29368, 29532, 29459, 29530, 24146, 24500, 26352, 27441, 28788, 29370, 27673, 26925, 25249, 24430]), _ = {}; g = c(v, g); for (var x = new RegExp(g.join("|")), b = 0; b < m.length; b++)_[y[b]] = m[b]; return e = f(e.split(""), (function (t) { return _[t] || t })).join(""), f(e.split(x), (function (t) { return d(t) })) }(0, "su尫stri犸坺幷囄獜呚囄獜扏su尫str氶h廲廲呚l灮i犸囄呚墠O娲氶呚呚廲廲廲朰墠h姈i囄朰彟曰氙si坺犸彟欱殛"); t = n, e = 265, function (e) { for (; --e;)t.push(t.shift()) }(++e); var r = function (t, e) { return n[t -= 0] }; return function (t) { var e = { dmedm: "F5L2O6R6AD8990O", haael: function (t, e) { return t + e }, eeaaa: function (t, e) { return t(e) }, xhcid: function (t, e) { return t + e }, deiic: function (t, e) { return t - e } }, n = e[r("0x0")], i = t[r("0x1")](e[r("0x2")](t[r("0x3")]("?"), 1)), o = e[r("0x4")](md5, e[r("0x5")](md5(i + n), "H0A9P8P7Y6ABQO0")); return r("0x6") + o[r("0x7")](e.deiic(o.length, 12)) } } var T = function (t, e, n) { var r, o, a = "", s = [], u = "jsonp" + Math.ceil(1e5 * Math.random()), h = t.indexOf("?") > 0 ? "&" : "?"; for (var c in n = Object.assign({}, { jsonpCallback: "jsonp", timeout: 5e4, jsonp: "callback" }, n), e) ({}).hasOwnProperty.call(e, c) && (a = "object" === i(e[c]) ? c + "=" + JSON.stringify(e[c]) : c + "=" + e[c], s.push(a)); function l() { r.parentNode && r.parentNode.removeChild(r), window[u] = null } return t += h + s.join("&"), o = document.getElementsByTagName("script")[0] || document.head, t = t + "&" + n.jsonp + "=" + u, t += E()(t), (r = document.createElement("script")).src = t, r.type = "text/javascript", o.parentNode.appendChild(r, o), new Promise((function (t, e) { window[u] = function (e) { if (e && "string" == typeof e) try { e = JSON.parse(e) } catch (t) { e = {}, console.error("[ERROR] Parse Error.") } t(e), l() }, r.onerror = function (t) { l(), e({ errno: -2, errmsg: "[ERROR] Load Error: ".concat(t), data: {} }) } })) }, A = function () { function t() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this._size = 0, this._cache = void 0, this.keyList = [], this._options = void 0, this._size = t, this._cache = new window.Map; var n = { clearCallback: null }; this._options = Object.assign({}, n, e) } var e = t.prototype; return e.setData = function (t, e) { 0 !== this._size && (this._cache.size >= this._size && this._removeOld(), this._cache.has(t) || this.keyList.push(t), this._cache.set(t, e)) }, e.getData = function (t) { return this._cache.get(t) }, e._removeOld = function () { for (var t = Math.round(.6 * this._size), e = 0; e < t; e++) { var n = this.keyList[e]; this._options.clearCallback && this._options.clearCallback(this.getData(n)), this._cache.delete(n) } this.keyList.splice(0, t) }, e.clear = function () { this._cache.clear(), this.keyList = [] }, o(t, [{ key: "cacheCount", get: function () { return this._cache.size } }]), t }(), C = function () { function t() { var t = this; this.rid = "", this.roadName = "", this.roadWidth = 5, this.isCurrentRoad = 0, this.pointList = [], this.getTopoInRoad = function (e) { var n = [], r = t.pointList, i = r.length, o = t.getPointByPanoId(e); if (!o || i <= 1) return n; var a = o.order; return 0 === a ? n.push(t.generateTopoData(o.dir, r[1])) : a === i - 1 ? n.push(t.generateTopoData(r[a - 1].dir + 180, r[a - 1])) : (n.push(t.generateTopoData((r[a - 1].dir + 180) % 360, r[a - 1])), n.push(t.generateTopoData(r[a].dir, r[a + 1]))), n }, this.getPointByPanoId = function (e) { for (var n, r = t.pointList, i = 0, o = r.length; i < o; i++)if (r[i].panoId === e) { n = r[i]; break } return n } } return t.prototype.generateTopoData = function (t, e) { return void 0 !== e && (e.topoDir = t, e.roadName = this.roadName), e }, t }(), R = function () { var t = this; this.image = void 0, this.panoId = "", this.iid = "", this.panoType = "", this.panoX = 0, this.panoY = 0, this.panoZ = 0, this.heading = 0, this.pitch = 0, this.defaultHeading = void 0, this.defaultPitch = void 0, this.northDir = 0, this.fixHeading = 0, this.fixPitch = 0, this.fixRoll = 0, this.deviceHeight = 0, this.date = "20130822", this.time = "", this.provider = 1, this.admission = "GS(2013)6021", this.photos = [], this.roadName = "", this.roads = [], this.vpoints = [], this.topoArray = void 0, this.currentRoad = void 0, this.roadWidth = void 0, this.getCurrentRoad = function () { if (t.currentRoad) return t.currentRoad; for (var e = t.roads, n = 0, r = e.length; n < r; n++)if (e[n].isCurrentRoad) { t.currentRoad = e[n]; break } return t.currentRoad }, this.getTopos = function () { if (t.topoArray) return t.topoArray; if (t.currentRoad || (t.currentRoad = t.getCurrentRoad()), !t.currentRoad) return []; if (t.topoArray = t.currentRoad.getTopoInRoad(t.panoId), t.vpoints.length < 1) return t.topoArray; for (var e, n = t.vpoints.length - 1; n >= 0; n--)(e = t.vpoints[n]).topoDir = e.dir, t.topoArray.push(e); return t.topoArray }, this.getRoadWidth = function () { return void 0 === t.roadWidth && (t.currentRoad || (t.currentRoad = t.getCurrentRoad()), t.currentRoad ? t.roadWidth = t.currentRoad.roadWidth : t.roadWidth = 0), t.roadWidth } }; function S(t) { var e = {}; return e.panoId = t.PID, e.panoType = t.Type, e.rid = t.RID, e.dir = t.DIR, e.roadName = t.RoadName, e.order = t.Order, e.panoX = t.X / 100, e.panoY = t.Y / 100, void 0 !== t.CPointX && void 0 !== t.CPointY && (e.cPoint = { x: t.CPointX / 100, y: t.CPointY / 100 }), e } function P(t) { if (!t) return console.error("Get none from server"), null; var e = t.result; if (e && 0 !== e.error) return console.error("Get error from server"), null; var n = t.content; if (void 0 === n || 0 === n.length || void 0 === n[0]) return console.error("Get empty data from server"), null; var r = n[0], i = new R, o = r.Roll, a = {}; if (i.panoId = r.ID, r.Inters instanceof Array) { var s = r.Inters[0]; void 0 !== s && (i.iid = s.IID) } if (i.panoType = r.Type, i.panoX = (r.X || 0) / 100, i.panoY = (r.Y || 0) / 100, i.panoZ = (r.Z || 0) / 100, i.heading = void 0 !== r.MoveDir ? r.MoveDir : 0, i.northDir = r.NorthDir, i.fixHeading = void 0 !== r.Heading ? r.Heading : 270 - r.NorthDir, i.fixPitch = r.Pitch, i.fixRoll = 90 < o || -90 > o ? 0 : o, i.deviceHeight = r.DeviceHeight, i.date = r.Date || i.date, i.time = r.Time, i.provider = void 0 !== r.Provider ? r.Provider : i.provider, i.admission = r.Admission || i.admission, i.timeLine = r.TimeLine || [], i.roadName = r.Rname, r.Roads) { var u = r.Roads; i.roads = u.map((function (t) { return a[t.ID] = t.Name, function (t) { var e = new C; if (e.rid = t.ID, e.roadName = t.Name, e.roadWidth = void 0 !== t.Width ? t.Width / 100 : 0, e.isCurrentRoad = t.IsCurrent || 0, t.Panos) for (var n = t.Panos, r = 0, i = n.length; r < i; r++)e.pointList.push(S(n[r])); return e }(t) })) } if (r.Links) for (var h = r.Links, c = h.length, l = 0; l < c; l++) { var f = h[l]; f.RoadName = a[f.RID], i.vpoints.push(S(f)) } return i.photos = r.Photos || [], i } function D(t, e) { var n = (65535 & t) + (65535 & e); return (t >> 16) + (e >> 16) + (n >> 16) << 16 | 65535 & n } function O(t, e, n, r, i, o) { return D((a = D(D(e, t), D(r, o))) << (s = i) | a >>> 32 - s, n); var a, s } function I(t, e, n, r, i, o, a) { return O(e & n | ~e & r, t, e, i, o, a) } function L(t, e, n, r, i, o, a) { return O(e & r | n & ~r, t, e, i, o, a) } function B(t, e, n, r, i, o, a) { return O(e ^ n ^ r, t, e, i, o, a) } function k(t, e, n, r, i, o, a) { return O(n ^ (e | ~r), t, e, i, o, a) } function U(t, e) { var n, r, i, o, a; t[e >> 5] |= 128 << e % 32, t[14 + (e + 64 >>> 9 << 4)] = e; var s = 1732584193, u = -271733879, h = -1732584194, c = 271733878; for (n = 0; n < t.length; n += 16)r = s, i = u, o = h, a = c, s = I(s, u, h, c, t[n], 7, -680876936), c = I(c, s, u, h, t[n + 1], 12, -389564586), h = I(h, c, s, u, t[n + 2], 17, 606105819), u = I(u, h, c, s, t[n + 3], 22, -1044525330), s = I(s, u, h, c, t[n + 4], 7, -176418897), c = I(c, s, u, h, t[n + 5], 12, 1200080426), h = I(h, c, s, u, t[n + 6], 17, -1473231341), u = I(u, h, c, s, t[n + 7], 22, -45705983), s = I(s, u, h, c, t[n + 8], 7, 1770035416), c = I(c, s, u, h, t[n + 9], 12, -1958414417), h = I(h, c, s, u, t[n + 10], 17, -42063), u = I(u, h, c, s, t[n + 11], 22, -1990404162), s = I(s, u, h, c, t[n + 12], 7, 1804603682), c = I(c, s, u, h, t[n + 13], 12, -40341101), h = I(h, c, s, u, t[n + 14], 17, -1502002290), s = L(s, u = I(u, h, c, s, t[n + 15], 22, 1236535329), h, c, t[n + 1], 5, -165796510), c = L(c, s, u, h, t[n + 6], 9, -1069501632), h = L(h, c, s, u, t[n + 11], 14, 643717713), u = L(u, h, c, s, t[n], 20, -373897302), s = L(s, u, h, c, t[n + 5], 5, -701558691), c = L(c, s, u, h, t[n + 10], 9, 38016083), h = L(h, c, s, u, t[n + 15], 14, -660478335), u = L(u, h, c, s, t[n + 4], 20, -405537848), s = L(s, u, h, c, t[n + 9], 5, 568446438), c = L(c, s, u, h, t[n + 14], 9, -1019803690), h = L(h, c, s, u, t[n + 3], 14, -187363961), u = L(u, h, c, s, t[n + 8], 20, 1163531501), s = L(s, u, h, c, t[n + 13], 5, -1444681467), c = L(c, s, u, h, t[n + 2], 9, -51403784), h = L(h, c, s, u, t[n + 7], 14, 1735328473), s = B(s, u = L(u, h, c, s, t[n + 12], 20, -1926607734), h, c, t[n + 5], 4, -378558), c = B(c, s, u, h, t[n + 8], 11, -2022574463), h = B(h, c, s, u, t[n + 11], 16, 1839030562), u = B(u, h, c, s, t[n + 14], 23, -35309556), s = B(s, u, h, c, t[n + 1], 4, -1530992060), c = B(c, s, u, h, t[n + 4], 11, 1272893353), h = B(h, c, s, u, t[n + 7], 16, -155497632), u = B(u, h, c, s, t[n + 10], 23, -1094730640), s = B(s, u, h, c, t[n + 13], 4, 681279174), c = B(c, s, u, h, t[n], 11, -358537222), h = B(h, c, s, u, t[n + 3], 16, -722521979), u = B(u, h, c, s, t[n + 6], 23, 76029189), s = B(s, u, h, c, t[n + 9], 4, -640364487), c = B(c, s, u, h, t[n + 12], 11, -421815835), h = B(h, c, s, u, t[n + 15], 16, 530742520), s = k(s, u = B(u, h, c, s, t[n + 2], 23, -995338651), h, c, t[n], 6, -198630844), c = k(c, s, u, h, t[n + 7], 10, 1126891415), h = k(h, c, s, u, t[n + 14], 15, -1416354905), u = k(u, h, c, s, t[n + 5], 21, -57434055), s = k(s, u, h, c, t[n + 12], 6, 1700485571), c = k(c, s, u, h, t[n + 3], 10, -1894986606), h = k(h, c, s, u, t[n + 10], 15, -1051523), u = k(u, h, c, s, t[n + 1], 21, -2054922799), s = k(s, u, h, c, t[n + 8], 6, 1873313359), c = k(c, s, u, h, t[n + 15], 10, -30611744), h = k(h, c, s, u, t[n + 6], 15, -1560198380), u = k(u, h, c, s, t[n + 13], 21, 1309151649), s = k(s, u, h, c, t[n + 4], 6, -145523070), c = k(c, s, u, h, t[n + 11], 10, -1120210379), h = k(h, c, s, u, t[n + 2], 15, 718787259), u = k(u, h, c, s, t[n + 9], 21, -343485551), s = D(s, r), u = D(u, i), h = D(h, o), c = D(c, a); return [s, u, h, c] } function N(t) { var e, n = "", r = 32 * t.length; for (e = 0; e < r; e += 8)n += String.fromCharCode(t[e >> 5] >>> e % 32 & 255); return n } function F(t) { var e, n = []; for (n[(t.length >> 2) - 1] = void 0, e = 0; e < n.length; e += 1)n[e] = 0; var r = 8 * t.length; for (e = 0; e < r; e += 8)n[e >> 5] |= (255 & t.charCodeAt(e / 8)) << e % 32; return n } function j(t) { var e, n, r = "0123456789abcdef", i = ""; for (n = 0; n < t.length; n += 1)e = t.charCodeAt(n), i += r.charAt(e >>> 4 & 15) + r.charAt(15 & e); return i } function z(t) { return unescape(encodeURIComponent(t)) } function V(t) { return function (t) { return N(U(F(t), 8 * t.length)) }(z(t)) } function G(t, e) { return function (t, e) { var n, r, i = F(t), o = [], a = []; for (o[15] = a[15] = void 0, i.length > 16 && (i = U(i, 8 * t.length)), n = 0; n < 16; n += 1)o[n] = 909522486 ^ i[n], a[n] = 1549556828 ^ i[n]; return r = U(o.concat(F(e)), 512 + 8 * e.length), N(U(a.concat(r), 640)) }(z(t), z(e)) } var W, H, Z, q, Y = function (t, e, n) { return e ? n ? G(e, t) : j(G(e, t)) : n ? V(t) : j(V(t)) }, X = function (t, e) { return T(t, {}, { jsonp: "fn" }) }, K = function (t, e) { if ("PANORAMA" === t) { var n = window._BMapSecurityConfig && window._BMapSecurityConfig.serviceHost ? window._BMapSecurityConfig.serviceHost + "?qt=pano_entry&v=gl" : "https://api.map.baidu.com/?qt=pano_entry&v=gl&ak=" + window.BMAP_AUTHENTIC_KEY; "function" == typeof e ? X(n).then((function (t) { e() })).catch((function (t) { })) : X(n + "&callback=" + e) } }, Q = function (t) { if ("PANORAMA" === t) alert("您需要申请全景地图服务使用权限") }, J = (H = null, Z = 0, q = W || 5e3, function (t) { var e = (1e5 * Math.random()).toFixed(0); window["cbk" + e] = function (t) { t && void 0 !== t.error && 0 === t.error || K("PANORAMA", (function (t) { t && void 0 !== t.error && 0 === t.error || Q("PANORAMA") })) }, Z += t, H || (H = setTimeout((function () { var t = window._BMapSecurityConfig && window._BMapSecurityConfig.serviceHost ? window._BMapSecurityConfig.serviceHost + "?qt=pano_count&v=gl&consume=" + Z : "https://api.map.baidu.com/?qt=pano_count&v=gl&ak=" + window.BMAP_AUTHENTIC_KEY + "&consume=" + Z; X(t + "&callback=window.cbk" + e), Z = 0, H = null }), q)) }), $ = function (t, e) { var n = (e = e || {}).counter ? e.counter : 1, r = !1 !== e.isCounter, i = Date.parse(new Date), o = i / 1e3, a = t + "-" + (o + 1800) + "-" + i + "-" + window.BMAP_AUTHENTIC_KEY + "-SJvEY5h37ZDh5pHS", s = Y(a), u = "auth_key=" + (o + 1800) + "-" + i + "-" + window.BMAP_AUTHENTIC_KEY + "-" + s; return r && J(n), u }, tt = function () { function t(e) { var n = this; this.getPanoById = function (e) { var r; r = "".concat(t.SERVICE_URL, "?qt=sdata&sid=").concat(e, "&").concat($("/")), n.getDataByUrl(r).then((function (t) { var e = P(t); if (null === e) throw new Error("数据解析异常"); return n._cache.setData(r, t), n._pano.dispatchEvent(d.DATA_LOADED, { data: e }), n._pano.dispatchEvent(d.ID_CHANGED, e.panoId), n._pano.dispatchEvent(d.POSITION_CHANGED, new f(e.panoX, e.panoY)), e })).catch((function (t) { n._pano.dispatchEvent({ type: d.PANO_ERROR, data: t }) })) }, this.getPanoByLocation = function (e, r) { var i; i = "".concat(t.SERVICE_URL, "?qt=qsdata&x=").concat(e.lng, "&y=").concat(e.lat).concat(r ? "&r=" + r : "", "&action=1&").concat($("/")), n.getDataByUrl(i).then((function (t) { var r = P(t); n._cache.setData(i, t), n._pano.dispatchEvent(d.DATA_LOADED, { data: r }), n._pano.dispatchEvent(d.POSITION_CHANGED, e) })).catch((function (t) { n._pano.dispatchEvent({ type: d.PANO_ERROR, data: t }) })) }, this._pano = e, this._cache = new A(10) } return t.prototype.getDataByUrl = function (t) { var e = this._cache.getData(t); return e ? Promise.resolve(e) : T(t, {}, { jsonp: "fn" }) }, t }(); tt.SERVICE_URL = "//apisv0.bdimg.com/"; var et = n((function (t) { function e(t, e, n, r, i, o, a) { try { var s = t[o](a), u = s.value } catch (t) { return void n(t) } s.done ? e(u) : Promise.resolve(u).then(r, i) } t.exports = function (t) { return function () { var n = this, r = arguments; return new Promise((function (i, o) { var a = t.apply(n, r); function s(t) { e(a, i, o, s, u, "next", t) } function u(t) { e(a, i, o, s, u, "throw", t) } s(void 0) })) } }, t.exports.__esModule = !0, t.exports.default = t.exports })), nt = e(et), rt = n((function (t) {
        var e = r.default; function n() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            t.exports = n = function () { return r }, t.exports.__esModule = !0, t.exports.default = t.exports; var r = {}, i = Object.prototype, o = i.hasOwnProperty, a = "function" == typeof Symbol ? Symbol : {}, s = a.iterator || "@@iterator", u = a.asyncIterator || "@@asyncIterator", h = a.toStringTag || "@@toStringTag"; function c(t, e, n) { return Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }), t[e] } try { c({}, "") } catch (t) { c = function (t, e, n) { return t[e] = n } } function l(t, e, n, r) { var i = e && e.prototype instanceof p ? e : p, o = Object.create(i.prototype), a = new A(r || []); return o._invoke = function (t, e, n) { var r = "suspendedStart"; return function (i, o) { if ("executing" === r) throw new Error("Generator is already running"); if ("completed" === r) { if ("throw" === i) throw o; return R() } for (n.method = i, n.arg = o; ;) { var a = n.delegate; if (a) { var s = w(a, n); if (s) { if (s === d) continue; return s } } if ("next" === n.method) n.sent = n._sent = n.arg; else if ("throw" === n.method) { if ("suspendedStart" === r) throw r = "completed", n.arg; n.dispatchException(n.arg) } else "return" === n.method && n.abrupt("return", n.arg); r = "executing"; var u = f(t, e, n); if ("normal" === u.type) { if (r = n.done ? "completed" : "suspendedYield", u.arg === d) continue; return { value: u.arg, done: n.done } } "throw" === u.type && (r = "completed", n.method = "throw", n.arg = u.arg) } } }(t, n, a), o } function f(t, e, n) { try { return { type: "normal", arg: t.call(e, n) } } catch (t) { return { type: "throw", arg: t } } } r.wrap = l; var d = {}; function p() { } function v() { } function m() { } var g = {}; c(g, s, (function () { return this })); var y = Object.getPrototypeOf, _ = y && y(y(C([]))); _ && _ !== i && o.call(_, s) && (g = _); var x = m.prototype = p.prototype = Object.create(g); function b(t) { ["next", "throw", "return"].forEach((function (e) { c(t, e, (function (t) { return this._invoke(e, t) })) })) } function M(t, n) { function r(i, a, s, u) { var h = f(t[i], t, a); if ("throw" !== h.type) { var c = h.arg, l = c.value; return l && "object" == e(l) && o.call(l, "__await") ? n.resolve(l.__await).then((function (t) { r("next", t, s, u) }), (function (t) { r("throw", t, s, u) })) : n.resolve(l).then((function (t) { c.value = t, s(c) }), (function (t) { return r("throw", t, s, u) })) } u(h.arg) } var i; this._invoke = function (t, e) { function o() { return new n((function (n, i) { r(t, e, n, i) })) } return i = i ? i.then(o, o) : o() } } function w(t, e) { var n = t.iterator[e.method]; if (void 0 === n) { if (e.delegate = null, "throw" === e.method) { if (t.iterator.return && (e.method = "return", e.arg = void 0, w(t, e), "throw" === e.method)) return d; e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method") } return d } var r = f(n, t.iterator, e.arg); if ("throw" === r.type) return e.method = "throw", e.arg = r.arg, e.delegate = null, d; var i = r.arg; return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = void 0), e.delegate = null, d) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, d) } function E(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function T(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function A(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(E, this), this.reset(!0) } function C(t) { if (t) { var e = t[s]; if (e) return e.call(t); if ("function" == typeof t.next) return t; if (!isNaN(t.length)) { var n = -1, r = function e() { for (; ++n < t.length;)if (o.call(t, n)) return e.value = t[n], e.done = !1, e; return e.value = void 0, e.done = !0, e }; return r.next = r } } return { next: R } } function R() { return { value: void 0, done: !0 } } return v.prototype = m, c(x, "constructor", m), c(m, "constructor", v), v.displayName = c(m, h, "GeneratorFunction"), r.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name)) }, r.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, m) : (t.__proto__ = m, c(t, h, "GeneratorFunction")), t.prototype = Object.create(x), t }, r.awrap = function (t) { return { __await: t } }, b(M.prototype), c(M.prototype, u, (function () { return this })), r.AsyncIterator = M, r.async = function (t, e, n, i, o) { void 0 === o && (o = Promise); var a = new M(l(t, e, n, i), o); return r.isGeneratorFunction(e) ? a : a.next().then((function (t) { return t.done ? t.value : a.next() })) }, b(x), c(x, h, "Generator"), c(x, s, (function () { return this })), c(x, "toString", (function () { return "[object Generator]" })), r.keys = function (t) { var e = []; for (var n in t) e.push(n); return e.reverse(), function n() { for (; e.length;) { var r = e.pop(); if (r in t) return n.value = r, n.done = !1, n } return n.done = !0, n } }, r.values = C, A.prototype = { constructor: A, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(T), !t) for (var e in this) "t" === e.charAt(0) && o.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (t) { if (this.done) throw t; var e = this; function n(n, r) { return a.type = "throw", a.arg = t, e.next = n, r && (e.method = "next", e.arg = void 0), !!r } for (var r = this.tryEntries.length - 1; r >= 0; --r) { var i = this.tryEntries[r], a = i.completion; if ("root" === i.tryLoc) return n("end"); if (i.tryLoc <= this.prev) { var s = o.call(i, "catchLoc"), u = o.call(i, "finallyLoc"); if (s && u) { if (this.prev < i.catchLoc) return n(i.catchLoc, !0); if (this.prev < i.finallyLoc) return n(i.finallyLoc) } else if (s) { if (this.prev < i.catchLoc) return n(i.catchLoc, !0) } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return n(i.finallyLoc) } } } }, abrupt: function (t, e) { for (var n = this.tryEntries.length - 1; n >= 0; --n) { var r = this.tryEntries[n]; if (r.tryLoc <= this.prev && o.call(r, "finallyLoc") && this.prev < r.finallyLoc) { var i = r; break } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, d) : this.complete(a) }, complete: function (t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), d }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), T(n), d } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.tryLoc === t) { var r = n.completion; if ("throw" === r.type) { var i = r.arg; T(n) } return i } } throw new Error("illegal catch attempt") }, delegateYield: function (t, e, n) { return this.delegate = { iterator: C(t), resultName: e, nextLoc: n }, "next" === this.method && (this.arg = void 0), d } }, r
        } t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports
    })); e(rt); var it = rt(), ot = it; try { regeneratorRuntime = it } catch (t) { "object" == typeof globalThis ? globalThis.regeneratorRuntime = it : Function("r", "regeneratorRuntime = r")(it) } function at(t, e) { if (!t) throw new Error("math.gl assertion ".concat(e)) } const st = { EPSILON: 1e-12, debug: !1, precision: 4, printTypes: !1, printDegrees: !1, printRowMajor: !0 }; function ut(t, { precision: e = st.precision } = {}) { return t = function (t) { return Math.round(t / st.EPSILON) * st.EPSILON }(t), "".concat(parseFloat(t.toPrecision(e))) } function ht(t) { return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView) } function ct(t, e, n) { const r = st.EPSILON; n && (st.EPSILON = n); try { if (t === e) return !0; if (ht(t) && ht(e)) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!ct(t[n], e[n])) return !1; return !0 } return t && t.equals ? t.equals(e) : e && e.equals ? e.equals(t) : "number" == typeof t && "number" == typeof e && Math.abs(t - e) <= st.EPSILON * Math.max(1, Math.abs(t), Math.abs(e)) } finally { st.EPSILON = r } } class lt extends (function (t) { function e() { var e = Reflect.construct(t, Array.from(arguments)); return Object.setPrototypeOf(e, Object.getPrototypeOf(this)), e } return e.prototype = Object.create(t.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t, e }(Array)) { clone() { return (new this.constructor).copy(this) } fromArray(t, e = 0) { for (let n = 0; n < this.ELEMENTS; ++n)this[n] = t[n + e]; return this.check() } toArray(t = [], e = 0) { for (let n = 0; n < this.ELEMENTS; ++n)t[e + n] = this[n]; return t } from(t) { return Array.isArray(t) ? this.copy(t) : this.fromObject(t) } to(t) { return t === this ? this : ht(t) ? this.toArray(t) : this.toObject(t) } toTarget(t) { return t ? this.to(t) : this } toFloat32Array() { return new Float32Array(this) } toString() { return this.formatString(st) } formatString(t) { let e = ""; for (let n = 0; n < this.ELEMENTS; ++n)e += (n > 0 ? ", " : "") + ut(this[n], t); return "".concat(t.printTypes ? this.constructor.name : "", "[").concat(e, "]") } equals(t) { if (!t || this.length !== t.length) return !1; for (let e = 0; e < this.ELEMENTS; ++e)if (!ct(this[e], t[e])) return !1; return !0 } exactEquals(t) { if (!t || this.length !== t.length) return !1; for (let e = 0; e < this.ELEMENTS; ++e)if (this[e] !== t[e]) return !1; return !0 } negate() { for (let t = 0; t < this.ELEMENTS; ++t)this[t] = -this[t]; return this.check() } lerp(t, e, n) { if (void 0 === n) return this.lerp(this, t, e); for (let r = 0; r < this.ELEMENTS; ++r) { const i = t[r]; this[r] = i + n * (e[r] - i) } return this.check() } min(t) { for (let e = 0; e < this.ELEMENTS; ++e)this[e] = Math.min(t[e], this[e]); return this.check() } max(t) { for (let e = 0; e < this.ELEMENTS; ++e)this[e] = Math.max(t[e], this[e]); return this.check() } clamp(t, e) { for (let n = 0; n < this.ELEMENTS; ++n)this[n] = Math.min(Math.max(this[n], t[n]), e[n]); return this.check() } add(...t) { for (const e of t) for (let t = 0; t < this.ELEMENTS; ++t)this[t] += e[t]; return this.check() } subtract(...t) { for (const e of t) for (let t = 0; t < this.ELEMENTS; ++t)this[t] -= e[t]; return this.check() } scale(t) { if ("number" == typeof t) for (let e = 0; e < this.ELEMENTS; ++e)this[e] *= t; else for (let e = 0; e < this.ELEMENTS && e < t.length; ++e)this[e] *= t[e]; return this.check() } multiplyByScalar(t) { for (let e = 0; e < this.ELEMENTS; ++e)this[e] *= t; return this.check() } check() { if (st.debug && !this.validate()) throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'")); return this } validate() { let t = this.length === this.ELEMENTS; for (let e = 0; e < this.ELEMENTS; ++e)t = t && Number.isFinite(this[e]); return t } sub(t) { return this.subtract(t) } setScalar(t) { for (let e = 0; e < this.ELEMENTS; ++e)this[e] = t; return this.check() } addScalar(t) { for (let e = 0; e < this.ELEMENTS; ++e)this[e] += t; return this.check() } subScalar(t) { return this.addScalar(-t) } multiplyScalar(t) { for (let e = 0; e < this.ELEMENTS; ++e)this[e] *= t; return this.check() } divideScalar(t) { return this.multiplyByScalar(1 / t) } clampScalar(t, e) { for (let n = 0; n < this.ELEMENTS; ++n)this[n] = Math.min(Math.max(this[n], t), e); return this.check() } get elements() { return this } } function ft(t) { if (!Number.isFinite(t)) throw new Error("Invalid number ".concat(t)); return t } function dt(t, e, n = "") { if (st.debug && !function (t, e) { if (t.length !== e) return !1; for (let e = 0; e < t.length; ++e)if (!Number.isFinite(t[e])) return !1; return !0 }(t, e)) throw new Error("math.gl: ".concat(n, " some fields set to invalid numbers'")); return t } class pt extends lt { get x() { return this[0] } set x(t) { this[0] = ft(t) } get y() { return this[1] } set y(t) { this[1] = ft(t) } len() { return Math.sqrt(this.lengthSquared()) } magnitude() { return this.len() } lengthSquared() { let t = 0; for (let e = 0; e < this.ELEMENTS; ++e)t += this[e] * this[e]; return t } magnitudeSquared() { return this.lengthSquared() } distance(t) { return Math.sqrt(this.distanceSquared(t)) } distanceSquared(t) { let e = 0; for (let n = 0; n < this.ELEMENTS; ++n) { const r = this[n] - t[n]; e += r * r } return ft(e) } dot(t) { let e = 0; for (let n = 0; n < this.ELEMENTS; ++n)e += this[n] * t[n]; return ft(e) } normalize() { const t = this.magnitude(); if (0 !== t) for (let e = 0; e < this.ELEMENTS; ++e)this[e] /= t; return this.check() } multiply(...t) { for (const e of t) for (let t = 0; t < this.ELEMENTS; ++t)this[t] *= e[t]; return this.check() } divide(...t) { for (const e of t) for (let t = 0; t < this.ELEMENTS; ++t)this[t] /= e[t]; return this.check() } lengthSq() { return this.lengthSquared() } distanceTo(t) { return this.distance(t) } distanceToSquared(t) { return this.distanceSquared(t) } getComponent(t) { return at(t >= 0 && t < this.ELEMENTS, "index is out of range"), ft(this[t]) } setComponent(t, e) { return at(t >= 0 && t < this.ELEMENTS, "index is out of range"), this[t] = e, this.check() } addVectors(t, e) { return this.copy(t).add(e) } subVectors(t, e) { return this.copy(t).subtract(e) } multiplyVectors(t, e) { return this.copy(t).multiply(e) } addScaledVector(t, e) { return this.add(new this.constructor(t).multiplyScalar(e)) } } var vt = 1e-6, mt = "undefined" != typeof Float32Array ? Float32Array : Array, gt = Math.random; function yt() { var t = new mt(2); return mt != Float32Array && (t[0] = 0, t[1] = 0), t } function _t(t, e) { var n = new mt(2); return n[0] = t, n[1] = e, n } function xt(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t } function bt(t, e, n) { return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t } function Mt(t, e, n) { return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t } function wt(t, e) { var n = e[0] - t[0], r = e[1] - t[1]; return Math.hypot(n, r) } function Et(t, e) { var n = e[0] - t[0], r = e[1] - t[1]; return n * n + r * r } function Tt(t) { var e = t[0], n = t[1]; return Math.hypot(e, n) } function At(t) { var e = t[0], n = t[1]; return e * e + n * n } function Ct(t, e, n) { var r = e[0], i = e[1]; return t[0] = n[0] * r + n[4] * i + n[12], t[1] = n[1] * r + n[5] * i + n[13], t } Math.hypot || (Math.hypot = function () { for (var t = 0, e = arguments.length; e--;)t += arguments[e] * arguments[e]; return Math.sqrt(t) }); var Rt, St = Tt, Pt = xt, Dt = bt, Ot = Mt, It = wt, Lt = Et, Bt = At, kt = (Rt = yt(), function (t, e, n, r, i, o) { var a, s; for (e || (e = 2), n || (n = 0), s = r ? Math.min(r * e + n, t.length) : t.length, a = n; a < s; a += e)Rt[0] = t[a], Rt[1] = t[a + 1], i(Rt, Rt, o), t[a] = Rt[0], t[a + 1] = Rt[1]; return t }), Ut = Object.freeze({ __proto__: null, create: yt, clone: function (t) { var e = new mt(2); return e[0] = t[0], e[1] = t[1], e }, fromValues: _t, copy: function (t, e) { return t[0] = e[0], t[1] = e[1], t }, set: function (t, e, n) { return t[0] = e, t[1] = n, t }, add: function (t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t }, subtract: xt, multiply: bt, divide: Mt, ceil: function (t, e) { return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t }, floor: function (t, e) { return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t }, min: function (t, e, n) { return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t }, max: function (t, e, n) { return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t }, round: function (t, e) { return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t }, scale: function (t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t }, scaleAndAdd: function (t, e, n, r) { return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t }, distance: wt, squaredDistance: Et, length: Tt, squaredLength: At, negate: function (t, e) { return t[0] = -e[0], t[1] = -e[1], t }, inverse: function (t, e) { return t[0] = 1 / e[0], t[1] = 1 / e[1], t }, normalize: function (t, e) { var n = e[0], r = e[1], i = n * n + r * r; return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t }, dot: function (t, e) { return t[0] * e[0] + t[1] * e[1] }, cross: function (t, e, n) { var r = e[0] * n[1] - e[1] * n[0]; return t[0] = t[1] = 0, t[2] = r, t }, lerp: function (t, e, n, r) { var i = e[0], o = e[1]; return t[0] = i + r * (n[0] - i), t[1] = o + r * (n[1] - o), t }, random: function (t, e) { e = e || 1; var n = 2 * gt() * Math.PI; return t[0] = Math.cos(n) * e, t[1] = Math.sin(n) * e, t }, transformMat2: function (t, e, n) { var r = e[0], i = e[1]; return t[0] = n[0] * r + n[2] * i, t[1] = n[1] * r + n[3] * i, t }, transformMat2d: function (t, e, n) { var r = e[0], i = e[1]; return t[0] = n[0] * r + n[2] * i + n[4], t[1] = n[1] * r + n[3] * i + n[5], t }, transformMat3: function (t, e, n) { var r = e[0], i = e[1]; return t[0] = n[0] * r + n[3] * i + n[6], t[1] = n[1] * r + n[4] * i + n[7], t }, transformMat4: Ct, rotate: function (t, e, n, r) { var i = e[0] - n[0], o = e[1] - n[1], a = Math.sin(r), s = Math.cos(r); return t[0] = i * s - o * a + n[0], t[1] = i * a + o * s + n[1], t }, angle: function (t, e) { var n = t[0], r = t[1], i = e[0], o = e[1], a = Math.sqrt(n * n + r * r) * Math.sqrt(i * i + o * o), s = a && (n * i + r * o) / a; return Math.acos(Math.min(Math.max(s, -1), 1)) }, zero: function (t) { return t[0] = 0, t[1] = 0, t }, str: function (t) { return "vec2(" + t[0] + ", " + t[1] + ")" }, exactEquals: function (t, e) { return t[0] === e[0] && t[1] === e[1] }, equals: function (t, e) { var n = t[0], r = t[1], i = e[0], o = e[1]; return Math.abs(n - i) <= vt * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(r - o) <= vt * Math.max(1, Math.abs(r), Math.abs(o)) }, len: St, sub: Pt, mul: Dt, div: Ot, dist: It, sqrDist: Lt, sqrLen: Bt, forEach: kt }); function Nt(t, e, n) { const r = e[0], i = e[1], o = e[2], a = n[3] * r + n[7] * i + n[11] * o || 1; return t[0] = (n[0] * r + n[4] * i + n[8] * o) / a, t[1] = (n[1] * r + n[5] * i + n[9] * o) / a, t[2] = (n[2] * r + n[6] * i + n[10] * o) / a, t } function Ft() { var t = new mt(3); return mt != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t } function jt(t) { var e = new mt(3); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e } function zt(t) { var e = t[0], n = t[1], r = t[2]; return Math.hypot(e, n, r) } function Vt(t, e, n) { var r = new mt(3); return r[0] = t, r[1] = e, r[2] = n, r } function Gt(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t } function Wt(t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t } function Ht(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t } function Zt(t, e, n) { return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t } function qt(t, e, n) { return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t } function Yt(t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t } function Xt(t, e) { var n = e[0] - t[0], r = e[1] - t[1], i = e[2] - t[2]; return Math.hypot(n, r, i) } function Kt(t, e) { var n = e[0] - t[0], r = e[1] - t[1], i = e[2] - t[2]; return n * n + r * r + i * i } function Qt(t) { var e = t[0], n = t[1], r = t[2]; return e * e + n * n + r * r } function Jt(t, e) { var n = e[0], r = e[1], i = e[2], o = n * n + r * r + i * i; return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = e[0] * o, t[1] = e[1] * o, t[2] = e[2] * o, t } function $t(t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] } function te(t, e, n) { var r = e[0], i = e[1], o = e[2], a = n[0], s = n[1], u = n[2]; return t[0] = i * u - o * s, t[1] = o * a - r * u, t[2] = r * s - i * a, t } function ee(t, e, n) { var r = e[0], i = e[1], o = e[2], a = n[3] * r + n[7] * i + n[11] * o + n[15]; return a = a || 1, t[0] = (n[0] * r + n[4] * i + n[8] * o + n[12]) / a, t[1] = (n[1] * r + n[5] * i + n[9] * o + n[13]) / a, t[2] = (n[2] * r + n[6] * i + n[10] * o + n[14]) / a, t } function ne(t, e, n) { var r = e[0], i = e[1], o = e[2]; return t[0] = r * n[0] + i * n[3] + o * n[6], t[1] = r * n[1] + i * n[4] + o * n[7], t[2] = r * n[2] + i * n[5] + o * n[8], t } function re(t, e, n) { var r = n[0], i = n[1], o = n[2], a = n[3], s = e[0], u = e[1], h = e[2], c = i * h - o * u, l = o * s - r * h, f = r * u - i * s, d = i * f - o * l, p = o * c - r * f, v = r * l - i * c, m = 2 * a; return c *= m, l *= m, f *= m, d *= 2, p *= 2, v *= 2, t[0] = s + c + d, t[1] = u + l + p, t[2] = h + f + v, t } function ie(t, e, n, r) { var i = [], o = []; return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[0], o[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r), o[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r), t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t } function oe(t, e, n, r) { var i = [], o = []; return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r), o[1] = i[1], o[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r), t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t } function ae(t, e, n, r) { var i = [], o = []; return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r), o[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r), o[2] = i[2], t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t } function se(t, e) { var n = t[0], r = t[1], i = t[2], o = e[0], a = e[1], s = e[2], u = Math.sqrt(n * n + r * r + i * i) * Math.sqrt(o * o + a * a + s * s), h = u && $t(t, e) / u; return Math.acos(Math.min(Math.max(h, -1), 1)) } function ue(t, e) { var n = t[0], r = t[1], i = t[2], o = e[0], a = e[1], s = e[2]; return Math.abs(n - o) <= vt * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - a) <= vt * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(i - s) <= vt * Math.max(1, Math.abs(i), Math.abs(s)) } var he = Ht, ce = Zt, le = qt, fe = Xt, de = Kt, pe = zt, ve = Qt, me = function () { var t = Ft(); return function (e, n, r, i, o, a) { var s, u; for (n || (n = 3), r || (r = 0), u = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < u; s += n)t[0] = e[s], t[1] = e[s + 1], t[2] = e[s + 2], o(t, t, a), e[s] = t[0], e[s + 1] = t[1], e[s + 2] = t[2]; return e } }(), ge = Object.freeze({ __proto__: null, create: Ft, clone: jt, length: zt, fromValues: Vt, copy: Gt, set: function (t, e, n, r) { return t[0] = e, t[1] = n, t[2] = r, t }, add: Wt, subtract: Ht, multiply: Zt, divide: qt, ceil: function (t, e) { return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t }, floor: function (t, e) { return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t }, min: function (t, e, n) { return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t }, max: function (t, e, n) { return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t }, round: function (t, e) { return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t }, scale: Yt, scaleAndAdd: function (t, e, n, r) { return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t }, distance: Xt, squaredDistance: Kt, squaredLength: Qt, negate: function (t, e) { return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t }, inverse: function (t, e) { return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t }, normalize: Jt, dot: $t, cross: te, lerp: function (t, e, n, r) { var i = e[0], o = e[1], a = e[2]; return t[0] = i + r * (n[0] - i), t[1] = o + r * (n[1] - o), t[2] = a + r * (n[2] - a), t }, hermite: function (t, e, n, r, i, o) { var a = o * o, s = a * (2 * o - 3) + 1, u = a * (o - 2) + o, h = a * (o - 1), c = a * (3 - 2 * o); return t[0] = e[0] * s + n[0] * u + r[0] * h + i[0] * c, t[1] = e[1] * s + n[1] * u + r[1] * h + i[1] * c, t[2] = e[2] * s + n[2] * u + r[2] * h + i[2] * c, t }, bezier: function (t, e, n, r, i, o) { var a = 1 - o, s = a * a, u = o * o, h = s * a, c = 3 * o * s, l = 3 * u * a, f = u * o; return t[0] = e[0] * h + n[0] * c + r[0] * l + i[0] * f, t[1] = e[1] * h + n[1] * c + r[1] * l + i[1] * f, t[2] = e[2] * h + n[2] * c + r[2] * l + i[2] * f, t }, random: function (t, e) { e = e || 1; var n = 2 * gt() * Math.PI, r = 2 * gt() - 1, i = Math.sqrt(1 - r * r) * e; return t[0] = Math.cos(n) * i, t[1] = Math.sin(n) * i, t[2] = r * e, t }, transformMat4: ee, transformMat3: ne, transformQuat: re, rotateX: ie, rotateY: oe, rotateZ: ae, angle: se, zero: function (t) { return t[0] = 0, t[1] = 0, t[2] = 0, t }, str: function (t) { return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")" }, exactEquals: function (t, e) { return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] }, equals: ue, sub: he, mul: ce, div: le, dist: fe, sqrDist: de, len: pe, sqrLen: ve, forEach: me }); const ye = [0, 0, 0]; let _e, xe; class be extends pt { static get ZERO() { return _e || (_e = new be(0, 0, 0), Object.freeze(_e)), _e } constructor(t = 0, e = 0, n = 0) { super(-0, -0, -0), 1 === arguments.length && ht(t) ? this.copy(t) : (st.debug && (ft(t), ft(e), ft(n)), this[0] = t, this[1] = e, this[2] = n) } set(t, e, n) { return this[0] = t, this[1] = e, this[2] = n, this.check() } copy(t) { return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check() } fromObject(t) { return st.debug && (ft(t.x), ft(t.y), ft(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check() } toObject(t) { return t.x = this[0], t.y = this[1], t.z = this[2], t } get ELEMENTS() { return 3 } get z() { return this[2] } set z(t) { this[2] = ft(t) } angle(t) { return se(this, t) } cross(t) { return te(this, this, t), this.check() } rotateX({ radians: t, origin: e = ye }) { return ie(this, this, e, t), this.check() } rotateY({ radians: t, origin: e = ye }) { return oe(this, this, e, t), this.check() } rotateZ({ radians: t, origin: e = ye }) { return ae(this, this, e, t), this.check() } transform(t) { return this.transformAsPoint(t) } transformAsPoint(t) { return ee(this, this, t), this.check() } transformAsVector(t) { return Nt(this, this, t), this.check() } transformByMatrix3(t) { return ne(this, this, t), this.check() } transformByMatrix2(t) { return function (t, e, n) { const r = e[0], i = e[1]; t[0] = n[0] * r + n[2] * i, t[1] = n[1] * r + n[3] * i, t[2] = e[2] }(this, this, t), this.check() } transformByQuaternion(t) { return re(this, this, t), this.check() } } class Me extends pt { static get ZERO() { return xe || (xe = new Me(0, 0, 0, 0), Object.freeze(xe)), xe } constructor(t = 0, e = 0, n = 0, r = 0) { super(-0, -0, -0, -0), ht(t) && 1 === arguments.length ? this.copy(t) : (st.debug && (ft(t), ft(e), ft(n), ft(r)), this[0] = t, this[1] = e, this[2] = n, this[3] = r) } set(t, e, n, r) { return this[0] = t, this[1] = e, this[2] = n, this[3] = r, this.check() } copy(t) { return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check() } fromObject(t) { return st.debug && (ft(t.x), ft(t.y), ft(t.z), ft(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this } toObject(t) { return t.x = this[0], t.y = this[1], t.z = this[2], t.w = this[3], t } get ELEMENTS() { return 4 } get z() { return this[2] } set z(t) { this[2] = ft(t) } get w() { return this[3] } set w(t) { this[3] = ft(t) } transform(t) { return ee(this, this, t), this.check() } transformByMatrix3(t) { return function (t, e, n) { const r = e[0], i = e[1], o = e[2]; t[0] = n[0] * r + n[3] * i + n[6] * o, t[1] = n[1] * r + n[4] * i + n[7] * o, t[2] = n[2] * r + n[5] * i + n[8] * o, t[3] = e[3] }(this, this, t), this.check() } transformByMatrix2(t) { return function (t, e, n) { const r = e[0], i = e[1]; t[0] = n[0] * r + n[2] * i, t[1] = n[1] * r + n[3] * i, t[2] = e[2], t[3] = e[3] }(this, this, t), this.check() } transformByQuaternion(t) { return re(this, this, t), this.check() } applyMatrix4(t) { return t.transform(this, this), this } } class we extends lt { toString() { let t = "["; if (st.printRowMajor) { t += "row-major:"; for (let e = 0; e < this.RANK; ++e)for (let n = 0; n < this.RANK; ++n)t += " ".concat(this[n * this.RANK + e]) } else { t += "column-major:"; for (let e = 0; e < this.ELEMENTS; ++e)t += " ".concat(this[e]) } return t += "]", t } getElementIndex(t, e) { return e * this.RANK + t } getElement(t, e) { return this[e * this.RANK + t] } setElement(t, e, n) { return this[e * this.RANK + t] = ft(n), this } getColumn(t, e = new Array(this.RANK).fill(-0)) { const n = t * this.RANK; for (let t = 0; t < this.RANK; ++t)e[t] = this[n + t]; return e } setColumn(t, e) { const n = t * this.RANK; for (let t = 0; t < this.RANK; ++t)this[n + t] = e[t]; return this } } function Ee() { var t = new mt(9); return mt != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t } function Te(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = e[4], u = e[5], h = e[6], c = e[7], l = e[8], f = n[0], d = n[1], p = n[2], v = n[3], m = n[4], g = n[5], y = n[6], _ = n[7], x = n[8]; return t[0] = f * r + d * a + p * h, t[1] = f * i + d * s + p * c, t[2] = f * o + d * u + p * l, t[3] = v * r + m * a + g * h, t[4] = v * i + m * s + g * c, t[5] = v * o + m * u + g * l, t[6] = y * r + _ * a + x * h, t[7] = y * i + _ * s + x * c, t[8] = y * o + _ * u + x * l, t } function Ae(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t } var Ce = Te, Re = Ae, Se = Object.freeze({ __proto__: null, create: Ee, fromMat4: function (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t }, clone: function (t) { var e = new mt(9); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e }, copy: function (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t }, fromValues: function (t, e, n, r, i, o, a, s, u) { var h = new mt(9); return h[0] = t, h[1] = e, h[2] = n, h[3] = r, h[4] = i, h[5] = o, h[6] = a, h[7] = s, h[8] = u, h }, set: function (t, e, n, r, i, o, a, s, u, h) { return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = o, t[5] = a, t[6] = s, t[7] = u, t[8] = h, t }, identity: function (t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t }, transpose: function (t, e) { if (t === e) { var n = e[1], r = e[2], i = e[5]; t[1] = e[3], t[2] = e[6], t[3] = n, t[5] = e[7], t[6] = r, t[7] = i } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8]; return t }, invert: function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], u = e[6], h = e[7], c = e[8], l = c * a - s * h, f = -c * o + s * u, d = h * o - a * u, p = n * l + r * f + i * d; return p ? (p = 1 / p, t[0] = l * p, t[1] = (-c * r + i * h) * p, t[2] = (s * r - i * a) * p, t[3] = f * p, t[4] = (c * n - i * u) * p, t[5] = (-s * n + i * o) * p, t[6] = d * p, t[7] = (-h * n + r * u) * p, t[8] = (a * n - r * o) * p, t) : null }, adjoint: function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], u = e[6], h = e[7], c = e[8]; return t[0] = a * c - s * h, t[1] = i * h - r * c, t[2] = r * s - i * a, t[3] = s * u - o * c, t[4] = n * c - i * u, t[5] = i * o - n * s, t[6] = o * h - a * u, t[7] = r * u - n * h, t[8] = n * a - r * o, t }, determinant: function (t) { var e = t[0], n = t[1], r = t[2], i = t[3], o = t[4], a = t[5], s = t[6], u = t[7], h = t[8]; return e * (h * o - a * u) + n * (-h * i + a * s) + r * (u * i - o * s) }, multiply: Te, translate: function (t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = e[4], u = e[5], h = e[6], c = e[7], l = e[8], f = n[0], d = n[1]; return t[0] = r, t[1] = i, t[2] = o, t[3] = a, t[4] = s, t[5] = u, t[6] = f * r + d * a + h, t[7] = f * i + d * s + c, t[8] = f * o + d * u + l, t }, rotate: function (t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = e[4], u = e[5], h = e[6], c = e[7], l = e[8], f = Math.sin(n), d = Math.cos(n); return t[0] = d * r + f * a, t[1] = d * i + f * s, t[2] = d * o + f * u, t[3] = d * a - f * r, t[4] = d * s - f * i, t[5] = d * u - f * o, t[6] = h, t[7] = c, t[8] = l, t }, scale: function (t, e, n) { var r = n[0], i = n[1]; return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t }, fromTranslation: function (t, e) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t }, fromRotation: function (t, e) { var n = Math.sin(e), r = Math.cos(e); return t[0] = r, t[1] = n, t[2] = 0, t[3] = -n, t[4] = r, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t }, fromScaling: function (t, e) { return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t }, fromMat2d: function (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t }, fromQuat: function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = n + n, s = r + r, u = i + i, h = n * a, c = r * a, l = r * s, f = i * a, d = i * s, p = i * u, v = o * a, m = o * s, g = o * u; return t[0] = 1 - l - p, t[3] = c - g, t[6] = f + m, t[1] = c + g, t[4] = 1 - h - p, t[7] = d - v, t[2] = f - m, t[5] = d + v, t[8] = 1 - h - l, t }, normalFromMat4: function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], u = e[6], h = e[7], c = e[8], l = e[9], f = e[10], d = e[11], p = e[12], v = e[13], m = e[14], g = e[15], y = n * s - r * a, _ = n * u - i * a, x = n * h - o * a, b = r * u - i * s, M = r * h - o * s, w = i * h - o * u, E = c * v - l * p, T = c * m - f * p, A = c * g - d * p, C = l * m - f * v, R = l * g - d * v, S = f * g - d * m, P = y * S - _ * R + x * C + b * A - M * T + w * E; return P ? (P = 1 / P, t[0] = (s * S - u * R + h * C) * P, t[1] = (u * A - a * S - h * T) * P, t[2] = (a * R - s * A + h * E) * P, t[3] = (i * R - r * S - o * C) * P, t[4] = (n * S - i * A + o * T) * P, t[5] = (r * A - n * R - o * E) * P, t[6] = (v * w - m * M + g * b) * P, t[7] = (m * x - p * w - g * _) * P, t[8] = (p * M - v * x + g * y) * P, t) : null }, projection: function (t, e, n) { return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / n, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t }, str: function (t) { return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")" }, frob: function (t) { return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]) }, add: function (t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t }, subtract: Ae, multiplyScalar: function (t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t }, multiplyScalarAndAdd: function (t, e, n, r) { return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t }, exactEquals: function (t, e) { return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] }, equals: function (t, e) { var n = t[0], r = t[1], i = t[2], o = t[3], a = t[4], s = t[5], u = t[6], h = t[7], c = t[8], l = e[0], f = e[1], d = e[2], p = e[3], v = e[4], m = e[5], g = e[6], y = e[7], _ = e[8]; return Math.abs(n - l) <= vt * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(r - f) <= vt * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(i - d) <= vt * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(o - p) <= vt * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - v) <= vt * Math.max(1, Math.abs(a), Math.abs(v)) && Math.abs(s - m) <= vt * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(u - g) <= vt * Math.max(1, Math.abs(u), Math.abs(g)) && Math.abs(h - y) <= vt * Math.max(1, Math.abs(h), Math.abs(y)) && Math.abs(c - _) <= vt * Math.max(1, Math.abs(c), Math.abs(_)) }, mul: Ce, sub: Re }); function Pe() { var t = new mt(16); return mt != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t } function De(t) { var e = new mt(16); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e } function Oe(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t } function Ie(t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t } function Le(t, e) { if (t === e) { var n = e[1], r = e[2], i = e[3], o = e[6], a = e[7], s = e[11]; t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[6] = e[9], t[7] = e[13], t[8] = r, t[9] = o, t[11] = e[14], t[12] = i, t[13] = a, t[14] = s } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15]; return t } function Be(t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], u = e[6], h = e[7], c = e[8], l = e[9], f = e[10], d = e[11], p = e[12], v = e[13], m = e[14], g = e[15], y = n * s - r * a, _ = n * u - i * a, x = n * h - o * a, b = r * u - i * s, M = r * h - o * s, w = i * h - o * u, E = c * v - l * p, T = c * m - f * p, A = c * g - d * p, C = l * m - f * v, R = l * g - d * v, S = f * g - d * m, P = y * S - _ * R + x * C + b * A - M * T + w * E; return P ? (P = 1 / P, t[0] = (s * S - u * R + h * C) * P, t[1] = (i * R - r * S - o * C) * P, t[2] = (v * w - m * M + g * b) * P, t[3] = (f * M - l * w - d * b) * P, t[4] = (u * A - a * S - h * T) * P, t[5] = (n * S - i * A + o * T) * P, t[6] = (m * x - p * w - g * _) * P, t[7] = (c * w - f * x + d * _) * P, t[8] = (a * R - s * A + h * E) * P, t[9] = (r * A - n * R - o * E) * P, t[10] = (p * M - v * x + g * y) * P, t[11] = (l * x - c * M - d * y) * P, t[12] = (s * T - a * C - u * E) * P, t[13] = (n * C - r * T + i * E) * P, t[14] = (v * _ - p * b - m * y) * P, t[15] = (c * b - l * _ + f * y) * P, t) : null } function ke(t) { var e = t[0], n = t[1], r = t[2], i = t[3], o = t[4], a = t[5], s = t[6], u = t[7], h = t[8], c = t[9], l = t[10], f = t[11], d = t[12], p = t[13], v = t[14], m = t[15]; return (e * a - n * o) * (l * m - f * v) - (e * s - r * o) * (c * m - f * p) + (e * u - i * o) * (c * v - l * p) + (n * s - r * a) * (h * m - f * d) - (n * u - i * a) * (h * v - l * d) + (r * u - i * s) * (h * p - c * d) } function Ue(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = e[4], u = e[5], h = e[6], c = e[7], l = e[8], f = e[9], d = e[10], p = e[11], v = e[12], m = e[13], g = e[14], y = e[15], _ = n[0], x = n[1], b = n[2], M = n[3]; return t[0] = _ * r + x * s + b * l + M * v, t[1] = _ * i + x * u + b * f + M * m, t[2] = _ * o + x * h + b * d + M * g, t[3] = _ * a + x * c + b * p + M * y, _ = n[4], x = n[5], b = n[6], M = n[7], t[4] = _ * r + x * s + b * l + M * v, t[5] = _ * i + x * u + b * f + M * m, t[6] = _ * o + x * h + b * d + M * g, t[7] = _ * a + x * c + b * p + M * y, _ = n[8], x = n[9], b = n[10], M = n[11], t[8] = _ * r + x * s + b * l + M * v, t[9] = _ * i + x * u + b * f + M * m, t[10] = _ * o + x * h + b * d + M * g, t[11] = _ * a + x * c + b * p + M * y, _ = n[12], x = n[13], b = n[14], M = n[15], t[12] = _ * r + x * s + b * l + M * v, t[13] = _ * i + x * u + b * f + M * m, t[14] = _ * o + x * h + b * d + M * g, t[15] = _ * a + x * c + b * p + M * y, t } function Ne(t, e, n) { var r, i, o, a, s, u, h, c, l, f, d, p, v = n[0], m = n[1], g = n[2]; return e === t ? (t[12] = e[0] * v + e[4] * m + e[8] * g + e[12], t[13] = e[1] * v + e[5] * m + e[9] * g + e[13], t[14] = e[2] * v + e[6] * m + e[10] * g + e[14], t[15] = e[3] * v + e[7] * m + e[11] * g + e[15]) : (r = e[0], i = e[1], o = e[2], a = e[3], s = e[4], u = e[5], h = e[6], c = e[7], l = e[8], f = e[9], d = e[10], p = e[11], t[0] = r, t[1] = i, t[2] = o, t[3] = a, t[4] = s, t[5] = u, t[6] = h, t[7] = c, t[8] = l, t[9] = f, t[10] = d, t[11] = p, t[12] = r * v + s * m + l * g + e[12], t[13] = i * v + u * m + f * g + e[13], t[14] = o * v + h * m + d * g + e[14], t[15] = a * v + c * m + p * g + e[15]), t } function Fe(t, e, n) { var r = n[0], i = n[1], o = n[2]; return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * o, t[9] = e[9] * o, t[10] = e[10] * o, t[11] = e[11] * o, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t } function je(t, e, n, r) { var i, o, a, s, u, h, c, l, f, d, p, v, m, g, y, _, x, b, M, w, E, T, A, C, R = r[0], S = r[1], P = r[2], D = Math.hypot(R, S, P); return D < vt ? null : (R *= D = 1 / D, S *= D, P *= D, i = Math.sin(n), a = 1 - (o = Math.cos(n)), s = e[0], u = e[1], h = e[2], c = e[3], l = e[4], f = e[5], d = e[6], p = e[7], v = e[8], m = e[9], g = e[10], y = e[11], _ = R * R * a + o, x = S * R * a + P * i, b = P * R * a - S * i, M = R * S * a - P * i, w = S * S * a + o, E = P * S * a + R * i, T = R * P * a + S * i, A = S * P * a - R * i, C = P * P * a + o, t[0] = s * _ + l * x + v * b, t[1] = u * _ + f * x + m * b, t[2] = h * _ + d * x + g * b, t[3] = c * _ + p * x + y * b, t[4] = s * M + l * w + v * E, t[5] = u * M + f * w + m * E, t[6] = h * M + d * w + g * E, t[7] = c * M + p * w + y * E, t[8] = s * T + l * A + v * C, t[9] = u * T + f * A + m * C, t[10] = h * T + d * A + g * C, t[11] = c * T + p * A + y * C, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t) } function ze(t, e, n) { var r = Math.sin(n), i = Math.cos(n), o = e[4], a = e[5], s = e[6], u = e[7], h = e[8], c = e[9], l = e[10], f = e[11]; return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = o * i + h * r, t[5] = a * i + c * r, t[6] = s * i + l * r, t[7] = u * i + f * r, t[8] = h * i - o * r, t[9] = c * i - a * r, t[10] = l * i - s * r, t[11] = f * i - u * r, t } function Ve(t, e, n) { var r = Math.sin(n), i = Math.cos(n), o = e[0], a = e[1], s = e[2], u = e[3], h = e[8], c = e[9], l = e[10], f = e[11]; return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * i - h * r, t[1] = a * i - c * r, t[2] = s * i - l * r, t[3] = u * i - f * r, t[8] = o * r + h * i, t[9] = a * r + c * i, t[10] = s * r + l * i, t[11] = u * r + f * i, t } function Ge(t, e, n) { var r = Math.sin(n), i = Math.cos(n), o = e[0], a = e[1], s = e[2], u = e[3], h = e[4], c = e[5], l = e[6], f = e[7]; return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * i + h * r, t[1] = a * i + c * r, t[2] = s * i + l * r, t[3] = u * i + f * r, t[4] = h * i - o * r, t[5] = c * i - a * r, t[6] = l * i - s * r, t[7] = f * i - u * r, t } function We(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = r + r, u = i + i, h = o + o, c = r * s, l = r * u, f = r * h, d = i * u, p = i * h, v = o * h, m = a * s, g = a * u, y = a * h; return t[0] = 1 - (d + v), t[1] = l + y, t[2] = f - g, t[3] = 0, t[4] = l - y, t[5] = 1 - (c + v), t[6] = p + m, t[7] = 0, t[8] = f + g, t[9] = p - m, t[10] = 1 - (c + d), t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t } function He(t, e) { var n = e[0], r = e[1], i = e[2], o = e[4], a = e[5], s = e[6], u = e[8], h = e[9], c = e[10]; return t[0] = Math.hypot(n, r, i), t[1] = Math.hypot(o, a, s), t[2] = Math.hypot(u, h, c), t } function Ze(t, e) { var n = new mt(3); He(n, e); var r = 1 / n[0], i = 1 / n[1], o = 1 / n[2], a = e[0] * r, s = e[1] * i, u = e[2] * o, h = e[4] * r, c = e[5] * i, l = e[6] * o, f = e[8] * r, d = e[9] * i, p = e[10] * o, v = a + c + p, m = 0; return v > 0 ? (m = 2 * Math.sqrt(v + 1), t[3] = .25 * m, t[0] = (l - d) / m, t[1] = (f - u) / m, t[2] = (s - h) / m) : a > c && a > p ? (m = 2 * Math.sqrt(1 + a - c - p), t[3] = (l - d) / m, t[0] = .25 * m, t[1] = (s + h) / m, t[2] = (f + u) / m) : c > p ? (m = 2 * Math.sqrt(1 + c - a - p), t[3] = (f - u) / m, t[0] = (s + h) / m, t[1] = .25 * m, t[2] = (l + d) / m) : (m = 2 * Math.sqrt(1 + p - a - c), t[3] = (s - h) / m, t[0] = (f + u) / m, t[1] = (l + d) / m, t[2] = .25 * m), t } function qe(t, e, n, r) { var i = e[0], o = e[1], a = e[2], s = e[3], u = i + i, h = o + o, c = a + a, l = i * u, f = i * h, d = i * c, p = o * h, v = o * c, m = a * c, g = s * u, y = s * h, _ = s * c, x = r[0], b = r[1], M = r[2]; return t[0] = (1 - (p + m)) * x, t[1] = (f + _) * x, t[2] = (d - y) * x, t[3] = 0, t[4] = (f - _) * b, t[5] = (1 - (l + m)) * b, t[6] = (v + g) * b, t[7] = 0, t[8] = (d + y) * M, t[9] = (v - g) * M, t[10] = (1 - (l + p)) * M, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t } function Ye(t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = n + n, s = r + r, u = i + i, h = n * a, c = r * a, l = r * s, f = i * a, d = i * s, p = i * u, v = o * a, m = o * s, g = o * u; return t[0] = 1 - l - p, t[1] = c + g, t[2] = f - m, t[3] = 0, t[4] = c - g, t[5] = 1 - h - p, t[6] = d + v, t[7] = 0, t[8] = f + m, t[9] = d - v, t[10] = 1 - h - l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t } function Xe(t, e, n, r, i, o, a) { var s = 1 / (n - e), u = 1 / (i - r), h = 1 / (o - a); return t[0] = 2 * o * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * o * u, t[6] = 0, t[7] = 0, t[8] = (n + e) * s, t[9] = (i + r) * u, t[10] = (a + o) * h, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = a * o * 2 * h, t[15] = 0, t } function Ke(t, e, n, r, i) { var o, a = 1 / Math.tan(e / 2); return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (o = 1 / (r - i), t[10] = (i + r) * o, t[14] = 2 * i * r * o) : (t[10] = -1, t[14] = -2 * r), t } var Qe = Ke; function Je(t, e, n, r, i, o, a) { var s = 1 / (e - n), u = 1 / (r - i), h = 1 / (o - a); return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * u, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * h, t[11] = 0, t[12] = (e + n) * s, t[13] = (i + r) * u, t[14] = (a + o) * h, t[15] = 1, t } var $e = Je; function tn(t, e, n, r) { var i, o, a, s, u, h, c, l, f, d, p = e[0], v = e[1], m = e[2], g = r[0], y = r[1], _ = r[2], x = n[0], b = n[1], M = n[2]; return Math.abs(p - x) < vt && Math.abs(v - b) < vt && Math.abs(m - M) < vt ? Ie(t) : (c = p - x, l = v - b, f = m - M, i = y * (f *= d = 1 / Math.hypot(c, l, f)) - _ * (l *= d), o = _ * (c *= d) - g * f, a = g * l - y * c, (d = Math.hypot(i, o, a)) ? (i *= d = 1 / d, o *= d, a *= d) : (i = 0, o = 0, a = 0), s = l * a - f * o, u = f * i - c * a, h = c * o - l * i, (d = Math.hypot(s, u, h)) ? (s *= d = 1 / d, u *= d, h *= d) : (s = 0, u = 0, h = 0), t[0] = i, t[1] = s, t[2] = c, t[3] = 0, t[4] = o, t[5] = u, t[6] = l, t[7] = 0, t[8] = a, t[9] = h, t[10] = f, t[11] = 0, t[12] = -(i * p + o * v + a * m), t[13] = -(s * p + u * v + h * m), t[14] = -(c * p + l * v + f * m), t[15] = 1, t) } function en(t, e, n, r) { var i = e[0], o = e[1], a = e[2], s = r[0], u = r[1], h = r[2], c = i - n[0], l = o - n[1], f = a - n[2], d = c * c + l * l + f * f; d > 0 && (c *= d = 1 / Math.sqrt(d), l *= d, f *= d); var p = u * f - h * l, v = h * c - s * f, m = s * l - u * c; return (d = p * p + v * v + m * m) > 0 && (p *= d = 1 / Math.sqrt(d), v *= d, m *= d), t[0] = p, t[1] = v, t[2] = m, t[3] = 0, t[4] = l * m - f * v, t[5] = f * p - c * m, t[6] = c * v - l * p, t[7] = 0, t[8] = c, t[9] = l, t[10] = f, t[11] = 0, t[12] = i, t[13] = o, t[14] = a, t[15] = 1, t } function nn(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t[9] = e[9] - n[9], t[10] = e[10] - n[10], t[11] = e[11] - n[11], t[12] = e[12] - n[12], t[13] = e[13] - n[13], t[14] = e[14] - n[14], t[15] = e[15] - n[15], t } var rn = Ue, on = nn, an = Object.freeze({ __proto__: null, create: Pe, clone: De, copy: Oe, fromValues: function (t, e, n, r, i, o, a, s, u, h, c, l, f, d, p, v) { var m = new mt(16); return m[0] = t, m[1] = e, m[2] = n, m[3] = r, m[4] = i, m[5] = o, m[6] = a, m[7] = s, m[8] = u, m[9] = h, m[10] = c, m[11] = l, m[12] = f, m[13] = d, m[14] = p, m[15] = v, m }, set: function (t, e, n, r, i, o, a, s, u, h, c, l, f, d, p, v, m) { return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = o, t[5] = a, t[6] = s, t[7] = u, t[8] = h, t[9] = c, t[10] = l, t[11] = f, t[12] = d, t[13] = p, t[14] = v, t[15] = m, t }, identity: Ie, transpose: Le, invert: Be, adjoint: function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], u = e[6], h = e[7], c = e[8], l = e[9], f = e[10], d = e[11], p = e[12], v = e[13], m = e[14], g = e[15]; return t[0] = s * (f * g - d * m) - l * (u * g - h * m) + v * (u * d - h * f), t[1] = -(r * (f * g - d * m) - l * (i * g - o * m) + v * (i * d - o * f)), t[2] = r * (u * g - h * m) - s * (i * g - o * m) + v * (i * h - o * u), t[3] = -(r * (u * d - h * f) - s * (i * d - o * f) + l * (i * h - o * u)), t[4] = -(a * (f * g - d * m) - c * (u * g - h * m) + p * (u * d - h * f)), t[5] = n * (f * g - d * m) - c * (i * g - o * m) + p * (i * d - o * f), t[6] = -(n * (u * g - h * m) - a * (i * g - o * m) + p * (i * h - o * u)), t[7] = n * (u * d - h * f) - a * (i * d - o * f) + c * (i * h - o * u), t[8] = a * (l * g - d * v) - c * (s * g - h * v) + p * (s * d - h * l), t[9] = -(n * (l * g - d * v) - c * (r * g - o * v) + p * (r * d - o * l)), t[10] = n * (s * g - h * v) - a * (r * g - o * v) + p * (r * h - o * s), t[11] = -(n * (s * d - h * l) - a * (r * d - o * l) + c * (r * h - o * s)), t[12] = -(a * (l * m - f * v) - c * (s * m - u * v) + p * (s * f - u * l)), t[13] = n * (l * m - f * v) - c * (r * m - i * v) + p * (r * f - i * l), t[14] = -(n * (s * m - u * v) - a * (r * m - i * v) + p * (r * u - i * s)), t[15] = n * (s * f - u * l) - a * (r * f - i * l) + c * (r * u - i * s), t }, determinant: ke, multiply: Ue, translate: Ne, scale: Fe, rotate: je, rotateX: ze, rotateY: Ve, rotateZ: Ge, fromTranslation: function (t, e) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t }, fromScaling: function (t, e) { return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, fromRotation: function (t, e, n) { var r, i, o, a = n[0], s = n[1], u = n[2], h = Math.hypot(a, s, u); return h < vt ? null : (a *= h = 1 / h, s *= h, u *= h, r = Math.sin(e), o = 1 - (i = Math.cos(e)), t[0] = a * a * o + i, t[1] = s * a * o + u * r, t[2] = u * a * o - s * r, t[3] = 0, t[4] = a * s * o - u * r, t[5] = s * s * o + i, t[6] = u * s * o + a * r, t[7] = 0, t[8] = a * u * o + s * r, t[9] = s * u * o - a * r, t[10] = u * u * o + i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t) }, fromXRotation: function (t, e) { var n = Math.sin(e), r = Math.cos(e); return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = r, t[6] = n, t[7] = 0, t[8] = 0, t[9] = -n, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, fromYRotation: function (t, e) { var n = Math.sin(e), r = Math.cos(e); return t[0] = r, t[1] = 0, t[2] = -n, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = n, t[9] = 0, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, fromZRotation: function (t, e) { var n = Math.sin(e), r = Math.cos(e); return t[0] = r, t[1] = n, t[2] = 0, t[3] = 0, t[4] = -n, t[5] = r, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, fromRotationTranslation: We, fromQuat2: function (t, e) { var n = new mt(3), r = -e[0], i = -e[1], o = -e[2], a = e[3], s = e[4], u = e[5], h = e[6], c = e[7], l = r * r + i * i + o * o + a * a; return l > 0 ? (n[0] = 2 * (s * a + c * r + u * o - h * i) / l, n[1] = 2 * (u * a + c * i + h * r - s * o) / l, n[2] = 2 * (h * a + c * o + s * i - u * r) / l) : (n[0] = 2 * (s * a + c * r + u * o - h * i), n[1] = 2 * (u * a + c * i + h * r - s * o), n[2] = 2 * (h * a + c * o + s * i - u * r)), We(t, e, n), t }, getTranslation: function (t, e) { return t[0] = e[12], t[1] = e[13], t[2] = e[14], t }, getScaling: He, getRotation: Ze, fromRotationTranslationScale: qe, fromRotationTranslationScaleOrigin: function (t, e, n, r, i) { var o = e[0], a = e[1], s = e[2], u = e[3], h = o + o, c = a + a, l = s + s, f = o * h, d = o * c, p = o * l, v = a * c, m = a * l, g = s * l, y = u * h, _ = u * c, x = u * l, b = r[0], M = r[1], w = r[2], E = i[0], T = i[1], A = i[2], C = (1 - (v + g)) * b, R = (d + x) * b, S = (p - _) * b, P = (d - x) * M, D = (1 - (f + g)) * M, O = (m + y) * M, I = (p + _) * w, L = (m - y) * w, B = (1 - (f + v)) * w; return t[0] = C, t[1] = R, t[2] = S, t[3] = 0, t[4] = P, t[5] = D, t[6] = O, t[7] = 0, t[8] = I, t[9] = L, t[10] = B, t[11] = 0, t[12] = n[0] + E - (C * E + P * T + I * A), t[13] = n[1] + T - (R * E + D * T + L * A), t[14] = n[2] + A - (S * E + O * T + B * A), t[15] = 1, t }, fromQuat: Ye, frustum: Xe, perspectiveNO: Ke, perspective: Qe, perspectiveZO: function (t, e, n, r, i) { var o, a = 1 / Math.tan(e / 2); return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (o = 1 / (r - i), t[10] = i * o, t[14] = i * r * o) : (t[10] = -1, t[14] = -r), t }, perspectiveFromFieldOfView: function (t, e, n, r) { var i = Math.tan(e.upDegrees * Math.PI / 180), o = Math.tan(e.downDegrees * Math.PI / 180), a = Math.tan(e.leftDegrees * Math.PI / 180), s = Math.tan(e.rightDegrees * Math.PI / 180), u = 2 / (a + s), h = 2 / (i + o); return t[0] = u, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = h, t[6] = 0, t[7] = 0, t[8] = -(a - s) * u * .5, t[9] = (i - o) * h * .5, t[10] = r / (n - r), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = r * n / (n - r), t[15] = 0, t }, orthoNO: Je, ortho: $e, orthoZO: function (t, e, n, r, i, o, a) { var s = 1 / (e - n), u = 1 / (r - i), h = 1 / (o - a); return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * u, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = h, t[11] = 0, t[12] = (e + n) * s, t[13] = (i + r) * u, t[14] = o * h, t[15] = 1, t }, lookAt: tn, targetTo: en, str: function (t) { return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")" }, frob: function (t) { return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]) }, add: function (t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t[9] = e[9] + n[9], t[10] = e[10] + n[10], t[11] = e[11] + n[11], t[12] = e[12] + n[12], t[13] = e[13] + n[13], t[14] = e[14] + n[14], t[15] = e[15] + n[15], t }, subtract: nn, multiplyScalar: function (t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12] * n, t[13] = e[13] * n, t[14] = e[14] * n, t[15] = e[15] * n, t }, multiplyScalarAndAdd: function (t, e, n, r) { return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t[9] = e[9] + n[9] * r, t[10] = e[10] + n[10] * r, t[11] = e[11] + n[11] * r, t[12] = e[12] + n[12] * r, t[13] = e[13] + n[13] * r, t[14] = e[14] + n[14] * r, t[15] = e[15] + n[15] * r, t }, exactEquals: function (t, e) { return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15] }, equals: function (t, e) { var n = t[0], r = t[1], i = t[2], o = t[3], a = t[4], s = t[5], u = t[6], h = t[7], c = t[8], l = t[9], f = t[10], d = t[11], p = t[12], v = t[13], m = t[14], g = t[15], y = e[0], _ = e[1], x = e[2], b = e[3], M = e[4], w = e[5], E = e[6], T = e[7], A = e[8], C = e[9], R = e[10], S = e[11], P = e[12], D = e[13], O = e[14], I = e[15]; return Math.abs(n - y) <= vt * Math.max(1, Math.abs(n), Math.abs(y)) && Math.abs(r - _) <= vt * Math.max(1, Math.abs(r), Math.abs(_)) && Math.abs(i - x) <= vt * Math.max(1, Math.abs(i), Math.abs(x)) && Math.abs(o - b) <= vt * Math.max(1, Math.abs(o), Math.abs(b)) && Math.abs(a - M) <= vt * Math.max(1, Math.abs(a), Math.abs(M)) && Math.abs(s - w) <= vt * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(u - E) <= vt * Math.max(1, Math.abs(u), Math.abs(E)) && Math.abs(h - T) <= vt * Math.max(1, Math.abs(h), Math.abs(T)) && Math.abs(c - A) <= vt * Math.max(1, Math.abs(c), Math.abs(A)) && Math.abs(l - C) <= vt * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(f - R) <= vt * Math.max(1, Math.abs(f), Math.abs(R)) && Math.abs(d - S) <= vt * Math.max(1, Math.abs(d), Math.abs(S)) && Math.abs(p - P) <= vt * Math.max(1, Math.abs(p), Math.abs(P)) && Math.abs(v - D) <= vt * Math.max(1, Math.abs(v), Math.abs(D)) && Math.abs(m - O) <= vt * Math.max(1, Math.abs(m), Math.abs(O)) && Math.abs(g - I) <= vt * Math.max(1, Math.abs(g), Math.abs(I)) }, mul: rn, sub: on }); function sn() { var t = new mt(4); return mt != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t } function un(t) { var e = new mt(4); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e } function hn(t, e, n, r) { var i = new mt(4); return i[0] = t, i[1] = e, i[2] = n, i[3] = r, i } function cn(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t } function ln(t, e, n, r, i) { return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t } function fn(t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t } function dn(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t } function pn(t, e, n) { return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t[3] = e[3] * n[3], t } function vn(t, e, n) { return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t[3] = e[3] / n[3], t } function mn(t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t } function gn(t, e) { var n = e[0] - t[0], r = e[1] - t[1], i = e[2] - t[2], o = e[3] - t[3]; return Math.hypot(n, r, i, o) } function yn(t, e) { var n = e[0] - t[0], r = e[1] - t[1], i = e[2] - t[2], o = e[3] - t[3]; return n * n + r * r + i * i + o * o } function _n(t) { var e = t[0], n = t[1], r = t[2], i = t[3]; return Math.hypot(e, n, r, i) } function xn(t) { var e = t[0], n = t[1], r = t[2], i = t[3]; return e * e + n * n + r * r + i * i } function bn(t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = n * n + r * r + i * i + o * o; return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = n * a, t[1] = r * a, t[2] = i * a, t[3] = o * a, t } function Mn(t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3] } function wn(t, e, n, r) { var i = e[0], o = e[1], a = e[2], s = e[3]; return t[0] = i + r * (n[0] - i), t[1] = o + r * (n[1] - o), t[2] = a + r * (n[2] - a), t[3] = s + r * (n[3] - s), t } function En(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3]; return t[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * a, t[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * a, t[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * a, t[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * a, t } function Tn(t, e) { return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] } function An(t, e) { var n = t[0], r = t[1], i = t[2], o = t[3], a = e[0], s = e[1], u = e[2], h = e[3]; return Math.abs(n - a) <= vt * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - s) <= vt * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - u) <= vt * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(o - h) <= vt * Math.max(1, Math.abs(o), Math.abs(h)) } var Cn, Rn = dn, Sn = pn, Pn = vn, Dn = gn, On = yn, In = _n, Ln = xn, Bn = function () { var t = sn(); return function (e, n, r, i, o, a) { var s, u; for (n || (n = 4), r || (r = 0), u = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < u; s += n)t[0] = e[s], t[1] = e[s + 1], t[2] = e[s + 2], t[3] = e[s + 3], o(t, t, a), e[s] = t[0], e[s + 1] = t[1], e[s + 2] = t[2], e[s + 3] = t[3]; return e } }(), kn = Object.freeze({ __proto__: null, create: sn, clone: un, fromValues: hn, copy: cn, set: ln, add: fn, subtract: dn, multiply: pn, divide: vn, ceil: function (t, e) { return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t[3] = Math.ceil(e[3]), t }, floor: function (t, e) { return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t[3] = Math.floor(e[3]), t }, min: function (t, e, n) { return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t[3] = Math.min(e[3], n[3]), t }, max: function (t, e, n) { return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t[3] = Math.max(e[3], n[3]), t }, round: function (t, e) { return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t[3] = Math.round(e[3]), t }, scale: mn, scaleAndAdd: function (t, e, n, r) { return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t }, distance: gn, squaredDistance: yn, length: _n, squaredLength: xn, negate: function (t, e) { return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t }, inverse: function (t, e) { return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t[3] = 1 / e[3], t }, normalize: bn, dot: Mn, cross: function (t, e, n, r) { var i = n[0] * r[1] - n[1] * r[0], o = n[0] * r[2] - n[2] * r[0], a = n[0] * r[3] - n[3] * r[0], s = n[1] * r[2] - n[2] * r[1], u = n[1] * r[3] - n[3] * r[1], h = n[2] * r[3] - n[3] * r[2], c = e[0], l = e[1], f = e[2], d = e[3]; return t[0] = l * h - f * u + d * s, t[1] = -c * h + f * a - d * o, t[2] = c * u - l * a + d * i, t[3] = -c * s + l * o - f * i, t }, lerp: wn, random: function (t, e) { var n, r, i, o, a, s; e = e || 1; do { a = (n = 2 * gt() - 1) * n + (r = 2 * gt() - 1) * r } while (a >= 1); do { s = (i = 2 * gt() - 1) * i + (o = 2 * gt() - 1) * o } while (s >= 1); var u = Math.sqrt((1 - a) / s); return t[0] = e * n, t[1] = e * r, t[2] = e * i * u, t[3] = e * o * u, t }, transformMat4: En, transformQuat: function (t, e, n) { var r = e[0], i = e[1], o = e[2], a = n[0], s = n[1], u = n[2], h = n[3], c = h * r + s * o - u * i, l = h * i + u * r - a * o, f = h * o + a * i - s * r, d = -a * r - s * i - u * o; return t[0] = c * h + d * -a + l * -u - f * -s, t[1] = l * h + d * -s + f * -a - c * -u, t[2] = f * h + d * -u + c * -s - l * -a, t[3] = e[3], t }, zero: function (t) { return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t }, str: function (t) { return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")" }, exactEquals: Tn, equals: An, sub: Rn, mul: Sn, div: Pn, dist: Dn, sqrDist: On, len: In, sqrLen: Ln, forEach: Bn }); !function (t) { t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL0ROW3 = 3] = "COL0ROW3", t[t.COL1ROW0 = 4] = "COL1ROW0", t[t.COL1ROW1 = 5] = "COL1ROW1", t[t.COL1ROW2 = 6] = "COL1ROW2", t[t.COL1ROW3 = 7] = "COL1ROW3", t[t.COL2ROW0 = 8] = "COL2ROW0", t[t.COL2ROW1 = 9] = "COL2ROW1", t[t.COL2ROW2 = 10] = "COL2ROW2", t[t.COL2ROW3 = 11] = "COL2ROW3", t[t.COL3ROW0 = 12] = "COL3ROW0", t[t.COL3ROW1 = 13] = "COL3ROW1", t[t.COL3ROW2 = 14] = "COL3ROW2", t[t.COL3ROW3 = 15] = "COL3ROW3" }(Cn || (Cn = {})); const Un = 45 * Math.PI / 180, Nn = 1, Fn = .1, jn = 500, zn = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]); class Vn extends we { static get IDENTITY() { return function () { Wn || (Wn = new Vn, Object.freeze(Wn)); return Wn }() } static get ZERO() { return function () { Gn || (Gn = new Vn([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Gn)); return Gn }() } get ELEMENTS() { return 16 } get RANK() { return 4 } get INDICES() { return Cn } constructor(t) { super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), 1 === arguments.length && Array.isArray(t) ? this.copy(t) : this.identity() } copy(t) { return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check() } set(t, e, n, r, i, o, a, s, u, h, c, l, f, d, p, v) { return this[0] = t, this[1] = e, this[2] = n, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = s, this[8] = u, this[9] = h, this[10] = c, this[11] = l, this[12] = f, this[13] = d, this[14] = p, this[15] = v, this.check() } setRowMajor(t, e, n, r, i, o, a, s, u, h, c, l, f, d, p, v) { return this[0] = t, this[1] = i, this[2] = u, this[3] = f, this[4] = e, this[5] = o, this[6] = h, this[7] = d, this[8] = n, this[9] = a, this[10] = c, this[11] = p, this[12] = r, this[13] = s, this[14] = l, this[15] = v, this.check() } toRowMajor(t) { return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t } identity() { return this.copy(zn) } fromObject(t) { return this.check() } fromQuaternion(t) { return Ye(this, t), this.check() } frustum(t) { const { left: e, right: n, bottom: r, top: i, near: o = Fn, far: a = jn } = t; return a === 1 / 0 ? function (t, e, n, r, i, o) { const a = 2 * o / (n - e), s = 2 * o / (i - r), u = (n + e) / (n - e), h = (i + r) / (i - r), c = -1, l = -1, f = -2 * o; t[0] = a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = 0, t[7] = 0, t[8] = u, t[9] = h, t[10] = c, t[11] = l, t[12] = 0, t[13] = 0, t[14] = f, t[15] = 0 }(this, e, n, r, i, o) : Xe(this, e, n, r, i, o, a), this.check() } lookAt(t) { const { eye: e, center: n = [0, 0, 0], up: r = [0, 1, 0] } = t; return tn(this, e, n, r), this.check() } ortho(t) { const { left: e, right: n, bottom: r, top: i, near: o = Fn, far: a = jn } = t; return $e(this, e, n, r, i, o, a), this.check() } orthographic(t) { const { fovy: e = Un, aspect: n = Nn, focalDistance: r = 1, near: i = Fn, far: o = jn } = t; Hn(e); const a = e / 2, s = r * Math.tan(a), u = s * n; return this.ortho({ left: -u, right: u, bottom: -s, top: s, near: i, far: o }) } perspective(t) { const { fovy: e = 45 * Math.PI / 180, aspect: n = 1, near: r = .1, far: i = 500 } = t; return Hn(e), Qe(this, e, n, r, i), this.check() } determinant() { return ke(this) } getScale(t = [-0, -0, -0]) { return t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), t } getTranslation(t = [-0, -0, -0]) { return t[0] = this[12], t[1] = this[13], t[2] = this[14], t } getRotation(t, e) { t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], e = e || [-0, -0, -0]; const n = this.getScale(e), r = 1 / n[0], i = 1 / n[1], o = 1 / n[2]; return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * r, t[5] = this[5] * i, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * r, t[9] = this[9] * i, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t } getRotationMatrix3(t, e) { t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0], e = e || [-0, -0, -0]; const n = this.getScale(e), r = 1 / n[0], i = 1 / n[1], o = 1 / n[2]; return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = this[4] * r, t[4] = this[5] * i, t[5] = this[6] * o, t[6] = this[8] * r, t[7] = this[9] * i, t[8] = this[10] * o, t } transpose() { return Le(this, this), this.check() } invert() { return Be(this, this), this.check() } multiplyLeft(t) { return Ue(this, t, this), this.check() } multiplyRight(t) { return Ue(this, this, t), this.check() } rotateX(t) { return ze(this, this, t), this.check() } rotateY(t) { return Ve(this, this, t), this.check() } rotateZ(t) { return Ge(this, this, t), this.check() } rotateXYZ(t) { return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2]) } rotateAxis(t, e) { return je(this, this, t, e), this.check() } scale(t) { return Fe(this, this, Array.isArray(t) ? t : [t, t, t]), this.check() } translate(t) { return Ne(this, this, t), this.check() } transform(t, e) { return 4 === t.length ? (dt(e = En(e || [-0, -0, -0, -0], t, this), 4), e) : this.transformAsPoint(t, e) } transformAsPoint(t, e) { const { length: n } = t; let r; switch (n) { case 2: r = Ct(e || [-0, -0], t, this); break; case 3: r = ee(e || [-0, -0, -0], t, this); break; default: throw new Error("Illegal vector") }return dt(r, t.length), r } transformAsVector(t, e) { let n; switch (t.length) { case 2: n = function (t, e, n) { const r = e[0], i = e[1], o = n[3] * r + n[7] * i || 1; return t[0] = (n[0] * r + n[4] * i) / o, t[1] = (n[1] * r + n[5] * i) / o, t }(e || [-0, -0], t, this); break; case 3: n = Nt(e || [-0, -0, -0], t, this); break; default: throw new Error("Illegal vector") }return dt(n, t.length), n } transformPoint(t, e) { return this.transformAsPoint(t, e) } transformVector(t, e) { return this.transformAsPoint(t, e) } transformDirection(t, e) { return this.transformAsVector(t, e) } makeRotationX(t) { return this.identity().rotateX(t) } makeTranslation(t, e, n) { return this.identity().translate([t, e, n]) } } let Gn, Wn; function Hn(t) { if (t > 2 * Math.PI) throw Error("expected radians") } function Zn() { var t = new mt(4); return mt != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t } function qn(t) { return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t } function Yn(t, e, n) { n *= .5; var r = Math.sin(n); return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = Math.cos(n), t } function Xn(t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = n[0], u = n[1], h = n[2], c = n[3]; return t[0] = r * c + a * s + i * h - o * u, t[1] = i * c + a * u + o * s - r * h, t[2] = o * c + a * h + r * u - i * s, t[3] = a * c - r * s - i * u - o * h, t } function Kn(t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = Math.sqrt(n * n + r * r + i * i), s = Math.exp(o), u = a > 0 ? s * Math.sin(a) / a : 0; return t[0] = n * u, t[1] = r * u, t[2] = i * u, t[3] = s * Math.cos(a), t } function Qn(t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = Math.sqrt(n * n + r * r + i * i), s = a > 0 ? Math.atan2(a, o) / a : 0; return t[0] = n * s, t[1] = r * s, t[2] = i * s, t[3] = .5 * Math.log(n * n + r * r + i * i + o * o), t } function Jn(t, e, n, r) { var i, o, a, s, u, h = e[0], c = e[1], l = e[2], f = e[3], d = n[0], p = n[1], v = n[2], m = n[3]; return (o = h * d + c * p + l * v + f * m) < 0 && (o = -o, d = -d, p = -p, v = -v, m = -m), 1 - o > vt ? (i = Math.acos(o), a = Math.sin(i), s = Math.sin((1 - r) * i) / a, u = Math.sin(r * i) / a) : (s = 1 - r, u = r), t[0] = s * h + u * d, t[1] = s * c + u * p, t[2] = s * l + u * v, t[3] = s * f + u * m, t } function $n(t, e) { var n, r = e[0] + e[4] + e[8]; if (r > 0) n = Math.sqrt(r + 1), t[3] = .5 * n, n = .5 / n, t[0] = (e[5] - e[7]) * n, t[1] = (e[6] - e[2]) * n, t[2] = (e[1] - e[3]) * n; else { var i = 0; e[4] > e[0] && (i = 1), e[8] > e[3 * i + i] && (i = 2); var o = (i + 1) % 3, a = (i + 2) % 3; n = Math.sqrt(e[3 * i + i] - e[3 * o + o] - e[3 * a + a] + 1), t[i] = .5 * n, n = .5 / n, t[3] = (e[3 * o + a] - e[3 * a + o]) * n, t[o] = (e[3 * o + i] + e[3 * i + o]) * n, t[a] = (e[3 * a + i] + e[3 * i + a]) * n } return t } function tr(t, e, n, r) { var i = .5 * Math.PI / 180; e *= i, n *= i, r *= i; var o = Math.sin(e), a = Math.cos(e), s = Math.sin(n), u = Math.cos(n), h = Math.sin(r), c = Math.cos(r); return t[0] = o * u * c - a * s * h, t[1] = a * s * c + o * u * h, t[2] = a * u * h - o * s * c, t[3] = a * u * c + o * s * h, t } var er, nr, rr, ir, or, ar, sr = un, ur = hn, hr = cn, cr = ln, lr = fn, fr = Xn, dr = mn, pr = Mn, vr = wn, mr = _n, gr = mr, yr = xn, _r = yr, xr = bn, br = Tn, Mr = An, wr = (er = Ft(), nr = Vt(1, 0, 0), rr = Vt(0, 1, 0), function (t, e, n) { var r = $t(e, n); return r < -.999999 ? (te(er, nr, e), pe(er) < 1e-6 && te(er, rr, e), Jt(er, er), Yn(t, er, Math.PI), t) : r > .999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (te(er, e, n), t[0] = er[0], t[1] = er[1], t[2] = er[2], t[3] = 1 + r, xr(t, t)) }), Er = (ir = Zn(), or = Zn(), function (t, e, n, r, i, o) { return Jn(ir, e, i, o), Jn(or, n, r, o), Jn(t, ir, or, 2 * o * (1 - o)), t }), Tr = (ar = Ee(), function (t, e, n, r) { return ar[0] = n[0], ar[3] = n[1], ar[6] = n[2], ar[1] = r[0], ar[4] = r[1], ar[7] = r[2], ar[2] = -e[0], ar[5] = -e[1], ar[8] = -e[2], xr(t, $n(t, ar)) }), Ar = Object.freeze({ __proto__: null, create: Zn, identity: qn, setAxisAngle: Yn, getAxisAngle: function (t, e) { var n = 2 * Math.acos(e[3]), r = Math.sin(n / 2); return r > vt ? (t[0] = e[0] / r, t[1] = e[1] / r, t[2] = e[2] / r) : (t[0] = 1, t[1] = 0, t[2] = 0), n }, getAngle: function (t, e) { var n = pr(t, e); return Math.acos(2 * n * n - 1) }, multiply: Xn, rotateX: function (t, e, n) { n *= .5; var r = e[0], i = e[1], o = e[2], a = e[3], s = Math.sin(n), u = Math.cos(n); return t[0] = r * u + a * s, t[1] = i * u + o * s, t[2] = o * u - i * s, t[3] = a * u - r * s, t }, rotateY: function (t, e, n) { n *= .5; var r = e[0], i = e[1], o = e[2], a = e[3], s = Math.sin(n), u = Math.cos(n); return t[0] = r * u - o * s, t[1] = i * u + a * s, t[2] = o * u + r * s, t[3] = a * u - i * s, t }, rotateZ: function (t, e, n) { n *= .5; var r = e[0], i = e[1], o = e[2], a = e[3], s = Math.sin(n), u = Math.cos(n); return t[0] = r * u + i * s, t[1] = i * u - r * s, t[2] = o * u + a * s, t[3] = a * u - o * s, t }, calculateW: function (t, e) { var n = e[0], r = e[1], i = e[2]; return t[0] = n, t[1] = r, t[2] = i, t[3] = Math.sqrt(Math.abs(1 - n * n - r * r - i * i)), t }, exp: Kn, ln: Qn, pow: function (t, e, n) { return Qn(t, e), dr(t, t, n), Kn(t, t), t }, slerp: Jn, random: function (t) { var e = gt(), n = gt(), r = gt(), i = Math.sqrt(1 - e), o = Math.sqrt(e); return t[0] = i * Math.sin(2 * Math.PI * n), t[1] = i * Math.cos(2 * Math.PI * n), t[2] = o * Math.sin(2 * Math.PI * r), t[3] = o * Math.cos(2 * Math.PI * r), t }, invert: function (t, e) { var n = e[0], r = e[1], i = e[2], o = e[3], a = n * n + r * r + i * i + o * o, s = a ? 1 / a : 0; return t[0] = -n * s, t[1] = -r * s, t[2] = -i * s, t[3] = o * s, t }, conjugate: function (t, e) { return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t }, fromMat3: $n, fromEuler: tr, str: function (t) { return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")" }, clone: sr, fromValues: ur, copy: hr, set: cr, add: lr, mul: fr, scale: dr, dot: pr, lerp: vr, length: mr, len: gr, squaredLength: yr, sqrLen: _r, normalize: xr, exactEquals: br, equals: Mr, rotationTo: wr, sqlerp: Er, setAxes: Tr }); function Cr(t) { return Cr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, Cr(t) } var Rr = function (t) { return "[object String]" === Object.prototype.toString.call(t) }, Sr = function (t) { var e = "[object Function]" === Object.prototype.toString.call(t), n = "[object AsyncFunction]" === Object.prototype.toString.call(t); return e || n }, Pr = 365611; function Dr(t, e) { this.type = t, this.returnValue = !0, this.target = e || null, this.currentTarget = null } var Or = function () { function t() { this.__listeners = void 0 } var e = t.prototype; return e.on = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; this.alias("addEventListener")(e) }, e.off = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; this.alias("removeEventListener")(e) }, e.emit = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; this.alias("dispatchEvent")(e) }, e.addEventListener = function (t, e, n) { if (Sr(e)) { var r; !this.__listeners && (this.__listeners = {}); var i = this.__listeners; if ("string" == typeof n && n) { if (/[^\w-]/.test(n)) throw "nonstandard key:" + n; e.hashCode = n, r = n } !t.startsWith("on") && (t = "on" + t), "object" !== Cr(i[t]) && (i[t] = {}), r = r || (++Pr).toString(), e.hashCode = r, i[t][r] = e } }, e.removeEventListener = function (t, e) { if (Sr(e)) e = e.hashCode; else if (!Rr(e)) return; !this.__listeners && (this.__listeners = {}), !t.startsWith("on") && (t = "on" + t); var n = this.__listeners; n[t] && n[t][e] && delete n[t][e] }, e.dispatchEvent = function (t, e) { Rr(t) && (t = new Dr(t)), !this.__listeners && (this.__listeners = {}); var n = this.__listeners, r = t.type, i = e || t; if (t.target = t.target || this, t.currentTarget = this, 0 !== r.indexOf("on") && (r = "on".concat(r)), Sr(n[r]) && n[r].call(this, i), "object" === Cr(n[r])) for (var o in n[r]) Object.prototype.hasOwnProperty.call(n[r], o) && n[r][o].call(this, i); return t.returnValue }, e.alias = function (t) { var e = this; return function (n) { return e[t].apply(e, n) } }, t }(); function Ir(t, e) { var n = e[2], r = e[0], i = e[1], o = e[3], a = o * o, s = n * n, u = r * r, h = i * i, c = i * n - r * o, l = .4999999; return c < -l ? (t[0] = Math.PI / 2, t[1] = 2 * Math.atan2(i, o), t[2] = 0) : c > l ? (t[0] = -Math.PI / 2, t[1] = 2 * Math.atan2(i, o), t[2] = 0) : (t[0] = Math.asin(-2 * (n * i - r * o)), t[1] = Math.atan2(2 * (n * r + i * o), s - u - h + a), t[2] = Math.atan2(2 * (r * i + n * o), -s - u + h + a)), t } var Lr = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.DefaultOrder; this.isEuler = !0, this._x = void 0, this._y = void 0, this._z = void 0, this._order = void 0, this._onChangeCallback = void 0, this._x = e, this._y = n, this._z = r, this._order = i, this._onChangeCallback = function () { } } var e = t.prototype; return e.set = function (t, e, n) { var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; return this._x = t, this._y = e, this._z = n, r && this._onChangeCallback(), this }, e.clone = function () { return new t(this._x, this._y, this._z, this._order) }, e.copy = function (t) { return t.isEuler ? (this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this) : this }, e.equals = function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, e.toVector3 = function () { return Vt(this._x, this._y, this._z) }, e.onChange = function (t) { "function" == typeof t && (this._onChangeCallback = t) }, o(t, [{ key: "x", get: function () { return this._x }, set: function (t) { this._x = t, this._onChangeCallback() } }, { key: "y", get: function () { return this._y }, set: function (t) { this._y = t, this._onChangeCallback() } }, { key: "z", get: function () { return this._z }, set: function (t) { this._z = t, this._onChangeCallback() } }, { key: "order", get: function () { return this._order }, set: function (t) { this._order = t, this._onChangeCallback() } }]), t }(); function Br() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (t) { var e = 16 * Math.random() | 0; return ("x" === t ? e : 3 & e | 8).toString(16) })) } Lr.DefaultOrder = "XYZ"; var kr = function (t) { return 180 * t / Math.PI }, Ur = function (t) { function e() { var n; return (n = t.call(this) || this).isObject3D = !0, n.uuid = Br(), n.name = "", n.parent = null, n.children = [], n.visible = !0, n.position = Ft(), n.rotation = new Lr, n.scale = Vt(1, 1, 1), n.quaternion = Zn(), n.up = jt(e.DefaultUp), n.modelMatrix = Pe(), n.worldMatrix = Pe(), n.modelMatrixNeedUpdate = !1, n.worldMatrixNeedsUpdate = !1, n.rotation.onChange((function () { n.modelMatrixNeedUpdate = !0 })), n } c(e, t); var n = e.prototype; return n.rotateX = function (t) { this.rotation.x = t }, n.rotateY = function (t) { this.rotation.y = t }, n.rotateZ = function (t) { this.rotation.z = t }, n.translate = function (t, e, n) { var r = Vt(t, e, n); return this.position = Wt(this.position, this.position, r), this.modelMatrixNeedUpdate = !0, this }, n.setPosition = function (t, e, n) { var r = Vt(t, e, n); return ue(this.position, r) || (this.position = r, this.modelMatrixNeedUpdate = !0), this }, n.lookAt = function (t, e, n) { var r = this.up, i = this.position, o = Vt(t, e, n), a = en(Pe(), i, o, r), s = Ze(Zn(), a), u = Ir(Ft(), s); this.rotation.set(kr(u[0]), kr(u[1]), kr(u[2])) }, n.setVisible = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (this.visible !== t && (this.visible = t, e)) for (var n = 0, r = this.children.length; n < r; n++)this.children[n].setVisible(t, e) }, n.setScale = function (t, e, n) { var r = Vt(t, e, n); return ue(this.scale, r) || (this.scale = r, this.modelMatrixNeedUpdate = !0), this }, n.updateMatrix = function () { Ie(this.modelMatrix), qn(this.quaternion), tr(this.quaternion, this.rotation.x, this.rotation.y, this.rotation.z), qe(this.modelMatrix, this.quaternion, this.position, this.scale), this.modelMatrixNeedUpdate = !1, this.worldMatrixNeedsUpdate = !0 }, n.updateWorldMatrix = function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; !0 !== this.modelMatrixNeedUpdate && !0 !== t || this.updateMatrix(), !0 === this.worldMatrixNeedsUpdate && (this.parent ? Ue(this.worldMatrix, this.parent.worldMatrix, this.modelMatrix) : Oe(this.worldMatrix, this.modelMatrix), this.worldMatrixNeedsUpdate = !1, t = !0); for (var e = 0, n = this.children.length; e < n; e++)this.children[e].updateWorldMatrix(t) }, n.add = function (t) { if (t === this) return console.error("object3D.add: object can't be added as a child of itself. ==> ".concat(t)), this; if (t instanceof Array) { for (var e = 0, n = t.length; e < n; e++)this.add(t[e]); return this } return t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t)) : console.error("Object3D.add: object not an instance of Object3D.", t), this }, n.remove = function (t) { if (t instanceof Array) { for (var e = 0, n = t.length; e < n; e++)this.remove(t[e]); return this } var r = this.children.indexOf(t); return -1 !== r && (t.parent = null, this.children.splice(r, 1)), this }, n.traverse = function (t) { t(this), this.children && this.children.length > 0 && this.children.forEach((function (e) { e.traverse(t) })) }, n.clone = function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], n = new e; if (n.up = jt(this.up), n.scale = jt(this.scale), n.position = jt(this.position), n.rotation = this.rotation.clone(), n.quaternion = sr(this.quaternion), n.modelMatrix = De(this.modelMatrix), n.worldMatrix = De(this.worldMatrix), n.visible = this.visible, this.children.length && t) for (var r = 0, i = this.children.length; r < i; r++)n.add(this.children[r].clone()); return n }, n.raycast = function (t) { return null }, e }(Or); Ur.DefaultUp = Vt(0, 1, 0); var Nr = function () { function t(t, e) { this.isBox = !0, this.min = void 0, this.max = void 0, this.min = void 0 !== t ? t : Vt(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : Vt(-1 / 0, -1 / 0, -1 / 0) } var e = t.prototype; return e.set = function (t, e) { return Gt(this.min, t), Gt(this.max, e), this }, e.setFromBufferAttribute = function (t) { for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = t.array, u = t.count, h = t.itemSize, c = 0; c < u; c++) { var l = s[c * h], f = s[c * h + 1], d = s[c * h + 2]; l < e && (e = l), f < n && (n = f), d < r && (r = d), l > i && (i = l), f > o && (o = f), d > a && (a = d) } var p = Vt(e, n, r), v = Vt(i, o, a); return this.set(p, v), this }, e.getCenter = function () { return this.isInvalid() ? Ft() : Vt((this.max[0] + this.min[0]) / 2, (this.max[1] + this.min[1]) / 2, (this.max[2] + this.min[2]) / 2) }, e.isInvalid = function () { return this.max[0] < this.min[0] || this.max[1] < this.min[1] || this.max[2] < this.min[2] }, t }(), Fr = function () { function t(e, n, r) { var i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; if (this.isBufferAttribute = !0, this.name = "", this.type = void 0, this.array = void 0, this.itemSize = void 0, this.count = void 0, this.normalized = void 0, this.usage = void 0, this.needUpdate = void 0, Array.isArray(e)) throw new TypeError("BufferAttribute: array should be a Typed Array."); if (this.name = "BufferAttribute", this.array = e, this.itemSize = n, this.count = void 0 !== e ? e.length / n : 0, this.normalized = !0 === i, this.usage = 35044, this.needUpdate = !0, void 0 === r) { var o = this.array; this.type = t.FLOAT, o instanceof Int8Array ? this.type = t.BYTE : o instanceof Uint8Array ? this.type = t.UNSIGNED_BYTE : o instanceof Int16Array ? this.type = t.SHORT : o instanceof Uint16Array ? this.type = t.UNSIGNED_SHORT : o instanceof Int32Array ? this.type = t.INT : o instanceof Uint32Array && (this.type = t.UNSIGNED_INT) } else this.type = r } t.isBufferAttribute = function (e) { var n = !1; return e && e instanceof t && (n = !0), n }; var e = t.prototype; return e.setUsage = function (t) { return this.usage = t, this }, e.setArray = function (t) { return this.array.set(t), this }, t }(); Fr.BYTE = 5120, Fr.UNSIGNED_BYTE = 5121, Fr.SHORT = 5122, Fr.UNSIGNED_SHORT = 5123, Fr.INT = 5124, Fr.UNSIGNED_INT = 5125, Fr.FLOAT = 5126; var jr = function (t) { function e(e, n, r, i) { var o; return (o = t.call(this, new Uint8Array(e), n, r, i) || this).name = "Uint8BufferAttribute", o } return c(e, t), e }(Fr), zr = function (t) { function e(e, n, r, i) { var o; return (o = t.call(this, new Uint16Array(e), n, r, i) || this).name = "Uint16BufferAttribute", o } return c(e, t), e }(Fr), Vr = function (t) { function e(e, n, r, i) { var o; return (o = t.call(this, new Uint32Array(e), n, r, i) || this).name = "Uint32BufferAttribute", o } return c(e, t), e }(Fr), Gr = function (t) { function e(e, n, r, i) { var o; return (o = t.call(this, new Float32Array(e), n, r, i) || this).name = "Float32ArrayAttribute", o } return c(e, t), e }(Fr), Wr = function (t) { function e(e, n, r, i) { var o; if (Array.isArray(e)) { var a = function (t) { for (var e, n = Number.MAX_VALUE, r = -Number.MAX_VALUE, i = t.length - 1; i >= 0; i--)n > (e = t[i]) && (n = e), r < e && (r = e); return { min: n, max: r } }(e); o = new (a.max > 65535 ? Uint32Array : Uint16Array)(e) } else o = e; return t.call(this, o, n, r, i) || this } return c(e, t), e }(Fr), Hr = 0, Zr = function (t) { function e() { for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return (e = t.call.apply(t, [this].concat(r)) || this).id = Hr++, e.uuid = Br(), e.name = "", e.type = "BufferGeometry", e.indexes = null, e.attributes = {}, e.__webglInit = !1, e.groupsNeedUpdate = !1, e.boundingBox = null, e } c(e, t); var n = e.prototype; return n.getIndexes = function () { return this.indexes }, n.getCenter = function () { return this.computeBoundingBox(), this.boundingBox ? this.boundingBox.getCenter() : void 0 }, n.setIndexes = function (t) { return Array.isArray(t) || ArrayBuffer.isView(t) ? this.indexes = new Wr(t, 1) : Wr.isBufferAttribute(t) && (this.indexes = t), this }, n.getAttribute = function (t) { return t ? this.attributes[t] : this.attributes }, n.setAttribute = function (t, e) { return t && Fr.isBufferAttribute(e) && (this.attributes[t] = e), this }, n.deleteAttribute = function (t) { return this.attributes[t] && delete this.attributes[t], this }, n.computeBoundingBox = function () { null === this.boundingBox && (this.boundingBox = new Nr); var t = this.attributes.position; t && t.isBufferAttribute && this.boundingBox.setFromBufferAttribute(t) }, e }(Or), qr = new be, Yr = new be, Xr = new be, Kr = function (t) { function e(e, n) { var r; return (r = t.call(this) || this).type = "Mesh", r.geometry = void 0, r.material = void 0, r.materialChanged = void 0, r.__webglInit = !1, r.geometry = void 0 !== e ? e : new Zr, r.material = void 0 !== n ? n : null, r.materialChanged = !1, r } c(e, t); var n = e.prototype; return n.updateMaterial = function (t) { this.material && t.isMaterial && t.uuid !== this.material.uuid && (this.material = t, this.materialChanged = !0) }, n.raycast = function (t) { var e = this.geometry, n = e.indexes && e.indexes.array, r = e.attributes.position.array; if (!n) return null; for (var i = 0; i < n.length; i += 3) { var o = 3 * n[i], a = 3 * n[i + 1], s = 3 * n[i + 2], u = qr.set(r[o], r[o + 1], r[o + 2]).transform(this.worldMatrix), h = Yr.set(r[a], r[a + 1], r[a + 2]).transform(this.worldMatrix), c = Xr.set(r[s], r[s + 1], r[s + 2]).transform(this.worldMatrix), l = t.intersectTriangle(u, h, c); if (l) return { distance: l.distance, point: l.point, object: this } } return null }, e }(Ur), Qr = function (t) { function e() { for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return (e = t.call.apply(t, [this].concat(r)) || this).type = "Scene", e.isScene = !0, e.autoUpdate = !0, e } c(e, t); var n = e.prototype; return n.updateWorldMatrix = function () { var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; !0 === this.autoUpdate && t.prototype.updateWorldMatrix.call(this, e) }, n.clone = function (n) { return void 0 === n && (n = new e), t.prototype.clone.call(this, n), n.autoUpdate = this.autoUpdate, n }, e }(Ur), Jr = function (t) { function e() { var e; return (e = t.call(this) || this).type = "Geometry", e.vertices = [], e.verticesBufferData = new Float32Array, e.indicesBufferData = new Uint16Array, e.uvtsBufferData = new Float32Array, e.groupsNeedUpdate = !1, e } return c(e, t), e }(Or), $r = new be, ti = new be, ei = new be, ni = new be, ri = new be, ii = function () { function t(t, e) { this.origin = void 0, this.direction = void 0, this.origin = t || new be, this.direction = e || new be(0, 0, -1) } var e = t.prototype; return e.set = function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, e.setFromCamera = function (t, e) { var n = new be(e.position[0], e.position[1], e.position[2]), r = (new Vn).fromArray(e.projectionMatrix), i = e.worldMatrix, o = new Me(t[0], t[1], .5, 1).transform(r).transform(i), a = o.x, s = o.y, u = o.z, h = new be(a, s, u).sub(n).normalize(); this.set(n, h) }, e.getPointByLen = function (t, e) { var n = void 0 !== e ? e : new be; return n.copy(this.direction), n.scale(t), n.add(this.origin), n }, e.intersectTriangle_Old = function (t, e, n) { var r, i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], o = arguments.length > 4 ? arguments[4] : void 0, a = $r.copy(e).subtract(t), s = ti.copy(n).subtract(t), u = ei.copy(a).cross(s), h = ni.copy(this.origin).subtract(t), c = this.direction.dot(u); if (0 < c) { if (i) return null; r = 1 } else { if (!(0 > c)) return null; r = -1, c = -c } s.copy((new be).copy(h).cross(s)); var l = r * this.direction.dot(s); if (0 > l) return null; var f = r * this.direction.dot((new be).copy(h).cross(a)); if (0 > f) return null; if (l + f > c) return null; var d = -r * h.dot(u); return 0 > d ? null : this.getPointByLen(d / c, o) }, e.intersectTriangle = function (t, e, n) { var r = arguments.length > 4 ? arguments[4] : void 0, i = 1e-6, o = $r.subVectors(e, t), a = ti.subVectors(n, t), s = ei.copy(this.direction).cross(a), u = o.dot(s); if (u > -i && u < i) return null; var h = 1 / u, c = ni.subVectors(this.origin, t), l = h * c.dot(s); if (l < 0 || l > 1) return null; var f = ri.copy(c).cross(o), d = h * this.direction.dot(f); if (d < 0 || l + d > 1) return null; var p = a.dot(f) * h; return p > i ? { distance: p, point: this.getPointByLen(p, r) } : null }, e.intersectSphere = function (t, e, n) { var r = (new be).subtract(t, this.origin), i = r.dot(this.direction), o = r.dot(r) - i * i, a = e * e; if (o > a) return null; var s = Math.sqrt(a - o), u = i - s, h = i + s; return 0 > u && 0 > h ? null : 0 > u ? this.getPointByLen(h, n) : this.getPointByLen(u, n) }, t }(); function oi(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return ai(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ai(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function ai(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var si = function () { function t(t, e, n, r) { this.ray = void 0, this.near = void 0, this.far = void 0, this.ray = new ii(t, e), this.near = n || 0, this.far = r || 1 / 0 } var e = t.prototype; return e.set = function (t, e) { this.ray.set(t, e) }, e.setFromCamera = function (t, e) { var n = new be(e.position[0], e.position[1], e.position[2]), r = (new Vn).fromArray(e.projectionMatrix).invert(), i = e.worldMatrix, o = new Me(t[0], t[1], .5, 1).transform(r).transform(i), a = o.x, s = o.y, u = o.z, h = new be(a, s, u).sub(n).normalize(); this.set(n, h) }, e.pick = function (t) { var e, n = this.ray, r = [], i = oi([].concat(t)); try { for (i.s(); !(e = i.n()).done;) { var o = e.value.raycast(n); o && r.push(o) } } catch (t) { i.e(t) } finally { i.f() } return r.sort((function (t, e) { return t.distance - e.distance })), r }, t }(), ui = function (t) { function e(n) { var r; return (r = t.call(this) || this).image = void 0, r.flipY = !0, r.premultiplyAlpha = !1, r.needsUpdate = !0, r.glTexture = null, r.isTexture = !0, r.gl = null, r.__textureInit = !1, r.clone = function (t) { return void 0 === t && (t = new e), t.image = r.image, t.flipY = r.flipY, t }, r.destory = function () { r.emit("destory", r.glTexture) }, r.destoryTexture = function () { r.glTexture && r.gl && (r.off("destory", r.destoryTexture), r.gl.deleteTexture(r.glTexture)) }, void 0 !== n && (r.image = n), r } return c(e, t), e.prototype.init = function (t) { !0 !== this.__textureInit && (this.gl = t, this.glTexture = t.createTexture(), this.on("destory", this.destoryTexture), this.__textureInit = !0) }, e }(Or), hi = function (t) { function e(e) { var n; return (n = t.call(this) || this).isCube = !0, n.image = e || [], n.flipY = !1, n } return c(e, t), e }(ui), ci = function () { function t(t, e, n) { var r = this; this.gl = void 0, this.maxTextureSize = void 0, this.maxTextures = void 0, this.usedTextureUnits = 0, this.getTextureUnit = function () { var t = r.usedTextureUnits; return r.usedTextureUnits >= r.maxTextures ? r.usedTextureUnits = 0 : r.usedTextureUnits += 1, t }, this.resetUsedTextureUnits = function () { r.usedTextureUnits = 0 }, this.setTexture = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; if (t instanceof hi) r.setCubeTexture(t, e); else { var n = r.gl; n.activeTexture(n.TEXTURE0 + e), t.needsUpdate ? (t.init(n), r.uploadTexture(n, t)) : n.bindTexture(n.TEXTURE_2D, t.glTexture) } }, this.setTextureForRenderTarget = function (t) { var e = r.gl; t.glTexture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, t.glTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), r.setTextureParameter(e); var n = e.RGBA, i = e.RGBA, o = e.UNSIGNED_BYTE; e.texImage2D(e.TEXTURE_2D, 0, n, t.width, t.height, 0, i, o, null) }, this.uploadTexture = function (t, e) { e.init(t), t.bindTexture(t.TEXTURE_2D, e.glTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), r.setTextureParameter(t), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e.image), e.needsUpdate = !1 }, this.setTextureParameter = function (t) { t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR) }, this.gl = t, this.maxTextureSize = n, this.maxTextures = e } return t.prototype.setCubeTexture = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = t.image; if (6 !== n.length) throw new Error("[setCubeTexture] CubeTexture need six images, but get\n                ".concat(n.length, "\n            ")); var r = this.gl; if (t.needsUpdate) { t.init(r), r.activeTexture(r.TEXTURE0 + e), r.bindTexture(r.TEXTURE_CUBE_MAP, t.glTexture), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, t.flipY), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE); for (var i = 0; i < 6; i++) { var o = n[i]; r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, o) } t.needsUpdate = !1 } else r.bindTexture(r.TEXTURE_CUBE_MAP, t.glTexture) }, t }(), li = n((function (t) { t.exports = function (t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r }, t.exports.__esModule = !0, t.exports.default = t.exports })); e(li); var fi = n((function (t) { t.exports = function (t) { if (Array.isArray(t)) return li(t) }, t.exports.__esModule = !0, t.exports.default = t.exports })); e(fi); var di = n((function (t) { t.exports = function (t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }, t.exports.__esModule = !0, t.exports.default = t.exports })); e(di); var pi = n((function (t) { t.exports = function (t, e) { if (t) { if ("string" == typeof t) return li(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? li(t, e) : void 0 } }, t.exports.__esModule = !0, t.exports.default = t.exports })); e(pi); var vi = n((function (t) { t.exports = function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }, t.exports.__esModule = !0, t.exports.default = t.exports })); e(vi); var mi = e(n((function (t) { t.exports = function (t) { return fi(t) || di(t) || pi(t) || vi() }, t.exports.__esModule = !0, t.exports.default = t.exports }))), gi = n((function (t) { t.exports = function (t) { if (Array.isArray(t)) return t }, t.exports.__esModule = !0, t.exports.default = t.exports })); e(gi); var yi = n((function (t) { t.exports = function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) { var r, i, o = [], a = !0, s = !1; try { for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0); } catch (t) { s = !0, i = t } finally { try { a || null == n.return || n.return() } finally { if (s) throw i } } return o } }, t.exports.__esModule = !0, t.exports.default = t.exports })); e(yi); var _i = n((function (t) { t.exports = function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }, t.exports.__esModule = !0, t.exports.default = t.exports })); e(_i); var xi = e(n((function (t) { t.exports = function (t, e) { return gi(t) || yi(t, e) || pi(t, e) || _i() }, t.exports.__esModule = !0, t.exports.default = t.exports }))), bi = function (t, e, n) { if (t && e && e.length) for (var r = e.length, i = 0; i < r; i++) { var o = void 0, a = void 0, s = void 0, u = e[i], h = xi(u, 2), c = h[0], l = h[1], f = c.type, d = c.value; switch (c.type) { case "1i": case "1f": t["uniform".concat(f)](l, c.value); break; case "2f": case "3f": case "4f": t["uniform".concat(f)].apply(t, [l].concat(mi(d))); break; case "t": if (!(o = c.value) || !o.image && !o.glTexture) break; a = n.getTextureUnit(), t.uniform1i(l, a), n.setTexture(o, a); break; case "tv": s = []; for (var p = c.value, v = 0, m = p.length; v < m; v++)s[v] = n.getTextureUnit(); t.uniform1iv(l, s); for (var g = 0, y = p.length; g < y; g++)(o = p[g]) && (o.image || o.glTexture) && (a = s[g], n.setTexture(o, a)); break; case "mat4fv": t.uniformMatrix4fv(l, !1, c.value); break; default: console.warn("[UniformOperation] Unknown uniform type: ".concat(f)) } } }; var Mi = "\nvoid main() {\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n", wi = "\nvoid main() {\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n", Ei = 0, Ti = function (t) { function e() { for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return (e = t.call.apply(t, [this].concat(r)) || this).isMaterial = !0, e.id = Ei++, e.type = "Material", e.name = "", e.uuid = Br(), e.uniforms = {}, e.vertexShader = Mi, e.fragmentShader = wi, e.program = null, e.depthTest = !0, e.visible = !0, e.opacity = 1, e.needsUpdate = !0, e.uniformsList = [], e } c(e, t); var n = e.prototype; return n.setValues = function (t) { if (void 0 !== t) for (var e in t) if (Object.prototype.hasOwnProperty.call(t, e)) { var n = t[e]; if (void 0 === n) { console.warn("Material: '" + e + "' parameter is undefined."); continue } if (void 0 === this[e]) { console.warn("".concat(this.type, ": ").concat(e, " is not a property of this material.")); continue } var r = "set" + e.charAt(0).toUpperCase() + e.slice(1); "function" == typeof this[r] ? this[r](n) : this[e] = n } }, n.clone = function () { return (new e).copy(this) }, n.copy = function (t) { return this.uniforms = function (t) { var e, n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) for (var i in n[r] = {}, t[r]) Object.prototype.hasOwnProperty.call(t[r], i) && ((e = t[r][i]) && e.isTexture ? n[r][i] = e.clone() : n[r][i] = e instanceof Array ? e.slice(0) : e); return n }(t.uniforms), this.depthTest = t.depthTest, this.visible = t.visible, this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this }, o(e, [{ key: "defines", get: function () { return "" } }]), e }(Or), Ai = { useColor: "USE_COLOR", useUV: "NEED_UV" }, Ci = function () { function t() { this.useColor = !1, this.useUV = !1 } return t.prototype.getDefines = function () { for (var t = [], e = 0, n = Object.keys(this); e < n.length; e++) { var r = n[e]; Ai[r] && !0 === this[r] && t.push("#define ".concat(Ai[r])) } return t.push(""), t.join("\n") }, t }(), Ri = "\n#ifdef NEED_UV\n    varying vec2 vUV;\n#endif\nvoid main(void) {\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n    #ifdef NEED_UV\n        vUV = uv;\n    #endif\n}\n", Si = "\nprecision mediump float;\n#ifdef NEED_UV\n    varying vec2 vUV;\n    uniform sampler2D uSampler;\n#endif\n#ifdef USE_COLOR\n    uniform vec4 uColor;\n#endif\nuniform float uOpacity;\nvoid main(void) {\n    vec4 finalColor;\n    vec4 defaultColor = vec4(1.0, 0.0, 0.0, 1.0);\n    finalColor = defaultColor;\n    #ifdef USE_COLOR\n        finalColor = uColor;\n    #endif\n    #ifdef NEED_UV\n        finalColor = texture2D(uSampler, vUV);\n    #endif\n    gl_FragColor = vec4(finalColor.rgb, finalColor.a * uOpacity);\n}\n", Pi = function (t) { function e() { var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return (e = t.call(this) || this).map = null, e.color = [1, 0, 0, 1], e.type = "BasicMaterial", e.opacity = 1, e.depthTest = !0, e.vertexShader = Ri, e.fragmentShader = Si, e.uniforms = { uSampler: { type: "t", value: null }, uColor: { type: "4f", value: [1, 0, 0, 1] }, uOpacity: { type: "1f", value: e.opacity } }, e.setValues(n), e } c(e, t); var n = e.prototype; return n.setOpacity = function (t) { this.uniforms.uOpacity.value = t, this.opacity = t }, n.setColor = function (t) { !Array.isArray(t) || t.length < 4 || (this.uniforms.uColor.value = t, this.color = t) }, n.setMap = function (t) { var e = this; t && (t instanceof Promise ? t.then((function (t) { e.uniforms.uSampler.value = t instanceof ui == !0 ? t : new ui(t) })).catch((function (t) { return console.error(t) })) : !0 === t.isTexture && (this.uniforms.uSampler.value = t), this.map = t) }, o(e, [{ key: "defines", get: function () { var t = new Ci; return t.useColor = !!this.color, t.useUV = !!this.map, t.getDefines() } }]), e }(Ti), Di = function (t) { var e = this; this.gl = void 0, this.newAttributes = new Uint8Array(16), this.enabledAttributes = new Uint8Array(16), this.currentDepthTest = !1, this.currentDepthWrite = !0, this.currentColorWrite = !0, this.currentDoubleSided = !1, this.currentFlipSided = !1, this.initAttributes = function () { for (var t = 0, n = e.newAttributes.length; t < n; t++)e.newAttributes[t] = 0 }, this.enableAttribute = function (t) { var n = e.gl, r = e.newAttributes, i = e.enabledAttributes; r[t] = 1, 0 === i[t] && (n.enableVertexAttribArray(t), i[t] = 1) }, this.disableAttribute = function (t) { var n = e.gl, r = e.newAttributes, i = e.enabledAttributes; r[t] = 0, 1 === i[t] && (n.disableVertexAttribArray(t), i[t] = 0) }, this.disableUnusedAttributes = function () { for (var t = e.gl, n = e.newAttributes, r = e.enabledAttributes, i = 0, o = r.length; i < o; i++)r[i] !== n[i] && (t.disableVertexAttribArray(i), r[i] = 0) }, this.setDepthTest = function (t) { var n = e.gl; e.currentDepthTest !== t && (t ? n.enable(n.DEPTH_TEST) : n.disable(n.DEPTH_TEST), e.currentDepthTest = t) }, this.setDepthWrite = function (t) { var n = e.gl; e.currentDepthWrite !== t && (n.depthMask(t), e.currentDepthWrite = t) }, this.setColorWrite = function (t) { var n = e.gl; e.currentColorWrite !== t && (n.colorMask(t, t, t, t), e.currentColorWrite = t) }, this.setDefaultGLState = function (t, n, r, i) { var o = e.gl; o.clearColor(229 / 255, 227 / 255, 223 / 255, 1), o.clear(o.COLOR_BUFFER_BIT | o.DEPTH_BUFFER_BIT), o.clearDepth(1), o.clearStencil(0), o.disable(o.DEPTH_TEST), o.depthFunc(o.LEQUAL), o.frontFace(o.CCW), o.disable(o.CULL_FACE), o.depthMask(!0), o.enable(o.BLEND), o.blendFunc(o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA), o.viewport(t, n, r, i) }, this.setDoubleSided = function (t) { var n = e.gl; e.currentDoubleSided !== t && (t ? n.disable(n.CULL_FACE) : n.enable(n.CULL_FACE), e.currentDoubleSided = t) }, this.setFlipSided = function (t) { var n = e.gl; e.currentFlipSided !== t && (t ? n.frontFace(n.CW) : n.frontFace(n.CCW), e.currentFlipSided = t) }, this.reset = function () { for (var t = e.enabledAttributes, n = 0; n < t.length; n++)t[n] = 0; e.currentDepthTest = !1, e.currentDepthWrite = !0, e.currentColorWrite = !0, e.currentDoubleSided = !1, e.currentFlipSided = !1 }, this.gl = t }, Oi = function (t) { var e = this; this.maxTextures = void 0, this.maxTextureSize = void 0, this.maxVerticesOneDraw = void 0, this.maxVertexShaderTextureUnits = void 0, this.maxFragmentShaderTextureUnits = void 0, this.gl = void 0, this.getMaxTextures = function () { var t = e.gl; return t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS) }, this.getLineWidthRange = function () { var t = e.gl; return t.getParameter(t.ALIASED_LINE_WIDTH_RANGE) }, this.getMaxVertexShaderTextureUnits = function () { var t = e.gl; return t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS) }, this.getMaxFragmentShaderTextureUnits = function () { var t = e.gl; return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS) }, this.getMaxTextureSize = function () { var t = e.gl; return t.getParameter(t.MAX_TEXTURE_SIZE) }, this.getMaxVerticesOneDraw = function () { return e.gl.getExtension("OES_element_index_uint") ? 4294967296 : 65535 }, this.getLegalPrecision = function (t) { var n = e.gl, r = n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT), i = n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT), o = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT), a = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT), s = r && o && r.precision > 0 && o.precision > 0, u = i && a && i.precision > 0 && a.precision > 0; return "highp" !== t || s ? "mediump" !== t || u || (t = "lowp", console.warn("[WebGLCapability] mediump is not supported, using lowp by default.")) : u ? (t = "mediump", console.warn("[WebGLCapability] highp is not supported, using mediump by default.")) : (t = "lowp", console.warn("[WebGLCapability] highp and mediump is not supported, using lowp by default.")), t }, this.gl = t, this.maxTextures = this.getMaxTextures(), this.maxVertexShaderTextureUnits = this.getMaxVertexShaderTextureUnits(), this.maxFragmentShaderTextureUnits = this.getMaxFragmentShaderTextureUnits(), this.maxTextureSize = this.getMaxTextureSize(), this.maxVerticesOneDraw = this.getMaxVerticesOneDraw() }, Ii = 0, Li = function (t, e, n) { var r = t.createShader(n); if (!r) throw new Error("Something went wrong while compile the shader."); return t.shaderSource(r, e), t.compileShader(r), t.getShaderParameter(r, t.COMPILE_STATUS) || console.error("Error compiling shader: ".concat(t.getShaderInfoLog(r))), r }, Bi = function () { function t(t, e, n) { this.usedTimes = void 0, this.id = void 0, this.code = void 0, this.program = void 0, this.attributes = void 0, this.uniforms = void 0, this.gl = void 0, this.parameters = void 0, this.precision = void 0, this.gl = t, this.parameters = e, this.precision = n.precision || "highp", this.usedTimes = 1, this.id = Ii++; var r = e.defines, i = void 0 === r ? "" : r, o = e.vertexShader, a = e.fragmentShader; this.code = i + o + a, this.program = this.createProgram(t, e, this.precision), this.attributes = this.fetchAttributes(t, this.program), this.uniforms = function (t, e) { var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], i = {}, o = r.length; if (!o) return i; for (var a = 0; a < o; a++)i[n = r[a]] = t.getUniformLocation(e, n); return i }(t, this.program, this.getFullUniforms(e.uniforms)) } var e = t.prototype; return e.getAttributes = function () { return this.attributes }, e.getUniforms = function () { return this.uniforms }, e.createProgram = function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "highp", r = e.vertexShader, i = e.fragmentShader, o = e.defines, a = void 0 === o ? "" : o, s = ["precision ".concat(n, " float;"), "uniform mat4 modelMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat4 mvpMatrix;", "attribute vec3 position;", "attribute vec2 uv;", ""].join("\n"), u = t.createProgram(), h = ["precision ".concat(n, " float;"), ""].join("\n"), c = Li(t, s + a + r, t.VERTEX_SHADER), l = Li(t, h + a + i, t.FRAGMENT_SHADER); if (!u) throw new Error("Something went wrong while createProgram."); return t.attachShader(u, c), t.attachShader(u, l), t.linkProgram(u), u }, e.fetchAttributes = function (t, e) { for (var n = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) { var o = t.getActiveAttrib(e, i); if (!o) throw new Error("Something went wrong while getActiveAttrib."); var a = o.name; n[a] = t.getAttribLocation(e, a) } return n }, e.getFullUniforms = function (t) { var e = ["mvpMatrix", "modelMatrix", "projectionMatrix", "viewMatrix"]; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.push(n); return e }, t }(), ki = { canvas: document.createElement("canvas"), context: void 0, width: 0, height: 0, pixelRatio: 1, precision: "highp", alpha: !1, premultipliedAlpha: !0, antialias: !0, stencil: !0, depth: !0, preserveDrawingBuffer: !1 }, Ui = function () { function t() { var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.state = void 0, this.domElement = void 0, this.capability = void 0, this.textureOperation = void 0, this._gl = void 0, this.parameters = void 0, this.programs = void 0, this.viewportInfo = void 0, this.autoDisposeProgram = !0, this.currentCacheState = void 0, this.setSize = function (e, n) { var r = t.parameters, i = r.canvas, o = r.pixelRatio; i.style.width = "".concat(e, "px"), i.style.height = "".concat(n, "px"), i.width = e * o, i.height = n * o, t.setViewport(0, 0, e, n) }, this.setViewport = function (e, n, r, i) { var o = t.parameters.pixelRatio, a = t.viewportInfo; a.x = e * o, a.y = n * o, a.width = r * o, a.height = i * o, t._gl.viewport.apply(t._gl, Object.values(a)) }, this.setClearColor = function (e, n, r) { var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1; !0 === t.parameters.premultipliedAlpha && (e *= i, n *= i, r *= i), t._gl.clearColor(e, n, r, i) }, this.getContext = function () { return t._gl }, this.forceContextLoss = function () { try { var e = t._gl.getExtension("WEBGL_lose_context"); e && e.loseContext() } catch (t) { console.error("[WebGLRenderer] WEBGL_lose_context error: ", t) } }, this.initScene = function (e) { !0 === e.visible && e.traverse((function (e) { !0 === e.visible && e instanceof Kr && t.initMesh(e) })) }, this.initMesh = function (e) { !0 === e.visible && (!0 !== e.__webglInit && (e.__webglInit = !0, e.addEventListener("removed", t.onObjectRemoved)), e.geometry && t.checkAndUpdateGeometry(e.geometry), e.children && e.children.length > 0 && e.children.forEach((function (e) { t.initMesh(e) }))) }, this.checkAndUpdateGeometry = function (e) { !0 !== e.__webglInit && (e.__webglInit = !0, e.addEventListener("removed", t.onGeometryRemove), e.groupsNeedUpdate = !0), !0 === e.groupsNeedUpdate && ("BufferGeometry" === e.type ? t.updateBufferGeometry(e) : t.updateGeometryBuffer(e, t._gl.STATIC_DRAW), e.groupsNeedUpdate = !1) }, this.updateGeometryBuffer = function (e, n) { var r = e.verticesBufferData, i = e.uvtsBufferData, o = e.indicesBufferData, a = e.borderVerticesBufferData, s = t._gl; 0 < r.length && (e.glVerticesBuffer = s.createBuffer(), s.bindBuffer(s.ARRAY_BUFFER, e.glVerticesBuffer), s.bufferData(s.ARRAY_BUFFER, r, n)), 0 < i.length && (e.glUvtsBuffer = s.createBuffer(), s.bindBuffer(s.ARRAY_BUFFER, e.glUvtsBuffer), s.bufferData(s.ARRAY_BUFFER, i, n)), 0 < o.length && (e.glIndicesBuffer = s.createBuffer(), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.glIndicesBuffer), s.bufferData(s.ELEMENT_ARRAY_BUFFER, o, n)), !0 === e.showBorder && void 0 !== a && 0 < a.length && (e.glBorderVerticesBuffer = s.createBuffer(), s.bindBuffer(s.ARRAY_BUFFER, e.glBorderVerticesBuffer), s.bufferData(s.ARRAY_BUFFER, e.borderVerticesBufferData, n)) }, this.renderScene = function (e, n) { !0 === e.visible && e.traverse((function (e) { e instanceof Kr && (t.renderObject(e, n), e.children.length && e.children.forEach((function (e) { t.renderObject(e, n) }))) })) }, this.renderObject = function (e, n) { var r = e.material, i = e.geometry; if (!0 === e.visible && r && i && !0 === r.visible) { t.state.setDepthTest(r.depthTest); var o = !1, a = t.setProgram(n, r, e); o = "BufferGeometry" === i.type ? t.updateVerticesAttribute2(a, i, !1) : t.updateVerticesAttribute(a, i, !1), t.renderGeometryWithProgram(a, i, r, o) } }, this.setProgram = function (e, n, r) { var i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], o = t._gl; t.textureOperation.resetUsedTextureUnits(), t.checkAndUpdateMaterial(r.material); var a = n.program, s = a.getUniforms(); return a.id !== t.currentCacheState.programId && (o.useProgram(a.program), t.currentCacheState.programId = a.id), !1 !== i && bi(o, n.uniformsList, t.textureOperation), t.updateMVPMatrix(s, e, r), a }, this.checkAndUpdateMaterial = function (e) { void 0 !== e && (!0 !== e.__webglInit && (e.__webglInit = !0, e.addEventListener("removed", t.onMaterialRomove), e.needsUpdate = !0), !0 === e.needsUpdate && (t.updateMaterial(e), e.needsUpdate = !1)) }, this.updateMaterial = function (e) { e.program && t.removeMaterial(e); for (var n = null, r = t.programs.length, i = e.defines, o = (void 0 === i ? "" : i) + e.vertexShader + e.fragmentShader, a = r - 1; a >= 0; a--) { var s = t.programs[a]; if (s.code === o) { (n = s).usedTimes++; break } } if (null === n) { var u = { uniforms: e.uniforms, defines: e.defines || "", vertexShader: e.vertexShader, fragmentShader: e.fragmentShader }; n = new Bi(t._gl, u, { precision: t.parameters.precision }), t.programs.push(n) } e.program = n, e.uniformsList = []; var h = 0, c = n.uniforms, l = e.uniforms; for (var f in l) if (Object.prototype.hasOwnProperty.call(l, f)) { var d = c[f]; d && (e.uniformsList[h] = [l[f], d], h++) } }, this.updateMVPMatrix = function (e, n, r) { if (void 0 !== e.mvpMatrix) { var i = De(n.projectionMatrix); Ue(i, i, n.viewMatrix), Ue(i, i, r.worldMatrix), t._gl.uniformMatrix4fv(e.mvpMatrix, !1, i), t._gl.uniformMatrix4fv(e.modelMatrix, !1, r.worldMatrix), t._gl.uniformMatrix4fv(e.viewMatrix, !1, n.viewMatrix), t._gl.uniformMatrix4fv(e.projectionMatrix, !1, n.projectionMatrix) } t.currentCacheState.camera = n }, this.renderGeometryWithProgram = function (e, n, r) { var i = t._gl, o = t.currentCacheState.curRenderTarget; if (e.uniforms.showDebugLine && i.uniform1i(e.uniforms.showDebugLine, 0), "BufferGeometry" === n.type ? i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, n.indexesBuffer) : i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, n.glIndicesBuffer), null !== o && void 0 !== o.glFrameBuffer) { var a = i.checkFramebufferStatus(i.FRAMEBUFFER); if (i.FRAMEBUFFER_COMPLETE !== a) return t.removeRenderTarget(o), void (t.currentCacheState.curRenderTarget = null) } n.indexes && n.indexes.count > 0 ? i.drawElements(i.TRIANGLES, n.indexes.count, i.UNSIGNED_SHORT, 0) : i.drawArrays(i.TRIANGLES, 0, n.attributes.position.count) }, this.onObjectRemoved = function (e) { e.target.traverse((function (e) { e.removeEventListener("removed", t.onObjectRemoved), t.removeObject(e) })) }, this.onGeometryRemove = function (e) { var n = e.target; n.removeEventListener("removed", t.onGeometryRemove), t.removeGeometry(n) }, this.onMaterialRomove = function (e) { var n = e.target; n.removeEventListener("removed", t.onMaterialRomove), t.removeMaterial(n) }, this.onRenderTargetRemove = function (e) { var n = e.target; n.removeEventListener("removed", t.onRenderTargetRemove), t.removeRenderTarget(n) }, this.removeObject = function (t) { t.geometry && delete t.geometry.__webglInit, delete t.__webglInit }, this.removeGeometry = function (e) { delete e.__webglInit, t.deleteBuffers(e), t.currentCacheState.geometryProgramId = null }, this.deleteBuffers = function (e) { ["glVerticesBuffer", "glUvtsBuffer", "glIndicesBuffer", "glBorderVerticesBuffer"].forEach((function (n) { t._gl.deleteBuffer(e[n]), void 0 !== e[n] && 0 < e[n] && delete e[n] })) }, this.removeMaterial = function (e) { var n = e.program.program; if (n) { e.program = null; for (var r = t.programs, i = r.length - 1; i >= 0; i--) { var o = r[i]; if (o.program === n) { o.usedTimes--, 0 === o.usedTimes && !1 !== t.autoDisposeProgram && (r.splice(i, 1), t._gl.deleteProgram(n)); break } } } }, this.removeRenderTarget = function (e) { t._gl.deleteRenderbuffer(e.glDepthBuffer), e.glDepthBuffer = null, t._gl.deleteTexture(e.glTexture), e.glTexture = null, t._gl.deleteFramebuffer(e.glFrameBuffer), e.glFrameBuffer = null }, this.parameters = Object.assign({}, ki, e), e && !e.canvas && (this.parameters.canvas = document.createElement("canvas")), this.initGL(), this.programs = [], this.viewportInfo = { x: 0, y: 0, width: this.parameters.canvas.width, height: this.parameters.canvas.height }, this.parameters.width && this.parameters.height && this.setSize(this.parameters.width, this.parameters.height), this.domElement = this.parameters.canvas, this.state = new Di(this._gl), this.state.setDefaultGLState.apply(this.state, Object.values(this.viewportInfo)), this.currentCacheState = { programId: null, geometryProgramId: null, materialId: null, camera: null, curRenderTarget: null }, this.capability = new Oi(this._gl); var n = this.capability.maxTextures, r = this.capability.maxTextureSize; this.textureOperation = new ci(this._gl, n, r) } var e = t.prototype; return e.clearBuffer = function () { var t = this._gl; t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT) }, e.initGL = function () { var t = this, e = this.parameters, n = e.canvas, r = e.context, i = e.alpha, o = e.depth, a = e.stencil, s = e.antialias, u = e.premultipliedAlpha, h = e.preserveDrawingBuffer; try { var c = { alpha: i, depth: o, stencil: a, antialias: s, premultipliedAlpha: u, preserveDrawingBuffer: h }, l = r || n.getContext("webgl", c) || n.getContext("experimental-webgl", c) || n.getContext("moz-webgl", c) || n.getContext("webkit-3d", c); if (!l) throw null !== n.getContext ? "Error creating WebGL context with your provided attributes." : "Error creating WebGL context."; this._gl = l, n.addEventListener("webglcontextlost", (function (e) { e.preventDefault(), void 0 !== t.state && (t.resetGLState(), t.state.setDefaultGLState.apply(t.state, Object.values(t.viewportInfo))) }), !1) } catch (t) { console.error("[WebGLRenderer] Create webgl error: ", t) } }, e.resetGLState = function () { this.currentCacheState = { programId: null, geometryProgramId: null, materialId: null, camera: null, curRenderTarget: null }, this.state.reset() }, e.setRenderTarget = function (t) { var e = this._gl; void 0 !== t && null === t.glFrameBuffer && (t.addEventListener("removed", this.onRenderTargetRemove), t.glFrameBuffer = e.createFramebuffer(), e.bindFramebuffer(e.FRAMEBUFFER, t.glFrameBuffer), this.textureOperation.setTextureForRenderTarget(t), t.glDepthBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, t.glDepthBuffer), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, t.width, t.height), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t.glTexture, 0), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t.glDepthBuffer), e.bindTexture(e.TEXTURE_2D, null), e.bindRenderbuffer(e.RENDERBUFFER, null), e.bindFramebuffer(e.FRAMEBUFFER, null)) }, e.render = function (t, e, n) { if (e.isCamera) { var r = this._gl; if (t.updateWorldMatrix(), e.updateWorldMatrix(), e.updateProjectionMatrix(), this.currentCacheState.camera = null, void 0 !== n) this.setRenderTarget(n), this.currentCacheState.curRenderTarget = n, r.bindFramebuffer(r.FRAMEBUFFER, n.glFrameBuffer), r.viewport(0, 0, n.width, n.height); else { var i = this.viewportInfo, o = i.width, a = i.height; this.currentCacheState.curRenderTarget = null, r.bindFramebuffer(r.FRAMEBUFFER, null), r.viewport(0, 0, o, a) } this.initScene(t), this.renderScene(t, e) } else console.error("[WebGLRenderer]  Camera is not leagal.") }, e.updateBufferGeometry = function (t) { var e = this._gl, n = t.getIndexes(), r = t.getAttribute(); for (var i in r) if (Object.prototype.hasOwnProperty.call(r, i)) { var o = i + "Buffer", a = r[i], s = a.array, u = a.usage; t[o] = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, t[o]), e.bufferData(e.ARRAY_BUFFER, s, u) } n && (t.indexesBuffer = e.createBuffer(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.indexesBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, n.array, n.usage)) }, e.updateVerticesAttribute2 = function (t, e) { var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r = this._gl, i = !1, o = "".concat(e.id, "_").concat(t.id); if (o !== this.currentCacheState.geometryProgramId) { this.currentCacheState.geometryProgramId = o, this.state.initAttributes(), i = !0; var a = e.getAttribute(); for (var s in a) if (Object.prototype.hasOwnProperty.call(a, s)) { var u = s + "Buffer", h = a[s], c = h.itemSize, l = h.type, f = h.normalized; 0 <= t.attributes[s] && (!0 !== n && (r.bindBuffer(r.ARRAY_BUFFER, e[u]), r.vertexAttribPointer(t.attributes[s], c, l, f, 0, 0)), this.state.enableAttribute(t.attributes[s])) } } return this.state.disableUnusedAttributes(), i }, e.updateVerticesAttribute = function (t, e) { var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r = this._gl, i = !1, o = "".concat(e.id, "_").concat(t.id); if (o !== this.currentCacheState.geometryProgramId) { this.currentCacheState.geometryProgramId = o, this.state.initAttributes(), i = !0; var a = t.getAttributes(); 0 <= a.position && (!0 !== n && (r.bindBuffer(r.ARRAY_BUFFER, e.glVerticesBuffer), r.vertexAttribPointer(a.position, 3, r.FLOAT, !1, 0, 0)), this.state.enableAttribute(a.position)), 0 <= a.uv && void 0 !== e.glUvtsBuffer && (r.bindBuffer(r.ARRAY_BUFFER, e.glUvtsBuffer), r.vertexAttribPointer(a.uv, 2, r.FLOAT, !1, 0, 0), this.state.enableAttribute(a.uv)) } return this.state.disableUnusedAttributes(), i }, t }(), Ni = function (t) { function e(e, n, r, i, o, a) { var s; switch ((s = t.call(this) || this).addIntoBuffer = function (t, e, n) { t[n] = e[0], t[n + 1] = e[1], t[n + 2] = e[2] }, s.get3DVertex = function (t, e) { var n; switch (e) { case "x": n = Vt(0, t[0], t[1]); break; case "y": n = Vt(t[0], 0, t[1]); break; default: n = Vt(t[0], t[1], 0) }return n }, s.zeroAxis = void 0 !== o ? o : "z", s.zeroAxis) { case "x": s.normal = Vt(-1, 0, 0); break; case "y": default: s.normal = Vt(0, -1, 0); break; case "z": s.normal = Vt(0, 0, -1) }a = void 0 !== a ? a : {}, s.showBorder = !(!1 === a.showBorder), s.borderWidth = void 0 !== a.borderWidth ? a.borderWidth : 1, s.borderColor = void 0 !== a.borderColor ? a.borderColor : [0, 0, 0, 1]; var u, h, c, l = .5 * e, f = .5 * n, d = r || 1, p = i || 1, v = e / d, m = n / p, g = (d + 1) * (p + 1); s.verticesBufferData = new Float32Array(3 * g), s.uvtsBufferData = new Float32Array(2 * g), s.indicesBufferData = new (g > 65535 ? Uint32Array : Uint16Array)(d * p * 6); for (var y = 0, _ = 0, x = 0; x <= p; x++) { u = x * m - f; for (var b = 0; b <= d; b++)c = _t(b * v - l, u), h = s.get3DVertex(c, s.zeroAxis), s.vertices.push(h), s.addIntoBuffer(s.verticesBufferData, h, y), s.uvtsBufferData[_] = b / d, s.uvtsBufferData[_ + 1] = 1 - x / p, y += 3, _ += 2 } for (var M, w, E, T, A = 0, C = 0; C < p; C++)for (var R = 0; R < d; R++)M = R + (d + 1) * C, w = R + (d + 1) * (C + 1), E = R + 1 + (d + 1) * (C + 1), T = R + 1 + (d + 1) * C, s.addIntoBuffer(s.indicesBufferData, [M, w, E], A), s.addIntoBuffer(s.indicesBufferData, [M, E, T], A + 3), A += 6; s.borderIndicesBufferData = new Uint16Array(4), s.borderIndicesBufferData[0] = 0, s.borderIndicesBufferData[1] = d, s.borderIndicesBufferData[2] = (d + 1) * p, s.borderIndicesBufferData[3] = (d + 1) * (p + 1) - 1; var S = 0; s.borderVerticesBufferData = new Float32Array(6 * (d + p)); for (var P = 0; P < g; P += d + 1)s.addIntoBuffer(s.borderVerticesBufferData, s.vertices[P], S), S += 3; for (var D = (d + 1) * p + 1; D < g; D++)s.addIntoBuffer(s.borderVerticesBufferData, s.vertices[D], S), S += 3; for (var O = (d + 1) * p - 1; O > 0; O -= d + 1)s.addIntoBuffer(s.borderVerticesBufferData, s.vertices[O], S), S += 3; for (var I = d - 1; I > 0; I--)s.addIntoBuffer(s.borderVerticesBufferData, s.vertices[I], S), S += 3; return s } return c(e, t), e }(Jr), Fi = "z", ji = function (t) { function e(n, r, i, o) { var a, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; a = t.call(this) || this; var u = e.buildPlane(n, r, i, o, s), h = u.uvs, c = u.indices, l = u.normals, f = u.vertices; return a.name = "PlaneBufferGeometry", a.setAttribute("position", new Gr(f, 3)), a.setAttribute("normals", new Gr(l, 3)), a.setAttribute("uv", new Gr(h, 2)), a.setIndexes(c), a } return c(e, t), e.buildPlane = function (t, n, r, i) { for (var o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}, a = o.normalAxis, s = void 0 === a ? Fi : a, u = o.useBack, h = void 0 !== u && u, c = o.normalDest, l = void 0 === c ? 0 : c, f = .5 * t, d = .5 * n, p = r || 1, v = i || 1, m = t / p, g = n / v, y = e.getNormal(s, h), _ = [], x = [], b = [], M = [], w = 0; w <= v; w++)for (var E = w * g - d, T = 0; T <= p; T++) { var A = T * m - f, C = e.get3DVertex([A, E], s, l); b.push.apply(b, mi(C)), _.push(T / p, 1 - w / v), M.push.apply(M, mi(y)) } for (var R = 0; R < v; R++)for (var S = 0; S < p; S++) { var P = S + (p + 1) * R, D = S + (p + 1) * (R + 1), O = S + 1 + (p + 1) * (R + 1), I = S + 1 + (p + 1) * R; x.push(P, D, O), x.push(P, O, I) } return { uvs: _, indices: x, vertices: b, normals: M } }, e.getNormal = function (t) { var e, n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = n ? -1 : 1; switch (t) { case "x": e = [r, 0, 0]; break; case Fi: e = [0, 0, r]; break; default: e = [0, r, 0] }return e }, e }(Zr); ji.get3DVertex = function (t, e) { var n, r = xi(t, 2), i = r[0], o = r[1], a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; switch (e) { case "x": n = [a, i, o]; break; case "y": n = [i, a, o]; break; default: n = [i, o, a] }return n }; var zi = function (t) { function e(e, n, r, i, o, a) { var s; (s = t.call(this) || this).name = "BoxGeometry"; var u = s.initBox(e, n, r, i, o, a), h = u.uvs, c = u.normals, l = u.vertices, f = u.indices; return s.setAttribute("position", new Gr(l, 3)), s.setAttribute("normals", new Gr(c, 3)), s.setAttribute("uv", new Gr(h, 2)), s.setIndexes(f), s } return c(e, t), e.prototype.initBox = function (t, e, n, r, i, o) { var a = [], s = ji.buildPlane, u = s(n, e, o, i, { normalAxis: "x", normalDest: t / 2 }), h = s(n, e, o, i, { normalAxis: "x", useBack: !0, normalDest: -t / 2 }), c = s(t, n, r, o, { normalAxis: "y", normalDest: e / 2 }), l = s(t, n, r, o, { normalAxis: "y", useBack: !0, normalDest: -e / 2 }), f = s(t, e, r, i, { normalAxis: "z", normalDest: n / 2 }), d = s(t, e, r, i, { normalAxis: "z", useBack: !0, normalDest: -n / 2 }); a.push(u, h, c, l, f, d); for (var p = 0, v = [], m = [], g = [], y = [], _ = function (t) { var e = a[t], n = e.uvs, r = e.vertices, i = e.normals, o = e.indices, s = p; v = v.concat(n), m = m.concat(r), g = g.concat(i), y = y.concat(o.map((function (t) { return s + t }))), p += r.length / 3 }, x = 0; x < 6; x++)_(x); return { uvs: v, vertices: m, normals: g, indices: y } }, e }(Zr), Vi = function (t) { function e(e, n) { var r; return (r = t.call(this) || this).width = void 0, r.height = void 0, r.glFrameBuffer = null, r.glDepthBuffer = null, r.flipY = !1, r.premultiplyAlpha = !1, r.glTexture = null, r.width = e, r.height = n, r } return c(e, t), e }(Or); function Gi(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return Wi(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Wi(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function Wi(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var Hi = function () { function t() { this.faceCount = 0, this.verticesCoords = [], this.textureCoords = [], this.uvs = [], this.vertices = [], this.normals = [], this.indexes = [] } var e = t.prototype; return e.load = function (t) { var e = this; return new Promise((function (n) { (function (t) { var e = new XMLHttpRequest; return e.open("GET", t, !0), e.send(null), new Promise((function (t) { e.addEventListener("load", (function () { t(e.responseText) }), !1) }), (function (t) { e.addEventListener("error", (function (e) { console.error("request error"), t(e) }), !1) })) })(t).then((function (t) { e.parse(t); var r = e.genObject3D(); n(r) })) })) }, e.genObject3D = function () { var t = new Zr; t.setAttribute("position", new Gr(this.vertices, 3)), this.uvs.length && t.setAttribute("uv", new Gr(this.uvs, 2)), t.setIndexes(this.indexes); var e = new Pi; return new Kr(t, e) }, e.parse = function (t) { var e, n = Gi(t.split("\n")); try { for (n.s(); !(e = n.n()).done;) { var r = e.value, i = r.indexOf("#"); -1 !== i && (r = r.substring(0, i)); var o = (r = r.trim()).split(/\s+/); switch (o[0]) { case "v": this.verticesCoords.push(parseFloat(o[1]), parseFloat(o[2]), parseFloat(o[3])); break; case "vn": this.normals.push(parseFloat(o[1]), parseFloat(o[2]), parseFloat(o[3])); break; case "vt": this.textureCoords.push(parseFloat(o[1]), parseFloat(o[2])); break; case "p": case "l": case "usemtl": break; case "f": o.shift(), this.parseFaceLine(o) } } } catch (t) { n.e(t) } finally { n.f() } }, e.parseFaceLine = function (t) { for (var e = [], n = t.length, r = 0; r < n; r++) { var i = t[r]; if (i.length > 0) { var o = i.split("/"); e.push(o) } } for (var a = e[0], s = 1, u = e.length - 1; s < u; s++) { var h = e[s], c = e[s + 1]; this.addFace(a, h, c) } }, e.addFace = function (t, e, n) { var r = this.verticesCoords, i = r.length / 3, o = this.parseVertexIndex(t[0], i), a = this.parseVertexIndex(e[0], i), s = this.parseVertexIndex(n[0], i); this.vertices.push(r[o], r[o + 1], r[o + 2], r[a], r[a + 1], r[a + 2], r[s], r[s + 1], r[s + 2]); var u = 3 * this.faceCount; if (this.indexes.push(u, u + 1, u + 2), this.faceCount++, "" !== t[1]) { var h = this.textureCoords, c = h.length, l = this.parseUVIndex(t[1], c), f = this.parseUVIndex(e[1], c), d = this.parseUVIndex(n[1], c); this.uvs.push(h[l], h[l + 1], h[f], h[f + 1], h[d], h[d + 1]) } t[2] }, e.parseVertexIndex = function (t, e) { var n = parseInt(t, 10); return 3 * (n >= 0 ? n - 1 : n + e / 3) }, e.parseUVIndex = function (t, e) { var n = parseInt(t, 10); return 2 * (n >= 0 ? n - 1 : n + e / 2) }, t }(); function Zi(t) { return new Promise((function (e, n) { var r = new Image; r.src = t, r.crossOrigin = "Anonymous", r.onload = function () { e(r) }, r.onerror = function (t) { n(t) } })) } function qi(t) { if (6 !== t.length) throw new Error("[loadCubeTexture] param urls need len six. [px, nx, py, ny, pz, nz]"); return new Promise((function (e, n) { for (var r = 0, i = new hi, o = i.image, a = function (a) { Zi(t[a]).then((function (t) { r++, o[a] = t, 6 === r && (i.needsUpdate = !0, e(i)) })).catch((function (t) { console.error(t), n(t) })) }, s = 0; s < 6; s++)a(s) })) } var Yi = function (t) { function e() { var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .1, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3e3; return (e = t.call(this) || this).isCamera = !0, e.viewMatrix = Pe(), e.projectionMatrix = Pe(), e.projectionMatrixNeedUpdate = !1, e._far = void 0, e._near = void 0, e._far = r, e._near = n, e } return c(e, t), e.prototype.updateWorldMatrix = function () { var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; t.prototype.updateWorldMatrix.call(this, e), Be(this.viewMatrix, this.worldMatrix) }, o(e, [{ key: "near", get: function () { return this._near }, set: function (t) { this._near = t, this.projectionMatrixNeedUpdate = !0 } }, { key: "far", get: function () { return this._far }, set: function (t) { this._far = t, this.projectionMatrixNeedUpdate = !0 } }]), e }(Ur), Xi = function (t) { function e(e, n, r, i, o, a) { var s; return (s = t.call(this, o, a) || this)._left = void 0, s._right = void 0, s._top = void 0, s._bottom = void 0, s._top = r, s._left = e, s._right = n, s._bottom = i, s.updateProjectionMatrix(!0), s } c(e, t); var n = e.prototype; return n.updateProjectionMatrix = function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (!0 === t || !0 === this.projectionMatrixNeedUpdate) { var e = (this.right - this.left) / 2, n = (this.top - this.bottom) / 2, r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2, o = r - e, a = r + e, s = i + n, u = i - n; Ie(this.projectionMatrix), $e(this.projectionMatrix, o, a, s, u, this.near, this.far), this.projectionMatrixNeedUpdate = !1 } }, n.clone = function (n) { return void 0 === n && (n = new e(0, 0, 0, 0, 0, 0)), t.prototype.clone.call(this, n), n.left = this.left, n.right = this.right, n.top = this.top, n.bottom = this.bottom, n.near = this.near, n.far = this.far, n.updateProjectionMatrix(), n.updateWorldMatrix(), n }, o(e, [{ key: "top", get: function () { return this._top }, set: function (t) { t !== this._top && (this._top = t, this.projectionMatrixNeedUpdate = !0) } }, { key: "left", get: function () { return this._left }, set: function (t) { t !== this._left && (this._left = t, this.projectionMatrixNeedUpdate = !0) } }, { key: "right", get: function () { return this._right }, set: function (t) { t !== this._right && (this._right = t, this.projectionMatrixNeedUpdate = !0) } }, { key: "bottom", get: function () { return this._bottom }, set: function (t) { t !== this._bottom && (this._bottom = t, this.projectionMatrixNeedUpdate = !0) } }]), e }(Yi), Ki = function (t) { function e(e, n, r, i) { var o; return (o = t.call(this, r, i) || this).type = "PerspectiveCamera", o._fov = void 0, o._aspect = void 0, o._fov = e, o._aspect = n, o.updateProjectionMatrix(!0), o } c(e, t); var n = e.prototype; return n.updateProjectionMatrix = function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; !0 !== t && !0 !== this.projectionMatrixNeedUpdate || (Ie(this.projectionMatrix), Qe(this.projectionMatrix, this.fov * Math.PI / 180, this.aspect, this.near, this.far), this.projectionMatrixNeedUpdate = !1) }, n.clone = function (n) { return void 0 === n && (n = new e(0, 0, 0, 0)), t.prototype.clone.call(this, n), n.fov = this.fov, n.aspect = this.aspect, n.near = this.near, n.far = this.far, n.updateProjectionMatrix(), n.updateWorldMatrix(), n }, o(e, [{ key: "fov", get: function () { return this._fov }, set: function (t) { t !== this._fov && (this._fov = t, this.projectionMatrixNeedUpdate = !0) } }, { key: "aspect", get: function () { return this._aspect }, set: function (t) { t !== this._aspect && (this._aspect = t, this.projectionMatrixNeedUpdate = !0) } }]), e }(Yi), Qi = Object.freeze({ __proto__: null, Mesh: Kr, Scene: Qr, Geometry: Jr, Object3D: Ur, Raycaster: si, Texture: ui, CubeTexture: hi, TextureOperation: ci, Material: Ti, BasicMaterial: Pi, BufferGeometry: Zr, WebGLRenderer: Ui, PlaneGeometry: Ni, BoxGeometry: zi, WebGLRenderTarget: Vi, PlaneBufferGeometry: ji, Box3: Nr, OBJLoader: Hi, loadImage: Zi, loadTexture: function (t, e, n) { return Zi(t).then((function (t) { var n = new ui(t); return e && e(n), n })).catch((function (t) { n && n(t) })) }, loadCubeTexture: qi, Vec2: Ut, Vec3: ge, Vec4: kn, Mat3: Se, Mat4: an, Quat: Ar, quatToEuler: Ir, BufferAttribute: Fr, Uint8BufferAttribute: jr, Uint16BufferAttribute: zr, Uint32BufferAttribute: Vr, Float32ArrayAttribute: Gr, UintBufferAttribute: Wr, OrthographicCamera: Xi, PerspectiveCamera: Ki }), Ji = function () { function t(t) { this.pano = void 0, this.panoData = void 0, this._meshs = new Kr, this.pano = t } return o(t, [{ key: "camera", get: function () { return this.pano.camera } }, { key: "meshs", get: function () { return this._meshs }, set: function (t) { this._meshs = t } }]), t }(), $i = ["varying vec3 v_normal;", "void main(void){", "   gl_Position = mvpMatrix * vec4(position, 1.0);", "   v_normal = normalize(position.xyz);", "}"].join("\n"), to = ["uniform samplerCube uSampler;", "uniform float uOpacity;", "varying vec3 v_normal;", "void main(void){", "    vec4 textureColor = textureCube(uSampler, normalize(v_normal));", "    gl_FragColor = vec4(textureColor.rgb, textureColor.a * uOpacity);", "}"].join("\n"), eo = function (t) { function e(e) { var n; return (n = t.call(this, e) || this).initMesh(), n } c(e, t); var n = e.prototype; return n.initMesh = function () { var t = new zi(8, 8, 8, 1, 1, 1), e = new Ti; e.vertexShader = $i, e.fragmentShader = to, e.uniforms = { vColor: { type: "4f", value: [1, 0, 0, 1] }, uSampler: { type: "t", value: null }, uOpacity: { type: "1f", value: 1 } }; var n = new Kr(t, e); n.visible = !1, n.setScale(-1, 1, 1), this.meshs = n }, n.setData = function (t) { var e = this; if (!t.image || 6 !== t.image.length) throw new Error("天空盒模型需要6张纹理，但只获取到 ".concat(t.image ? t.image.length : 0, "张")); this.panoData = t; var n = this.meshs; qi(t.image).then((function (t) { n.material.uniforms.uSampler.value = t, n.visible = !0, e.pano.emit({ type: d.REFRESH, log: "[Refresh Log] 立方贴图加载完成， 渲染一帧" }) })).catch((function (t) { return console.error(t) })) }, n.update = function () { }, n.draw = function () { }, e }(Ji), no = function (t) { return t }, ro = function (t) { return t * t }, io = function (t) { return -t * (t - 2) }, oo = ro, ao = io, so = Object.freeze({ __proto__: null, linear: no, reverse: function (t) { return 1 - t }, easeInQuad: ro, easeInCubic: function (t) { return Math.pow(t, 3) }, easeOutQuad: io, easeOutCubic: function (t) { return Math.pow(t - 1, 3) + 1 }, easeInOutQuad: function (t) { return t < .5 ? t * t * 2 : -2 * (t - 2) * t - 1 }, easeInOutCubic: function (t) { return t < .5 ? 4 * Math.pow(t, 3) : 4 * Math.pow(t - 1, 3) + 1 }, easeInOutSine: function (t) { return (1 - Math.cos(Math.PI * t)) / 2 }, easeIn: oo, easeOut: ao }), uo = function () { }, ho = function () { function t(t, e, n) { var r = this, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : no; this.from = void 0, this.to = void 0, this.duration = void 0, this.easingFn = void 0, this._isPlaying = !1, this._autoTimer = null, this._startTime = null, this._onUpdateCallback = uo, this._onEndCallback = uo, this.start = function () { return r._isPlaying || (r._isPlaying = !0, r._startTime = r.getNow()), r }, this.stop = function () { return r._isPlaying = !1, r }, this.startAndAutoUpdate = function () { if (r._isPlaying) return r; r.start(), r._autoTimer = null; return function t() { r.update(), r._autoTimer = requestAnimationFrame(t) }(), r }, this.onEnd = function (t) { return "function" == typeof t ? r._onEndCallback = t : console.warn("[Warning] onUpdate required a funtion"), r }, this.onUpdate = function (t) { return "function" == typeof t ? r._onUpdateCallback = t : console.warn("[Warning] onUpdate required a funtion"), r }, this.update = function () { if (!r._isPlaying) return !1; var t = r.from, e = r.to, n = r.getNow(), i = r.easingFn, o = r._startTime; if (o > n) return !1; var a = (n - o) / r.duration, s = t + (e - t) * i(a = 0 === r.duration || a > 1 ? 1 : a); return r._onUpdateCallback(s), 1 === a && r.handleEnd(), !0 }, this.from = t, this.to = e, this.duration = n, this.easingFn = i } var e = t.prototype; return e.getNow = function () { return Date.now() }, e.handleEnd = function () { this._isPlaying = !1, this._autoTimer = null, this._onEndCallback() }, t }(), co = function (t, e, n) { var r = .5 * e, i = .5 * n; return _t((t[0] - r) / r, (i - t[1]) / i) }, lo = function (t, e, n) { var r = .5 * e, i = .5 * n; return _t((t[0] + 1) * r, (1 - t[1]) * i) }, fo = function (t, e, n, r) { var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 100, o = sn(), a = co(t, n, r), s = hn(a[0], a[1], i, 1), u = Pe(), h = e.worldMatrix; return Be(u, e.projectionMatrix), En(o, s, u), En(o, o, h), o }, po = function (t, e, n, r) { var i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o = hn(e[0], e[1], e[2], 1); if (En(o, o, t.viewMatrix), 0 < o[2] && !0 !== i) return null; En(o, o, t.projectionMatrix), o[0] = o[0] / o[3], o[1] = o[1] / o[3], o[2] = o[2] / o[3], o[3] = 1; var a = _t(o[0], o[1]); return lo(a, n, r) }, vo = function (t, e, n, r) { var i = po(e, t, n, r) || [-1, -1], o = xi(i, 2), a = o[0], s = o[1], u = !1; return a >= 0 && a <= n && s >= 0 && s <= r && (u = !0), u }, mo = Object.freeze({ __proto__: null, viewportToNormalizeProjection: co, normalizeProjectionToViewport: lo, viewportToWorld: fo, worldToViewport: po, isCoordsInView: vo }), go = function () { function t() { var e = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500; this.getVertexs = function () { return e.vertexs }, this.getFacesVertex = function () { return e.facesVertex }, this.generateTextureCoord = function (n, r, i) { var o = e.facesVertex[Math.round(e.facesVertex.length / 2)]; if (o) { for (var a = [], s = Math.pow(2, 5 - i), u = r % s, h = n % s, c = t.H_SEGS / e.cols, l = 1 / c, f = 1 / ((t.V_SEGS - 1) / e.rows), d = 0; d < o.length / 3; d++) { var p = d % (c + 1) * l, v = Math.floor(d / (c + 1)) * f; p = p / s + 1 * u / s, v = v / s + 1 * h / s, 1 === i && (v *= 2), a.push(p, v) } return a } }, this.getFaceIndex = function (n) { var r = 0, i = xi(n, 3), o = i[0], a = i[1], s = i[2], u = Math.round(180 * Math.atan(Math.abs(s) / Math.abs(o)) / Math.PI); o > 0 ? s < 0 && (u = 360 - u) : u = s > 0 ? 180 - u : 180 + u, u %= 360, r = a > e._x3 ? 7 : a > e._x2 ? 6 : a > e._x1 ? 5 : a > 0 ? 4 : a > -e._x1 ? 3 : a > -e._x2 ? 2 : a > -e._x3 ? 1 : 0; var h = Math.floor(u / 22.5), c = t.H_SEGS; return [h, r, h + r * (c / (c / e.cols))] }, this.viewportToSphereCoord = function (t, n, r, i) { var o = e.radius, a = fo(t, i, n, r), s = xi(a, 3), u = s[0], h = s[1], c = s[2], l = o / Math.sqrt(u * u + h * h + c * c); return [u * l, h * l, c * l] }, this.getFaceVertex = function (n, r) { var i = t.H_SEGS / e.cols, o = r + n * (t.H_SEGS / i); return e.facesVertex[o] }, this.radius = n, this.rows = t.DEFAULT_COLS / 2, this.cols = t.DEFAULT_COLS, this.vertexs = null, this.facesVertex = [], this.facesVertexIndice = [], this.init() } var e = t.prototype; return e.init = function () { var t = this.getSphereVertexInfo(); this.facesVertexIndice = this.getSphereFacesIndices(), this.vertexs = t.vertexs, this.facesVertex = t.facesVertex, this.calcConst() }, e.calcConst = function () { var t = 360 / this.cols; this._x1 = Math.cos(g(3 * t)) * this.radius, this._x2 = Math.cos(g(2 * t)) * this.radius, this._x3 = Math.cos(g(1 * t)) * this.radius }, e.getSphereVertexInfo = function () { for (var e, n = [], r = [], i = this.radius, o = t.H_SEGS, a = t.V_SEGS, s = 360 / o, u = 180 / (a - 1), h = o / this.cols, c = o / h, l = 0, f = 0, d = [], p = 0; p < a; p++) { var v = Math.sin(g(p * u - 90)) * i, m = Math.cos(g(p * u - 90)) * i; v = Math.round(100 * v) / 100, m = Math.round(100 * m) / 100, l = Math.floor(p / h); for (var y = 0; y < o; y++) { var _ = Math.cos(g(y * s)) * m, x = Math.sin(g(y * s)) * m; if (_ = Math.round(100 * _) / 100, x = Math.round(100 * x) / 100, n.push(_, v, x), e = (f = Math.floor(y / h)) + l * c, l < this.rows && (r[e] || (r[e] = []), r[e].push(_, v, x)), l > 0 && p % h == 0) { var b = f + (l - 1) * c; r[b].push(_, v, x), y > 0 && y % h == 0 && r[b - 1] && r[b - 1].push(_, v, x), y === o - 1 && r[b].push(d[0], d[1], d[2]) } 0 === f && 0 === y && (d = [_, v, x]), y > 0 && y % h == 0 && r[e - 1] && r[e - 1].push(_, v, x), l < this.rows && y === o - 1 && r[e].push(d[0], d[1], d[2]) } } return { vertexs: n, facesVertex: r } }, e.getSphereFacesIndices = function () { for (var e = [], n = t.H_SEGS / this.cols, r = n + 1, i = 0; i < n; i++)for (var o = 0; o < n; o++) { var a = i * r, s = a + o + 1, u = a + o + 1 + r; e.push(a + o, s, u), s = a + o + 1 + r, e.push(a + o, s, a + r + o) } return e }, e.getSphereFacesIndicesByimageZoom = function (e) { for (var n = this, r = [], i = t.H_SEGS, o = Math.pow(2, 5 - e), a = i / this.cols + 1, s = a * a, u = function (t) { for (var e = function (e) { n.facesVertexIndice.forEach((function (n) { r.push(n + s * e + s * t * 2) })) }, i = 0; i < o; i++)e(i) }, h = 0; h < o; h++)u(h); return r }, t }(); go.DEFAULT_COLS = Math.pow(2, 4), go.H_SEGS = 64, go.V_SEGS = 33; var yo = function () { function t() { this._counter = 0, this._imageCollection = {} } var e = t.prototype; return e.getImageInstance = function () { var t; for (var e in this._imageCollection) if (this._imageCollection[e] && !0 === this._imageCollection[e]._free) return this._imageCollection[e]._free = !1, this._imageCollection[e]; t = new Image; var n = this.getGUID(); return this._imageCollection[n] = t, t }, e.freeImage = function (t) { t && (t._free = !0, t.src = "", t.onload = t.onerror = null) }, e.getGUID = function () { return this._counter++, "img_".concat(this._counter) }, t }(), _o = function () { function t(e, n) { var r = this, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ""; this.imageInstancePool = void 0, this.tileImagesCache = void 0, this.textureInfo = void 0, this.pano = void 0, this.udtVersion = void 0, this.cdnList = void 0, this.calcTileKey = function (t, e, n, r) { return "".concat(t, "_").concat(e, "_").concat(n, "_").concat(r) }, this.loadImage = function (t, e, n, i) { var o = r.calcTileKey(t, e, n, i), a = r.getTilesUrl(t, { x: e, y: n }, i), s = r.tileImagesCache.getData(o); return new Promise((function (t, e) { s ? t(s._loaded ? s : null) : ((s = r.imageInstancePool.getImageInstance()).crossOrigin = "anonymous", s._loaded = !1, s.onload = function () { s._loaded = !0, t(s) }, s.onerror = function (t) { console.error("Tile ".concat(o, " load error => "), t), e(t) }, s.src = a, r.tileImagesCache.setData(o, s)) })) }, this.loadTexture = function (t, e, n, i) { var o = r.calcTileKey(t, e, n, i), a = r.textureInfo.getData(o); return new Promise((function (s, u) { a && a.loaded ? s(a) : r.loadImage(t, e, n, i).then((function (t) { if (!t) return null; var e = new ui(t); 1 !== i && r.textureInfo.setData(o, e), s(e) })).catch((function (t) { console.error("[TextureManager] loadTexture fail => ".concat(t)), u(null) })) })) }, this.loadTopoTexture = function (t) { var e = 0, n = new Image; return new Promise((function (r) { n.onload = function () { var t = new ui(n); t.flipY = !1, r(t) }, n.onerror = function () { 2 > e ? (e++, n.src = "".concat(t, "&random=").concat((new Date).getTime())) : r(null) }, n.crossOrigin = "anonymous", n.src = t })) }, this.clear = function () { r.textureInfo.clear() }, this.pano = e, this.udtVersion = i, this.cdnList = n || e.opts.tileBaseUrls, this.imageInstancePool = new yo, this.tileImagesCache = new A(t.MAX_TILE_CACHED, { clearCallback: function (t) { r.imageInstancePool.freeImage(t) } }), this.textureInfo = new A(t.MAX_TILE_CACHED, { clearCallback: function (t) { t.destory() } }) } var e = t.prototype; return e.getRandomCDN = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e = t.length; return t[Math.floor(Math.random() * e)] }, e.getTilesUrl = function (e, n, r) { return this.getRandomCDN(this.cdnList) + (t.TILE_URL_TEMPLATE + "&".concat($("/", { isCounter: !0 }))).replace("{udt}", this.udtVersion).replace("{sid}", e).replace("{x}", "".concat(n.x)).replace("{y}", "".concat(n.y)).replace("{zoom}", "".concat(r)) }, t }(); _o.MAX_TILE_CACHED = 160, _o.TILE_URL_TEMPLATE = "?qt=pdata&sid={sid}&pos={y}_{x}&z={zoom}&udt={udt}&from=H5"; var xo = ["attribute vec2 uvBack;", "varying mediump vec2 vTextureCoordBack;", "varying mediump vec2 vTextureCoord;", "void main(void) {", "    gl_Position = mvpMatrix * vec4(position, 1.0);", "    vTextureCoordBack = uvBack;", "    vTextureCoord = uv;", "}"].join("\n"), bo = ["precision mediump float;", "varying vec2 vTextureCoordBack;", "varying vec2 vTextureCoord;", "uniform sampler2D uSamplerBack;", "uniform sampler2D uSampler;", "uniform bool uDrawThumb;", "uniform bool uDrawBack;", "uniform float uAlpha;", "void main(void) {", "    if (uDrawThumb) {", "        gl_FragColor = texture2D(uSamplerBack, vTextureCoordBack);", "        return;", "    }", "    if (uAlpha == 1.0) {", "        gl_FragColor = texture2D(uSampler, vTextureCoord);", "        return;", "    }", "    if (uDrawBack) {", "        gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha + texture2D(uSamplerBack, vTextureCoordBack) * (1.0 - uAlpha);", "    } else {", "        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));", "        gl_FragColor =  vec4(textureColor.rgb, textureColor.a * uAlpha);", "    }", "}"].join("\n"), Mo = ["varying highp vec2 vTextureCoord;", "void main(void) {", "    gl_Position = mvpMatrix * vec4(position, 1.0);", "    vTextureCoord = uv;", "}"].join("\n"), wo = ["precision mediump float;", "uniform sampler2D uSampler;", "varying highp vec2 vTextureCoord;", "void main(void) {", "    gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"].join("\n"), Eo = ["varying highp vec2 vTextureCoord;", "void main(void) {", "    gl_Position = mvpMatrix * vec4(position, 1.0);", "    vTextureCoord = uv;", "}"].join("\n"), To = ["uniform sampler2D uSampler;", "uniform float uOpacity;", "varying vec2 vTextureCoord;", "void main(void){", "    vec4 textureColor = texture2D(uSampler, vTextureCoord);", "    gl_FragColor = vec4(textureColor.rgb, textureColor.a * uOpacity);", "}"].join("\n"), Ao = ["varying highp vec3 vTextureCoord;", "void main(void){", "   gl_Position = mvpMatrix  * vec4(position, 1.0);", "   vTextureCoord = vec3(uv, 1.0) * length(position);", "}"].join("\n"), Co = ["uniform sampler2D uSampler;", "uniform float uOpacity;", "varying vec3 vTextureCoord;", "uniform bool showDebugLine;", "uniform vec4 vColor;", "void main(void){", "   if (!showDebugLine) {", "       vec4 textureColor = texture2DProj(uSampler, vTextureCoord);", "       gl_FragColor = vec4(textureColor.rgb, textureColor.a * uOpacity);", "   } else {", "       gl_FragColor = vec4(vColor.rgb, vColor.a);", "   }", "}"].join("\n"), Ro = function () { function t(e, n, r, i) { this.nodes = void 0, this.level = void 0, this.key = void 0, this.nodes = [], this.level = e, this.key = "".concat(r, "_").concat(i), e < n && (this.nodes[0] = new t(e + 1, n, 2 * r, 2 * i), this.nodes[1] = new t(e + 1, n, 2 * r, 2 * i + 1), this.nodes[2] = new t(e + 1, n, 2 * r + 1, 2 * i), this.nodes[3] = new t(e + 1, n, 2 * r + 1, 2 * i + 1)) } var e = t.prototype; return e.hasNodes = function () { return this.nodes.length > 0 }, e.getNodeKeysByLevel = function (t) { if (t < this.level) return console.warn("指定节点".concat(t, " 不在当前节点").concat(this.level, "范围内！")), []; if (this.level === t) return [this.key]; for (var e = [], n = 0; n < this.nodes.length; n++)if (Object.prototype.hasOwnProperty.call(this.nodes, n)) { var r = this.nodes[n]; if (this.level === t - 1) e.push(r.key); else if (r.hasNodes()) { var i = r.getNodeKeysByLevel(t); e.push.apply(e, mi(i)) } } return e }, t }(); var So = function (t) { function e(e) { var n; return (n = t.call(this, e) || this).name = "SphereRender", n.sphere = void 0, n.textureManager = void 0, n.imgColsRows = void 0, n.curThumbTexture = void 0, n.meshCache = {}, n.tileInfoCache = {}, n.imgRange = void 0, n.faceRange = void 0, n.hitTile = void 0, n.setData = function (t) { n.panoData = t, n.curThumbTexture = null, n.loadThumbTextures(t.panoId) }, n.update = function () { n.updateRangeInfo(), n.checkAndLoadTiles() }, n.checkAndLoadTiles = function () { if (n.curThumbTexture && n.panoData) { var t = n.panoData.panoId, e = n.camera, r = n.imgColsRows[n._imgZoom], i = r.cols, o = i - 1, a = r.rows - 1, s = n.pano.getContainerSize(), u = s.width, h = s.height, c = !1, l = [], f = xi(n.imgRange, 4), d = f[0], p = f[1], v = f[2], m = f[3]; if (vo(Vt(0, 100, 0), e, u, h)) { for (var g = 0; g <= v; g++)for (var y = 0; y <= o; y++)n.checkAndLoadTile(t, y, g, n._imgZoom), l.push([g, y]); v < m && (v += 1, c = !0) } else if (vo(Vt(0, -100, 0), e, u, h)) { for (var _ = m; _ <= a; _++)for (var x = 0; x <= o; x++)n.checkAndLoadTile(t, x, _, n._imgZoom), l.push([_, x]); v < m && (m -= 1, c = !0) } else c = !0; if (!0 === c) { p > o && (p = o); for (var b = d; b <= p; b++)for (var M = v; M <= m; M++) { var w = b < 0 ? b + i : b; n.checkAndLoadTile(t, w, M, n._imgZoom), l.push([M, w]) } } n.hitTile = l, l.forEach((function (t) { var e = xi(t, 2), r = e[0], i = e[1], o = "".concat(r, "_").concat(i, "_").concat(n._imgZoom); if (void 0 === n.tileInfoCache[o]) { var a = new Ro(n._imgZoom, 5, r, i).getNodeKeysByLevel(5); n.tileInfoCache[o] = a } })) } }, n.draw = function () { var t = n.meshs; if (!n.faceRange || !n.curThumbTexture) return !1; t.children = []; for (var e = function (e, r) { var i = n.curThumbTexture, o = n.textureManager.calcTileKey(n.panoData.panoId, e, r, n._imgZoom), a = n.textureManager.textureInfo.getData(o), s = !1, u = null; if (a ? !(u = a).finished && u.aniInfo && u.aniInfo && u.aniInfo.update() : i && (s = !0, u = i), u) { var h = "".concat(r, "_").concat(e, "_").concat(n._imgZoom), c = n.meshCache[h]; if (!c) { if (!(c = n.createTileMesh(r, e))) return; n.meshCache[h] = c } if (!c.material) return; var l = c.material.uniforms; l.uSamplerBack.value = i, s ? l.uDrawThumb.value = !0 : (l.uDrawThumb.value = !1, l.uSampler.value = u, l.uAlpha.value = u.alpha), t.add(c) } }, r = 0; r < n.hitTile.length; r++) { var i = xi(n.hitTile[r], 2), o = i[0]; e(i[1], o) } return !0 }, n.pano = e, n.sphere = new go(e.opts.radius), n.textureManager = new _o(e), n.imgColsRows = function () { for (var t = [], e = 0; e <= 5; e++)t[e] = e < 2 ? { cols: 1, rows: 1 } : { cols: Math.pow(2, e - 1), rows: Math.pow(2, e - 1) / 2 }; return t }(), n.curThumbTexture = null, n.meshs = new Kr, n } c(e, t); var n = e.prototype; return n.checkAndLoadTile = function (t, e, n, r) { var i = this, o = this.textureManager, a = o.calcTileKey(t, e, n, r); !0 !== (void 0 !== o.textureInfo.getData(a)) && this.textureManager.loadTexture(t, e, n, r).then((function (t) { t && !t.done && (t.aniInfo = i.createTextureAnimation(t), t.done = !0, i.pano.dispatchEvent({ type: d.REFRESH, log: "[Refresh Log] 瓦片加载完成， 渲染一帧" })) })) }, n.loadThumbTextures = function (t) { var e = this; this.textureManager.loadTexture(t, 0, 0, 1).then((function (t) { e.curThumbTexture = t, e.pano.dispatchEvent({ type: d.THUMB_LOADED }), e.pano.dispatchEvent({ debug: !0, type: d.REFRESH, log: "[Refresh Log] 缩略图加载完毕，渲染一帧" }) })) }, n.createTextureAnimation = function (t) { var e = this; return t.alpha = 0, new ho(0, 1, 300).onUpdate((function (n) { t.alpha = n, e.pano.dispatchEvent({ debug: !0, type: d.REFRESH, log: "[Refresh Log] 纹理清晰度渐变动画，渲染一帧" }) })).onEnd((function () { t.finished = !0 })).start() }, n.createTileMesh = function (t, e) { var n = new Ti, r = new Zr; if (n.depthTest = !1, n.vertexShader = xo, n.fragmentShader = bo, n.uniforms = { uSampler: { type: "t", value: null }, uSamplerBack: { type: "t", value: null }, uDrawThumb: { type: "1i", value: 1 }, uDrawBack: { type: "1i", value: 1 }, uAlpha: { type: "1f", value: 1 } }, !this.setGeometryAttrib(r, t, e)) return null; var i = new Kr(r, n); return i.name = "tile-mesh", i }, n.setGeometryAttrib = function (t, e, n) { var r = "".concat(e, "_").concat(n, "_").concat(this._imgZoom), i = this.tileInfoCache[r]; if (!i) return !1; for (var o = [], a = [], s = [], u = 0; u < i.length; u++) { var h = i[u].split("_"), c = this.sphere.rows, l = Number(h[1]), f = c - 1 - Number(h[0]); o.push.apply(o, mi(this.sphere.getFaceVertex(f, l))), a.push.apply(a, mi(this.sphere.generateTextureCoord(f, l, this._imgZoom))), s.push.apply(s, mi(this.sphere.generateTextureCoord(f, l, 1))) } var d = this.sphere.getSphereFacesIndicesByimageZoom(this._imgZoom); return t.setAttribute("uv", new Gr(a, 2)), t.setAttribute("uvBack", new Gr(s, 2)), t.setAttribute("position", new Gr(o, 3)), t.setIndexes(d), !0 }, n.getTileBoundary = function () { var t = this.pano.getContainerSize(), e = t.width, n = t.height, r = _t(0, 0), i = _t(e, 0), o = _t(0, n), a = _t(e, n), s = _t(.5 * e, 0), u = _t(.5 * e, n), h = _t(0, .5 * n), c = _t(e, .5 * n), l = this.getSpherePosition(r), f = this.getSpherePosition(i), d = this.getSpherePosition(o), p = this.getSpherePosition(a), v = this.getSpherePosition(s), m = this.getSpherePosition(u), g = this.getSpherePosition(h), y = this.getSpherePosition(c), _ = Math.max(l[1], v[1], f[1]), x = Math.min(d[1], m[1], p[1]), b = [l[0], g[0], d[0], v[0]], w = [f[0], y[0], p[0], m[0]], E = Math.min.apply(Math, b), T = Math.max.apply(Math, w), A = M(b), C = M(w), R = this.sphere.cols, S = R / 2; A.max - A.min > S && (E = Math.min.apply(Math, mi(b.filter((function (t) { return t > S }))))), C.max - C.min > S && (T = Math.max.apply(Math, mi(w.filter((function (t) { return t < S }))))), E > T && (E -= R); var P = this.getImgIndexByFaceColRow(E, _), D = xi(P, 2), O = D[0], I = D[1], L = this.getImgIndexByFaceColRow(T, x), B = xi(L, 2); return [[E, T, _, x], [O, B[0], I, B[1]]] }, n.updateRangeInfo = function () { var t = this.getTileBoundary(), e = xi(t, 2), n = e[0], r = e[1]; this.imgRange = r, this.faceRange = n }, n.getImgIndexByFaceColRow = function (t, e, n) { n = n || this._imgZoom; var r = Math.pow(2, 5 - n), i = Math.floor(t / r), o = Math.floor(e / r); return [i, o = this.imgColsRows[n].rows - o - 1, i + o * go.DEFAULT_COLS / r] }, n.normalizeNum = function (t, e) { for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = t; r < n;)r += e; return r %= e }, n.getSpherePosition = function (t) { var e = this.camera, n = this.pano.getContainerSize(), r = n.width, i = n.height, o = this.sphere.viewportToSphereCoord(t, r, i, e), a = this.sphere.getFaceIndex(o), s = xi(a, 2); return _t(s[0], s[1]) }, n.generateBackThumb = function (t) { if (t) { var e = this.pano, n = e.getContainerSize(), r = n.width, i = n.height, o = "//apisv0.bdimg.com/?udt=20140616&qt=pdata&pos=0_0&z=2&sid=".concat(t, "&from=H5&").concat($("/", { isCounter: !0 })), a = e.getPanes().tileLayer; a.style.backgroundImage = 'url("' + o + '")', a.style.backgroundPosition = "50% 50%", a.style.backgroundSize = "150% 150%", a.style.width = "".concat(r, "px"), a.style.height = "".concat(i, "px") } }, o(e, [{ key: "_imgZoom", get: function () { return this.pano.imageZoom } }]), e }(Ji), Po = [10, -20, 30, 10, -20, 10, -10, -20, 10, -10, -20, 30].map((function (t) { return -20 === t ? -20 : 1.8 * t })), Do = [10, -22, 30, 10, -22, 10, -10, -22, 10, -10, -22, 30].map((function (t) { return -22 === t ? -22 : 1.8 * t })), Oo = [1.8, -20, 24.9, 1.8, -20, 16.3, -1.8, -20, 16.3, -1.8, -20, 24.9].map((function (t) { return -20 === t ? -20 : 1.8 * t })), Io = [0, 0, 0, .5, .25, .5, .25, 0], Lo = function () { function t(t, e, n) { var r = this; this.mesh = void 0, this.material = void 0, this.linkData = void 0, this._pano = void 0, this.northDir = void 0, this.yAxisDis = void 0, this.isPosInArrow = function (t, e, n, i, o) { var a = _t(t, e), s = fo(a, n, i, o, -1), u = 200 * s[0], h = 200 * s[1], c = 200 * s[2], l = r.yAxisDis / h; if (l < 0) return !1; var f = [u * l, h * l, c * l]; return r.isHitLink(f) }, this._pano = t, this.linkData = e, this.northDir = n, this.yAxisDis = 0, this.linkData.refinedDir = _((e.topoDir || 0) + this.northDir), this.material = this.createArrowMaterial(), this.mesh = this.initMesh(), this.changePose() } var e = t.prototype; return e.initMesh = function () { var t = this.createGeometry(), e = new Kr(t, this.material); return e.visible = !1, e.name = "link-mesh", e }, e.createArrowMaterial = function () { var t = new Ti; return t.depthTest = !1, t.vertexShader = Mo, t.fragmentShader = wo, t.uniforms = { uSampler: { type: "t", value: null } }, t }, e.setTopoTexture = function (t) { t.isTexture && (this.material.uniforms.uSampler.value = t) }, e.setVisible = function (t) { this.mesh.setVisible(t, !0) }, e.createGeometry = function () { var t = new Zr, e = this.getTextCoord(this.linkData.topoDir), n = [].concat(Do, Po, Oo), r = [].concat([.5, 0, .5, .5, 1, .5, 1, 0], [0, 0, 0, .5, .5, .5, .5, 0], e), i = [].concat([0, 1, 2, 0, 2, 3], [4, 5, 6, 4, 6, 7], [8, 9, 11, 10, 11, 9]); return t.setAttribute("position", new Gr(n, 3)), t.setAttribute("uv", new Gr(r, 2)), t.setIndexes(i), t }, e.changePose = function (t) { t = t || this.mesh; var e = 50, n = -30, r = this._pano.getPov().pitch, i = this.linkData.refinedDir; (e += 20 * this._pano.getZoom(), r < 0) && (e *= (90 - (r = Math.abs(r))) / 90, n -= 20 * r / 90); var o = Math.cos(g(i)) * e, a = Math.sin(g(i)) * e; this.yAxisDis = n + -20, t.setPosition(o, n, a), t.rotateY(-_(i - 90)), t.rotateX(-5), t.updateWorldMatrix(!0) }, e.getTextCoord = function (t) { t = (t + 360) % 360; var e = Math.ceil(Math.floor(t / 22.5) / 2); 8 === e && (e = 0); for (var n = Io.slice(0), r = Math.floor(e / 2), i = e % 2, o = 0; o < n.length; o++)o % 2 == 0 ? (n[o] += .25 * r, n[o] = .5 * n[o]) : (n[o] += .5 * i, n[o] = .5 * n[o] + .5); return n }, e.isHitLink = function (t) { var e = t[0], n = t[2], r = this.mesh.worldMatrix, i = Vt(Po[0], Po[1], Po[2]), o = Vt(Po[6], Po[7], Po[8]), a = Vt((i[0] + o[0]) / 2, (i[1] + o[1]) / 2, (i[2] + o[2]) / 2); return ee(a, a, r), Math.abs(e - a[0]) < 18 && Math.abs(n - a[2]) < 18 }, t }(), Bo = function (t) { function e(e) { var n; return (n = t.call(this, e) || this).name = "PanoLinkRender", n.linkVisible = !0, n.textureManager = void 0, n.linkInfos = [], n.setData = function (t) { if (t && (o = t.getTopos, a = "[object Function]" === Object.prototype.toString.call(o), s = "[object AsyncFunction]" === Object.prototype.toString.call(o), a || s)) { n.reset(); var e = t.getTopos(), r = t.northDir, i = t.panoType === p.TYPE_STREET; e.length && i && (n.linkInfos = e.map((function (t) { return new Lo(n.pano, t, r) })), n.meshs = n.linkInfos.map((function (t) { return t.mesh })), n.loadTextures(), n.setVisible(!0)) } var o, a, s }, n.clickChecker = function (t, e) { if (n.linkVisible) { var r = n.getIdByTouchPos(t, e); return r && (n.setVisible(!1), n.pano.dispatchEvent({ type: d.LINK_CLICK, id: r }), n.pano.setId(r, { animation: !0 })), !r } }, n.pano = e, n.meshs = [], n.textureManager = new _o(e), n } c(e, t); var n = e.prototype; return n.reset = function () { this.meshs = [], this.linkInfos = [] }, n.update = function () { this.linkInfos.forEach((function (t) { t.changePose() })) }, n.setVisible = function (t) { var e = this.linkInfos; if (!(e.length < 1)) { var n = this.pano.opts.linksControl, r = !1; !0 === n && (r = t), this.linkVisible = r, e.forEach((function (t) { return t.setVisible(r) })) } }, n.draw = function () { }, n.loadTextures = function () { var t = this, e = this.pano.opts.imgPath ? "".concat(this.pano.opts.imgPath, "topo_arrow.png") : p.TOPO_ARROW_TEXTURE; this.textureManager.loadTopoTexture(e).then((function (e) { e && t.linkInfos.forEach((function (t) { t.setTopoTexture(e) })) })) }, n.getIdByTouchPos = function (t, e) { var n = this, r = null; if (!this.linkInfos.length) return r; var i = this.pano.getContainerSize(), o = i.width, a = i.height, s = this.linkInfos.filter((function (r) { return r.isPosInArrow(t, e, n.camera, o, a) })); return s.length && (r = s[0].linkData.panoId), r }, e }(Ji), ko = function () { function t(t, e, n) { var r = this; this.start = function () { r.fadeAni.start(), r._pano.dispatchEvent({ debug: !0, log: "淡出动画，渲染一帧", type: d.REFRESH }) }, this.update = function () { r.fadeAni.update() }, this._pano = t, this.gl = this._pano.gl, this.snapshot = e, this.scene = this.initScene(), this.camera = this.initCamera(); this.fadeAni = new ho(1, 0, 600).onUpdate((function (t) { r.material.uniforms.uOpacity.value = t, r._pano.dispatchEvent({ type: d.REFRESH }) })).onEnd((function () { n && n(), r._pano.dispatchEvent({ type: d.REFRESH, debug: !0, log: "淡出动画结束，渲染一帧" }) })) } var e = t.prototype; return e.initScene = function () { var t = new Qr, e = this._pano.getContainerSize(), n = e.width, r = e.height, i = new ji(n, r), o = this.initMaterial(), a = new Kr(i, o); return t.add(a), t }, e.initMaterial = function () { var t = new Ti; return t.depthTest = !1, t.vertexShader = Eo, t.fragmentShader = To, t.uniforms = { uSampler: { type: "t", value: this.snapshot }, uOpacity: { type: "1f", value: 1 } }, this.material = t, t }, e.initCamera = function () { var t = this._pano.getContainerSize(), e = t.width / 2, n = t.height / 2; return new Xi(-e, e, n, -n, 0, 11e3) }, t }(), Uo = function () { function t(t, e, n) { var r = this; this.start = function () { r.waveAni.start(), r._pano.dispatchEvent({ debug: !0, log: "淡出动画，渲染一帧", type: d.REFRESH }) }, this.update = function () { r.waveAni.update() }, this._pano = t, this.gl = this._pano.gl, this.snapshot = e, this.scene = this.initScene(), this.camera = this.initCamera(); this.waveAni = new ho(0, 1, 800).onUpdate((function (t) { r.material.uniforms.progress.value = t, r.material.uniforms.uOpacity.value = 1 - t, r._pano.dispatchEvent({ type: d.REFRESH }) })).onEnd((function () { n && n(), r._pano.dispatchEvent({ type: d.REFRESH, debug: !0, log: "淡出动画结束，渲染一帧" }) })) } var e = t.prototype; return e.initCamera = function () { var t = this._pano.getContainerSize(), e = t.width / 2, n = t.height / 2; return new Xi(-e, e, n, -n, 0, 11e3) }, e.initScene = function () { var t = new Qr, e = this._pano.getContainerSize(), n = e.width, r = e.height, i = new ji(n, r), o = this.initMaterial(), a = new Kr(i, o); return t.add(a), t }, e.initMaterial = function () { var t = new Ti, e = this._pano.getContainerSize(), n = e.width, r = e.height; return t.depthTest = !1, t.vertexShader = Eo, t.fragmentShader = "\n    uniform float aspect;\n    uniform float radius;\n    uniform float amp;\n    uniform float band;\n    uniform float waves;\n    uniform float speed;\n    uniform float progress;\n    uniform vec2 uCenter;\n    uniform sampler2D uSampler;\n    uniform float uOpacity;\n\n    varying vec2 vTextureCoord;\n\n    void main() {\n        vec2 tc = vTextureCoord;\n        vec2 uv = vec2(0.0, 0.0);\n        vec2 p;\n        float len;\n        vec2 uv_offset;\n        float wave_width = band * radius;\n\n        p = (tc - uCenter);\n        p.x = p.x * aspect;\n        len = length(p);\n\n        float current_radius = radius * progress;\n        float damp_factor = 1.0;\n        if (progress > .5) {\n            damp_factor = (1.0 - progress) * 2.0;\n        }\n\n        float cut_factor = clamp(wave_width * damp_factor - abs(current_radius - len), 0.0, 1.0);\n        float waves_factor = waves * len / radius;\n        uv_offset = (p / len) * cos((waves_factor - progress * speed) * 3.14) * amp * cut_factor;\n\n        uv += uv_offset;\n\n        vec4 t_image = texture2D(uSampler, fract(tc + uv));\n\n        // gl_FragColor = t_image;\n        gl_FragColor = vec4(t_image.rgb, t_image.a * uOpacity);\n    }\n", t.uniforms = { uSampler: { type: "t", value: this.snapshot }, uCenter: { type: "2f", value: [.5, .5] }, uOpacity: { type: "1f", value: 1 }, progress: { type: "1f", value: 0 }, speed: { type: "1f", value: 4 }, waves: { type: "1f", value: 14 }, band: { type: "1f", value: .3 }, amp: { type: "1f", value: .3 }, aspect: { type: "1f", value: n / r }, radius: { type: "1f", value: 1 } }, this.material = t, t }, t }(), No = function () { function t(t, e, n, r) { var i = this; this.startAni = function () { i.animation.start() }, this.update = function () { i.animation.update() }, this.pano = t, this.distance = n, this.refinedDir = e, this.camera = this.pano.camera, this.cameraBase = this.pano.camera.clone(), this.handleEnd = r, this.initAni() } return t.prototype.initAni = function () { var t = this, e = this.distance, n = this.refinedDir, r = Math.cos(g(n)), i = Math.sin(g(n)); this.animation = new ho(0, 1, 400, so.easeOutQuad).onUpdate((function (n) { var o = e * n, a = r * o, s = i * o; t.camera.setPosition(a, 0, s), t.pano.dispatchEvent({ debug: !0, type: d.REFRESH, log: "[Refresh Log] 前进动画， 渲染一帧" }) })).onEnd((function () { t.handleEnd && t.handleEnd() })) }, t }(), Fo = function (t, e, n, r) { this.x = t || 0, this.y = e || 0, this.width = n || 0, this.height = r || 0 }, jo = function (t, e) { var n = this; this.angleDegreeDelta = function (t, e) { var n = Math.abs(t - e); return n > 180 ? 360 - n : n }, this.getRoad = function (t, e, n, r, i) { for (var o, a = [], s = [[-t / 2, -e, -10], [-t / 2, -e, -20], [t / 2, -e, -10], [t / 2, -e, -20]], u = s.length, h = 0; h < u; h++)ee(o = s[h], o, n), a[h] = { x: o[0] * r * .5, y: -o[1] * i * .5 }; return a }, this.getIntersection = function (t, e, n, r) { if (t.x === e.x || n.x === r.x) return null; var i = (e.y - t.y) / (e.x - t.x), o = (r.y - n.y) / (r.x - n.x); if (i === o) return null; var a = (o * n.x - i * t.x + t.y - n.y) / (o - i); return { x: a, y: i * (a - t.x) + t.y } }, this.calculateVanishPoint = function (t, e, r, i) { var o = n.getIntersection(t[0], t[1], t[2], t[3]); return null === o ? null : (o.x += r * e * .5, o.y += i * e * .5, o) }, this.getOuterRect = function (t, e, n) { return new Fo(t * (n - 1) * .5, e * (n - 1) * .5, t, e) }, this.transformPoint = function (t, e, n) { return t && void 0 !== t.x && void 0 !== t.y ? { x: t.x + e, y: t.y + n } : t }, this.getInnerRect = function (t, e, r, i, o) { var a = n.transformPoint(t, .5 * -r * o, .5 * -i * o), s = n.transformPoint(a, 0, 20), u = n.transformPoint(a, 10, 20), h = n.getIntersection(e[0], e[1], s, u), c = n.getIntersection(e[2], e[3], s, u), l = n.transformPoint(h, 0, -70), f = new Fo(l.x + r * o * .5, l.y + i * o * .5, c.x - h.x, 70); return f = n.fixInnerRectPosition(f, t), f = n.fixInnerRectSize(f, t, r) }, this.fixInnerRectPosition = function (t, e) { var n = t, r = (e.x - t.x) / t.width, i = 0; return r > .7 && (i = r - .7), r < .3 && (i = .3 - r), n.x = n.x + n.width * i, n }, this.fixInnerRectSize = function (t, e, n) { var r, i, o, a, s = t; s.width / n > .12 && (a = (o = .12 * n) * (s.width / s.height), r = s.x + (s.width - o) * (e.x - s.x) / s.width, i = s.y + (s.height - a) * (e.y - s.y) / s.height, s = new Fo(r, i, o, a)); var u = s.width / s.height; return a = s.height, u > 1.2 && (a = s.height * u / 1.2), u < .9 && (a = s.height * u / .9), i = s.y + s.height - a, s.height = a, s.y = i, s }, this.panoData = t.panoData, this.camera = t.camera, this.projectionMatrix = this.camera.projectionMatrix, this.fov = g(this.camera.fov), this.traverseDir = e, this.cameraHeading = t.getPov().heading || 0, this.isMovingForward = this.angleDegreeDelta(this.cameraHeading, this.traverseDir) <= 90, this.roadWith = Math.min(1.5 * this.panoData.getRoadWidth(), 10), this.deviceHeight = this.panoData.deviceHeight || 2.2, this.panoWidth = t._container.clientWidth, this.panoHeight = t._container.clientHeight; var r = this.angleDegreeDelta(this.cameraHeading, this.traverseDir) > 45; this.snapshotRatio = r ? 1 : 1.8, this.projectionRoadInfos = this.getRoad(this.roadWith, this.deviceHeight, this.projectionMatrix, this.panoWidth, this.panoHeight), this.vanishPoint = this.calculateVanishPoint(this.projectionRoadInfos, this.snapshotRatio, this.panoWidth, this.panoHeight), this.innerRect = this.getInnerRect(this.vanishPoint, this.projectionRoadInfos, this.panoWidth, this.panoHeight, this.snapshotRatio), this.outerRect = this.getOuterRect(this.panoWidth, this.panoHeight, this.snapshotRatio), this.focusLength = .5 * this.panoHeight / Math.tan(.75 * this.fov), this.vanishPointDeltaX = this.vanishPoint.x - this.outerRect.x - .5 * this.outerRect.width, this.vanishPointDeltaY = this.vanishPoint.y - this.outerRect.y - .5 * this.outerRect.height }, zo = { FAR: [10, 10, 0], LEFT: [0, 10, 30], RIGHT: [0, 10, 30], TOP: [10, 0, 30], BOTTOM: [10, 0, 30] }, Vo = { FAR: ["innerTopLeftVertex", "innerBottomRightVertex"], LEFT: ["outerTopLeftVertex", "innerBottomLeftVertex"], RIGHT: ["innerTopRightVertex", "outerBottomRightVertex"], TOP: ["outerTopLeftVertex", "innerTopRightVertex"], BOTTOM: ["innerBottomLeftVertex", "outerBottomRightVertex"] }, Go = Object.keys(zo), Wo = function (t) { function e(e, n) { var r; if ((r = t.call(this) || this).createSkeleton = function (t) { var e = t.vanishPoint, n = t.innerRect, r = t.outerRect, i = t.focusLength, o = r.y + r.height - n.y - n.height, a = e.y - n.y, s = e.x - n.x, u = n.x + n.width - e.x, h = r.y + r.height - e.y, c = o * i / (h - o), l = u * (i + c) / i, f = -(s * (i + c) / i), d = h + a * (i + c) / i - h, p = -h, v = c / 5; return { innerTopLeftVertex: { x: f, y: d, z: -c }, innerBottomLeftVertex: { x: f, y: p, z: -c }, innerTopRightVertex: { x: l, y: d, z: -c }, innerBottomRightVertex: { x: l, y: p, z: -c }, outerTopLeftVertex: { x: f, y: d, z: v }, outerTopRightVertex: { x: l, y: d, z: v }, outerBottomLeftVertex: { x: f, y: p, z: v }, outerBottomRightVertex: { x: l, y: p, z: v } } }, r.modelSkeleton = function (t, e) { var n = [], i = []; return Go.forEach((function (o) { var a = xi(Vo[o], 2), s = a[0], u = a[1], h = n.length / 3; n = n.concat(r.calculatePlaneVertex(t[s], t[u], o, e)), i = i.concat(r.calculateIndices(o, h)) })), [n, i] }, r.calculatePlaneVertex = function (t, e, n, i) { for (var o, a = [], s = xi(zo[n], 3), u = s[0], h = s[1], c = s[2], l = r.linerInterpolate(t.x, e.x, u), f = r.linerInterpolate(t.y, e.y, h), d = r.linerInterpolate(t.z, e.z, c), p = 0; p <= u; p++)for (var v = 0; v <= h; v++)for (var m = 0; m <= c; m++)En(o = hn(l[p], f[v], d[m], 1), o, i), o[0] = o[0] / o[3], o[1] = o[1] / o[3], o[2] = o[2] / o[3], a.push(o[0], o[1], o[2]); return a }, r.calculateIndices = function (t, e) { var n = [], r = zo[t]; r = r.filter((function (t) { return t > 0 })); for (var i = xi(r, 2), o = i[0], a = i[1], s = 0, u = 0, h = 0, c = 0, l = 0; l < o; l++)for (var f = 0; f < a; f++)u = (s = e + (a + 1) * l + f) + 1, c = (h = s + a + 1) + 1, n.push(s, h, c), n.push(s, c, u); return n }, r.linerInterpolate = function (t, e, n) { var r = []; if (n <= 0) r.push(t); else for (var i = (e - t) / n, o = 0; o <= n; o++)r[o] = t + i * o; return r }, r.calculateUVCoordinate = function (t, e, n) { for (var i, o = t.camera, a = t.panoWidth, s = t.panoHeight, u = t.vanishPointDeltaX, h = t.vanishPointDeltaY, c = [], l = e.width, f = e.height, d = 0, p = 0, v = n.length / 3, m = 0; m < v; m++)En(i = hn(n[3 * m], n[3 * m + 1], n[3 * m + 2], 1), i, o.viewMatrix), En(i, i, o.projectionMatrix), i[0] = i[0] / i[3], i[1] = i[1] / i[3], i[2] = i[2] / i[3], i[3] = 1, d = (i[0] * a * .5 + u + .5 * l) / l, p = (i[1] * s * .5 + h + .5 * f) / f, c.push(r.getValidateUV(d), r.getValidateUV(p)); return new Float32Array(c) }, r.getValidateUV = function (t) { return Math.max(-.1, Math.min(1.1, t)) }, r.rotationMatrix = Pe(), r.camera = e.camera, e.isMovingForward) Ve(r.rotationMatrix, r.rotationMatrix, g(_(-e.traverseDir + e.panoData.heading))); else { var i = _(180 - e.traverseDir + e.panoData.heading); Ve(r.rotationMatrix, r.rotationMatrix, g(i)) } r.cuboidVertexes = r.createSkeleton(e); var o = r.modelSkeleton(r.cuboidVertexes, r.rotationMatrix), a = xi(o, 2), s = a[0], u = a[1]; return r.verticesBufferData = new Float32Array(s), r.indicesBufferData = new Uint16Array(u), r.uvtsBufferData = r.calculateUVCoordinate(e, n, s, r.rotationMatrix), r.setAttribute("position", new Gr(r.verticesBufferData, 3)), r.setAttribute("uv", new Gr(r.uvtsBufferData, 2)), r.setIndexes(r.indicesBufferData), r } return c(e, t), e }(Zr), Ho = [0, 1, 0, .5], Zo = function () { function t(t, e, n, r, i) { var o = this; this.start = function () { o.animation.start(), o._pano.dispatchEvent({ debug: !0, log: "淡出动画，渲染一帧", type: d.REFRESH }) }, this.update = function () { o.animation.update() }, this._pano = t, this.distance = e, this.handleEnd = i, this.traverseDir = r, this.snapshot = n, this.camera = t.camera, this.scene = this.initScene(), this.rotationMatrix = this.traverseGeometry.rotationMatrix, this.initAni() } var e = t.prototype; return e.initAni = function () { var t = this, e = Vt(0, 0, this.distance); ee(e, e, this.rotationMatrix), this.animation = new ho(0, 1, 700, so.linear).onUpdate((function (n) { var r = Ft(); Yt(r, e, n), t.scene.traverse((function (t) { t.position = r, t.updateWorldMatrix(!0) })), t._pano.dispatchEvent({ debug: !0, type: d.REFRESH, log: "[Refresh Log] 前进动画， 渲染一帧" }) })).onEnd((function () { t.handleEnd && t.handleEnd(), t._pano.dispatchEvent({ debug: !0, type: d.REFRESH, log: "[Refresh Log] 前进动画， 渲染一帧" }) })) }, e.initScene = function () { var t = new Qr, e = this._pano.getContainerSize(), n = e.width, r = e.height, i = new jo(this._pano, this.traverseDir), o = new Fo(0, 0, n, r), a = new Wo(i, o), s = this.initMaterial(), u = new Kr(a, s); return this.traverseGeometry = a, t.add(u), t }, e.initMaterial = function () { var t = new Ti; return t.depthTest = !1, t.vertexShader = Ao, t.fragmentShader = Co, t.uniforms = { uSampler: { type: "t", value: this.snapshot }, uOpacity: { type: "1f", value: 1 }, vColor: { type: "4f", value: Ho }, showDebugLine: { type: "1i", value: true } }, this.material = t, t }, t }(), qo = function () { function t() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; this.x = t, this.y = e } return t.prototype.equals = function (t) { return t && t.x === this.x && t.y === this.y }, t }(), Yo = function () { function t(t, e) { var n = this; this.setData = function (t, e) { n.panoData = t, n.nextPanoData = e }, this.sceneChangeHandler = function () { if (n.panoData && n.nextPanoData) return new Promise((function (t) { var e = n.isStreet(n.panoData.panoType), r = n.isStreet(n.nextPanoData.panoType), i = n.snapshotFn(), o = n.pano.animationType; if (o && ["waterwave", "fade"].indexOf(o) > -1) switch (o) { case "waterwave": n.prepareWaterWave(i), t(); break; case "fade": n.prepareFade(i), t() } else r && e ? (n.setDir(), n.prepareTraverse(i).then((function (e) { n.prepareFade(e), t() }))) : (n.prepareFade(i), t()) })) }, this.setSnapshot = function (t) { n.snapshot = t }, this.pano = t, this.snapshotFn = e, this.panoData = null, this.nextPanoData = null, this.changeAni = null, this.animateDir = 0 } var e = t.prototype; return e.draw = function () { if (this.changeAni) { var t = this.changeAni, e = t.scene, n = t.camera; this.changeAni.update(), this.pano.renderer.render(e, n) } }, e.setDir = function () { if (this.panoData && this.nextPanoData) { var t = this.nextPanoData.panoId, e = this.panoData.getTopos().filter((function (e) { return e && e.panoId === t })); if (e.length) { var n = e[0].topoDir; this.animateDir = n } else this.animateDir = this.pano.getPov().heading || 0 } }, e.prepareJump = function () { var t = this, e = this.calcJumpDistance(); return new Promise((function (n) { t.changeAni = new No(t.pano, t.animateDir, e, (function () { t.changeAni = null, n() })), t.changeAni.startAni(), t.pano.dispatchEvent({ debug: !0, log: "穿梭动画，渲染一帧", type: d.REFRESH }) })) }, e.prepareTraverse = function (t) { var e = this, n = this.calcJumpDistance(); return new Promise((function (r) { e.changeAni = new Zo(e.pano, n, t, e.animateDir, (function () { var t = e.snapshotFn(e.changeAni.scene, e.changeAni.camera); r(t), e.changeAni = null })), e.changeAni.start(), e.pano.dispatchEvent({ debug: !0, log: "穿梭动画，渲染一帧", type: d.REFRESH }) })) }, e.prepareFade = function (t) { var e = this; this.changeAni = new ko(this.pano, t, (function () { e.changeAni = null, e.pano.emit(d.SCENE_CHANGE_END) })) }, e.prepareWaterWave = function (t) { var e = this; this.changeAni = new Uo(this.pano, t, (function () { e.changeAni = null, e.pano.emit(d.SCENE_CHANGE_END) })) }, e.calcJumpDistance = function () { var t, e, n = 300, r = (t = new qo(this.panoData.panoX, this.panoData.panoY), e = new qo(this.nextPanoData.panoX, this.nextPanoData.panoY), t && e ? Math.round(Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))) : 0); "number" == typeof r && (n *= Math.pow(r, 1 / 4)); return n }, e.isStreet = function (t) { return t === p.TYPE_STREET }, t }(), Xo = function () { function t(t, e) { var n = e.fov, r = void 0 === n ? 145 : n, i = e.cameraY, o = void 0 === i ? 3e3 : i, a = e.handleEnd; this._pano = void 0, this.originFov = void 0, this.originRotateX = void 0, this.originRotateY = void 0, this.targetFov = void 0, this.targetCameraY = void 0, this.handleEnd = void 0, this.animate = void 0, this._pano = t, this.originFov = this.camera.fov, this.originRotateX = this.camera.rotation.x, this.originRotateY = this.camera.rotation.y, this.targetFov = r, this.targetCameraY = o, this.handleEnd = a, this.init() } var e = t.prototype; return e.start = function () { this._pano.dispatchEvent({ type: d.REFRESH, debug: !0, log: "开场动画动画起始，渲染一帧" }), this.animate.start() }, e.update = function () { this.animate.update() }, e.init = function () { var t = this, e = this.camera; this.handleCameraChange(0), this.animate = new ho(0, 1, p.FISHEYE_DURATION, so.easeInOutQuad).onUpdate((function (e) { t.handleCameraChange(e), t._pano.dispatchEvent({ type: d.REFRESH, debug: !0, log: "开场动画动画，渲染一帧" }) })).onEnd((function () { e.fov = t.originFov, e.rotateX(t.originRotateX), e.rotateY(t.originRotateY), e.setPosition(0, 0, 0), e.updateWorldMatrix(), e.updateProjectionMatrix(), t._pano.dispatchEvent({ type: d.REFRESH, debug: !0, log: "开场动画动画结束，渲染一帧" }), t.handleEnd() })) }, e.handleCameraChange = function (t) { var e = this.camera, n = this.targetCameraY, r = this.targetFov - (this.targetFov - this.originFov) * t, i = (this.originRotateX - -90) * t - 90, o = this.originRotateY * t; e.fov = r, e.rotateX(i), e.rotateY(o), e.setPosition(0, n - n * t, 0), e.updateWorldMatrix(), e.updateProjectionMatrix() }, o(t, [{ key: "camera", get: function () { return this._pano.camera } }]), t }(); function Ko(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return Qo(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Qo(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function Qo(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var Jo = function () { function t(t) { var e = this; this.name = "PanoOverlayManager", this.overlays = [], this.pano = void 0, this.isReady = !1, this.clickChecker = function (t, n) { var r, i = !0, o = Ko(e.overlays); try { for (o.s(); !(r = o.n()).done;) { var a = r.value, s = a.dom.getBoundingClientRect(), u = s.left, h = s.right, c = s.top, l = s.bottom; if (t >= u && t <= h && n >= c && n <= l) { i = !1, a.handleClick(); break } } } catch (t) { o.e(t) } finally { o.f() } return i }, this.pano = t } var e = t.prototype; return e.handleAdd = function (t) { t && t.id && (this.overlays.some((function (e) { return e.id === t.id })) || (this.overlays.push(t), this.isReady && t.init(this.pano))) }, e.handleRemove = function (t) { for (var e = 0; e < this.overlays.length; e++)if (this.overlays[e].id === t.id) return this.overlays[e].remove(), void this.overlays.splice(e, 1) }, e.init = function () { this.isReady = !0; var t, e = Ko(this.overlays); try { for (e.s(); !(t = e.n()).done;) { t.value.init(this.pano) } } catch (t) { e.e(t) } finally { e.f() } }, e.draw = function () { if (this.isReady) { var t, e = Ko(this.overlays); try { for (e.s(); !(t = e.n()).done;) { t.value.draw() } } catch (t) { e.e(t) } finally { e.f() } } }, e.destroy = function () { var t, e = Ko(this.overlays); try { for (e.s(); !(t = e.n()).done;) { t.value.remove() } } catch (t) { e.e(t) } finally { e.f() } this.overlays = [] }, t }(); function $o(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return ta(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ta(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function ta(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var ea = function () { function t(t) { var e = this; this.renderer = void 0, this.gl = void 0, this.camera = void 0, this.cameraNoFix = null, this.panoData = null, this.scene = void 0, this.sceneChange = void 0, this.openingAni = void 0, this.sphereRender = void 0, this.linkGLRender = void 0, this.overlayManager = void 0, this.skyboxRender = void 0, this.pano = void 0, this.renderThreadId = null, this.requestId = null, this.isRAFRuning = !1, this.setData = function () { var t = nt(ot.mark((function t(n) { var r, o; return ot.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if (n) { t.next = 2; break } return t.abrupt("return"); case 2: if (!e.panoData || !e.pano.useAnimation) { t.next = 8; break } return e.sceneChange.setData(e.panoData, n), t.next = 6, e.sceneChange.sceneChangeHandler(); case 6: void 0 !== e.pano.backupUseAnimation && (e.pano.useAnimation = e.pano.backupUseAnimation), e.pano.animationType = ""; case 8: e.reset(), e.panoData = n, e.pano.panoData = n, void 0 === i(n.defaultHeading) && void 0 === i(n.defaultPitch) || e.pano.handlePovChange({ heading: n.defaultHeading, pitch: n.defaultPitch }), r = n.image && 6 === n.image.length, (o = r ? e.skyboxRender : e.sphereRender).setData(n), e.linkGLRender.setData(n), e.overlayManager.init(), e.scene.add(o.meshs), e.updateProjectionMatrix(e.camera), e.updateCameraHeadingAndPitch(e.camera); case 20: case "end": return t.stop() } }), t) }))); return function (e) { return t.apply(this, arguments) } }(), this.getSnapshot = function (t, n) { t = t || e.scene, n = n || e.camera; var r = e.pano.getContainerSize(), i = r.width, o = r.height, a = new Vi(i, o); return a.premultiplyAlpha = !0, e.renderer.render(t, n, a), a }, this.update = function () { e.panoData && (e.sphereRender.update(), e.linkGLRender.update(), e.startRenderThread()) }, this.onThumbLoaded = function () { e.sceneChange.changeAni && e.sceneChange.changeAni.start(); var t = e.linkGLRender.meshs; t && e.scene.add(t), e.startFishEyeAni() }, this.startRenderThread = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 100; e.renderThreadId && (clearTimeout(e.renderThreadId), e.renderThreadId = null), e.renderThreadId = window.setTimeout((function () { e.isRAFRuning = !1, e.renderThreadId = null }), t), e.isRAFRuning || (e.isRAFRuning = !0, e.renderFrame()) }, this.resize = function () { var t = e.pano.getContainer(); e.renderer.setSize(t.clientWidth, t.clientHeight) }; var n = window.devicePixelRatio || 1, r = t.getContainer(); this.pano = t, this.renderer = new Ui({ premultipliedAlpha: !1, preserveDrawingBuffer: t.opts.enableCapture || !1, antialias: !(n > 1), pixelRatio: n, width: r.clientWidth, height: r.clientHeight }), this.renderer.setSize(r.clientWidth, r.clientHeight), t.getPanes().tileLayer.appendChild(this.renderer.domElement), this.gl = this.renderer.getContext(), this.camera = new Ki(75, r.clientWidth / r.clientHeight, .01, 67e3), this.scene = new Qr, t.gl = this.gl, t.canvas = this.renderer.domElement, t.scene = this.scene, t.camera = this.camera, t.cameraNoFix = this.cameraNoFix, t.renderer = this.renderer, t.renders = [], this.sceneChange = new Yo(t, this.getSnapshot), this.initModule() } var e = t.prototype; return e.initModule = function () { var t = this.pano; this.sphereRender = new So(t), this.linkGLRender = new Bo(t), this.overlayManager = new Jo(t), this.skyboxRender = new eo(t), this.pano.renders.push(this.sphereRender, this.linkGLRender, this.overlayManager, this.skyboxRender) }, e.reset = function () { this.scene.remove(this.sphereRender.meshs), this.scene.remove(this.linkGLRender.meshs) }, e.getModule = function (t) { var e, n = null, r = $o(this.pano.renders); try { for (r.s(); !(e = r.n()).done;) { var i = e.value; if (i.name === t) { n = i; break } } } catch (t) { r.e(t) } finally { r.f() } return n }, e.renderFrame = function () { !1 !== this.isRAFRuning ? (this.openingAni && this.openingAni.update(), this.sphereRender.draw(), this.renderer.render(this.scene, this.camera), this.overlayManager.draw(), this.sceneChange.draw(), this.requestId = requestAnimationFrame(this.renderFrame.bind(this))) : this.requestId && (cancelAnimationFrame(this.requestId), this.requestId = null) }, e.startFishEyeAni = function () { var t = this; this.pano.fisheye && (this.openingAni = new Xo(this.pano, { handleEnd: function () { t.openingAni = null, t.pano.fisheye = !1 } }), setTimeout((function () { t.openingAni.start(), t.startRenderThread() }), p.FISHEYE_DELAY)) }, e.updateProjectionMatrix = function (t, e) { var n = this.pano.getFov(e), r = this.pano.getContainerSize(), i = r.width / r.height; t.fov = n, t.aspect = i, t.updateProjectionMatrix() }, e.updateCameraHeadingAndPitch = function (t) { var e = this.pano.getPov(), n = e.heading, r = e.pitch, i = this.panoData, o = i.fixHeading, a = void 0 === o ? 0 : o, s = i.fixPitch, u = void 0 === s ? 0 : s, h = i.fixRoll, c = void 0 === h ? 0 : h; t.rotateX(r - u), t.rotateY(-n + a), t.rotateZ(c), t.updateWorldMatrix() }, e.safeCall = function (t, e, n) { var r = this.getModule(t); if (r && r[e]) return r[e].apply(r, n || []); throw new Error("[safeCall] get module error => ".concat(t)) }, o(t, [{ key: "isCanUpdate", get: function () { var t = this.sceneChange.changeAni, e = this.openingAni; return this.panoData && !(t || e) } }]), t }(), na = function () { function t(t) { var e = this; this.updateAnglePerPixel = function () { e._anglePerPixel = e._pano.calcAnglePerPixel() }, this.destroy = function () { e.bindEvent(!1) }, this._pano = t, this._displayZoom = t.getZoom(), this._anglePerPixel = t.calcAnglePerPixel(), this._container = t.getContainer(), this.lock = !1, this.clickTimer = null, this.dragAni = null, this.state = { initPos: null, initHeading: 0, initPitch: 0, lastDiffPos: null, moveDiffPos: null, isTouchDown: !1, isTouchMove: !1, startTime: 0, lastMoveTime: 0 } } var e = t.prototype; return e.init = function () { if (!this._initialized) { if (this._initialized = !0, this.isMobile = navigator.userAgent.toLowerCase().match(/ipod|ipad|iphone|android/), this.isMobile) { this.EVENTS = { START: "touchstart", MOVING: "touchmove", END: "touchend", OUT: "touchcancel", WHEEL: "gesturechange", DOMMouseScroll: "DOMMouseScroll" }; var t = this._container.getBoundingClientRect ? this._container.getBoundingClientRect() : {}, e = t.left, n = void 0 === e ? 0 : e, r = t.top, i = void 0 === r ? 0 : r; this.getPagePosition = function (t) { var e = t.touches.length > 0 ? t.touches[0] : t.changedTouches[0]; return { x: e.pageX - n, y: e.pageY - i } } } else this.EVENTS = { START: "mousedown", MOVING: "mousemove", END: "mouseup", OUT: "mouseout", WHEEL: "mousewheel" }, this.getPagePosition = function (t) { return { x: t.offsetX, y: t.offsetY } }; this.bindEvent() } }, e.bindEvent = function () { var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e = document.body, n = this.EVENTS, r = n.START, i = n.MOVING, o = n.END, a = this._pano._svContainer, s = t ? "addEventListener" : "removeEventListener"; a[s](r, this.handleDown.bind(this)), a[s](i, this.handleMove.bind(this)), e[s](o, this.handleUp.bind(this)) }, e.handleDown = function (t) { this.dragAni && this.dragAni.stop(); var e = this.state, n = this.getPagePosition(t), r = this._pano.getPov(); e.initPos = n, e.isTouchDown = !0, e.initHeading = r.heading, e.initPitch = r.pitch, e.startTime = x(), this._pano.dispatchEvent(d.TOUCH_START, t) }, e.handleMove = function (t) { if (this.state.isTouchDown) { this.state.isTouchMove = !0; var e = this.calcDiffPos(this.state.initPos, this.getPagePosition(t)); this.setPov(e), this.state.moveDiffPos = e, this.state.lastDiffPos = e, this.state.lastMoveTime = x(), t.preventDefault(), t.stopPropagation() } }, e.handleUp = function (t) { var e = this; if (this.state.isTouchDown) { var n = !0, r = this.getPagePosition(t); if (t.pos = r, this.state.isTouchDown = !1, this._pano.dispatchEvent(d.TOUCH_END, t), this._pano.renders.length) for (var i = 0; i < this._pano.renders.length; i++) { var o = this._pano.renders[i]; if (o.clickChecker && !(n = o.clickChecker(r.x, r.y))) { t.stopPropagation(); break } } if (!1 !== n) if (this.state.isTouchMove) this.state.isTouchMove = !1, this.processMotion(t); else if (t.stopPropagation(), this.clickTimer) clearTimeout(this.clickTimer), this.clickTimer = null, this._pano.dispatchEvent(d.DOUBLE_CLICK, t); else { this.clickTimer = setTimeout((function () { e.clickTimer = null, e._pano.dispatchEvent(d.CLICK, t) }), 300) } } }, e.setPov = function (t) { var e = t.x, n = t.y, r = -e * this._anglePerPixel, i = n * this._anglePerPixel, o = this.state.initHeading + r, a = this.state.initPitch + i; this._pano.setPov({ heading: o, pitch: a }) }, e.processMotion = function (t) { var e = this, n = this.state, r = x(), i = r - n.lastMoveTime, o = n.moveDiffPos, a = o.x, s = o.y; if (i < 300 && (Math.abs(a) > 10 || Math.abs(s) > 10)) { var u = this.calcDiffPos(this.state.initPos, this.getPagePosition(t)), h = 2 * Math.sqrt(Math.pow(u.x, 2) + Math.pow(u.y, 2)) / (.008 * (r - n.startTime)), c = [u.x > 0 ? 1 : -1, u.y > 0 ? 1 : -1], l = Math.abs(u.x), f = Math.abs(u.y), p = Math.atan2(f, l), v = Math.cos(p) * h, m = Math.sin(p) * h; -1 === c[0] && (v = -v), -1 === c[1] && (m = -m), this.dragAni && this.dragAni.stop(); var g = this._pano.getPov(), y = g.heading, _ = g.pitch; n.initHeading = y, n.initPitch = _; this.dragAni = new ho(0, 1, 400, (function (t) { return .3125 * t - .15625 * t * t })).onUpdate((function (t) { var n = (t *= 6.4) * v, r = t * m; e.setPov({ x: n, y: r }) })).onEnd((function () { e.dragAni = null, e._pano.dispatchEvent({ type: d.POV_CHANGED_END }) })).startAndAutoUpdate() } else this._pano.dispatchEvent({ type: d.POV_CHANGED_END }) }, e.calcDiffPos = function (t, e) { return t && e ? { x: e.x - t.x, y: e.y - t.y } : { x: 0, y: 0 } }, t }(); function ra(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = function (t, e) { if (!t) return; if ("string" == typeof t) return ia(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); "Object" === n && t.constructor && (n = t.constructor.name); if ("Map" === n || "Set" === n) return Array.from(t); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ia(t, e) }(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function ia(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var oa = function () { function t(t) { this.pano = t, this.preZoom = t.getZoom(), this.zoomChangeAni = null, this.debug = !1, this.panoServiceLock = !1, this.bindEvent(), this.initModule(), this.initResize(), this.handleContextStatus() } var e = t.prototype; return e.initModule = function () { var t = this.pano; this.panoService = new tt(t), this.panoGLRender = new ea(t), this.op = new na(t) }, e.initResize = function () { var t = this, e = this.pano.getContainerSize(), n = this.pano.getContainer(), r = function (n, r) { if (n && r) { var i = new l(n, r); i.equals(e) || (t.pano.dispatchEvent({ type: d.SIZE_CHANGED }), e = i) } }; if (void 0 !== window.ResizeObserver) { var i = new window.ResizeObserver((function (t) { var e, n = ra(t); try { for (n.s(); !(e = n.n()).done;) { var i = e.value.target; r(i.clientWidth, i.clientHeight) } } catch (t) { n.e(t) } finally { n.f() } })); i.observe(n), this.resizeOb = i } else this.checkSizeTimer = setInterval((function () { r(n.clientWidth, n.clientHeight) }), 80) }, e.bindEvent = function () { var t = this, e = this.pano; e.on(d.PANO_ERROR, (function () { t.panoServiceLock = !1 })), e.on(d.DATA_LOADED, (function (n) { t.pano.opts.visible ? t.pano.show() : t.pano.hide(), t.panoServiceLock = !1, n.options && n.options.animation && (e.backupUseAnimation = e.useAnimation, e.useAnimation = n.options.animation, "" !== n.options.animationType && (e.animationType = n.options.animationType)), t.panoGLRender.setData(n.data), t.op.init() })), e.on(d.SET_POV, (function (n) { var r = n.pov, i = n.options, o = (void 0 === i ? { animation: !0 } : i).animation; if (t.panoGLRender.isCanUpdate) { var a = function (n) { e.handlePovChange(n) && (t.panoGLRender.updateCameraHeadingAndPitch(e.camera), t.panoGLRender.update(), e.dispatchEvent(d.POV_CHANGED, n)) }; if (o) { var s = e.getPov(), u = s.heading, h = s.pitch, c = r.heading - u, l = r.pitch - h; c > 180 ? (u += 360, c = r.heading - u) : c < -180 && (u -= 360, c = r.heading - u), new ho(0, 1, 400, so["ease-out"]).onUpdate((function (t) { a({ heading: u + t * c, pitch: h + t * l }) })).onEnd((function () { })).startAndAutoUpdate() } else a(r) } else e.handlePovChange(r) })), e.on(d.ZOOM_CHANGED, (function () { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (t.panoGLRender.isCanUpdate) { var r = t.preZoom, i = e.getZoom(); if (r !== i) { var o = n.noAnimation || !1; if (t.zoomChangeAni && (t.zoomChangeAni.stop(), t.zoomChangeAni = null), o) return t.op.updateAnglePerPixel(), t.panoGLRender.updateProjectionMatrix(e.camera), t.panoGLRender.update(), void (t.preZoom = i); var a = 400; t.zoomChangeAni = new ho(r, i, a, so.easeOutCubic).onUpdate((function (n) { t.panoGLRender.updateProjectionMatrix(e.camera, n), t.panoGLRender.update(n) })).onEnd((function () { t.zoomChangeAni = null, t.preZoom = i })).startAndAutoUpdate() } } })), e.on(d.DOUBLE_CLICK, (function () { t.panoGLRender.isCanUpdate && (v.isMobile && (3 === e.getZoom() ? e.setZoom(2) : e.setZoom(3))) })), e.on(d.REFRESH, (function (e) { var n = e.duration || 200; t.panoGLRender.startRenderThread(n), t.debug && e.log && e.debug && console.warn(e.log) })), e.on(d.SET_ID, (function (e) { if (!t.panoServiceLock && e.id) { t.panoServiceLock = !0, window.getPanoById = t.panoService.getPanoById; var n = (1e5 * Math.random()).toFixed(0); BMapGL._rd = BMapGL._rd || {}, BMapGL._rd["_cbk" + n] = function (t) { t && void 0 !== t.error && 0 === t.error ? window.getPanoById(e.id) : Q("PANORAMA"), delete BMapGL._rd["_cbk" + n] }, K("PANORAMA", "BMapGL._rd._cbk" + n) } })), e.on(d.SET_POSITION, (function (e) { if (!t.panoServiceLock && e.point) { t.panoServiceLock = !0, window.getPanoByLocation = t.panoService.getPanoByLocation; var n = (1e5 * Math.random()).toFixed(0); BMapGL._rd = BMapGL._rd || {}, BMapGL._rd["_cbk" + n] = function (t) { t && void 0 !== t.error && 0 === t.error ? window.getPanoByLocation(e.point) : Q("PANORAMA"), delete BMapGL._rd["_cbk" + n] }, K("PANORAMA", "BMapGL._rd._cbk" + n) } })), e.on(d.SIZE_CHANGED, (function () { t.op.updateAnglePerPixel(), t.panoGLRender.resize(), t.panoGLRender.updateProjectionMatrix(e.camera), t.panoGLRender.update() })), e.on(d.THUMB_LOADED, (function () { t.panoGLRender.onThumbLoaded(), t.panoGLRender.update() })), e.on(d.OVERLAY_ADD, (function (e) { t.panoGLRender.overlayManager.handleAdd(e) })), e.on(d.OVERLAY_REMOVE, (function (e) { t.panoGLRender.overlayManager.handleRemove(e) })), e.on(d.OVERLAYS_CLEAR, (function () { t.panoGLRender.overlayManager.destroy() })), e.on(d.LINK_VISIBLE_CHANGE, (function (e) { "boolean" == typeof e.value && (t.panoGLRender.safeCall("PanoLinkRender", "setVisible", [e.value]), t.pano.dispatchEvent(d.REFRESH)) })), e.on(d.DESTROY, (function () { t.op.destroy(), t.resizeOb && t.resizeOb.disconnect(), t.checkSizeTimer && clearInterval(t.checkSizeTimer), t.panoGLRender.renderer.forceContextLoss(), e.canvas.removeEventListener("webglcontextlost", t.onWebGLContextLost, !1) })); var n = v.isFirefox ? "DOMMouseScroll" : "mousewheel", r = new Date; e._svContainer.addEventListener(n, (function (t) { if (e.opts.enableScrollWheelZoom && e.opts.visible) { var n = new Date; if (n - r < 400) return; r = n; var i = -t.detail / 3 || t.wheelDelta / 120, o = e.getZoom() + i; e.setZoom(o), t.preventDefault() } })) }, e.getImgZoom = function () { return this.pano.calcDisplayZoom().imgZoom }, e.handleContextStatus = function () { this.pano.canvas.addEventListener("webglcontextlost", this.onWebGLContextLost, !1) }, e.onWebGLContextLost = function (t) { t.preventDefault(), setTimeout((function () { window.location.reload() }), 200) }, t }(); function aa(t, e, n) { t.addEventListener(e, n, !1) } var sa = function (t) { function e(e, n) { var r; (r = t.call(this) || this).panoData = null, r.opts = void 0, r.useAnimation = !1, r.backupUseAnimation = r.useAnimation, r.animationType = "", r.fisheye = !1, r.canvas = void 0, r.camera = void 0, r.renderer = void 0, r.gl = void 0, r.scene = void 0, r.cameraNoFix = void 0, r.renders = void 0, r.closeBtn = null, r.navigator = null, r._container = void 0, r._pov = { heading: 0, pitch: 0 }, r._id = null, r._position = null, r._zoom = 2, r._displayZoomResultsCache = {}, r._svContainer = void 0, r._eventManager = void 0, r._panes = void 0, r.addCloseButton = function (t) { var e = r.closeBtn = document.createElement("div"); e.className = "pano_close", e.style.cssText = ["position:absolute", "right:10px", "top:10px", "padding: 5px 8px;", "cursor:pointer", "border-radius: 4px", "font-size: 14px", "background-color: rgba(0,0,0,.55)", "z-index: 99", "color: #fff"].join(";"), e.innerText = "关闭", e.title = "退出全景", e.onclick = function () { r.hide(), t && t() }, r._svContainer.appendChild(e) }, r.getContainer = function () { return r._container }, r.getContainerSize = function () { var t = r._container; return new l(t.clientWidth, t.clientHeight) }, r.getPanes = function () { return r._panes }, r.show = function () { r.opts.visible = !0, w.show(r._svContainer) }, r.hide = function () { r.opts.visible = !1, w.hide(r._svContainer) }, r.getZoom = function () { return r._zoom }, r.setZoom = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; t !== r._zoom && (t > p.MAX_ZOOM && (t = p.MAX_ZOOM), t < p.MIN_ZOOM && (t = p.MIN_ZOOM), t !== r._zoom && (r._zoom = t, r.dispatchEvent(d.ZOOM_CHANGED, { noAnimation: e.noAnimation || !1 }))) }, r.getPov = function () { return r._pov }, r.setPov = function (t, e) { r.dispatchEvent(d.SET_POV, { pov: t, options: e || { animation: !1 } }) }, r.handlePovChange = function (t) { if ("object" === i(t)) { var e = !1, n = t.heading, o = t.pitch; if ("number" != typeof n || isNaN(n) || (e = !0, n = _(n), r._pov.heading = n), "number" == typeof o && !isNaN(n)) { e = !0; var a = r.opts.minPitch, s = r.opts.maxPitch; o > s && (o = s), o < a && (o = a), r._pov.pitch = o } return e } }, r.calcDisplayZoom = function (t, e) { t = t || r.getContainerSize(), e = e || r.getZoom(); var n = t, i = n.width, o = n.height, a = r.opts.maxImageZoom, s = r.opts.minImageZoom, u = "".concat(i, "_").concat(o, "_").concat(e); if (r._displayZoomResultsCache[u]) return r._displayZoomResultsCache[u]; for (var h = r.calcAnglePerPixel(), c = Math.floor(e) + 2, l = 360 / (2 * Math.pow(2, c - 2) * h); l > 512;)c++, l = 360 / (2 * Math.pow(2, c - 2) * h); if (c > a) { var f = c - a; l *= Math.pow(2, f), c = a } c < s && (c = s); var d = { imgZoom: c, displayTileSize: l = Math.round(l) }; return r._displayZoomResultsCache[u] = d, d }, r.calcAnglePerPixel = function () { return r.getFov() / r.getContainerSize().height }, r.getFov = function (t) { return t = t || r.getZoom(), (v.isMobile ? r.calcMobileFovy : r.calcPCFovy).call(a(r), t) }, r.getVisible = function () { return r.opts.visible }, r.setId = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; r.useAnimation = e.animation || !1, r.fisheye = e.fisheye || !1, r.animationType = e.animationType || "", r.dispatchEvent(d.SET_ID, { id: t }) }, r.setPosition = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; r.useAnimation = e.animation || !1, r.fisheye = e.fisheye || !1, r.animationType = e.animationType || "", r.dispatchEvent(d.SET_POSITION, { point: t }) }; var o = { minImageZoom: p.TILE_MIN_ZOOM, maxImageZoom: p.TILE_MAX_ZOOM, minPitch: p.MIN_PITCH, maxPitch: p.MAX_PITCH, radius: p.RADIUS, tileBaseUrls: p.TILE_BASE_URLS, linksControl: !0, navigationControl: !0, enableScrollWheelZoom: !0, enableCapture: !1, visible: !0 }; r.opts = Object.assign({}, o, n); var s = "string" == typeof e ? document.querySelector(e) : e; if (!s) throw new Error("全景引擎宿主容器不存在"); return r._container = s, r._init(), r } c(e, t); var n = e.prototype; return n.getPosition = function () { return this.position }, n.setOptions = function (t) { var e; for (e in t) if (Object.prototype.hasOwnProperty.call(t, e)) { var n = !0; if ("object" !== i(t[e]) && (n = t[e] !== this.opts[e]), this.opts[e] = t[e], !n) continue; switch (e) { case "linksControl": this.dispatchEvent(d.LINK_VISIBLE_CHANGE, { value: t[e] }); break; case "navigationControl": var r = !!t[e], o = this.navigator; r ? o.show() : o.hide() } } }, n.capture = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (this.canvas) { var e = this.canvas, n = t.quality || .8, r = t.type || "image/jpeg", i = e.toDataURL(r, n); return i } }, n.addOverlay = function (t) { this.dispatchEvent(d.OVERLAY_ADD, t) }, n.removeOverlay = function (t) { this.dispatchEvent(d.OVERLAY_REMOVE, t) }, n.clearOverlays = function () { this.dispatchEvent(d.OVERLAYS_CLEAR) }, n.destroy = function () { this.dispatchEvent(d.DESTROY) }, n._init = function () { this._createDoms(), this.navigator = function (t) { function e(t) { this._initialize(t) } return m(e.prototype, { _initialize: function (t) { this._pano = t, this.imgPath = t.opts.imgPath || "//api0.map.bdimg.com/images/", this._zoomInEnabled = !0, this._zoomOutEnabled = !0, this._render(), this._bind() }, _render: function () { this._container = w.create("div"); var t = this._container.style; t.position = "absolute", t.left = "10px", t.top = "10px", t.zIndex = 99; var e = this._container; e.innerHTML = this._generateHtml(), v.isPc ? (this._panBtnContainer = e.children[2], this._panBtns = [this._panBtnContainer.children[0], this._panBtnContainer.children[1], this._panBtnContainer.children[2], this._panBtnContainer.children[3]], this._svgDirGroup = e.children[1].childNodes[0], this._zoomContainer = e.children[3]) : v.isMobile && (this._zoomContainer = e.children[0]), this._btnZoomIn = this._zoomContainer.children[0], this._btnZoomOut = this._zoomContainer.children[1], v.isMobile && (this._zoomContainer.style.left = this._zoomContainer.style.top = "0", this._zoomContainer.style.width = "36px", this._zoomContainer.style.height = "78px", this._btnZoomIn.style.width = this._btnZoomOut.style.width = "33px", this._btnZoomIn.style.height = this._btnZoomOut.style.height = "36px", this._btnZoomOut.style.top = "37.5px"), this._pano.getZoom() >= p.MAX_ZOOM && this._setZoomBtnEnabled("zoomIn", !1), this._pano.getZoom() <= p.MIN_ZOOM && this._setZoomBtnEnabled("zoomOut", !1), this._pano._svContainer.appendChild(e) }, _generateHtml: function () { var t = []; return v.isPc && (t.push(this._generatePanHtml()), t.push(this._generateDirHtml()), t.push(this._generatePanBtnHtml())), t.push(this._generateZoomContainerHtml()), t.join("") }, _generateDirHtml: function () { return '<svg version="1.1" overflow="hidden" width="82px" height="82px" viewBox="0 0 82 82"style="position: absolute; top: 0px; left: 0px;"><g transform="rotate(0, 41, 41)"><rect x="33"y="1" width="14" height="12" rx="4" ry="4" stroke="#868685" stroke-width="1" fill="#f8f8f8"></rect><polyline points="37.5,9.5 37.5,3.5 42.5,9.5 42.5,3.5" stroke-linejoin="bevel" stroke-width="1.5" fill="#f2f4f6" stroke="#868685"></polyline></g></svg>' }, _generatePanHtml: function () { return '<div style="position:absolute;top:4px;left:4px;width:74px;height:74px;background:url(' + this.imgPath + 'st-navictrl.png) no-repeat;-webkit-user-select:none;overflow:hidden"><div></div></div>' }, _generatePanBtnHtml: function () { return '<div style="position:absolute;top:0px;left:0;width:82px;height:82px;user-select:none;"><div style="position:absolute;left:32px;top:13px;cursor:pointer;width:17px;height:17px;" title="向上平移"></div><div style="position:absolute;left:14px;top:32px;cursor:pointer;width:17px;height:17px;" title="向左平移"></div><div style="position:absolute;left:51px;top:32px;cursor:pointer;width:17px;height:17px;" title="向右平移"></div><div style="position:absolute;left:33px;top:51px;cursor:pointer;width:17px;height:17px;" title="向下平移"></div></div>' }, _generateZoomContainerHtml: function () { var t = "background-image:url('" + this.imgPath + "st-navictrl.png');background-repeat:no-repeat;background-position:-74px 0;"; return v.isMobile && (t = "background-image:url('" + this.imgPath + "st-navictrl-hd.png');background-repeat:no-repeat;background-position:0 0;background-size:180px 78px;"), '<div style="position:absolute;top:84px;left:30px;width:24px;height:52px;' + t + '-webkit-user-select:none;overflow:hidden"><div style="position:absolute;cursor:pointer;width:22px;height:24px;top:0;left:0;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)" title="放大一级"></div><div style="position:absolute;cursor:pointer;width:22px;height:24px;top:25px;left:0;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)" title="缩小一级"></div><div></div></div>' }, _bind: function () { var t = this._pano, e = this; if (v.isPc) { aa(this._panBtns[0], "click", (function () { var e = t.getPov(); t.setPov({ heading: e.heading, pitch: e.pitch + 30 }, { animation: !0 }) })), aa(this._panBtns[1], "click", (function () { var e = t.getPov(); t.setPov({ heading: e.heading - 45, pitch: e.pitch }, { animation: !0 }) })), aa(this._panBtns[2], "click", (function () { var e = t.getPov(); t.setPov({ heading: e.heading + 45, pitch: e.pitch }, { animation: !0 }) })), aa(this._panBtns[3], "click", (function () { var e = t.getPov(); t.setPov({ heading: e.heading, pitch: e.pitch - 30 }, { animation: !0 }) })); for (var n = 0; n < this._panBtns.length; n++)aa(this._panBtns[n], "mousedown", (function (t) { t.stopPropagation() })); e._mousedown = !1, aa(this._panBtnContainer, "mousedown", (function (n) { e._mousedown = !0, e._panBtnContainer.style.cursor = "grabbing", e._startHeading = e._calcAngle(n), e._curHeading = t.getPov().heading, n.preventDefault() })), aa(document, "mousemove", (function (n) { e._mousedown && t.setPov({ heading: e._curHeading + 360 - (e._calcAngle(n) - e._startHeading), pitch: t.getPov().pitch }) })), aa(document, "mouseup", (function () { e._mousedown && (e._mousedown = !1, e._panBtnContainer.style.cursor = "grab", e._startHeading = null) })), t.addEventListener("position_changed", (function () { var t = 360 - this.getPov().heading; e._svgDirGroup.setAttribute("transform", "rotate(" + t + ", 41, 41)") })), t.addEventListener("pov_changed", (function () { var t = 360 - this.getPov().heading; e._svgDirGroup.setAttribute("transform", "rotate(" + t + ", 41, 41)") })) } aa(this._btnZoomIn, "click", (function () { t.setZoom(t.getZoom() + 1) })), aa(this._btnZoomOut, "click", (function () { t.setZoom(t.getZoom() - 1) })), v.isPc ? (aa(this._btnZoomIn, "mousedown", (function () { e._redrawZoomBtn(e._zoomInEnabled, -98) })), aa(this._btnZoomOut, "mousedown", (function () { e._redrawZoomBtn(e._zoomOutEnabled, -122) })), aa(this._btnZoomIn, "mouseup", (function () { e._redrawZoomBtn(e._zoomInEnabled, -74) })), aa(this._btnZoomOut, "mouseup", (function () { e._redrawZoomBtn(e._zoomOutEnabled, -74) }))) : v.isMobile && (aa(this._btnZoomIn, "touchstart", (function () { e._redrawZoomBtn(e._zoomInEnabled, -98) })), aa(this._btnZoomOut, "touchstart", (function () { e._redrawZoomBtn(e._zoomOutEnabled, -122) })), aa(this._btnZoomIn, "touchend", (function () { e._redrawZoomBtn(e._zoomInEnabled, -74) })), aa(this._btnZoomOut, "touchend", (function () { e._redrawZoomBtn(e._zoomOutEnabled, -74) }))), t.addEventListener("zoom_changed", (function (n) { t.getZoom() >= p.MAX_ZOOM ? e._setZoomBtnEnabled("zoomIn", !1) : t.getZoom() <= p.MIN_ZOOM ? e._setZoomBtnEnabled("zoomOut", !1) : (e._setZoomBtnEnabled("zoomIn", !0), e._setZoomBtnEnabled("zoomOut", !0)) })) }, _redrawZoomBtn: function (t, e) { t && (v.isMobile && (e = (e + 74) / 24 * 36), this._zoomContainer.style.backgroundPosition = e + "px 0") }, show: function () { this._container.style.display = "" }, hide: function () { this._container.style.display = "none" }, _calcAngle: function (t) { var e = (t = window.event || t).pageX || t.clientX, n = t.pageY || t.clientY, r = this._pano.getContainer().getBoundingClientRect(); e = e - r.left - 50, n = -(n - r.top - 50); var i = Math.atan2(n, e) / Math.PI * 180; return i < 90 ? 90 - i : 450 - i }, _setZoomBtnEnabled: function (t, e) { if ("zoomIn" === t) if (e) { this._zoomInEnabled = !0, this._btnZoomIn.style.cursor = "pointer"; var n = -74; v.isMobile && (n = 0), this._zoomContainer.style.backgroundPosition = n + "px 0" } else { this._zoomInEnabled = !1, this._btnZoomIn.style.cursor = ""; var r = -170; v.isMobile && (r = -144), this._zoomContainer.style.backgroundPosition = r + "px 0" } if ("zoomOut" === t) if (e) { this._zoomOutEnabled = !0, this._btnZoomOut.style.cursor = "pointer"; var i = -74; v.isMobile && (i = 0), this._zoomContainer.style.backgroundPosition = i + "px 0" } else { this._zoomOutEnabled = !1, this._btnZoomOut.style.cursor = ""; var o = -146; v.isMobile && (o = -108), this._zoomContainer.style.backgroundPosition = o + "px 0" } } }), new e(t) }(this), this._eventManager = new oa(this) }, n._createDoms = function () { var t = this._container, e = w.create("div"), n = e.style; n.overflow = "hidden", n.position = "absolute", n.zIndex = "20", n.top = n.left = "0px", n.height = n.width = "100%", n.backgroundColor = "#e5e3df", n.display = "none", n.cursor = "grab", e.addEventListener("mousedown", (function () { return n.cursor = "grabbing" })), e.addEventListener("mouseup", (function () { return n.cursor = "grab" })), this._svContainer = e, this._panes = { tileLayer: this._createContainer("1"), maskLayer: this._createContainer("2"), linksLayer: this._createContainer("3"), overlayLayer: this._createContainer("4"), effectLayer: this._createContainer("5") }, e.appendChild(this._panes.tileLayer), e.appendChild(this._panes.linksLayer), e.appendChild(this._panes.overlayLayer), e.appendChild(this._panes.effectLayer), b() || (e.appendChild(this._panes.maskLayer), this._panes.maskLayer.style.width = "".concat(t.clientWidth, "px"), this._panes.maskLayer.style.height = "".concat(t.clientHeight, "px"), this._panes.maskLayer.style.overflow = "hidden"), t.appendChild(e), "absolute" !== w.getCurrentStyle(t).position && (t.style.position = "relative") }, n._createContainer = function (t) { var e = w.create("div"), n = e.style; return n.position = "absolute", n.top = n.left = "0", n.zIndex = t || "0", e }, n.calcMobileFovy = function (t) { var e = this.getContainerSize(), n = e.width, r = e.height, i = 240 / Math.pow(2, t), o = n / 2 / Math.tan(g(i / 2)), a = Math.atan2(r / 2, o); return 2 * y(a) }, n.calcPCFovy = function (t) { return 90 - 15 * (t - 1) }, o(e, [{ key: "imageZoom", get: function () { return this.calcDisplayZoom().imgZoom } }, { key: "panoId", get: function () { return this.panoData ? this.panoData.panoId : "" } }, { key: "panoNorthDir", get: function () { return this.panoData ? this.panoData.northDir : 0 } }, { key: "position", get: function () { return this.panoData && "number" == typeof this.panoData.panoX && "number" == typeof this.panoData.panoY ? new f(this.panoData.panoX, this.panoData.panoY) : null } }]), e }(Or), ua = { dom: null, anchor: null, width: null, height: null, altitude: 2, sphereZ: null, useUV: !1 }, ha = function (t) { function e(e) { var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return (n = t.call(this) || this).visible = !0, n.worldCoord = void 0, n.pov = void 0, n.id = n.genId(), n._pano = void 0, n.lastPanoPosition = null, n.initialized = !1, n.position = void 0, n.options = void 0, n.position = e, n.options = Object.assign({}, ua, r), n.pov = null, n } c(e, t); var n = e.prototype; return n.getPov = function () { return this.pov }, n.genId = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 4; return Number("".concat(Math.random().toString().substr(3, t)).concat(Date.now())).toString(36) }, n.init = function (t) { t && !this.initialized && (this._pano = t, this.lastPanoPosition = this._pano.position, this.worldCoord = this.options.useUV ? this.calcCoordsByUV() : this.calcCoordsByMC(), this.worldCoord && (this.initialized = !0, this.add(), this.draw())) }, n.calcCoordsByMC = function () { var t = this._pano.position; if (t && this.position) { var e, n = this.position, r = n.lng - t.lng, i = n.lat - t.lat, o = Math.atan2(r, i); o < 0 && (o += 2 * Math.PI), o = Math.round(y(o)); var a = 500, s = this.options, u = s.sphereZ, h = s.altitude; null === u ? e = 25 * h : (e = u || 0, a = Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2) + Math.pow(e, 2))); var c = y(Math.asin(e / a)); c = c > 90 ? 90 : c < -90 ? -90 : c; var l = _(o + this._pano.panoNorthDir), f = this.radius, d = Math.cos(g(c)) * f; d = Math.round(100 * d) / 100; var p = Math.cos(g(l)) * d, v = Math.sin(g(c)) * f, m = Math.sin(g(l)) * d; return this.pov = { heading: o, pitch: c }, Vt(p, v, m) } }, n.calcCoordsByUV = function () { if (this.position) { var t = this.radius, e = this.position, n = xi(e, 2), r = n[0], i = n[1], o = 2 * r * Math.PI, a = (i - .5) * Math.PI, s = Math.cos(a) * Math.cos(o) * t, u = Math.sin(a) * t, h = Math.cos(a) * Math.sin(o) * t; return this.pov = { heading: _(y(o) - this._pano.panoNorthDir), pitch: y(a) }, Vt(s, u, h) } }, n.add = function () { var t = this.options, e = t.width, n = t.height; if (this.dom) { var r = this._pano, i = this.dom; i.style.position = "absolute", r.getPanes().overlayLayer.appendChild(i), "number" != typeof e && (this.options.width = i.clientWidth), "number" != typeof n && (this.options.height = i.clientHeight), r.dispatchEvent({ type: "onoverlaydomadded", overlay: this }) } }, n.remove = function () { var t = this.dom; t && t.parentNode && t.parentNode.removeChild(t) }, n.povToPointGL = function () { if (!this.worldCoord) return null; var t = this._pano, e = t.camera, n = t.getContainerSize(), r = n.width, i = n.height; return po(e, this.worldCoord, r, i) }, n.draw = function () { if (this.initialized && this.visible && this._pano && this._pano.panoData && this.dom) { var t = this.lastPanoPosition, e = this._pano.position; t.lng === e.lng && t.lat === e.lat || (this.lastPanoPosition = e, this.worldCoord = this.options.useUV ? this.calcCoordsByUV() : this.calcCoordsByMC()); var n = this.dom, r = this.povToPointGL(); if (n.style.visibility = "hidden", r) { var i = this.calcAnchor(), o = "".concat(r[0] - i.width, "px"), a = "".concat(r[1] - i.height, "px"); if (isNaN(r[0]) || isNaN(r[1])) return; n.style.visibility = "visible", n.style.webkitTransform = "translate(".concat(o, ", ").concat(a, ")"), n.style.transform = "translate(".concat(o, ", ").concat(a, ")") } } }, n.handleClick = function () { this.dispatchEvent("click") }, n.calcAnchor = function () { var t = this.options, e = t.anchor, n = t.width, r = void 0 === n ? 0 : n, i = t.height; return e || new l(r / 2, (void 0 === i ? 0 : i) / 2) }, n.show = function () { this.visible = !0, this.dom && (this.dom.style.display = "") }, n.hide = function () { this.visible = !1, this.dom && (this.dom.style.display = "none") }, o(e, [{ key: "radius", get: function () { return this._pano ? this._pano.opts.radius : 0 } }, { key: "dom", get: function () { return this.options.dom } }]), e }(Or), ca = function (t) { function e(e, n) { var r = n.position, i = n.altitude, o = void 0 === i ? 2 : i, a = n.costomStyle, s = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = document.createElement("div"), r = { backgroundColor: "rgba(29, 29, 29, 0.8)", fontSize: "14px", padding: "7px 14px", height: "19px", color: "#fff", whiteSpace: "nowrap", borderRadius: "4px" }; return m(n.style, r, e), n.innerText = t, n }(e, void 0 === a ? {} : a); return t.call(this, r, { dom: s, altitude: o }) || this } return c(e, t), e }(ha); t.Converters = mo, t.Engines = Qi, t.EventType = d, t.PanoLabel = ca, t.PanoOverlay = ha, t.PanoramaService = function () { var t = this; this.getPanoById = function (e, n) { var r; r = "".concat(tt.SERVICE_URL, "?qt=sdata&sid=").concat(e, "&").concat($("/")), t.request(r).then((function (t) { n && n(t) })).catch((function (t) { n && n(null) })) }, this.getPanoByLocation = function (e, n, r) { var i; i = "".concat(tt.SERVICE_URL, "?qt=qsdata&x=").concat(e.lng, "&y=").concat(e.lat).concat(n ? "&r=" + n : "", "&action=1&").concat($("/")), t.request(i).then((function (t) { r && r(t) })).catch((function (t) { r && r(null) })) }, this.request = function (t) { return T(t, {}, { jsonp: "fn" }) } }, t.Point = f, t.getPanoControl = function (t, e) { var n, r, i, o = (e = e || {}).imgPath || "//api.map.baidu.com/images/"; function a(e) { e.call(this), this.defaultAnchor = t.ControlAnchor.TOP_RIGHT, this.defaultOffset = new t.Size(10, 10), this._isOn = !1 } return n = a, r = t.Control, (i = Object.create(r.prototype)).constructor = n, n.prototype = i, m(a.prototype, { initialize: function (t) { return this._map = t, this._render(), this._bind(), this._container }, _render: function () { var t = this, n = w.create("div"); n.innerHTML = '<span style="position:relative;top:33px;">全景</span>', n.title = "进入全景", m(n.style, { width: "49px", height: "51px", color: "#565656", background: 'url("'.concat(o, 'st-control.png")'), position: "absolute", cursor: "pointer", fontFamily: "arial,sans-serif", fontSize: "13px", textAlign: "center", boxShadow: "0px 0px 3px rgba(0, 0, 0, 0.3)", MozBoxShadow: "0px 0px 3px rgba(0, 0, 0, 0.3)", WebkitBoxShadow: "0px 0px 3px rgba(0, 0, 0, 0.3)" }), this._container = n; var r = this._map.getContainer(); r.appendChild(n); var i = { visible: !1 }; e.imgPath && (i.imgPath = [e.imgPath]), e.tileBaseUrl && (i.tileBaseUrls = [e.tileBaseUrl]), this._pano = new sa(r, i), this._pano.addCloseButton((function () { t.isMapEnableWheelZoom && t._map.enableScrollWheelZoom() })); var a = this._scout = w.create("div"); m(a.style, { position: "absolute", width: "24px", height: "41px", cursor: "pointer", backgroundImage: 'url("'.concat(o, 'st-scout.png")'), backgroundRepeat: "no-repeat", backgroundPosition: "-24px 0", overflow: "hidden", display: "none", zIndex: 11 }), r.appendChild(a); var s = this._infoWindow = w.create("div"); m(s.style, { position: "absolute", width: "112px", height: "119px", backgroundImage: 'url("'.concat(o, 'st-infowindow.gif")'), backgroundRepeat: "no-repeat", backgroundPosition: "0 0", display: "none", cursor: "pointer", zIndex: 12 }); var u = this._thumb = w.create("img"); s.appendChild(u), u.src = o + "st-noresult.png", m(u.style, { width: "100px", height: "75px", left: "6px", top: "6px", position: "absolute" }); var h = this._stDescription = w.create("div"); m(h.style, { position: "absolute", top: "85px", fontFamily: "arial,sans-serif", fontSize: "13px", paddingLeft: "6px" }), s.appendChild(h), r.appendChild(s) }, _updateView: function () { var t = this._container.style; this._isOn || this._isOver ? (t.backgroundPosition = "-49px 0", t.color = "#fff") : (t.backgroundPosition = "0 0", t.color = "#565656") }, _bind: function () { var n = this; this._pano.on("dataload", (function (t) { var r = t.data; r ? (n._currentSvId = r.panoId, e.tileBaseUrl ? n._thumb.src = "".concat(e.tileBaseUrl, "?&sid=").concat(r.panoId, "&pos=0_0&z=0") : n._thumb.src = "//apisv0.bdimg.com/?qt=pdata&sid=".concat(r.panoId, "&pos=0_0&z=0&from=H5&").concat($("/")), n._stDescription.innerHTML = r.roadName) : (n._currentSvId = null, n._thumb.src = o + "st-noresult.png", n._stDescription.innerHTML = "") })); var r = this; v.isPc && (this._container.addEventListener("mouseover", (function () { r._isOver = !0, r._updateView() })), this._container.addEventListener("mouseout", (function () { r._isOver = !1, r._updateView() }))), this._container.addEventListener("click", (function () { r._isOn ? r._close() : r._open() })), this._map.getContainer().addEventListener("mousemove", (function (e) { if (r._isOn) { var n = (e = window.event || e).pageX || e.clientX, i = e.pageY || e.clientY, a = function (t) { for (var e = { left: 0, top: 0 }; t && t.offsetParent;)e.left += t.offsetLeft, e.top += t.offsetTop, t = t.offsetParent; return e }(r._map.container), s = new qo(n - a.left, i - a.top), u = r._map.pixelToPoint(s); if ("" !== r._scout.style.display && v.isPc && (r._scout.style.display = "", r._infoWindow.style.display = ""), r._scout.style.left = s.x - 12 + "px", r._scout.style.top = s.y - 41 - 2 + "px", r._prePixel = r._curPixel, r._curPixel = s, r._prePixel) { var h = s.x - r._prePixel.x; h > 0 ? r._scout.style.backgroundPosition = "-48px 0" : h < 0 && (r._scout.style.backgroundPosition = "0 0") } r._curPixel.y < 170 ? r._infoStatus = 2 : r._infoStatus = 1, r._curPixel.x < 66 && (r._infoStatus = 3), r._curPixel.x > r._map.getSize().width - 56 - 10 && (r._infoStatus = 4); var c = 1 === r._infoStatus || 2 === r._infoStatus ? 112 : 126, l = 1 === r._infoStatus || 2 === r._infoStatus ? 119 : 105; 1 !== r._infoStatus && 2 !== r._infoStatus || (r._infoWindow.style.left = r._curPixel.x - Math.round(c / 2) + "px", 1 === r._infoStatus ? (r._infoWindow.style.top = r._curPixel.y - l - 42 + "px", r._infoWindow.style.backgroundPosition = "0 0", r._thumb.style.top = "6px", r._thumb.style.bottom = "", r._stDescription.style.top = "85px", r._stDescription.style.bottom = "") : (r._infoWindow.style.top = r._curPixel.y + 2 + "px", r._infoWindow.style.backgroundPosition = "-112px 0", r._thumb.style.top = "", r._thumb.style.bottom = "6px", r._stDescription.style.top = "", r._stDescription.style.bottom = "85px"), r._infoWindow.style.width = "112px", r._infoWindow.style.height = "119px", r._thumb.style.left = "6px", r._stDescription.style.left = "0"), 3 !== r._infoStatus && 4 !== r._infoStatus || (r._infoWindow.style.top = r._curPixel.y - Math.round(l / 2) - 20 + "px", 3 === r._infoStatus ? (r._infoWindow.style.left = r._curPixel.x + 12 + "px", r._infoWindow.style.backgroundPosition = "0 -119px", r._thumb.style.left = "20px", r._stDescription.style.left = "14px") : (r._infoWindow.style.left = r._curPixel.x - 12 - c + "px", r._infoWindow.style.backgroundPosition = "-126px -119px", r._thumb.style.left = "6px", r._stDescription.style.left = "0"), r._infoWindow.style.width = "126px", r._infoWindow.style.height = "105px"), r._infoWindow.style.backgroundImage = 'url("'.concat(o, 'st-infowindow.gif")'), r._timerId && (clearTimeout(r._timerId), r._timerId = null), r._timerId = setTimeout((function () { r._currentPoint = u, r._scout.style.backgroundPosition = "-24px 0"; var e = r._map.lnglatToMercator(u.lng, u.lat); r._pano.setPosition(new t.Point(e[0], e[1])) }), 200) } })), this._map.addEventListener("click", (function (t) { r._isOn && v.isMobile && (r._pano.setPosition(t.point), r._pano.show(), r._close()), r._isOn && r._currentSvId && (r._pano.setId(r._currentSvId), r._pano.show(), r._map.config.enableWheelZoom && (r._map.disableScrollWheelZoom(), r.isMapEnableWheelZoom = !0), r._close()) })) }, _open: function () { this._isOn || (this._isOn = !0, this._map.addTileLayer(this._panoCoverageLayer), v.isPc && (this._preDefaultCursor = this._map.getDefaultCursor(), this._preDraggingCursor = this._map.getDraggingCursor(), this._map.setDefaultCursor("pointer"), this._map.setDraggingCursor("pointer"))), this._updateView() }, _close: function () { this._isOn && (this._map.removeTileLayer(this._panoCoverageLayer), v.isPc && (this._scout.style.display = "none", this._infoWindow.style.display = "none", this._map.setDefaultCursor(this._preDefaultCursor), this._map.setDraggingCursor(this._preDraggingCursor)), this._isOn = !1), this._updateView() } }), new a(t.Control) }, t.getStreetViewCoverageLayer = function (t) { var e = new t.TileLayer({ transparentPng: !0, dataType: 1, cacheSize: 32 }); return e.zIndex = 110, e.getTilesUrl = window.PANORAMA_URL ? function (t, e) { var n = window.PANORAMA_URL + "/tile", r = t.x, i = t.y; return window.BMAPGL_84 && (i = Math.pow(2, e) - i - 1), "".concat(n, "?customid=panorama&x=").concat(r, "&y=").concat(i, "&z=").concat(e, "&type=WGS84") } : function (t, e) { var n = ["//apisv0.bdimg.com/", "//apisv1.bdimg.com/"], r = (Math.abs(t.x) + Math.abs(t.y)) % n.length; return "".concat(n[r], "?udt=").concat("20150114", "&qt=tile&styles=").concat("pl", "&x=").concat(t.x, "&y=").concat(t.y, "&z=").concat(e).replace(/-(\d+)/gi, "M$1") + "&" + $("/", { isCounter: !1 }) }, e }, t.init = function (t, e) { return new sa(t, e) }, Object.defineProperty(t, "__esModule", { value: !0 })
})(Pano = {});
window.BMapGL = window.BMapGL || {}; (function (bG, fF) { var e9 = e9 || { version: "20150702", emptyFn: function () { } }; (function () { e9._log = []; var i = 0; var T = {}; e9.BaseClass = function (kC) { T[(this.hashCode = (kC || e9.BaseClass.guid()))] = this }; e9.BaseClass.guid = function () { return "mz_" + (i++).toString(36) }; e9.BaseClass.create = function () { var kC = new e9.BaseClass(); kC.decontrol(); return kC }; var e = e9.instance = e9.I = function (kC) { return T[kC] }; e9.BaseClass.prototype.dispose = function () { if (this.hashCode) { delete T[this.hashCode] } for (var kC in this) { if (typeof this[kC] != "function") { delete this[kC] } } }; e9.BaseClass.prototype.getHashCode = function () { if (!this.hashCode) { T[(this.hashCode = e9.BaseClass.guid())] = this } return this.hashCode }; e9.BaseClass.prototype.decontrol = function () { delete T[this.hashCode] }; e9.BaseClass.prototype.toString = function () { return "[object " + (this._className || "Object") + "]" }; e9.BaseClass.prototype._wlog = function (kD, kE) { var kC = e9._log; if (kC.length > 100) { kC.reverse().length = 50; kC.reverse() } kC[kC.length] = "[" + kD + "][" + (this._className || "Object") + " " + this.hashCode + "] " + kE } })(); Function.prototype.inherits = function (kC, T) { var e, kD, kF = this.prototype, kE = function () { }; kE.prototype = kC.prototype; kD = this.prototype = new kE(); if (typeof (T) == "string") { kD._className = T } for (e in kF) { kD[e] = kF[e] } this.prototype.constructor = kF.constructor; kF = kE = null; return kD }; e9.BaseEvent = function (e, i) { this.type = e; this.returnValue = true; this.target = i || null; this.currentTarget = this.srcElement = null; this.cancelBubble = false; this.domEvent = null }; e9.BaseClass.prototype.on = e9.BaseClass.prototype.addEventListener = function (T, i) { if (typeof i !== "function") { return this._wlog("error", "addEventListener:" + i + " is not a function") } if (!this._listeners) { this._listeners = {} } var e = this._listeners; if (T.indexOf("on") !== 0) { T = "on" + T } if (typeof e[T] !== "object") { e[T] = {} } var kC = i.hashCode || e9.BaseClass.guid(); i.hashCode = kC; if (e[T][kC]) { this._wlog("warning", "repeat key:" + kC) } e[T][kC] = i }; e9.BaseClass.prototype.off = e9.BaseClass.prototype.removeEventListener = function (T, i) { if (typeof i == "function") { i = i.hashCode } else { if (typeof i !== "string" && typeof i !== "undefined") { return } } if (!this._listeners) { this._listeners = {} } if (T.indexOf("on") != 0) { T = "on" + T } var e = this._listeners; if (!e[T]) { return } if (i === undefined) { e[T] = {}; return } if (e[T][i]) { delete e[T][i] } }; e9.BaseClass.prototype.fire = e9.BaseClass.prototype.dispatchEvent = function (kC) { if (!this._listeners) { this._listeners = {} } var T, e = this._listeners, kD = kC.type; kC.target = kC.srcElement = kC.target || kC.srcElement || this; kC.currentTarget = this; if (typeof this[kD] == "function") { this[kD](kC) } if (typeof e[kD] == "object") { for (T in e[kD]) { if (typeof e[kD][T] == "function") { e[kD][T].call(this, kC) } } } return kC.returnValue }; e9.BaseEvent.prototype.inherit = function (T) { var i = this; this.domEvent = T = window.event || T; i.clientX = T.clientX || T.pageX; i.clientY = T.clientY || T.pageY; i.offsetX = T.offsetX || T.layerX; i.offsetY = T.offsetY || T.layerY; i.screenX = T.screenX; i.screenY = T.screenY; i.ctrlKey = T.ctrlKey || T.metaKey; i.shiftKey = T.shiftKey; i.altKey = T.altKey; return i }; e9.Browser = (function () { var T = navigator.userAgent; var kD = 0; var e = 0; var kE = 0; var i = 0; var kI = 0; var kG = 0; var kH = 0; var kF = 0; var kC = 0; var kJ = 0; if (typeof window.opera === "object" && /Opera(\s|\/)(\d+(\.\d+)?)/.test(T)) { kE = parseFloat(RegExp.$2) } else { if (/OPR(\/(\d+)(\..?)?)/.test(T)) { kE = parseInt(RegExp.$2, 10) } else { if (/Edge\/((\d+)\.\d+)/.test(T)) { kD = parseInt(RegExp.$2, 10) } else { if (/MSIE (\d+(\.\d+)?)/.test(T)) { e = parseFloat(RegExp.$1) } else { if (T.indexOf("Trident") > -1 && /rv:(\d+(\.\d+)?)/.test(T)) { e = parseInt(RegExp.$1, 10) } else { if (/Firefox(\s|\/)(\d+(\.\d+)?)/.test(T)) { kI = parseFloat(RegExp.$2) } else { if (navigator.vendor === "Netscape" && /Netscape(\s|\/)(\d+(\.\d+)?)/.test(T)) { kH = parseFloat(RegExp.$2) } else { if (T.indexOf("Safari") > -1 && /Version\/(\d+(\.\d+)?)/.test(T)) { i = parseFloat(RegExp.$1) } } } } } } } } if (T.indexOf("Trident") > -1 && /Trident\/(\d+(\.\d+)?)/.test(T)) { kF = parseInt(RegExp.$1, 10) } else { if (!e && !kD && T.indexOf("Gecko") > -1 && T.indexOf("KHTML") === -1 && /rv\:(\d+(\.\d+)?)/.test(T)) { kC = parseFloat(RegExp.$1) } else { if (!kD && /chrome\/(\d+(\.\d+)?)/i.test(T)) { kG = parseFloat(RegExp.$1) } else { if (!kD && /AppleWebKit\/(\d+(\.\d+)?)/.test(T)) { kJ = parseInt(RegExp.$1, 10) } } } } var kK = { edge: kD, ie: e, firefox: kI, netscape: kH, opera: kE, safari: i, chrome: kG, gecko: kC, trident: kF, webkit: kJ }; return kK })(); window.FeBrowser = e9.Browser; e9.Dom = {}; e9.Dom.createDom = function (i, e) { if (e9.isIE && e && e.name) { i = "<" + i + ' name="' + e9.String.escapeHTML(e.name) + '">' } var T = document.createElement(i); if (e) { e9.Dom.setProperties(T, e) } return T }; e9.Dom.getOffset = function (kC) { var kF = e9.Dom.getOwnerDocument(kC); var kE = e9.isGecko > 0 && kF.getBoxObjectFor && e9.Dom.getStyle(kC, "position") == "absolute" && (kC.style.top === "" || kC.style.left === ""); var kG = { left: 0, top: 0 }; var i = (e9.isIE && !e9.isStrict) ? kF.body : kF.documentElement; if (kC == i) { return kG } var T = null; var kD; if (kC.getBoundingClientRect) { kD = kC.getBoundingClientRect(); kG.left = kD.left + Math.max(kF.documentElement.scrollLeft, kF.body.scrollLeft); kG.top = kD.top + Math.max(kF.documentElement.scrollTop, kF.body.scrollTop); kG.left -= kF.documentElement.clientLeft; kG.top -= kF.documentElement.clientTop; if (e9.isIE && !e9.isStrict) { kG.left -= 2; kG.top -= 2 } } else { if (kF.getBoxObjectFor && !kE) { kD = kF.getBoxObjectFor(kC); var e = kF.getBoxObjectFor(i); kG.left = kD.screenX - e.screenX; kG.top = kD.screenY - e.screenY } else { T = kC; do { kG.left += T.offsetLeft; kG.top += T.offsetTop; if (e9.isWebkit > 0 && e9.Dom.getStyle(T, "position") == "fixed") { kG.left += kF.body.scrollLeft; kG.top += kF.body.scrollTop; break } T = T.offsetParent } while (T && T != kC); if (e9.isOpera > 0 || (e9.isWebkit > 0 && e9.Dom.getStyle(kC, "position") == "absolute")) { kG.top -= kF.body.offsetTop } T = kC.offsetParent; while (T && T != kF.body) { kG.left -= T.scrollLeft; if (!e9.isOpera || T.tagName != "TR") { kG.top -= T.scrollTop } T = T.offsetParent } } } return kG }; e9.Dom.getOwnerDocument = function (e) { return e.nodeType == 9 ? e : e.ownerDocument || e.document }; e9.Dom.setProperties = function (i, e) { e9.each(e, function (kC, T) { e9.Dom._setProperty(i, T, kC) }) }; e9.Dom._setProperty = function (i, e, T) { if (e == "style") { i.style.cssText = T } else { if (e == "class") { i.className = T } else { if (e == "for") { i.htmlFor = T } else { if (e in e9.Dom._DIRECT_ATTRIBUTE_MAP) { i.setAttribute(e9.Dom._DIRECT_ATTRIBUTE_MAP[e], T) } else { i[e] = T } } } } }; e9.Dom._DIRECT_ATTRIBUTE_MAP = { cellpadding: "cellPadding", cellspacing: "cellSpacing", colspan: "colSpan", rowspan: "rowSpan", valign: "vAlign", height: "height", width: "width", usemap: "useMap", frameborder: "frameBorder" }; e9.G = function () { for (var T = [], kC = arguments.length - 1; kC > -1; kC--) { var kD = arguments[kC]; T[kC] = null; if (typeof kD == "object" && kD && kD.dom) { T[kC] = kD.dom } else { if ((typeof kD == "object" && kD && kD.tagName) || kD == window || kD == document) { T[kC] = kD } else { if (typeof kD == "string" && (kD = document.getElementById(kD))) { T[kC] = kD } } } } return T.length < 2 ? T[0] : T }; e9.ac = function (e, i) { if (!(e = this.G(e))) { return } i = this.trim(i); if (!new RegExp("(^| )" + i.replace(/(\W)/g, "\\$1") + "( |$)").test(e.className)) { e.className = e.className.split(/\s+/).concat(i).join(" ") } }; e9.addClassName = e9.ac; e9.each = function (kE, e) { if (typeof e != "function") { return kE } if (kE) { if (kE.length === undefined) { for (var T in kE) { e.call(kE[T], kE[T], T) } } else { for (var kC = 0, kD = kE.length; kC < kD; kC++) { e.call(kE[kC], kE[kC], kC) } } } return kE }; e9.extend = function (kE, kC) { if (kE && kC && typeof (kC) == "object") { for (var kD in kC) { kE[kD] = kC[kD] } var T = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]; for (var e = 0, i; e < T.length; e++) { i = T[e]; if (Object.prototype.hasOwnProperty.call(kC, i)) { kE[i] = kC[i] } } } return kE }; e9.hide = function () { e9.each(arguments, function (e) { if (e = e9.G(e)) { e.style.display = "none" } }) }; e9.inherit = function (kG, kC, T) { var kF = kG.prototype; var kE = function () { }; kE.prototype = kC.prototype; var kD = kG.prototype = new kE(); if (typeof T == "string") { kD._className = T } for (var e in kF) { kD[e] = kF[e] } kG.prototype.constructor = kF.constructor; kF = null; return kD }; e9.isIE = 0; (function () { if (navigator.userAgent.indexOf("MSIE") > 0 && !window.opera) { /MSIE (\d+(\.\d+)?)/.test(navigator.userAgent); e9.isIE = parseFloat(RegExp.$1) } })(); e9.rc = function (e, i) { if (!(e = this.G(e))) { return } i = this.trim(i); var T = e.className.replace(new RegExp("(^| +)" + i.replace(/(\W)/g, "\\$1") + "( +|$)", "g"), "$2"); if (e.className != T) { e.className = T } }; e9.removeClassName = e9.rc; e9.show = function () { this.each(arguments, function (e) { if (e = e9.G(e)) { e.style.display = "" } }) }; e9.trim = function (e) { return e.replace(/(^[\s\t\xa0\u3000]+)|([\u3000\xa0\s\t]+$)/g, "") }; e9.getElementsByClassName = function (e, i) { if (e.getElementsByClassName) { return e.getElementsByClassName(i) } else { return (function T(kJ, kH) { if (kH == null) { kH = document } var kG = [], kF = kH.getElementsByTagName("*"), kC = kF.length, kI = new RegExp("(^|\\s)" + kJ + "(\\s|$)"), kE, kD; for (kE = 0, kD = 0; kE < kC; kE++) { if (kI.test(kF[kE].className)) { kG[kD] = kF[kE]; kD++ } } return kG })(i, e) } }; e9.toggleClass = function (e, i) { if (e9.hasClass(e, i)) { e9.removeClassName(e, i) } else { e9.addClassName(e, i) } }; e9.hasClass = function (kC, T) { if (!kC || !kC.className || typeof kC.className != "string") { return false } var i = -1; try { i = kC.className == T || kC.className.search(new RegExp("(\\s|^)" + T + "(\\s|$)")) } catch (kD) { return false } return i > -1 }; e9.insertHTML = function (kC, e, T) { kC = e9.G(kC); if (kC === null) { return kC } var i, kD; if (kC.insertAdjacentHTML) { kC.insertAdjacentHTML(e, T) } else { i = kC.ownerDocument.createRange(); e = e.toUpperCase(); if (e == "AFTERBEGIN" || e == "BEFOREEND") { i.selectNodeContents(kC); i.collapse(e == "AFTERBEGIN") } else { kD = e == "BEFOREBEGIN"; i[kD ? "setStartBefore" : "setEndAfter"](kC); i.collapse(kD) } i.insertNode(i.createContextualFragment(T)) } return kC }; if (typeof HTMLElement != "undefined" && HTMLElement.prototype.__lookupGetter__ && !HTMLElement.prototype.__lookupGetter__("children") && !window.opera) { try { HTMLElement.prototype.__defineGetter__("children", function () { for (var T = [], kC = 0, kE, kD = 0, e = this.childNodes.length; kD < e; kD++) { kE = this.childNodes[kD]; if (kE.nodeType == 1) { T[kC++] = kE; if (kE.name) { if (!T[kE.name]) { T[kE.name] = [] } T[kE.name][T[kE.name].length] = kE } if (kE.id) { T[kE.id] = kE } } } return T }) } catch (jP) { } } if (typeof (HTMLElement) != "undefined" && !window.opera && HTMLElement.prototype && !HTMLElement.prototype.insertAdjacentHTML) { HTMLElement.prototype.insertAdjacentHTML = function (i, T) { var kC = this.ownerDocument.createRange(); kC.setStartBefore(this); kC = kC.createContextualFragment(T); switch (i) { case "beforeBegin": this.parentNode.insertBefore(kC, this); break; case "afterBegin": this.insertBefore(kC, this.firstChild); break; case "beforeEnd": this.appendChild(kC); break; case "afterEnd": if (!this.nextSibling) { this.parentNode.appendChild(kC) } else { this.parentNode.insertBefore(kC, this.nextSibling) } break } } } if (typeof HTMLElement != "undefined" && !window.opera) { HTMLElement.prototype.contains = function (e) { if (!e) { return false } if (e == this) { return true } while (e = e.parentNode) { if (e == this) { return true } } return false } } if (!e9.Browser.ie && typeof Event != "undefined" && !window.opera) { Event.prototype.__defineSetter__("returnValue", function (e) { if (!e) { this.preventDefault() } return e }); Event.prototype.__defineSetter__("cancelBubble", function (e) { if (e) { this.stopPropagation() } return e }) } e9.each = function (kD, kC) { if (b0(kC)) { for (var T = 0, e = kD.length; T < e; T++) { if (kC.call(kD, kD[T], T) === false) { break } } } return kD }; e9.Platform = { x11: 0, macintosh: 0, windows: 0, android: 0, iphone: 0, ipad: 0 }; for (var jN in e9.Platform) { if (e9.Platform.hasOwnProperty(jN)) { e9.Platform[jN] = new RegExp(jN, "i").test(window.navigator.userAgent) ? 1 : 0 } } if (typeof (e9.Dom) === "undefined") { e9.Dom = {} } e9.Dom.getComputedStyle = function (i, e) { var kC = i.nodeType == 9 ? i : i.ownerDocument || i.document, T; if (kC.defaultView && kC.defaultView.getComputedStyle) { T = kC.defaultView.getComputedStyle(i, null); if (T) { return T[e] || T.getPropertyValue(e) } } else { if (i.currentStyle) { return i.currentStyle[e] || "" } } return "" }; var fW = e9.BaseEvent; var dh = e9.BaseClass; dh.prototype.toString = function () { return this._className || "" }; e9.on = function (T, i, e) { if (!(T = e9.G(T))) { return T } i = i.replace(/^on/, ""); if (T.addEventListener) { T.addEventListener(i, e, false) } else { if (T.attachEvent) { T.attachEvent("on" + i, e) } } return T }; e9.un = function (T, i, e) { if (!(T = e9.G(T))) { return T } i = i.replace(/^on/, ""); if (T.removeEventListener) { T.removeEventListener(i, e, false) } else { if (T.detachEvent) { T.detachEvent("on" + i, e) } } return T }; e9.hc = function (kC, T) { if (!kC || !kC.className || typeof kC.className != "string") { return false } var i = -1; try { i = kC.className == T || kC.className.search(new RegExp("(\\s|^)" + T + "(\\s|$)")) } catch (kD) { return false } return i > -1 }; e9.isEmptyObject = function (T) { if (Object.prototype.toString.call(T) === "[object Object]") { for (var e in T) { return false } return true } else { return false } }; var bZ = window.location.protocol === "http:" ? "http:" : "https:"; var eG = { fontFamily: 'Arial,Helvetica,"PingFang SC","Hiragino Sans GB",STHeiti,sans-serif', mapStyleNameIdPair: { "default": 0, "grayed-out": 1 }, mapHost: bZ + "//map.baidu.com", apiHost: window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"] ? window._BMapSecurityConfig["serviceHost"] : bZ + "//api.map.baidu.com", apiIMG: bZ + "//api.map.baidu.com/images", staticHost: bZ + "//webmap0.bdimg.com", imgPath: bZ + "//webmap0.bdimg.com/image/api/", tileDomain: [bZ + "//maponline0.bdimg.com", bZ + "//maponline1.bdimg.com", bZ + "//maponline2.bdimg.com", bZ + "//maponline3.bdimg.com"], panoTilePath: "//apisv1.bdimg.com/", rasterTilePath: "/tile/", vectorTilePath: "/pvd/", originTilePath: [bZ + "//pcor.baidu.com"], stylePath: "//maponline0.bdimg.com/sty/", bosPath: bZ + "//mapopen-pub-jsapigl.bj.bcebos.com/assets/images/", getIconSetPath: function (e) { var i = "map_icons2x/"; if (typeof e === "string" && this.mapStyleNameIdPair[e] > 0) { i = "map_icons2x_" + (this.mapStyleNameIdPair[e] - 1) + "/" } return bZ + this.stylePath + i }, getMapStyleFiles: function (T) { var kD = true; if (typeof T === "string" && T !== "default") { kD = false } var kE = kD ? "" : "_" + (this.mapStyleNameIdPair[T] - 1); var i = bH(); var kC = "udt=" + i.udt + "&v=" + i.ver; var e = bZ + this.stylePath; return [e + "icons_2x" + kE + ".js?" + kC, e + "fs" + kE + ".js?" + kC, e + "indoor_fs.js?" + kC] }, tvc: { ditu: { normal: { version: "088", updateDate: "20230830" }, satellite: { version: "009", updateDate: "20230830" }, normalTraffic: { version: "081", updateDate: "20230830" }, satelliteTraffic: { version: "083", updateDate: "20230830" }, mapJS: { version: "104", updateDate: "20230830" }, satelliteStreet: { version: "083", updateDate: "20230830" }, earthVector: { version: "001", updateDate: "20230830" } }, webapp: { high_normal: { version: "001", updateDate: "20230830" }, lower_normal: { version: "002", updateDate: "20230830" } }, api_for_mobile: { vector: { version: "002", updateDate: "20230830" }, vectorIcon: { version: "002", updateDate: "20230830" } } }, msv: { mapstyle: { version: "001", updateDate: "20230817" } } }; eG.imgResources = { blankGIF: eG.staticHost + "/res/litemapapi/v1d1/images/blank.gif?20170501", markerPng: eG.staticHost + "/res/litemapapi/v1d1/images/marker.png?20170501", locPng: eG.staticHost + "/res/litemapapi/v1d1/images/loc.png?20180918", locNewPng: eG.staticHost + "/res/litemapapi/v1d1/images/loc_new.png?20190314", zoomPng: eG.staticHost + "/res/litemapapi/v1d1/images/zoombtn.png?20180918", mapLogoPng: eG.staticHost + "/res/litemapapi/v1d1/images/logo-2x.png?20190226" }; var E = eG; var jE = "ruler.cur"; if (e9.Browser.ie || e9.Browser.edge) { e9.extend(E, { distCursor: "url(" + E.imgPath + jE + "),crosshair", defaultCursor: "url(" + E.imgPath + "openhand.cur),default", draggingCursor: "url(" + E.imgPath + "closedhand.cur),move" }) } else { if (e9.Browser.firefox) { e9.extend(E, { distCursor: "url(" + E.imgPath + jE + "),crosshair", defaultCursor: "-moz-grab", draggingCursor: "-moz-grabbing" }) } else { if (e9.Browser.chrome || e9.Browser.safari) { e9.extend(E, { distCursor: "url(" + E.imgPath + jE + ") 2 6,crosshair", defaultCursor: "url(" + E.imgPath + "openhand.cur) 8 8,default", draggingCursor: "url(" + E.imgPath + "closedhand.cur) 8 8,move" }); if (e9.Platform.macintosh) { E.defaultCursor = "-webkit-grab"; E.draggingCursor = "-webkit-grabbing" } } else { e9.extend(E, { distCursor: "url(" + E.imgPath + jE + "),crosshair", defaultCursor: "url(" + E.imgPath + "openhand.cur),default", draggingCursor: "url(" + E.imgPath + "closedhand.cur),move" }) } } } bG = bG || {}; bG.version = "gl"; if (!bG.coordType) { bG.coordType = "BMAP_COORD_BD09" } bG._register = []; bG.register = function (e) { this._register[this._register.length] = e }; bG.guid = 1; bG.getGUID = function (e) { return (e || "") + bG.guid++ }; var eZ = window.BMAP_AUTHENTIC_KEY || ""; function V(e, i, kC) { var T = new Date(); T.setTime(T.getTime() + kC * 24 * 60 * 60 * 1000); document.cookie = e + "=" + escape(i) + ";expires=" + T.toGMTString() } function a9(e, i) { if (localStorage) { return localStorage.setItem(e, i) } if (sessionStorage) { return sessionStorage.setItem(e, i) } } bG.getSeckeyCid = function () { var i = +new Date(); var e = bZ + "//dlswbr.baidu.com/heicha/mw/abclite-2063-s.js?_t=" + i; g4.load(e, i9) }; function i9() { if (window.___abvk) { a9("SECKEY_ABVK", window.___abvk) } } window.__abbaidu_2063_cb = function (i) { var e = JSON.parse(i); a9("BMAP_SECKEY", e.data) }; bG.bmapVerifyCbk = function (kD) { if (kD && kD.error !== 0) { bG = null; BMapGL = null; var kE = "百度未授权使用地图API，可能是因为您提供的密钥不是有效的百度地图开放平台密钥，或此密钥未对本应用的百度地图JavaScriptAPI授权。您可以访问如下网址了解如何获取有效的密钥：https://lbs.baidu.com/apiconsole/key#。"; switch (kD.error) { case 101: kE = "您所使用的密钥ak有问题，不支持jsapi服务，可以访问该网址了解如何获取有效密钥：http://lbsyun.baidu.com/apiconsole/key#。"; break; case 102: kE = "MCODE参数不存在，mobile类型MCODE参数必需，详情查看：http://lbsyun.baidu.com/apiconsole/key#。"; break; case 200: kE = "APP不存在，AK有误请检查再重试，详情查看：http://lbsyun.baidu.com/apiconsole/key#。"; break; case 201: kE = "APP被您禁用啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。"; break; case 202: kE = "APP被管理员删除啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。"; break; case 203: kE = "APP类型错误，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。"; break; case 210: kE = "APP IP校验失败，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。"; break; case 220: kE = "APP Referer校验失败。请检查该ak设置的白名单与访问所有的域名是否一致。详情查看：http://lbsyun.baidu.com/apiconsole/key#"; break; case 230: kE = "APP Mcode码校验失败，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。"; break; case 240: kE = "APP服务被禁用了，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。"; break; case 250: kE = "该用户不存在... 请登录 https://lbs.baidu.com 的控制台，注册成为开发者申请ak吧。"; break; case 251: kE = "该用户被自己删除啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情。"; break; case 252: kE = "该用户被管理员删除啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 了解如何获取有效密钥，或请联系我们了解详情。"; break; case 260: kE = "您所使用的密钥AK不包含该服务呢，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看服务选择情况，或请联系我们了解详情。"; break; case 261: kE = "您所使用的密钥AK的该服务被禁用啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看服务选择情况，或请联系我们了解详情。"; break; case 401: kE = "您所使用的AK并发超限了，请登录 http://lbsyun.baidu.com/cashier/quota#/home 了解详情。"; break; case 302: kE = "您所使用的AK天配额超限了，请登录 http://lbsyun.baidu.com/cashier/quota#/home 了解详情。"; break }alert(kE); var T = document.getElementsByClassName("bmap-container"); if (T) { for (var kC = 0; kC < T.length; kC++) { var e = T[kC]; if (e && e.firstChild && e.firstChild.id === "platform") { e.innerText = "" } } } } }; bG.frequencyCbk = function (e) { if (e) { window.QTFrequency = e } }; bG.verify = function () { if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var e = E.apiHost + "?qt=verify&v=gl&type=webgl&time=" + Date.now() + "&callback=" + fF + ".bmapVerifyCbk" } else { var e = E.apiHost + "/?qt=verify&v=gl&type=webgl&ak=" + eZ + "&time=" + Date.now() + "&callback=" + fF + ".bmapVerifyCbk" } g4.load(e) }; bG.frequency = function () { }; bG.apiLoad = bG.apiLoad || function () { }; function iu(i, e) { this._size = i; this._cache = []; this._totalGetTimes = 0; this._totalHitTimes = 0; this._options = { clearCallback: null, removeOldCallback: null }; e = e || {}; for (var T in e) { if (e.hasOwnProperty(T)) { this._options[T] = e[T] } } } iu.prototype.setData = function (T, kC) { var e = this._cache; var i = this._size; if (i === 0) { return } if (e.length > i) { this._removeOld() } if (!e[T]) { e.push(kC) } e[T] = kC; kC._key_ = T }; iu.prototype.getHitRate = function () { return Math.round(this._totalHitTimes / this._totalGetTimes * 1000) / 1000 }; iu.prototype.getData = function (i) { var e = this._cache[i]; if (e) { this._totalHitTimes++ } this._totalGetTimes++; return e }; iu.prototype.removeData = function (kD) { if (this._options.clearCallback) { this._options.clearCallback(this._cache[kD]) } var T = this._cache; var kE = T[kD]; for (var kC = 0, e = T.length; kC < e; kC++) { if (T[kC] === kE) { T.splice(kC, 1); break } } delete T[kD] }; iu.prototype._removeOld = function () { var e = this._cache; var kD = Math.round(this._size * 0.6); for (var kC = 0; kC < kD; kC++) { var T = e[kC]._key_; if (this._options.clearCallback) { this._options.clearCallback(e[T]) } delete e[T] } e.splice(0, kD); if (this._options.removeOldCallback) { this._options.removeOldCallback() } }; iu.prototype.clear = function () { var T = this._cache; for (var kD = 0, e = T.length; kD < e; kD++) { var kC = T[kD]._key_; if (this._options.clearCallback) { this._options.clearCallback(T[kC]) } delete T[kC] } this._cache = T = [] }; iu.prototype.forEach = function (kC) { var T = this._cache; for (var kE = 0, e = T.length; kE < e; kE++) { var kD = T[kE]._key_; kC(T[kD]) } }; iu.prototype.getBatch = function (kD) { var e = []; for (var kC = 0, T = kD.length; kC < T; kC++) { if (this.getData(kD[kC])) { e[e.length] = this.getData(kD[kC]) } } return e }; iu.prototype.clearExcept = function (kE) { var T = this._cache; for (var e = T.length, kD = e - 1; kD >= 0; kD--) { var kC = this._cache[kD]._key_; if (!kE[kC]) { T.splice(kD, 1); if (this._options.clearCallback) { this._options.clearCallback(T[kC]) } delete T[kC] } } }; iu.prototype.getDataCount = function () { return this._cache.length }; function je() { } e9.extend(je.prototype, { centerAndZoomIn: function (kH, T, kI) { var kF = this; if (!kH && !T) { return } kH = kH || this.centerPoint; T = T || this.zoomLevel; T = this._getProperZoom(T).zoom; if (this.mapType === BMAP_EARTH_MAP) { if (!this._earth) { this.mapType = BMAPGL_NORMAL_MAP; this.temp.originMapType = BMAP_EARTH_MAP; function kG() { kF._earth = new bG.Earth(kF, { showRealSunlight: kF.config.showRealSunlight, showMilkyway: kF.config.showMilkyway, earthBackground: kF.config.earthBackground }); kF._proxyEarthEvents(); kF._changeEarthMapType(BMAP_EARTH_MAP); e9.extend(kF, bG.EarthView.prototype); if (!kF._navigationCtrl && kF.config.showControls) { kF._navigationCtrl = new bG.NavigationControl3D(kF) } delete kF.temp.originMapType } hm.load("earth", function () { if (bG["FeatureStyle" + kF.config.style]) { kG() } else { kF.loadMapStyleFiles(function () { kG() }) } }) } } this.lastLevel = this.zoomLevel || T; this.zoomLevel = T; var kD = new fW("onload"); kD.point = kH; kD.zoom = T; this.centerPoint = this.restrictCenter(new cG(kH.lng, kH.lat)); if (this.centerPoint.zoom) { this.zoomLevel = this.centerPoint.zoom } this.defaultZoomLevel = this.defaultZoomLevel || this.zoomLevel; this.defaultCenter = this.defaultCenter || this.centerPoint; if (!this.loaded && !(this.temp.originMapType === BMAP_EARTH_MAP)) { var i = this.config.defaultMaxBounds; var kE = new o(i, "baidu", this.mapType); var kC = new hP({ mapType: this.mapType, copyright: kE, customLayer: false, baseLayer: true, tileTypeName: "web" }); kC._isInnerLayer = true; this.addTileLayer(kC); if (this.mapType === BMAP_SATELLITE_MAP && this._isHybridShow === true) { this._addHybirdMap() } } this.dispatchEvent(kD); this.loaded = true; kI = kI || {}; kI.callback && kI.callback() }, _setPlatformPosition: function (kI, kH, kL) { kL = kL || {}; if (kI === 0 && kH === 0 && !kL.point) { return } if (isNaN(kL.initMapOffsetX)) { kL.initMapOffsetX = this.offsetX } if (isNaN(kL.initMapOffsetY)) { kL.initMapOffsetY = this.offsetY } var kJ = kI + kL.initMapOffsetX; var kG = kH + kL.initMapOffsetY; if (kL.point) { var i = this.restrictCenter(kL.point); if (!i.equals(this.centerPoint)) { this.centerPoint = i.clone(); this.fire(new fW("oncenter_changed")) } } else { var kC = this.offsetX - kJ; var e = this.offsetY - kG; var T = this.getZoomUnits(); var kF = this.centerPoint.lng; var kE = this.centerPoint.lat; var kD = new cG(kF, kE); this.centerPoint = this.restrictCenter(new cG(kD.lng + kC * T, kD.lat - e * T), T); this.fire(new fW("oncenter_changed")); if (this.zoomLevel < 10) { kJ = this.offsetX - (this.centerPoint.lng - kD.lng) / T; kG = this.offsetY + (this.centerPoint.lat - kD.lat) / T } } this.offsetX = kJ; this.offsetY = kG; var kK = this.platform.style; kK.left = kJ + "px"; kK.top = kG + "px"; this.maskLayer.style.left = -kJ + "px"; this.maskLayer.style.top = -kG + "px"; if (kL.dispatchEvent !== false) { this.dispatchEvent(new fW("onmoving")) } }, zoomTo: function (e, kF, kJ) { kJ = kJ || {}; kJ.zoomCenter = kF; if (kJ.noAnimation !== true) { this.deepZoomTo(e, kJ); return } if (typeof e !== "number") { return } var kD = ev[this.mapType]; if (!kD) { return } var T = e; e = this._getProperZoom(e).zoom; if (e === this.zoomLevel) { var kG = new fW("onzoomexceeded"); kG.targetZoom = T; this.dispatchEvent(kG); kJ.callback && kJ.callback(); return } this.lastLevel = this.zoomLevel; if (kF) { this.temp._cPoint = kF; this.temp._cPixel = this.pointToPixelIn(kF) } else { if (this.getInfoWindow()) { var kI = this.getInfoWindow().getPoint(); this.temp._cPixel = this.pointToPixelIn(kI); this.temp._cPoint = kI } } if (this.config.zoomCenter) { kF = this.config.zoomCenter; this.temp._cPoint = kF; this.temp._cPixel = this.pointToPixelIn(kF) } if (kF || this.temp.infoWin && this.temp.infoWin.isOpen()) { var i = this.temp._cPoint; var kH = this.temp._cPixel; var kC = this.getZoomUnits(e); var kE = new cG(i.lng + kC * (this.width / 2 - kH.x), i.lat - kC * (this.height / 2 - kH.y)); this.centerPoint = this.restrictCenter(kE, kC, e); if (this.centerPoint.zoom) { e = this.centerPoint.zoom } } if (kJ.fireEvent !== false) { this.dispatchEvent(new fW("onzoomstart")) } if (e !== this.zoomLevel) { this.zoomLevel = e; this.dispatchEvent(new fW("onzooming")); this.dispatchEvent(new fW("onzoomstartcode")) } if (kJ.fireEvent !== false) { this.dispatchEvent(new fW("onzoomend")) } if (kJ.callback) { kJ.callback() } }, deepZoomMedia: function (e) { var i = this; if (!i.temp.isStdCtrlBusy) { i.temp.isStdCtrlBusy = true; i.deepZoomTo(i.zoomLevel + e); setTimeout(function () { i.temp.isStdCtrlBusy = false }, 400) } }, deepZoomTo: function (kG, kC) { kC = kC || {}; var kE = kG - this.zoomLevel; var kD = this._getProperZoom(kG); if (kD.exceeded) { var e = new fW("onzoomexceeded"); e.targetZoom = kG; this.dispatchEvent(e); return } var i; if (kC.zoomCenter) { i = this.pointToPixelIn(kC.zoomCenter) } else { if (this.getInfoWindow()) { i = this.pointToPixelIn(this.getInfoWindow().getPoint(), { zoom: this.lastLevel }) } else { var i = new fv(this.width / 2, this.height / 2) } } this.lastLevel = this.zoomLevel; var kF = this.deepZoom || new aH(this); var T = kE > 0 ? 1 : -1; kF.zoomMap(i, kE, T, null, kC) }, flyToIn: function (kH, e) { if (e === this.zoomLevel) { this.panToIn(kH); return } var kE = this._getProperZoom(e); if (kE.exceeded) { var kI = new fW("onzoomexceeded"); kI.targetZoom = e; this.dispatchEvent(kI); return } var kG = e - this.zoomLevel; var T = new fv(this.width / 2, this.height / 2); var i = this.pointToPixelIn(kH); var kF = new jo(i.x - T.x, i.y - T.y); this.lastLevel = this.zoomLevel; if (Math.abs(kG) >= 4 || Math.abs(kF.width) > this.width || Math.abs(kF.height) > this.height) { this.centerAndZoomIn(kH, e); return } var kD = this.deepZoom || new aH(this); var kC = kG > 0 ? 1 : -1; kD.zoomMap(i, kG, kC, kF) }, panToIn: function (i, T) { T = T || {}; if (!i || i.equals(this.centerPoint)) { T.callback && T.callback(); return } var kC = this.pointToPixelIn(i); var e = Math.round(this.width / 2); var kD = Math.round(this.height / 2); if (Math.abs(e - kC.x) > this.width || Math.abs(kD - kC.y) > this.height || T.noAnimation === true) { this._panToIn(e - kC.x, kD - kC.y, i); T.callback && T.callback() } else { this._panBy(e - kC.x, kD - kC.y, T) } }, _panToIn: function (i, e, kC) { var T = this.temp; if (T.operating === true) { return } if (T.dragAni) { T.dragAni.stop(); T.dragAni = null; this.dispatchEvent(new fW("onmoveend")) } this.dispatchEvent(new fW("onmovestart")); this._setPlatformPosition(i, e, { point: kC }); this.dispatchEvent(new fW("onmoveend")) }, panBy: function (i, e, T) { T = T || {}; i = Math.round(i) || 0; e = Math.round(e) || 0; if (Math.abs(i) <= this.width && Math.abs(e) <= this.height && T.noAnimation !== true) { this._panBy(i, e, T) } else { this._panToIn(i, e); T.callback && T.callback() } }, _panBy: function (i, e, kD) { if (this.temp.operating === true) { return } kD = kD || {}; this.dispatchEvent(new fW("onmovestart")); var kC = this; var T = kC.temp; T.pl = kC.offsetX; T.pt = kC.offsetY; if (T.tlPan) { T.tlPan.cancel() } if (T.dragAni) { T.dragAni.stop(); T.dragAni = null; this.dispatchEvent(new fW("onmoveend")) } T.tlPan = new fL({ fps: kD.fps || kC.config.fps, duration: kD.duration || kC.config.actionDuration, transition: kD.transition || gS.easeInOutQuad, render: function (kE) { this.terminative = kC.temp.operating; if (kC.temp.operating) { return } kC._setPlatformPosition(Math.ceil(i * kE), Math.ceil(e * kE), { initMapOffsetX: T.pl, initMapOffsetY: T.pt }) }, finish: function (kE) { kC.dispatchEvent(new fW("onmoveend")); kC.temp.tlPan = false; if (kC.temp.stopArrow === true) { kC.temp.stopArrow = false; if (kC.temp.arrow !== 0) { kC._arrow() } } kD.callback && kD.callback() } }) }, getCenterIn: function () { return this.centerPoint }, getZoom: function () { return this.zoomLevel }, setTilt: function () { }, getTilt: function () { return this._tilt }, setHeading: function () { }, getHeading: function () { return this._heading }, restrictCenter: function (kK, i, e) { this.isRestrict = false; i = i || this.getZoomUnits(); e = e || this.zoomLevel; var kI = this.pixelToPointIn(new fv(this.width, 0), { center: kK, zoom: e }); var kG = this.pixelToPointIn(new fv(0, this.height), { center: kK, zoom: e }); var kL = kK.lng; var kQ = kK.lat; if (this.config.restrictBounds !== null && !this.config.restrictBounds.isEmpty()) { var kP = this.config.restrictBounds; var kC = kP.getSouthWest(); var kN = kP.getNorthEast(); var kJ = jy.convertLL2MC(kC); var kE = jy.convertLL2MC(kN); kK.lng = this.calcNewLngByBounds(kL, kG, kI, kJ.lng, kE.lng, i); kK.lat = this.calcNewLatByBounds(kQ, kG, kI, kJ.lat, kE.lat, i); return kK } var kH = this.pixelToPointIn(new fv(0, 0), { center: kK, zoom: e }); var kD = this.pixelToPointIn(new fv(0, this.height), { center: kK, zoom: e }); if (this.zoomLevel < 5) { if (kH.lat > h5.MAX_LAT && kD.lat < h5.MIN_LAT) { this.isRestrict = true; var T = h5.MAX_LAT - kK.lat; var kF = kK.lat - h5.MIN_LAT; var kO; if (T < kF) { kO = T / (this.height / 2) } else { kO = kF / (this.height / 2) } var kM = 18 - r(kO); this.zoomLevel = Math.ceil(kM); kK.zoom = Math.ceil(kM); return kK } } if (kH.lat > h5.MAX_LAT) { this.isRestrict = true; kK.lat = h5.MAX_LAT - this.height / 2 * i } else { if (kD.lat < h5.MIN_LAT) { this.isRestrict = true; kK.lat = h5.MIN_LAT + this.height / 2 * i } } return kK } }); function h5(e, T) { if (typeof e === "string") { e = document.getElementById(e) } dh.call(this); this.container = e; this.width = e.clientWidth; this.height = e.clientHeight; this.offsetX = 0; this.offsetY = 0; this._setStyle(e); e.unselectable = "on"; e.innerHTML = ""; e9.ac(e, "bmap-container"); e.appendChild(this.render()); this._initDate = new Date(); this.platform = e.children[0]; this.maskLayer = this.platform.children[0]; this._panes = {}; this.centerPoint = new cG(0, 0); this.zoomLevel = 0; this._heading = 0; this._tilt = 0; this._bounds = new ik(); this.lastLevel = 0; this._lock = false; this._enableTiltZoom = 7; this._enableHeadingZoom = 7; this.defaultZoomLevel = null; this.defaultCenter = null; this.zoomEventStatus = "idle"; this.currentOperation = ep.idle; this._setConfig(T); this._initMapRenderType(); this._animationInfo = {}; this._animationInfoUnstopable = {}; this.suspendLoad = false; this.earthBoundary = true; this._customTileLabels = []; this.areaCustomLoaded = true; this.defaultPoint = new cG(116.418, 39.918); this._projectionMatrix3D = "perspective"; this.mapExtendBounds = null; if (this._renderType === "webgl") { this._workerMgr = new jV(this); this._featureMgr = new cm(); e9.extend(this, F.prototype); this.jobScheduler = new bs(this); this.benchmark = new c7(); this._setupWebGLMap(); this.deviceInfo = { hardwareInfo: { renderer: "", vendor: "" } }; if (df.ifSupportWebGL._renderer) { this.deviceInfo.hardwareInfo.renderer = df.ifSupportWebGL._renderer; this.deviceInfo.hardwareInfo.vendor = df.ifSupportWebGL._vendor } jg.setMap(this) } else { e9.extend(this, je.prototype) } if (!ev[this.config.mapType]) { this.config.mapType = BMAPGL_NORMAL_MAP } if (this.config.mapType === BMAP_EARTH_MAP && !this.config.enableEarth) { if (this.forceEnableEarth() === false) { this.config.mapType = BMAPGL_NORMAL_MAP } } this.mapType = this.config.mapType; this.preMapType = null; if (this.config.enableEarth) { var kE = this.maskLayer.style; kE.opacity = 0; kE.background = "#000"; if (this.config.mapType === BMAP_EARTH_MAP) { kE.opacity = 1 } setTimeout(function () { kE.WebkitTransition = kE.transition = "opacity .4s" }, 100) } this._isHybridShow = this.config.showStreetLayer; this.temp = { operating: false, arrow: 0, lastDomMoveTime: 0, lastLoadTileTime: 0, lastMovingTime: 0, canKeyboard: false, I: function (i) { return e9.I(i) }, curSpots: [], curSpotsArray: [], curAreaSpot: null, spotsGuid: 1, registerIndex: -1, hoverOnSpot: null, isStdCtrlBusy: false }; window.InstanceCore = this.temp.I; this.platform.style.cursor = this.config.defaultCursor; this._bind(); if (!bG.BMAP_INSTANCES) { bG.BMAP_INSTANCES = 1 } else { bG.BMAP_INSTANCES += 1 } for (var kC = 0; kC < bG._register.length; kC++) { bG._register[kC](this) } this.temp.registerIndex = kC; var kD = this; if (this._renderType === "webgl") { hm.load("oppcgl", function () { kD._asyncRegister() }) } else { hm.load("oppc", function () { kD._asyncRegister() }) } if (this.config.mapType === "B_EARTH_MAP") { if (!bG.Earth) { hm.load("earth", function () { }) } else { kD._syncAndChangeMapType("B_EARTH_MAP") } } } h5.MAX_TILT = 87; h5.MAX_DRAG_TILT = 73; h5.MAX_DRAG_TILT_L2 = 50; h5.MIN_TILT = 0; h5.MAX_LAT = 19431424; h5.MIN_LAT = -16023552; h5.WORLD_SIZE_MC_HALF = 20037726.372307256; h5.WORLD_SIZE_MC = h5.WORLD_SIZE_MC_HALF * 2; h5.RIGHT_EDGE_POINT = new cG(h5.WORLD_SIZE_MC_HALF, 0); h5.LEFT_EDGE_POINT = new cG(-h5.WORLD_SIZE_MC_HALF, 0); h5.HIGH_RES_MIN_RATIO = 1.2; h5.inherits(dh, "Map"); var fD = { NORMAL: "B_NORMAL_MAP", EARTH: "B_EARTH_MAP", SATELLITE: "B_STREET_MAP" }; bG.MapTypeId = fD; e9.extend(h5.prototype, { render: function () { var e = b6("div", { id: "platform" }); var kC = e.style; kC.overflow = "visible"; kC.position = "absolute"; kC.zIndex = 5; kC.top = kC.left = "0px"; var i = b6("div", { id: "mask", "class": "BMap_mask" }); var T = i.style; T.position = "absolute"; T.top = T.left = "0px"; T.zIndex = "9"; T.overflow = "hidden"; T.WebkitUserSelect = "none"; T.width = this.width + "px"; T.height = this.height + "px"; e.appendChild(i); return e }, _initMapRenderType: function () { var e = this.config.forceRenderType; if (e === "dom") { this._renderType = "dom"; return } else { if (e === "canvas") { if (df.isModernBrowser && !df.ifCanvas2dInBlackList()) { this._renderType = "canvas"; return } else { this._renderType = "dom"; return } } else { if (e === "webgl") { if (df.ifSupportWebGL()) { this._renderType = "webgl"; return } } } } if (df.ifSupportWebGL() && df.ifEnableWebGLMap()) { this._renderType = "webgl"; return } if (df.isModernBrowser && df.ifEnableCanvas2dMap()) { this._renderType = "canvas"; return } this._renderType = "dom" }, _setConfig: function (i) { i = i || {}; this.config = { bottomOffset: 0, clickInterval: 200, enableDragging: true, enableRotate: true, enableTilt: true, enableKeyboard: false, enableDblclickZoom: true, enableContinuousZoom: true, enableWheelZoom: false, enableRotateGestures: true, enableTiltGestures: true, enablePinchZoom: true, fixCenterWhenPinch: false, enableAutoResize: true, zoomCenter: null, fps: e9.Browser.ie ? 30 : 60, zoomerDuration: 240, actionDuration: 450, defaultCursor: E.defaultCursor, draggingCursor: E.draggingCursor, overlayMoveCursor: "pointer", coordType: BMapGL.coordType, mapType: BMAPGL_NORMAL_MAP, drawer: BMAP_SYS_DRAWER, enableInertialDragging: true, drawMargin: 500, drawMarginGL: 500, enableFulltimeSpotClick: false, enableResizeOnCenter: false, isModernBrowser: df.isModernBrowser, forceRenderType: "", textRenderType: null, ratio: gu() >= h5.HIGH_RES_MIN_RATIO ? 2 : 1, enableEarth: df.ifEnableEarth(), defaultMaxBounds: new ik(new cG(-21364736, -10616832), new cG(23855104, 15859712)), showControls: false, indoorControl: false, showRealSunlight: true, showMilkyway: true, earthBackground: null, showStreetLayer: true, showVectorStreetLayer: false, showVectorLine: false, textureScale: 1, minZoom: null, maxZoom: null, earthUseRound: true, earthMinZoom: null, earthMaxZoom: null, earthSun: true, earthClouds: true, earthMarkerShowAllTime: true, earthOpacity: null, earthFixAxis: false, style: "default", showCustomIndoor: true, backgroundColor: null, enableIconClick: false, autoSafeArea: false, ak: null, webgl2: false, restrictCenter: true, restrictBounds: null, smaa: false, preserveDrawingBuffer: false, privateOn: false, privateRegions: null, popRightClick: false, videoMuted: true, overlayTop: false, highRegion: { lineOpt: null, focusOpt: false }, forceReload: true, textureSizeHeight: 4096 * 2, markerUseRound: true, extendTiles: 0 }; for (var T in i) { if (i.hasOwnProperty(T)) { this.config[T] = i[T]; if (T === "fixCenterWhenResize") { this.config.enableResizeOnCenter = i[T] } } } if (i.style) { if (i.style["styleId"] && i.style["styleId"].length < 32) { this.config.style = i.style["styleId"] } else { this.config.style = i.style } } this._setTextRenderType(); this._displayOptions = { poi: true, poiText: true, poiIcon: true, overlay: true, layer: true, building: true, indoor: true, street: true, skyColors: ["rgba(226, 237, 248, 0)", "rgba(186, 211, 252, 1)"], isFlat: false, labelMargin: 0, buildingSideGradation: false }; if (i.displayOptions) { for (var e in i.displayOptions) { if (i.displayOptions.hasOwnProperty(e)) { this._displayOptions[e] = i.displayOptions[e] } } } this.updateFocusOptions(i.focusOptions, true); if (this.config.restrictCenter === false) { this._enableTiltZoom = 0; this._enableHeadingZoom = 0 } }, updateFocusOptions: function (e, T) { this._spotOptions = { open: false, gray: false, involve: 1, focus: 0, other: 7156516 }; if (e) { for (var i in e) { if (e.hasOwnProperty(i)) { this._spotOptions[i] = e[i] } } } if (this._webglMapScene && this._webglMapScene._painter) { this._webglMapScene._painter._hightLightEnable() } if (!T) { this._drawFrame() } }, getMinZoom: function () { var T; if (ev[this.mapType][this._renderType]) { T = ev[this.mapType][this._renderType].minZoom } else { T = ev[this.mapType].minZoom } if (this.config.minZoom !== null && this.config.minZoom >= T) { T = this.config.minZoom } if (this.mapType === "B_EARTH_MAP") { return T } var i = this.getSize(); var e = this.worldSize(T); while (e < i.width) { T++; e = this.worldSize(T) } return T }, getMaxZoom: function () { var e; if (ev[this.mapType][this._renderType]) { e = ev[this.mapType][this._renderType].maxZoom } else { e = ev[this.mapType].maxZoom } if (this.config.maxZoom !== null && this.config.maxZoom <= e) { e = this.config.maxZoom } else { if (this._renderType === "webgl") { e = 21 } } return e }, _drawFrame: function () { if (this._webglMapScene && this._webglMapScene._painter) { this._webglMapScene._painter.draw() } }, _setupWebGLMap: function () { var e = this; hm.load("mapgl", function () { e._asyncRegister() }) }, _setStyle: function (i) { var e = i.style; e.overflow = "hidden"; if (cq(i).position !== "absolute") { e.position = "relative" } e.backgroundImage = "url(" + E.imgPath + "bg.png)"; e.textAlign = "left"; e.touchAction = e.MSTouchAction = "none" }, _bind: function () { var e = this; if (e._renderType !== "webgl") { e._watchSize = function () { var T = e.getContainerSize(); if (e.width !== T.width || e.height !== T.height) { var kF = (T.width - e.width) / 2; var kH = (T.height - e.height) / 2; var kC = e.getZoomUnits(); var kE = e.centerPoint; if (kE && !e.config.enableResizeOnCenter) { e.centerPoint = new cG(kE.lng + kF * kC, kE.lat - kH * kC) } e.maskLayer.style.width = (e.width = T.width) + "px"; e.maskLayer.style.height = (e.height = T.height) + "px"; var kD = new fW("onresize"); kD.size = T; e.dispatchEvent(kD); e.fire(new fW("onsize_changed")); var i = parseInt(e.platform.style.left, 10) || 0; var kG = parseInt(e.platform.style.top, 10) || 0; if (e.currentOperation !== "undefined" && e.currentOperation !== ep.idle && (e.offsetX !== i || e.offsetY !== kG)) { e._setPlatformPosition(i, kG) } } } } else { e._watchSize = function () { var i = e.getContainerSize(); if (e.width !== i.width || e.height !== i.height) { var kC = e.getSize(); e.maskLayer.style.width = (e.width = i.width) + "px"; e.maskLayer.style.height = (e.height = i.height) + "px"; if (gu() !== e.config.ratio) { e.config.ratio = gu() } var kD = new fW("onresize"); kD.size = i; e.dispatchEvent(kD); var T = new fW("onsize_changed"); T.size = i; T.oldSize = kC; e.fire(T) } } } if (e.config.enableAutoResize) { e.temp.autoResizeTimer = setInterval(e._watchSize, 16) } this.on("size_changed", function () { var i = e.getMinZoom(); if (e.zoomLevel < i) { e.setZoomIn(i, { noAnimation: true }) } }); this.on("zoom_changed", function () { this.dispatchEvent(new fW("onzooming")) }) }, addControl: function (e) { if (e && b0(e._i)) { e._i(this); this.dispatchEvent(new fW("onaddcontrol", e)) } }, removeControl: function (e) { if (e && b0(e.remove)) { e.remove(); this.dispatchEvent(new fW("onremovecontrol", e)) } }, hideEarthBoundary: function () { this.earthBoundary = false }, showEarthBoundary: function () { this.earthBoundary = true }, addContextMenu: function (i, e) { if (i) { i.initialize(this, e); this.dispatchEvent(new fW("onaddcontextmenu", i)) } }, removeContextMenu: function (e) { if (e) { this.dispatchEvent(new fW("onremovecontextmenu", e)); e.remove() } }, addDistrictLayer: function (e) { if (e) { e.initialize(this) } }, removeDistrictLayer: function (e) { if (e) { e.removeDistrict(this, e) } }, addCustomHtmlLayer: function (e) { if (e) { e.initialize(this) } }, removeCustomHtmlLayer: function (e) { if (e) { e.removeLayer(e) } }, addParkingSpot: function (e) { if (e) { e.initialize(this) } }, removeParkingSpot: function (e) { if (e) { e.removeParkingSpot() } }, addOverlay: function (i) { if (i && b0(i._i)) { var T = new fW("onbeforeaddoverlay", i); T.overlay = i; this.dispatchEvent(T); i._i(this); T = new fW("onaddoverlay", i); T.overlay = i; this.dispatchEvent(T) } }, removeOverlay: function (i) { if (i && b0(i.remove)) { if (i instanceof cs) { if (this.stencil) { this.stencil = null } } var T = new fW("onremoveoverlay", i); T.overlay = i; i.remove(); this.dispatchEvent(T) } }, addFocusMask: function (e) { if (e instanceof i3) { jg.addFocusMask(e) } if (e instanceof Array) { for (var T = 0; T < e.length; T++) { if (e[T] instanceof i3) { jg.addFocusMask(e[T]) } } } this._drawFrame() }, removeFocusMask: function (e) { if (e instanceof i3) { jg.removeFocusMask(e) } if (e instanceof Array) { for (var T = 0; T < e.length; T++) { if (e[T] instanceof i3) { jg.removeFocusMask(e[T]) } } } this._drawFrame() }, clearFocusMasks: function () { jg.removeFocusMask(); this._drawFrame() }, clearOverlays: function () { this.dispatchEvent(new fW("onclearoverlays")) }, addTileLayer: function (kD) { if (!kD) { return } if (kD instanceof dB || kD instanceof ek) { if (kD.layer) { kD = kD.layer } else { return } } for (var kC = 0, e = this.tileMgr.tileLayers.length; kC < e; kC++) { var T = this.tileMgr.tileLayers[kC]; if (T === kD || T.getMapType() === kD.getMapType()) { return } } kD.initialize(this); this.dispatchEvent(new fW("onaddtilelayer", kD)) }, removeTileLayer: function (e) { if (e) { if (e instanceof dB || e instanceof ek) { if (e.layer) { e = e.layer } else { return } } e.remove(); this.dispatchEvent(new fW("onremovetilelayer", e)) } }, addNormalLayer: function (e) { if (!e || !(e instanceof cv)) { return } this.dispatchEvent(new fW("onaddnormallayer", e)) }, removeNormalLayer: function (e) { if (e && e instanceof cv) { this.dispatchEvent(new fW("onremovenormallayer", e)) } }, addGeoJSONLayer: function (e) { if (e && e instanceof aQ) { e.init(this) } }, removeGeoJSONLayer: function (e) { if (e && e instanceof aQ) { e.remove() } }, getTileLayer: function (e) { if (this.tileMgr) { return this.tileMgr.getTileLayer(e) } return null }, setMapType: function (e) { var i = this; if (this.mapType === e || this._mapTypeChanging) { return } if (e === BMAP_EARTH_MAP && !this.config.enableEarth) { return } if (this._earth && this._earth.getLock()) { return } this._mapTypeChanging = true; this.preMapType = this.mapType; this._boundsInPreMapType = this.getBoundsIn(); if (this.preMapType === BMAP_SATELLITE_MAP) { this._preStreetLayerShow = this._isHybridShow } if (e === BMAP_EARTH_MAP) { if (i.config.earthOpacity !== null) { i._webglPainter && (i._webglPainter._canvas.style.opacity = 0) } if (!bG.Earth) { hm.load("earth", function () { i._syncAndChangeMapType(e) }); return } i._syncAndChangeMapType(e) } else { if (this.preMapType !== BMAP_EARTH_MAP) { this._changeFlatMapType(e); this._mapTypeChanging = false } else { this._setMapTypeStatus(e, function (T, kC) { var kD = i._earth.getEarthCanvas(); i._changeFlatMapType(e, this.preMapType); if (i._mapTypeChangAni) { i._mapTypeChangAni.stop() } i._mapTypeChangAni = dx.start({ el: kD, style: "opacity", startValue: 1, endValue: 0, duration: 200, callback: function () { i._mapTypeChangAni = null; i._mapTypeChanging = false; if (i.config.earthOpacity !== null) { i._webglPainter && (i._webglPainter._canvas.style.opacity = 1) } } }); T = jy.convertLL2MC(T); if (i._renderType === "webgl") { e9.extend(i, F.prototype); i.setCenterIn(T, { noAnimation: true }); i.setZoomIn(kC, { noAnimation: true }) } else { e9.extend(i, je.prototype); i.centerAndZoomIn(T, kC) } }) } } }, _changeFlatMapType: function (kF) { if (!kF || !ev[kF]) { return } var kN = this.preMapType; this.mapType = kF; var kC = this.getTileLayer(kN); if (kC) { this.removeTileLayer(kC) } else { if (this.tileMgr.tileLayers.length) { var kM = this.getTileLayer("B_NORMAL_MAP"); if (kM) { this.removeTileLayer(kM) } else { kM = this.getTileLayer("B_SATELLITE_MAP"); kM && this.removeTileLayer(kM) } } } this._preStreetLayerShow = this.config.showStreetLayer; if (kN === BMAP_SATELLITE_MAP && this.config.showVectorStreetLayer) { this._removeHybirdVectorMap() } else { if (kN === BMAP_SATELLITE_MAP && this._preStreetLayerShow) { this._removeHybirdMap() } } if (this.mapType !== BMAP_EARTH_MAP || this._renderType !== "webgl" || this.baseLayerAdded !== true) { if (kF !== BMAP_NONE_MAP) { var T = new ik(new cG(-21364736, -10616832), new cG(23855104, 15859712)); var kK = new o(T, "baidu", kF); var kD = new hP({ mapType: this.mapType, copyright: kK, dataType: this.mapType === BMAP_SATELLITE_MAP ? gX : h3, customLayer: this.mapType === BMAP_SATELLITE_MAP, baseLayer: true, transparentPng: false, tileTypeName: this.mapType === BMAP_SATELLITE_MAP ? "web" : "na" }); kD._isInnerLayer = true; kD.setZIndex(0); this.addTileLayer(kD); if (this._renderType === "webgl" && !this.baseLayerAdded) { this.baseLayerAdded = true } } if (this.mapType === BMAP_NONE_MAP) { hQ.sendMessage(a1(4, 3, 15), ["layer", "blank"]) } else { if (this.mapType === BMAP_SATELLITE_MAP) { hQ.sendMessage(a1(4, 3, 2), ["layer", "raster"]) } else { hQ.sendMessage(a1(4, 3, 1, 1), ["layer", "vector", "normal"]) } } } if (kF === BMAP_SATELLITE_MAP) { this._featureMgr.clearLabelOverlayData(); this._featureMgr.setLabelData([]); if (this.config.showVectorStreetLayer) { this._addHybirdVectorMap() } else { if (this._preStreetLayerShow === true || typeof this._preStreetLayerShow === "undefined") { this._addHybirdMap() } } } var kH = this.tileMgr.tileLayers; for (var kG = 0, kE = kH.length; kG < kE; kG++) { var kI = kH[kG]; var kL = kI.tilesDiv; if (!kL) { continue } if (!kI._isInnerLayer && kL.style.visibility === "hidden") { kL.style.visibility = "" } } var kJ = new fW("onmaptypechange"); kJ.zoomLevel = this.zoomLevel; kJ.mapType = kF; kJ.exMapType = kN; this.dispatchEvent(kJ) }, showStreetLayer: function (e) { if (e) { this.hideVectorStreetLayer() } e ? this._addHybirdMap() : this._removeHybirdMap() }, showVectorStreetLayer: function () { this.hideStreetLayer(); this.hideVectorStreetLayer(); this.config.showVectorStreetLayer = true; if (this.mapType === BMAP_SATELLITE_MAP || this.mapType === BMAP_NONE_MAP) { this._addHybirdVectorMap() } }, hideStreetLayer: function (e) { this._hideStreetLayerOptions = e; this._removeHybirdMap(e) }, hideVectorStreetLayer: function () { this.config.showVectorStreetLayer = false; if (this.mapType === BMAP_SATELLITE_MAP || this.mapType === BMAP_NONE_MAP) { this._removeHybirdVectorMap() } }, _addHybirdVectorMap: function () { var e = new hP({ mapType: "B_NORMAL_MAP", dataType: h3, customLayer: false, baseLayer: false, transparentPng: true, tileTypeName: "na" }); e._isInnerLayer = true; e.setZIndex(1); this.addTileLayer(e) }, _removeHybirdVectorMap: function () { var kD = this.tileMgr.tileLayers; for (var kC = 0, e = kD.length; kC < e; kC++) { var T = kD[kC]; if (T._isInnerLayer && T.mapType === "B_NORMAL_MAP") { this.removeTileLayer(T) } } }, _addHybirdMap: function () { this._isHybridShow = true; if (this.mapType === "B_EARTH_MAP") { if (this._earth) { this._earth.showStreetLayer() } return } if (this._hybridTileLayer) { this.addTileLayer(this._hybridTileLayer); var kF = new fW("onstreetlayer_show"); this.dispatchEvent(kF); return } var kD = new ik(new cG(-21364736, -10616832), new cG(23855104, 15859712)); var T = new o(kD, "", BMAP_HYBRID_MAP); var i = new hP({ copyright: T, transparentPng: true, pack: true, tileTypeName: "web" }); i._isInnerLayer = true; var kC = this.isCanvasMap(); i.getTilesUrl = function (kG, kM) { var kK = ev.B_STREET_MAP; var kL = kd("ditu", "satelliteStreet"); var kH = kL.ver; var e = kL.udt; var kJ = fc.calcLoopParam(kG.x, kM).col; var kI = kK.tileUrls[Math.abs(kG.x + kG.y) % kK.tileUrls.length] + "?qt=vtile&x=" + (kJ + "").replace(/-/gi, "M") + "&y=" + (kG.y + "").replace(/-/gi, "M") + "&z=" + kM + "&styles=sl&v=" + kH + "&udt=" + e + "&scaler=" + gu() + "&showtext=" + (kC ? 0 : 1); return kI }; this._isHybridShow = true; this.addTileLayer(i); this._hybridTileLayer = i; var kE = new fW("onstreetlayer_show"); this.dispatchEvent(kE) }, _removeHybirdMap: function (i) { this._isHybridShow = false; if (this.mapType === "B_EARTH_MAP") { if (this._earth) { this._earth.hideStreetLayer(i) } return } if (this._hybridTileLayer) { this.removeTileLayer(this._hybridTileLayer); var T = new fW("onstreetlayer_hide"); this.dispatchEvent(T) } }, isStreetLayerShow: function () { return this._isHybridShow }, getTileId: function (e, kE) { var kC = ev[this.mapType]; if (typeof kC !== "object") { return null } var T = kC.baseUnits * Math.pow(2, (kC.zoomLevelBase - kE)); var kD = parseInt(e.lng / T, 10); var i = parseInt(e.lat / T, 10); return { row: kD, column: i, level: kE } }, reset: function () { this.centerAndZoomIn(this.defaultCenter, this.defaultZoomLevel, true) }, setOptions: function (i) { i = i || {}; var kD = this; for (var kC in i) { if (i.hasOwnProperty(kC)) { var T = true; if (typeof i[kC] !== "object") { T = i[kC] !== this.config[kC] } this.config[kC] = i[kC]; if (kC === "fixCenterWhenResize") { this.config.enableResizeOnCenter = i[kC] } if (!T) { continue } switch (kC) { case "style": case "styleUrl": var e = { os: i.style.os, sv: i.style.sv }; if (kC === "style" && i.styleUrl) { break } this.fire(new fW("onstyle_willchange")); this.loadMapStyleFiles(function () { var kE = new fW("onlayer_update"); kE.name = "na"; kD.fire(kE) }, e); break; case "enableAutoResize": if (i[kC] === true) { this.enableAutoResize() } else { this.disableAutoResize() } break; case "displayOptions": this.setDisplayOptions(i[kC]); break } } } }, setPrivateStatus: function (i) { if (typeof i === "boolean") { if (this.config.privateOn !== i) { this.config.privateOn = i; var e = new fW("onlayer_update"); e.name = "na"; this.fire(e) } } }, getPrivateStatus: function () { return this.config.privateOn }, setPrivateRegions: function (kD) { if (kD && kD instanceof Array) { var kC = true; for (var T = 0; T < kD.length; T++) { if (kD[T] instanceof cV) { continue } else { kC = false; break } } if (kC) { this.config.privateRegions = kD; var e = new fW("onlayer_update"); e.name = "na"; this.fire(e) } } }, getPrivateRegions: function () { if (!this.config.privateRegions) { return null } else { return this.config.privateRegions } }, enableDragging: function () { this.config.enableDragging = true }, disableDragging: function () { this.config.enableDragging = false }, enableInertialDragging: function () { this.config.enableInertialDragging = true }, disableInertialDragging: function () { this.config.enableInertialDragging = false }, enableScrollWheelZoom: function () { this.config.enableWheelZoom = true }, disableScrollWheelZoom: function () { this.config.enableWheelZoom = false }, enableContinuousZoom: function () { this.config.enableContinuousZoom = true }, disableContinuousZoom: function () { this.config.enableContinuousZoom = false }, enableResizeOnCenter: function () { this.config.enableResizeOnCenter = true }, disableResizeOnCenter: function () { this.config.enableResizeOnCenter = false }, enableDoubleClickZoom: function () { this.config.enableDblclickZoom = true }, disableDoubleClickZoom: function () { this.config.enableDblclickZoom = false }, enableKeyboard: function () { this.config.enableKeyboard = true }, disableKeyboard: function () { this.config.enableKeyboard = false }, getSize: function () { return new jo(this.width, this.height) }, enablePinchToZoom: function () { this.config.enablePinchZoom = true }, disablePinchToZoom: function () { this.config.enablePinchZoom = false }, enableRotateGestures: function () { this.config.enableRotateGestures = true }, disableRotateGestures: function () { this.config.enableRotateGestures = false }, enableTilt: function () { this.config.enableTilt = true }, disableTilt: function () { this.config.enableTilt = false }, enableRotate: function () { this.config.enableRotate = true }, disableRotate: function () { this.config.enableRotate = false }, enableAutoResize: function () { this.config.enableAutoResize = true; this._watchSize(); if (!this.temp.autoResizeTimer) { this.temp.autoResizeTimer = setInterval(this._watchSize, 16) } }, disableAutoResize: function () { this.config.enableAutoResize = false; if (this.temp.autoResizeTimer) { clearInterval(this.temp.autoResizeTimer); this.temp.autoResizeTimer = null } }, checkResize: function () { this._watchSize() }, resize: function () { this._watchSize() }, getContainerSize: function () { return new jo(this.container.clientWidth, this.container.clientHeight) }, _getProperZoom: function (T) { if (!T) { T = this.zoomLevel } var i = this.getMinZoom(); var e = this.getMaxZoom(); var kC = false; if (T < i) { kC = true; T = i } if (T > e) { kC = true; T = e } if (this._renderType !== "webgl") { T = Math.round(T) } return { zoom: T, exceeded: kC } }, getContainer: function () { return this.container }, getZoomUnits: function (T) { if (this.mapType === BMAP_EARTH_MAP) { return Math.pow(2, 18 - this._earth.getImageZoom()) } var e = ev[this.mapType]; if (typeof e !== "object") { return null } var i = T || this.zoomLevel; return Math.pow(2, (e.zoomLevelBase - i)) }, pointToPixelIn: function (kL, kN) { if (!kL) { return } kN = kN || {}; if (this.mapType === BMAP_EARTH_MAP) { var kC; if (!kL._llPt) { kC = jy.convertMC2LL(kL); kL._llPt = kC } kC = kL._llPt; var kH = null; var T = null; if (typeof kN.zoom === "number") { var kK = this._earth; var kM = kK._getEarthZoomByImgZoom(kN.zoom); if (kM <= 3) { kH = kK._generateTmpPMatrix(kM) } T = kK._generateTmpMVMatrix(kK.getCenter(), kM) } var kD = this._earth.fromLatLngToPixel(kC, { useRound: false, isCalcOnBack: true, matrixInfo: { modelViewMatrix: T, projectionMatrix: kH } }); return kD } if ((this._heading % 360 === 0 && this._tilt === 0) || !this._webglMapCamera) { var kJ = this.getZoomUnits(kN.zoom); var kF = kN.center || this.centerPoint; var i = this.width / 2; var kE = this.height / 2; var kI = (kL.lng - kF.lng) / kJ + i; var kG = (kF.lat - kL.lat) / kJ + kE; if (kN.useRound !== false) { kI = Math.round(kI); kG = Math.round(kG) } return new fv(kI, kG) } var e = this._webglMapCamera.fromMCToScreenPixel(kL.lng, kL.lat, kN); if (kN.useRound === false) { return e } e.x = Math.round(e.x); e.y = Math.round(e.y); return e }, pixelToPointIn: function (e, kJ) { if (!e) { return } kJ = kJ || {}; if (this.mapType === BMAP_EARTH_MAP) { if (typeof kJ.zoom === "number") { var kH = this._earth; var kE = null; var T = null; var kI = kH._getEarthZoomByImgZoom(kJ.zoom); if (kI <= 3) { kE = kH._generateTmpPMatrix(kI) } T = kH._generateTmpMVMatrix(kH.getCenter(), kI) } var i = this._earth.fromPixelToLatLng(e, { matrixInfo: { modelViewMatrix: T, projectionMatrix: kE } }); if (i === null) { return null } return jy.convertLL2MC(i) } if ((this._heading % 360 !== 0 || this._tilt > 0) && this._webglMapCamera) { return this._webglMapCamera.fromScreenPixelToMC(e.x, e.y, kJ) } var kF = kJ.center || this.centerPoint; var kG = this.getZoomUnits(kJ.zoom); var kD = kF.lng + kG * (e.x - this.width / 2); var kC = kF.lat - kG * (e.y - this.height / 2); return new cG(kD, kC) }, pointToOverlayPixelIn: function (e, kC) { kC = kC || {}; var T = this.pointToPixelIn(e, { zoom: kC.zoom, center: kC.center, forLabel: true, frustumTest: true, useRound: kC.useRound }); if (!T) { return } if (kC.fixPosition && this.mapType !== "B_EARTH_MAP") { var kD = this.getSize(); var i = this.worldSize(kC.zoom); if (T.x > kD.width) { while (T.x > kD.width) { T.x -= i } } else { if (T.x < 0) { while (T.x < 0) { T.x += i } } } } if (this._renderType === "webgl") { return T } T.x -= this.offsetX; T.y -= this.offsetY; return T }, overlayPixelToPointIn: function (i, e) { if (!i) { return } var T = i.clone(); if (this._renderType !== "webgl") { T.x += this.offsetX; T.y += this.offsetY } return this.pixelToPointIn(T, e) }, getProjection: function () { return new jy() }, lnglatToMercator: function (e, kC) { var i = new cG(e, kC); var T = jy.convertLL2MC(i); return [T.lng, T.lat] }, mercatorToLnglat: function (i, e) { if (isNaN(i) || isNaN(e)) { return [] } i = parseFloat(i); e = parseFloat(e); var kC = new cG(i, e); var T = jy.convertMC2LL(kC); return [T.lng, T.lat] }, getBoundsIn: function () { if (!this._bounds) { return } var kP = arguments[0]; if (this.mapType === BMAP_EARTH_MAP && this._earth) { var kJ = this._earth.getCustomBounds(); if (!kJ) { return this.config.defaultMaxBounds } var kI = kJ.getSouthWest(); var e = kJ.getNorthEast(); if (kI.lng > e.lng) { e.lng = 180 } var k6 = jy.convertLL2MC(kI); var kW = jy.convertLL2MC(e); var kM = this.config.defaultMaxBounds; var kV = Math.max(k6.lng, kM.sw.lng); var kU = Math.max(k6.lat, kM.sw.lat); var kO = Math.min(kW.lng, kM.ne.lng); var kN = Math.min(kW.lat, kM.ne.lat); var kR = new ik(new cG(kV, kU), new cG(kO, kN)); kR.pointBottomLeft = new cG(kV, kU); kR.pointBottomRight = new cG(kO, kU); kR.pointTopLeft = new cG(kV, kN); kR.pointTopRight = new cG(kO, kN); kR.setMinMax(); kR.makeNormalizedPoint(this._earth.getHeading()); return kR } kP = kP || {}; var kD = kP.margins || [0, 0, 0, 0]; var k1 = this.pixelToPointIn({ x: kD[3], y: this.height - kD[2] }, kP); var k5 = this.pixelToPointIn({ x: this.width - kD[1], y: kD[0] }, kP); var kT = typeof kP.heading === "number" ? kP.heading : (this._heading % 360); var T = typeof kP.tilt === "number" ? kP.tilt : this._tilt; var kL = this._webglMapCamera; if ((kT === 0 && T === 0) || !kL) { this._bounds.setSouthWest(k1); this._bounds.setNorthEast(k5); this._bounds.pointBottomLeft = k1; this._bounds.pointBottomRight = new cG(k5.lng, k1.lat); this._bounds.pointTopRight = k5; this._bounds.pointTopLeft = new cG(k1.lng, k5.lat); this._bounds.setMinMax(); this._bounds.makeNormalizedPoint(kT); return this._bounds } var kS = this.pixelToPointIn({ x: kD[3], y: kD[0] }, kP); var kC = kL.getPosition(); var k7 = Math.sqrt(Math.pow(kS.lng - kC[0], 2) + Math.pow(kS.lat - kC[1], 2)); var k2 = this.getZoomUnits(); var k9 = k7 / k2; var kZ = kL._frustumSideLen; var kH = kL._fovy; if (this._projectionMatrix3D !== "ortho" && (k9 > kZ || (90 - T) < kH / 2)) { var k8 = [kS.lng - kC[0], kS.lat - kC[1]]; if ((90 - T) < kH / 2) { k8[0] = -k8[0]; k8[1] = -k8[1] } var k0 = kZ * k2; var kG = [k8[0] / k7 * k0 + kC[0], k8[1] / k7 * k0 + kC[1]]; var kX = [k5.lng - kC[0], k5.lat - kC[1]]; if ((90 - T) < kH / 2) { kX[0] = -kX[0]; kX[1] = -kX[1] } var kE = [kX[0] / k7 * k0 + kC[0], kX[1] / k7 * k0 + kC[1]]; kS.lng = kG[0]; kS.lat = kG[1]; k5.lng = kE[0]; k5.lat = kE[1] } var kQ = this.pixelToPointIn({ x: this.width - kD[1], y: this.height - kD[2] }, kP); var kY = [k1, k5, kS, kQ]; var k4 = kY[0].lng; var la = kY[0].lat; var kF = kY[0].lng; var kK = kY[0].lat; for (var k3 = 1; k3 < 4; k3++) { if (kY[k3].lng < k4) { k4 = kY[k3].lng } if (kY[k3].lng > kF) { kF = kY[k3].lng } if (kY[k3].lat < la) { la = kY[k3].lat } if (kY[k3].lat > kK) { kK = kY[k3].lat } } this._bounds.setSouthWest(new cG(k4, la)); this._bounds.setNorthEast(new cG(kF, kK)); this._bounds.pointTopLeft = kS; this._bounds.pointTopRight = k5; this._bounds.pointBottomRight = kQ; this._bounds.pointBottomLeft = k1; this._bounds.makeNormalizedPoint(kT); this._bounds.setMinMax(); return this._bounds }, getExtendBounds: function () { var T = il.getInstance("na"); var kM = this.getZoom(); var e = Math.floor(kM); var kK = T.getDataZoom(kM); kK = ck(kK, ku.minDataZoom, ku.maxDataZoom); var kE = e; var kI = T.getTileSize(kM); var kS = T.getBaseTileSize(kM); var kF = this.getBoundsIn(); if (!kF) { return } var kJ = T.getMercatorSize(kM, kK); var kP; var kL; var kU; var kQ; var kO = map.getCenterIn(); kO = fc.calcLoopCenterPoint(kO); var kC = Math.floor(kO.lng / kJ); var kV = Math.floor(kO.lat / kJ); var kT = 0; var kG = 0; kF = fc.calcLoopMapBounds(kF, kO); if (kF.ne.lng > fc._mc180X) { var kD = fc.getSpaceDistanceInPixel(kK); kT = Math.ceil(kD / kS) } if (kF.sw.lng < fc._mcM180X) { var kD = fc.getSpaceDistanceInPixel(kK); kG = Math.ceil(kD / kS) } if (kF.ne.lat > 19505879.362428114 || kF.sw.lat < -15949096.637571886) { kF.ne.lat = 19505879.362428114; kF.sw.lat = -15949096.637571886 } var kR = [Math.floor(kF.sw.lng / kJ) - kG, Math.floor(kF.sw.lat / kJ)]; var i = [Math.floor(kF.ne.lng / kJ) + kT, Math.floor(kF.ne.lat / kJ)]; kP = kR[0] - this.config.extendTiles; kL = i[0] + 1 + this.config.extendTiles; kU = kR[1] - this.config.extendTiles; kQ = i[1] + 1 + this.config.extendTiles; var kN = jy.tileToBoundRange({ col: kL, row: kQ, baseTileSize: kS, zoom: kK }); var kH = jy.tileToBoundRange({ col: kP, row: kU, baseTileSize: kS, zoom: kK }); this.mapExtendBounds = new ik(kH.LL.sw, kN.LL.ne); return this.mapExtendBounds }, isLoaded: function () { return !!this.loaded }, _getBestLevel: function (i, kL) { var kE = 0; if (this._renderType === "webgl" && !b5()) { kE = 100 } var kF = kL.margins || [10, 10, 10, 10]; var kC = kL.zoomFactor || 0; var kG = kF[1] + kF[3]; var kD = kF[0] + kF[2]; var e = this.getMinZoom(); var kK = this.getMaxZoom(); var kJ = i.toSpan(); var kI = kJ.width / (this.width - kG - kE); var kH = kJ.height / (this.height - kD - kE); var T = 18 - r(Math.max(kI, kH)); if (T < e) { T = e } if (T > kK) { T = kK } T += kC; if (this._renderType !== "webgl") { T = Math.floor(T) } return T }, getViewportIn: function (kL, kD) { if (this.mapType === BMAP_EARTH_MAP) { kL = kL || []; var kF = []; for (var kM = 0; kM < kL.length; kM++) { if (!kL[kM]) { continue } kF.push(jy.convertMC2LL(kL[kM])) } var kN = this._earth.getViewportIn(kF, kD); var kC = kN.center; var kJ = kN.zoom; var kR = jy.convertLL2MC(kC); return { center: kR, zoom: kJ } } var kH = { center: this.getCenterIn(), zoom: this.getZoom() }; if (!kL || kL.length === 0) { return kH } kD = kD || {}; var kG; if (kL instanceof ik) { kG = kL } else { var kE = kL; kG = new ik(); for (var kK = kE.length - 1; kK >= 0; kK--) { kG.extend(kE[kK]) } if (kG.isEmpty()) { return kH } } var kQ = kG.getCenter(); var e = this._getBestLevel(kG, kD); if (kD.margins) { var T = kD.margins; var kP = (T[1] - T[3]) / 2; var kI = (T[0] - T[2]) / 2; var kO = this.getZoomUnits(e); kQ.lng = kQ.lng + kO * kP; kQ.lat = kQ.lat + kO * kI } return { center: kQ, zoom: e } }, setViewportIn: function (kC, kD) { if (this.mapType === BMAP_EARTH_MAP) { var kH; if (kC && kC.center) { var T = jy.convertMC2LL(kC.center); var kF = this._earth._getEarthZoomByImgZoom(kC.zoom, T); kH = { center: T, zoom: kF } } else { kH = []; for (var kE = 0; kE < kC.length; kE++) { var kG = jy.convertMC2LL(kC[kE]); kH[kE] = new cA(kG.lat, kG.lng) } } this._earth.setViewportIn(kH, kD); return } var e; if (kC && kC.center) { e = kC } else { e = this.getViewportIn(kC, kD) } kD = kD || {}; if (this._renderType === "webgl") { this.centerAndZoomIn(e.center, e.zoom, kD); return } if (e.zoom === this.zoomLevel && kD.enableAnimation !== false) { this.panToIn(e.center, { duration: 200, callback: kD.callback }) } else { this.centerAndZoomIn(e.center, e.zoom, kD) } }, addSpots: function (T, i) { if (!T || T.length === 0) { return } i = i || {}; var kE = i.zIndex || 0; var kD = typeof i.enableMultiResponse === "undefined" ? true : !!i.enableMultiResponse; this.spotsPool = this.spotsPool || {}; var e = "sp" + (this.temp.spotsGuid++); this.spotsPool[e] = { spots: T.slice(0), zIndex: kE, enableMultiResponse: kD }; var kC = this; hm.load("hotspot", function () { kC._asyncRegister() }); return e }, getSpots: function (e) { return this.spotsPool[e] && this.spotsPool[e].spots || [] }, removeSpots: function (e) { if (!e || !this.spotsPool[e]) { return } delete this.spotsPool[e] }, clearSpots: function () { delete this.spotsPool }, getIconByClickPosition: function (i) { if (!this.config.enableIconClick || !this._spotsMgr) { return null } var e = this._spotsMgr.getSpotsByScreenPosition(i); if (e[0] && e[0].userdata) { var T = e[0].userdata; return { name: T.name, uid: T.uid, position: T.iconPoint || e[0].pt } } return null }, setBounds: function (e) { ev[this.mapType].bounds = e.clone() }, getCoordType: function () { return this.config.coordType }, getPanes: function () { return this._panes }, getInfoWindow: function () { if (this.temp.infoWin && this.temp.infoWin.isOpen()) { return this.temp.infoWin } return null }, getDistanceIn: function (kD, e) { if (!kD || !e) { return } if (kD.equals(e)) { return 0 } if (this.mapType === BMAP_EARTH_MAP) { var kC = jy.convertMC2LL(kD); var T = jy.convertMC2LL(e); return this._earth.getDistance(kC, T) } var i = jy.getDistanceByMC(kD, e); return i }, getOverlays: function () { var kE = []; var kF = this._overlays; var kD = this._customOverlays; if (kF) { for (var kC in kF) { if (kF[kC] instanceof eM) { kE.push(kF[kC]) } } } if (kD) { for (var T = 0, e = kD.length; T < e; T++) { kE.push(kD[T]) } } return kE }, getMapType: function () { return this.mapType }, getMapCoordType: function () { return this.coordType }, _asyncRegister: function () { for (var e = this.temp.registerIndex; e < bG._register.length; e++) { if (bG._register[e] instanceof Function) { bG._register[e](this) } } this.temp.registerIndex = e }, setDefaultCursor: function (e) { this.config.defaultCursor = e; if (this.platform) { this.platform.style.cursor = this.config.defaultCursor } }, getDefaultCursor: function () { return this.config.defaultCursor }, setOverlayMoveCursor: function (e) { this.config.overlayMoveCursor = e }, getOverlayMoveCursor: function () { return this.config.overlayMoveCursor }, setDraggingCursor: function (e) { this.config.draggingCursor = e }, getDraggingCursor: function () { return this.config.draggingCursor }, _syncAndChangeMapType: function (e) { hQ.sendMessage(a1(4, 250), ["earth", ""]); var i = this; if (i._renderType === "webgl" && i.getTilt() > h5.MAX_DRAG_TILT_L2) { i.setTilt(h5.MAX_DRAG_TILT_L2, { callback: function () { i._changeEarthMapType(e) } }) } else { i._changeEarthMapType(e) } }, _changeEarthMapType: function (T) { var kC = this; var kF = kC.tileMgr.tileLayers; if (this._mapTypeChangAni) { this._mapTypeChangAni.stop() } var kE; if (this._earth) { kE = this._earth.getEarthCanvas() } if (!this._earth) { this.maskLayer.style.opacity = 1; this.maskLayer.style.zIndex = 999; this.maskLayer.style.background = "#000" } this._mapTypeChangAni = new fL({ duration: 400, render: function (e) { if (!kC._earth) { return } kE.style.opacity = e }, finish: function () { for (var e = kF.length - 1, kG = e; kG >= 0; kG--) { var kI = kF[kG].tilesDiv; if (kI) { kI.style.visibility = "hidden" } if (kF[kG]._isInnerLayer && kC._renderType !== "webgl") { kC.removeTileLayer(kF[kG]) } } kC._mapTypeChangAni = null; kC._mapTypeChanging = false; function kH() { var kM = kC.getZoom() - 2; var kN = kC.getCenterIn(); var kK = jy.convertMC2LL(kN); kC._earth = new bG.Earth(kC, { center: kK, zoom: kM, showRealSunlight: kC.config.showRealSunlight, showMilkyway: kC.config.showMilkyway, earthBackground: kC.config.earthBackground }); if (kC.config && kC.config.earthMaxZoom && kC._earth) { kC._earth.setMaxZoom(kC.config.earthMaxZoom) } if (kC.config && kC.config.earthMinZoom && kC._earth) { kC._earth.setMinZoom(kC.config.earthMinZoom) } kC._proxyEarthEvents(); var kJ = kC.mapType; kC.mapType = T; var kL = new fW("onmaptypechange"); kL.zoomLevel = this.zoomLevel; kL.mapType = T; kL.exMapType = kJ; kC.dispatchEvent(kL); kC._setMapTypeStatus(T); e9.extend(kC, bG.EarthView.prototype); if (!kC._navigationCtrl && kC.config.showControls) { kC._navigationCtrl = new fb(kC) } } if (!kC._earth) { if (bG["FeatureStyle" + kC.config.style]) { kH() } else { kC.loadMapStyleFiles(function () { kH() }) } } if (parseInt(kC.maskLayer.style.opacity, 10) === 1) { setTimeout(function () { kC.maskLayer.style.zIndex = 9; kC.maskLayer.style.opacity = 0 }, 1000) } } }); if (!this._earth) { return } var i = this.mapType; this.mapType = T; var kD = new fW("onmaptypechange"); kD.zoomLevel = this.zoomLevel; kD.mapType = T; kD.exMapType = i; this.dispatchEvent(kD); kC._setMapTypeStatus(T); e9.extend(kC, bG.EarthView.prototype) }, getMapStyleId: function () { if (typeof this.config.style === "string") { return this.config.style } return this.config.mapStyleId || "custom" }, getAreaStyleId: function () { return this.config.areaStyleId || "areaStyle" }, _printLog: function (e) { var i; switch (e) { case "mapvgl": i = 249; break; case "mapvthree": i = 248; break; case "bmapdraw": i = 247; break; default: break }if (i) { hQ.sendMessage(a1(4, i), [e]) } }, _setMapTypeStatus: function (T) { var kG = arguments[1]; if (T === BMAP_EARTH_MAP) { var kE = this._earth.getEarthCanvas(); if (kE) { kE.style.display = "" } var kH = { noAnimation: true }; if (this.earthMinZoom) { this._earth.setMinZoom(this.earthMinZoom); this.earthMinZoom = undefined } if (this.earthMaxZoom) { this._earth.setMaxZoom(this.earthMaxZoom); this.earthMaxZoom = undefined } this._earth.setCenter(jy.convertMC2LL(this.centerPoint), kH); this._earth.setImageZoom(this.zoomLevel, kH); this._earth.setTilt(this.getTilt(), kH); this._earth.setHeading(this.getHeading(), kH) } else { if (this.preMapType === BMAP_EARTH_MAP && this._earth) { var kF = this._earth; var kC = kF.getMapZoom(); var kD = kF._imageRawZoom || kC; var i = kD - kC; var e = kF.getCenter(); if (this._renderType === "webgl") { this._tilt = kF.getTilt(); if (this.zoomLevel > 7) { this._heading = kF.getHeading(); kG && kG(e, kC); return } if (kF.getHeading() !== 0) { kF.setTilt(this.getTilt()); kF.setHeading(this.getHeading(), { callback: function () { kG && kG(e, kC) } }) } else { kG && kG(e, kC) } return } if (i < 0.1 && kF.getTilt() === 0 && kF.getHeading() === 0) { kG && kG(e, kC); return } kF.setTilt(0); kF.setHeading(0); kF.setZoom(kF.getZoom() - i, { callback: function () { kG && kG(e, kC) } }) } } }, _proxyEarthEvents: function () { var kD = this; var kE = this._earth; kE.on("tilesload", function (i) { kD.fire(i) }); kE.on("centerandzoom", function (i) { kD.dispatchEvent(new fW("onmoveend")); kD.dispatchEvent(new fW("onzoomend")) }); function kC(i) { kD.fire(i) } var e = ["zoomstart", "zoomend", "tilesload", "sunlighttime_change", "sunlighttime_clear", "centerandzoom", "animation_start", "animation_stop", "movestart", "moveend", "moving", "dragstart", "dragend", "dragging"]; for (var T = 0; T < e.length; T++) { kE.on(e[T], kC) } }, forceEnableEarth: function () { this.config.forceEnableEarth = true; this.config.enableEarth = df.ifEnableEarth(true); this.dispatchEvent(new fW("forceenableearth")); return this.config.enableEarth }, setLock: function (e) { if (this.mapType === BMAP_EARTH_MAP) { this._earth.setLock(e) } this._lock = e }, getLock: function () { if (this.mapType === BMAP_EARTH_MAP) { return this._earth.getLock() } return this._lock }, getEarth: function () { return this._earth }, isSupportEarth: function () { return this.config.enableEarth }, isCanvasMap: function () { return !!(this._renderType === "canvas" && this.getMapType() !== "B_EARTH_MAP") }, getCanvasMapCoordByUid: function (kD) { if (this._renderType === "webgl") { var kE = this.tileMgr.tileLayers; for (var kC = 0; kC < kE.length; kC++) { if (kE[kC].labelProcessor) { return kE[kC].labelProcessor.getLabelByUid(kD, "") } } return null } var e = this.canvas2dMapMgr._labelClick; var T = e.findLabelByUid(kD); return T ? new cG(T.iconPos.geoX, T.iconPos.geoY) : null }, loadBizData: function (i) { var e = new fW("onloadbizdata"); e.data = i; this.dispatchEvent(e) }, unloadBizData: function () { var e = new fW("onunloadbizdata"); this.dispatchEvent(e) }, zoomIn: function (e) { this.setZoomIn(this.zoomLevel + 1, { zoomCenter: e }) }, zoomOut: function (e) { this.setZoomIn(this.zoomLevel - 1, { zoomCenter: e }) }, setMaxZoom: function (e) { if (this._renderType === "webgl") { this.config.maxZoom = e <= 25 ? e : 25 } else { this.config.maxZoom = e <= 19 ? e : 19 } }, setEarthMaxZoom: function (i) { var e = i <= this.getMaxZoom() - 2 ? i : this.getMaxZoom() - 2; if (this.mapType === "B_EARTH_MAP") { this._earth.setMaxZoom(e); this.earthMaxZoom = undefined; return } this.earthMaxZoom = e }, setMinZoom: function (e) { this.config.minZoom = e >= 3 ? e : 3 }, setEarthMinZoom: function (e) { var i = e - 2 >= 1 ? e - 2 : 1; if (this.mapType === "B_EARTH_MAP") { this._earth.setMinZoom(i); this.earthMinZoom = undefined; return } this.earthMinZoom = i }, setCenterIn: function (e, i) { i = i ? i : {}; i.tilt = i.tilt ? i.tilt : this.getTilt(); i.heading = i.heading ? i.heading : this.getHeading(); this.panToIn(e, i) }, getRenderType: function () { return this._renderType }, getSolarInfo: function (kC) { kC = kC || this._initDate; var T = fI(kC); var e = jy.convertLL2MC(new cG(T[0], T[1])); var kK = e.latLng; var kF = bG.Projection.convertMC2LL(this.centerPoint); var kH = kC.getUTCHours(); var kJ = kH + 24 * kF.lng / 360; var kI = kJ - 12; var kG = kI * 60 * 0.25; var kE = Math.asin(Math.sin(iX(kF.lat)) * Math.sin(iX(kK.lat)) + Math.cos(iX(kF.lat)) * Math.cos(iX(kK.lat)) * Math.cos(iX(kG))); var kD = Math.asin(Math.sin(iX(kG)) * Math.cos(iX(kK.lat)) / Math.cos(kE)); var i = "north"; if (kF.lat < kK.lat) { i = "south" } return { zenith: e, solarAltitude: kE, solarAzimuth: kD, centerPosition: i, position: e } }, setDisplayOptions: function (T) { if (!T) { return } for (var e in this._displayOptions) { if (this._displayOptions.hasOwnProperty(e)) { if (typeof T[e] === "boolean" || (e === "skyColors" && typeof T.skyColors === "object") || (e === "labelMargin" && typeof T.labelMargin === "number")) { this._displayOptions[e] = T[e] } } } var i = this.getMapType(); if (i === fD.NORMAL) { this.fire(new fW("ondisplayoptions_changed")) } else { if (i === fD.EARTH && this._earth) { this._earth.fire(new fW("ondisplayoptions_changed")) } } }, getHorizonPosY: function (e) { if (!e || !this._webglMapCamera) { return null } var i = this._webglMapCamera.fromMCToScreenPixel(e.lng, e.lat, { heading: 0 }); return i.y }, getIndoorInfo: function () { if (!this._indoorMgr) { return } return this._indoorMgr.getData() }, showIndoor: function (e, T) { if (this.map && this.map.parking) { this.map.parking.currentUid = e; this.map.parking.currentFloor = T } var i = new fW("onindoor_status_changed"); i.uid = e; i.floor = T; this.fire(i) }, addAreaSpot: function (e, T) { if (!e || e.length === 0) { return } T = T || {}; this.areaSpots = this.areaSpots || {}; var i = T.id || ("sp" + (this.temp.spotsGuid++)); this.areaSpots[i] = { spot: e, userData: T.userData }; var kC = this; hm.load("hotspot", function () { kC._asyncRegister() }); return i }, getAreaSpot: function (e) { if (this.areaSpots && this.areaSpots[e]) { return this.areaSpots[e] } return null }, removeAreaSpot: function (e) { if (!e || !this.areaSpots[e]) { return } delete this.areaSpots[e] }, clearAreaSpots: function () { this.areaSpots = {} }, resetSpotStatus: function () { this.fire(new fW("onspot_status_reset")) }, hightlightSpotByUid: function (e, T) { var i = new fW("onspot_highlight"); i.uid = e; i.tilePosStr = T; this.fire(i) }, setZoomIn: function (i, e) { e = e || {}; this.zoomTo(i, e.zoomCenter || null, e) }, restrictBounds: function (e) { if (e instanceof ik) { this.config.restrictBounds = e; this.restrictCenter(this.getCenterIn()); this.fire(new fW("oncenter_changed")) } }, getCurrentMaxTilt: function () { var e = this.zoomLevel; if (this.mapType === "B_EARTH_MAP") { return h5.MAX_DRAG_TILT_L2 } if (this.config.restrictCenter === false) { return h5.MAX_DRAG_TILT } if (this._projectionMatrix3D === "ortho") { return h5.MAX_DRAG_TILT } if (e >= 19) { return h5.MAX_DRAG_TILT } else { if (e <= 18) { if (e < this._enableTiltZoom) { if (e >= this._enableTiltZoom - 2) { return (1 - (this._enableTiltZoom - e) / 2) * h5.MAX_DRAG_TILT_L2 } return 0 } return h5.MAX_DRAG_TILT_L2 } else { return (h5.MAX_DRAG_TILT - h5.MAX_DRAG_TILT_L2) * (e - 18) + h5.MAX_DRAG_TILT_L2 } } }, worldSize: function (i) { var e = i || this.zoomLevel; return h5.WORLD_SIZE_MC / this.getZoomUnits(e) }, setTrafficOn: function (kC, e) { var i = this; if (kC && Number(kC) > 1) { j3.setZIndex(Number(kC)) } e = e || {}; if (e.reload) { var T = e.reloadTime || 5 * 60 * 1000; j3.reloadTimer = setInterval(function () { j3.clearCache(); var kD = new fW("onupdate"); i.fire(kD) }, T) } hQ.sendMessage(a1(4, 3, 3), ["layer", "traffic"]); this.addTileLayer(j3) }, setTrafficOff: function () { if (j3.reloadTimer) { clearInterval(j3.reloadTimer) } this.removeTileLayer(j3) }, showOverlayContainer: function () { this.setDisplayOptions({ overlay: true }) }, hideOverlayContainer: function () { this.setDisplayOptions({ overlay: false }) }, addLabelsToMapTile: function (kF, kE) { hQ.sendMessage(a1(4, 1, 4), ["instance", "custom_label"]); for (var kC = 0; kC < kF.length; kC++) { if (typeof kF[kC].type === "undefined") { kF[kC].type = "fixed" } if (typeof kF[kC].rank !== "number") { kF[kC].rank = 50000 } kF[kC].pt = kF[kC].position; kF[kC].custom = true; kF[kC].processedInZoom = 0; var T = false; for (var e = 0; e < this._customTileLabels.length; e++) { if (this._customTileLabels[e].uid === kF[kC].uid) { T = true; break } } if (!T) { this._customTileLabels.push(kF[kC]) } } var kD = new fW("onadd_tile_labels"); if (kE && kE instanceof ek) { kD.data = kF; kD.index = kE.layer.drawIndex; kD.model = "mvt" } this.dispatchEvent(kD) }, removeLabelsFromMapTile: function (kD, kC, T) { var kF = new fW("onremove_tile_labels"); if (kC && T) { kF.data = kD; kF.index = kC; kF.model = T } else { for (var kE = 0; kE < kD.length; kE++) { for (var e = 0; e < this._customTileLabels.length; e++) { if (this._customTileLabels[e].uid === kD[kE]) { this._customTileLabels.splice(e, 1); break } } } } this.dispatchEvent(kF) }, clearLabels: function (T, i) { var e = new fW("onclear_labels"); if (T && i) { e.data = []; e.index = T; e.model = i } else { this._customTileLabels.length = 0 } this.dispatchEvent(e) }, loadMapStyleFiles: function (kE, e) { this.customLoaded = false; var T = this.config.style; var kD = this.config.styleUrl; var kC = this; this._setTextRenderType(); if (typeof T === "string" && !kD) { if (bG["FeatureStyle" + T]) { this.customLoaded = true; kC.fire(new fW("onstyle_loaded")); kE(); return } bG["FeatureStyle" + T] = window.FeatureStyle; bG["iconSetInfo" + T] = window.iconSetInfo_high; bG.indoorStyle = window.indoorStyle; g4.load(E.getMapStyleFiles(T), function () { if (kC.config.style === T) { bG["FeatureStyle" + T] = window.FeatureStyle; bG["iconSetInfo" + T] = window.iconSetInfo_high; bG.indoorStyle = window.indoorStyle; kC.customLoaded = true; kC.fire(new fW("onstyle_loaded")); kE() } }) } else { hQ.sendMessage(a1(4, 1, 2), ["instance", "custom_style"]); var i = T; w.init(kC); w.getStyleJson(i, function (kG) { var kM = window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"] ? "" : eZ; var kO = bG.getGUID("custom"); var kL = kC.config.mapStyleId || 0; delete bG["customStyleInfo_" + kL]; delete bG["FeatureStyle" + kL]; kC.config.mapStyleId = kO; var kJ = {}; e9.extend(kJ, kG); var kH = Math.floor(kC.getZoom()); var kK; window["styleCbk_" + kO] = function (kP, kQ) { if (kQ !== kK || !bG["customStyleInfo_" + kO]) { return } if (typeof kP === "string") { kP = JSON.parse(kP) } w.onStyleDataBack(kP, kH, kO, kJ, kM, bG["customStyleInfo_" + kO]); kC.customLoaded = true; kC.fire(new fW("onstyle_loaded")); kE() }; bG["customStyleInfo_" + kO] = { zoomRegion: {}, zoomStyleBody: [], zoomFrontStyle: {} }; var kN = w.getStyleUrl(kG, kM, "styleCbk_" + kO, kH, e, bG["customStyleInfo_" + kO]); var kF = kN.split("?")[0]; kK = kN.split("?")[1]; if (kD) { kF = kD; kK = kF.split("?")[1] } if (!bG.iconSetInfoCustom) { var kI = E.getMapStyleFiles("default"); if (kC.config.showCustomIndoor) { kI.splice(1, 1) } else { kI.splice(1, 2) } g4.load(kI, function () { bG.iconSetInfoCustom = window.iconSetInfo_high; bG.indoorStyle = window.indoorStyle; if (kF.indexOf("jsonp") > "-1") { g4.load(kF) } else { if (bG["customStyleInfo_" + kO]) { bG["customStyleInfo_" + kO].xhr = it.post(kF, kK, window["styleCbk_" + kO], function () { kC.fire(new fW("onstyle_loaded_error")) }, function () { kC.fire(new fW("onstyle_loaded_timeout")) }) } } }) } else { if (kF.indexOf("jsonp") > "-1") { g4.load(kF) } else { if (bG["customStyleInfo_" + kO]) { bG["customStyleInfo_" + kO].xhr = it.post(kF, kK, window["styleCbk_" + kO], function () { kC.fire(new fW("onstyle_loaded_error")) }, function () { kC.fire(new fW("onstyle_loaded_timeout")) }) } } } }) } }, getFeatureStyleTags: function () { var e = []; var kD = Object.keys(bG); for (var kC = 0; kC < kD.length; kC++) { var T = kD[kC]; if (T.indexOf("FeatureStyle") > -1 && bG[T]) { e.push(T) } } return e }, setCopyrightOffset: function (kC, i) { var T = new fW("oncopyrightoffsetchange", { logo: kC, cpy: i }); this.dispatchEvent(T) }, _setTextRenderType: function (e) { if (e) { this.config.textRenderType = e; return } if (this.config.textRenderType !== null) { return } if (b5()) { this.config.textRenderType = "canvas" } else { if (typeof this.config.style === "string") { this.config.textRenderType = "image" } else { this.config.textRenderType = "canvas" } } }, destroy: function () { this._destroyed = true; this.disableAutoResize(); this.fire(new fW("ondestroy")); var e = this.config.mapStyleId || 0; delete bG["customStyleInfo_" + e]; delete bG["FeatureStyle" + e]; if (j3.reloadTimer) { clearInterval(j3.reloadTimer) } bG.BMAP_INSTANCES && (bG.BMAP_INSTANCES -= 1); if (!bG.BMAP_INSTANCES) { this.destroyStyle() } this.config = {}; this.clearSpots(); this._webGLStateId && d5.WebGLState.remove(this._webGLStateId); this.container.onselectstart = null; this.container.style.backgroundImage = ""; this.maskLayer = null; this.platform = null; hQ.kill(); jg.kill(); var i = this; setTimeout(function () { i._listeners = null; i._bounds = null; i.tileLabels = []; i._overlayMgrGL = null; i._overlayMgr = null; i._mapIcon = null; if (i._mouse) { i._mouse._drag = null; i._mouse = null } i.deepZoom = null; i.tileMgr = null; i.indexToRgb = null; i.toFormatCoords = null; i._webglMapCamera = null; i._normalLayerMgr = null; i._webglPainter = null; i._webglMapScene = null; i._indoorMgr = null; if (i._renderType === "webgl") { i._spotsMgr = null; i._workerMgr = null; i.jobScheduler = null; i.benchmark = null; i._featureMgr = null; i._labelProcessor = null; i._customLabelMgr = null } if (i.cpyCtrl) { i.cpyCtrl._map = null; i.cpyCtrl = null } i.logoCtrl = null; i._spotDataOnCanvas = null; i._navigationCtrl = null; i.container.innerHTML = ""; if (!bG.BMAP_INSTANCES) { window.FeatureStyle = null; window.iconSetInfo_high = null; window.indoorStyle = null; window._indoorMgr = null } }, 600) }, destroyStyle: function () { var e = []; var kD = Object.keys(bG); for (var kC = 0; kC < kD.length; kC++) { var T = kD[kC]; if (T.indexOf("FeatureStyle") > -1 || T.indexOf("iconSetInfo") > -1 || T.indexOf("indoorStyle") > -1) { e.push(T) } } for (var kC = 0; kC < e.length; kC++) { delete bG[e[kC]] } }, centerAndZoom: function (e, kG, T) { if (Object.prototype.toString.call(kG) !== "[object Undefined]") { kG = parseInt(kG, 10) } if (typeof e === "string") { var kD = this; var kF = new bo(); var kC = new cG(120.139406, 30.259097); kF.getPoint(e, function (kH) { if (kH && kH.lng && kH.lat) { e = kH; var kI = jy.convertLL2MC(e); kD.centerAndZoomIn(kI, kG, T) } else { var kI = jy.convertLL2MC(kC); kD.centerAndZoomIn(kI, kG, T); console.error("您好，城市名初始化地图使用地址解析服务，请检查该服务是否已超配额。") } }, e) } else { var kE = gb(e, this.config.coordType); var i = jy.convertLL2MC(kE); this.centerAndZoomIn(i, kG, T) } }, pointToPixel: function (e, T) { var i = jy.convertLL2MC(e); var kC = {}; e9.extend(kC, T); if (kC && kC.center) { kC.center = jy.convertLL2MC(kC.center) } return this.pointToPixelIn(i, kC) }, pixelToPoint: function (T, i) { var kC = {}; e9.extend(kC, i); if (kC && kC.center) { kC.center = jy.convertLL2MC(kC.center) } var e = this.pixelToPointIn(T, kC); return jy.convertMC2LL(e) }, pointToOverlayPixel: function (e, T) { var e = gb(e, this.config.coordType); var i = jy.convertLL2MC(e); var kC = {}; e9.extend(kC, T); if (kC && kC.center) { kC.center = jy.convertLL2MC(kC.center) } return this.pointToOverlayPixelIn(i, kC) }, overlayPixelToPoint: function (T, i) { var kC = {}; e9.extend(kC, i); if (kC && kC.center) { kC.center = jy.convertLL2MC(kC.center) } var e = this.overlayPixelToPointIn(T, kC); return jy.convertMC2LL(e) }, setViewport: function (T, kC) { var e; if (T && T.center) { e = {}; e9.extend(e, T); e.center = jy.convertLL2MC(e.center) } else { e = []; for (var kD = 0; kD < T.length; kD++) { e[kD] = jy.convertLL2MC(T[kD]) } } this.setViewportIn(e, kC) }, getViewport: function (kE, kC) { var T; if (kE && kE.length) { T = []; for (var kD = 0; kD < kE.length; kD++) { T[kD] = jy.convertLL2MC(kE[kD]) } } else { if (kE instanceof ik) { T = new ik(jy.convertLL2MC(kE.getSouthWest()), jy.convertLL2MC(kE.getNorthEast())); T.setMinMax() } } var e = this.getViewportIn(T, kC); e.center = jy.convertMC2LL(e.center); return e }, getDistance: function (kD, T) { var i = jy.convertLL2MC(kD); var kC = jy.convertLL2MC(T); var e = this.getDistanceIn(i, kC); return e }, setCenter: function (e, T) { if (typeof e === "string") { var kC = this; var kE = new bo(); kE.getPoint(e, function (kF) { if (kF) { e = gb(kF, BMapGL.coordType) } else { e = kC.defaultPoint; console.error("您好，城市名初始化地图使用地址解析服务，请检查该服务是否已超配额。") } var kG = jy.convertLL2MC(e); kC.setCenterIn(kG, T) }, e) } else { var kD = gb(e, this.config.coordType); var i = jy.convertLL2MC(kD); this.setCenterIn(i, T) } }, setZoom: function (T, e) { var i = {}; e9.extend(i, e); if (i && i.zoomCenter) { i.zoomCenter = jy.convertLL2MC(i.zoomCenter) } this.setZoomIn(T, i) }, flyTo: function (e, kD, T) { var kC = gb(e, this.config.coordType); var i = jy.convertLL2MC(kC); this.flyToIn(i, kD, T) }, panTo: function (e, T) { var i = jy.convertLL2MC(gb(e, BMapGL.coordType)); this.panToIn(i, T) }, getCenter: function () { var e = this.getCenterIn(); var i = jy.convertMC2LL(e); return js(i, this.config.coordType) }, getBounds: function () { var e = this.getBoundsIn(); var i = new ik(jy.convertMC2LL(e.getSouthWest()), jy.convertMC2LL(e.getNorthEast())); return i }, setMapStyleV2: function (e) { if (typeof e === "string") { this._setTextRenderType("image") } else { this._setTextRenderType("canvas") } this.setOptions({ style: e }) }, startViewAnimation: function (T) { var e = T._options.delay; var i = this; setTimeout(function () { T._start(i) }, e) }, pauseViewAnimation: function (e) { e._pause(this) }, continueViewAnimation: function (e) { e._continue(this) }, cancelViewAnimation: function (e) { e._cancel(this) }, getMapScreenshot: function () { return this._webglMapScene._painter._canvas.toDataURL() }, setCustomArea: function (i) { this.fire(new fW("onstyle_willchange")); this.areaCustomLoaded = false; var T = i.style; var kC = this; w.getStyleJson(T, function (kE) { var kJ = window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"] ? "" : eZ; var kL = bG.getGUID("customArea"); kC.config.areaStyleId = kL; var kH = {}; e9.extend(kH, kE); var kF = Math.floor(kC.getZoom()); var kI; window["styleCbk_" + kL] = function (kN, kO) { if (kO !== kI || !bG["customStyleInfo_" + kL]) { return } if (typeof kN === "string") { kN = JSON.parse(kN) } w.onStyleDataBack(kN, kF, kL, kH, kJ, bG["customStyleInfo_" + kL]); kC.areaCustomLoaded = true; kC.fire(new fW("onstyle_loaded")); var kM = new fW("onlayer_update"); kM.name = "na"; kC.fire(kM) }; bG["customStyleInfo_" + kL] = { zoomRegion: {}, zoomStyleBody: [], zoomFrontStyle: {} }; var kK = w.getStyleUrl(kE, kJ, "styleCbk_" + kL, kF, "", bG["customStyleInfo_" + kL]); var kD = kK.split("?")[0]; kI = kK.split("?")[1]; var kG = E.getMapStyleFiles("default"); if (kD.indexOf("jsonp") > "-1") { g4.load(kD) } else { bG["customStyleInfo_" + kL].xhr = it.post(kD, kI, window["styleCbk_" + kL]) } }); var e = {}; if (i.area) { e.area = i.area.map(function (kD) { return jy.convertLL2MC(kD) }) } e.customArea = true; this._workerMgr.setWorkerConfig(e) }, setProjectionMatrix3D: function (e) { this._projectionMatrix3D = e; this._webglMapCamera._updateProjectionMatrix(); this._drawFrame() } }); window.BMAP_NORMAL_MAP = "B_NORMAL_MAP"; window.BMAPGL_NORMAL_MAP = "B_NORMAL_MAP"; window.BMAP_SATELLITE_MAP = "B_SATELLITE_MAP"; window.BMAP_HYBRID_MAP = "B_STREET_MAP"; window.BMAP_EARTH_MAP = "B_EARTH_MAP"; window.BMAP_NONE_MAP = "B_NONE_MAP"; window.BMAP_COORD_MERCATOR = "BMAP_COORD_MERCATOR"; window.BMAP_COORD_GCJ02 = "BMAP_COORD_GCJ02"; window.BMAP_COORD_BD09 = "BMAP_COORD_BD09"; window.BMAP_COORD_GCJ02MERCATOR = "BMAP_COORD_GCJ02MERCATOR"; window.BMAP_COORD_WGS84 = "BMAP_COORD_WGS84"; window.BMAP_COORD_EPSG3857 = "BMAP_COORD_EPSG3857"; window.BMAP_SYS_DRAWER = 0; window.BMAP_SVG_DRAWER = 1; window.BMAP_VML_DRAWER = 2; window.BMAP_CANVAS_DRAWER = 3; var w = { environment: "jsapi", map: null, ontilesloaded: false, onstyle_loaded: false, init: function (i) { var e = this; e.map = i; this.changeCopyright(); this.setEnvironment(e.map.config.style); this.resetEventListener() }, resetEventListener: function () { var e = this; this.ontilesloaded = false; this.onstyle_loaded = false; e.map.addEventListener("ontilesloaded", e.checkLoadedStatus); e.map.addEventListener("onstyle_loaded", e.checkLoadedStatus) }, checkLoadedStatus: function (i) { w[i.type] = true; if (w.ontilesloaded && w.onstyle_loaded) { this.dispatchEvent(new fW("onstylechangetilesloaded")); this.removeEventListener("ontilesloaded", w.checkLoadedStatus); this.removeEventListener("onstyle_loaded", w.checkLoadedStatus) } }, changeCopyright: function () { var e = this; if (e.map.cpyCtrl) { e.map.cpyCtrl.hide(); if (e.environment !== "customEditor") { e.map.setCopyrightOffset(new jo(1, 1)) } } else { e.map.addEventListener("oncopyrightaddend", function () { e.map.cpyCtrl.hide(); if (e.environment !== "customEditor") { e.map.setCopyrightOffset(new jo(1, 1)) } }) } }, setEnvironment: function (e) { if (e.customEditor) { this.environment = "customEditor"; a2.map = this.map } else { if (e.sharing) { this.environment = "sharing" } else { if (e.preview) { this.environment = "preview" } else { this.environment = "jsapi" } } } }, getStyleJson: function (kC, kE) { var kD = this; if (kC.styleJson) { kE && kE(kC.styleJson) } else { if (kC.styleId) { var i = kC.styleId; var e = (Math.random() * 100000).toFixed(0); bG["_cbk_si_phpui" + e] = function (kG) { var kF = []; if (kG.result && kG.result["error"] === 0 && kG.content && kG.content["status"] === 0) { kF = kD.parseJson(kG.content["data"]["json"]); kE && kE(kF) } else { kE && kE("default") } }; bG["_cbk_si_api" + e] = function (kG) { var kF = []; if (kG.status === 0) { if (kG.info) { kF = kD.parseJson(kG.info["json"]) } else { kF = kD.parseJson(kG.data["json"]) } kE && kE(kF) } else { kE && kE("default") } }; var T = ""; switch (this.environment) { case "jsapi": if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { T = window._BMapSecurityConfig["serviceHost"] + "?qt=custom_map&v=3.0&style_id=" + i + "&type=publish" } else { T = eG.apiHost + "/?qt=custom_map&v=3.0&style_id=" + i + "&type=publish&ak=" + eZ } T += "&callback=" + fF + "._cbk_si_phpui" + e; break; case "sharing": T += "/apiconsole/custommap/getSharingJson"; T += "?styleid=" + i + "&type=edit"; T += "&ck=" + fF + "._cbk_si_api" + e; break; case "preview": T += "/apiconsole/custommap/getJson"; T += "?styleid=" + i + "&type=edit"; T += "&ck=" + fF + "._cbk_si_api" + e; break }g4.load(T) } else { kE && kE("default") } } }, parseJson: function (T) { if (T === null || T === "") { return [] } var i = { t: "featureType", e: "elementType", v: "visibility", c: "color", o: "opacity", l: "lightness", s: "saturation", w: "weight", z: "level", h: "hue", f: "fontsize", zri: "curZoomRegionId", zr: "curZoomRegion", i: "image" }; var kD = { all: "all", g: "geometry", "g.f": "geometry.fill", "g.s": "geometry.stroke", l: "labels", "l.t.f": "labels.text.fill", "l.t.s": "labels.text.stroke", "l.t": "labels.text", "l.i": "labels.icon", "g.tf": "geometry.topfill", "g.sf": "geometry.sidefill", t: "texture" }; var kC = T.split(","); var e = kC.map(function (kH) { var kG = kH.split("|").map(function (kN) { var kL = i[kN.split(":")[0]]; var kK = kD[kN.split(":")[1]] ? kD[kN.split(":")[1]] : kN.slice(kN.indexOf(":") + 1, kN.length); switch (kK) { case "poi": kK = "poilabel"; break; case "districtlabel": kK = "districtlabel"; break }var kM = {}; kM[kL] = kK; return kM }); var kE = kG[0]; var kJ = 1; if (kG[1]["elementType"]) { kJ = 2; e9.extend(kE, kG[1]) } var kI = {}; for (var kF = kJ; kF < kG.length; kF++) { e9.extend(kI, kG[kF]) } return e9.extend(kE, { stylers: kI }) }); return e }, getStyleUrl: function (i, kF, kD, T, kC, kH) { this.styleJson = i; if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var e = window._BMapSecurityConfig["serviceHost"] + "custom/v2/mapstyle?version=" + 4 + "&qt=custom_v2&is_all=true&is_new=1&" } else { var e = E.apiHost + "/custom/v2/mapstyle?version=" + 4 + "&ak=" + kF + "&qt=custom_v2&is_all=true&is_new=1&" } var kG = this.styleJson2styleStringV2(i, T, kH); e += "styles=" + encodeURIComponent(kG); if (kC && kC.os && kC.sv) { e += "&os=" + kC.os + "&sv=" + kC.sv } var kE = new Date()["getTime"](); e += "&timeStamp=" + kE; e += jL()(e); return e }, styleJson2styleStringV2: function (e, kK, kG) { var kL = { featureType: "t", elementType: "e", visibility: "v", color: "c", opacity: "o", lightness: "l", saturation: "s", weight: "w", level: "z", hue: "h", fontsize: "f", image: "i" }; var kM = { all: "all", geometry: "g", "geometry.fill": "g.f", "geometry.stroke": "g.s", labels: "l", "labels.text.fill": "l.t.f", "labels.text.stroke": "l.t.s", "labels.text": "l.t", "labels.icon": "l.i", "geometry.topfill": "g.tf", "geometry.sidefill": "g.sf", texture: "t" }; var kN = []; for (var kC = this.map.getMinZoom(); kC <= this.map.getMaxZoom(); kC++) { kG.zoomFrontStyle[kC] = {} } kG.zoomFrontStyle.main = {}; var T = false; for (var kC = 0; !!e[kC]; kC++) { var kJ = e[kC]; if (this.isOnlyZoomStyler(kJ)) { continue } kK = this.getFrontZoom(kJ, kK); if ((kJ.featureType === "land" || kJ.featureType === "all" || kJ.featureType === "background") && typeof kJ.elementType === "string" && (kJ.elementType === "geometry" || kJ.elementType === "texture" || kJ.elementType === "geometry.fill" || kJ.elementType === "all") && kJ.stylers && !T) { if (kJ.stylers["color"]) { kG.bmapLandColor = kJ.stylers["color"] } if (kJ.stylers["image"]) { kG.bmapLandFillTexture = kJ.stylers["image"] } if (kJ.stylers["opacity"]) { kG.bmapLandColor = kJ.stylers["opacity"] } if (kJ.stylers["visibility"] && kJ.stylers["visibility"] === "off") { kG.bmapLandColor = "#00000000" } if (kJ.featureType === "land") { T = true } } if (kJ.featureType === "building" && typeof kJ.elementType === "string" && kJ.elementType === "geometry.fill") { kG.buildingFill = true } if (kJ.featureType === "roadarrow" && kJ.elementType === "labels.icon" && kJ.stylers) { var kH = kJ.stylers["visibility"]; kG.zoomFrontStyle[kK]["bmapRoadarrowVisibility"] = kH } var kD = {}; e9.extend(kD, kJ); var kF = kD.stylers; delete kD.stylers; e9.extend(kD, kF); var kE = []; for (var kI in kL) { if (kD[kI]) { if (this.isEditorZoomKeys(kI)) { continue } if (kI === "elementType") { kE.push(kL[kI] + ":" + kM[kD[kI]]) } else { if (kI === "image") { kE.push(kL[kI] + ":" + encodeURIComponent(encodeURIComponent(kD[kI]))) } else { switch (kD[kI]) { case "poilabel": kD[kI] = "poi"; break; case "districtlabel": kD[kI] = "label"; break }kE.push(kL[kI] + ":" + kD[kI]) } } } } if (kE.length > 2) { kN.push(kE.join("|")) } } return kN.join(",") }, getFrontZoom: function (i, e) { var T = i.stylers["level"]; if (T === undefined) { return "main" } else { return parseInt(T, 10) } }, isZoomConfig: function (e) { var i = e.stylers["level"]; if (i === undefined) { return false } else { return true } }, isOnlyZoomStyler: function (e) { var i = {}; e9.extend(i, e.stylers); delete i.curZoomRegionId; delete i.curZoomRegion; delete i.level; if (e9.isEmptyObject(i)) { return true } else { return false } }, isSelectZoom: function (i, e) { var T = i.stylers["level"]; if (T === undefined) { return true } else { if (T === e + "") { return true } else { return false } } }, isEditorZoomKeys: function (e) { var i = { curZoomRegionId: true, curZoomRegion: true }; if (i[e]) { return true } else { return false } }, getZoomRegion: function (e, i) { var kC = e.stylers["level"]; var T = {}; e9.extend(T, i); if (kC === undefined) { return T } else { T[parseInt(kC, 10)] = true; return T } }, onStyleDataBack: function (kD, e, i, kC, kF, T) { if (kD.status !== 0) { return } if (kD.data.style.length === 3) { if (!T.baseFs) { T.baseFs = kD.data.style } bG.StyleBody = kD.data.style[2] } else { bG.StyleBody = kD.data.style } var kE = T.baseFs; bG["FeatureStyle" + i] = kE; this.updateFrontFeatureStyle(T) }, updateFrontFeatureStyle: function (T) { if (T.zoomFrontStyle.main["bmapRoadarrowVisibility"]) { for (var e = this.map.getMinZoom(); e <= this.map.getMaxZoom(); e++) { if (!T.zoomFrontStyle[e]["bmapRoadarrowVisibility"]) { T.zoomFrontStyle[e]["bmapRoadarrowVisibility"] = T.zoomFrontStyle.main["bmapRoadarrowVisibility"] } } } } }; var a2 = { map: null, labelCache: {}, calcDrawMc: function (T, i, e) { var kC = []; switch (i) { case "fill": kC = this.calcFill(T, e); break; case "line": break; case "building3d": kC = this.calcBuilding3d(T, e); break }return kC }, calcFill: function (kD, T) { var kE = []; for (var kC = 0; kC < kD.length; kC = kC + 5) { var e = this.coordToMc({ x: kD[kC], y: kD[kC + 1] }, T.row, T.col, T.mercatorSize, T.baseTileSize); kE.push(e[0], e[1]) } return kE }, calcLine: function (kD, T) { var kE = []; var kF = new Int16Array(kD.buffer); for (var kC = 0; kC < kF.length; kC = kC + 10) { var e = this.coordToMc({ x: kF[kC] / 10, y: kF[kC + 1] / 10 }, T.row, T.col, T.mercatorSize, T.baseTileSize); kE.push(e[0], e[1]) } return kE }, calcBuilding3d: function (kE, T) { var kF = []; var kC = {}; for (var kD = 0; kD < kE.length / 2; kD = kD + 7) { if (kE[kD] === kE[kD - 7] && kE[kD + 1] === kE[kD - 6]) { continue } if (kC[kE[kD].toString() + kE[kD + 1].toString()]) { continue } kC[kE[kD].toString() + kE[kD + 1].toString()] = true; var e = this.coordToMc({ x: kE[kD], y: kE[kD + 1] }, T.row, T.col, T.mercatorSize, T.baseTileSize); kF.push(e[0], e[1]) } return kF }, coordToMc: function (kD, kC, e, i, T) { return [kD.x * (i / T) + e * i, kD.y * (i / T) + kC * i] }, addDrawIntoAreaSpots: function (e, kD) { if (w.environment !== "customEditor") { return } if (!kD.styleIds) { return } for (var T = 0; T < kD.styleIds.length; T++) { var kG = 0; if (T > 0) { kG = kD.verticesLength[T - 1] } end = kD.verticesLength[T]; var kE = []; var kC = ""; if (kD.vertex) { kE = kD.vertex; kC = "building3d" } else { if (kD.data[0]) { kE = kD.data[0]; kC = kD.type } else { continue } } var kF = this.calcDrawMc(kE.slice(kG, end), kC, e); this.map.addAreaSpot(kF, { userData: { styleId: kD.styleIds[T], type: "mapstyle" } }) } }, addLabelIntoAreaSpots: function (e) { if (w.environment !== "customEditor") { return } for (var kD = 0; kD < e.length; kD++) { var kE = e[kD]; for (var kC = 0; kC < kE.fixedLabel.length; kC++) { var T = kE.fixedLabel[kC]; if (!T._mcBds) { continue } var kF = [T._mcBds[0].lng, T._mcBds[0].lat, T._mcBds[0].lng, T._mcBds[1].lat, T._mcBds[1].lng, T._mcBds[1].lat, T._mcBds[1].lng, T._mcBds[0].lat]; if (!this.labelCache[kF.join()]) { this.labelCache[kF.join()] = true; this.map.addAreaSpot(kF, { userData: { styleId: T.styleId, type: "mapstyle", name: T.name } }) } } } } }; function cu(i, e, kC, T) { this.cx = 3 * i; this.bx = 3 * (kC - i) - this.cx; this.ax = 1 - this.cx - this.bx; this.cy = 3 * e; this.by = 3 * (T - e) - this.cy; this.ay = 1 - this.cy - this.by; this.p1x = i; this.p1y = T; this.p2x = kC; this.p2y = T } cu.prototype.sampleCurveX = function (e) { return ((this.ax * e + this.bx) * e + this.cx) * e }; cu.prototype.sampleCurveY = function (e) { return ((this.ay * e + this.by) * e + this.cy) * e }; cu.prototype.sampleCurveDerivativeX = function (e) { return (3 * this.ax * e + 2 * this.bx) * e + this.cx }; cu.prototype.solveCurveX = function (e, kH) { if (typeof kH === "undefined") { kH = 0.000001 } var kG; var kF; var kD; var T; var kC; for (kD = e, kC = 0; kC < 8; kC++) { T = this.sampleCurveX(kD) - e; if (Math.abs(T) < kH) { return kD } var kE = this.sampleCurveDerivativeX(kD); if (Math.abs(kE) < 0.000001) { break } kD = kD - T / kE } kG = 0; kF = 1; kD = e; if (kD < kG) { return kG } if (kD > kF) { return kF } while (kG < kF) { T = this.sampleCurveX(kD); if (Math.abs(T - e) < kH) { return kD } if (e > T) { kG = kD } else { kF = kD } kD = (kF - kG) * 0.5 + kG } return kD }; cu.prototype.solve = function (e, i) { return this.sampleCurveY(this.solveCurveX(e, i)) }; var gS = {}; function fL(T) { var e = { duration: 1000, fps: 30, delay: 0, transition: gS.linear, dropLastAnimation: false }; if (T) { for (var kC in T) { e[kC] = T[kC] } } if (T.beginTime) { this._beginTime = T.beginTime } this._callbacks = []; this._options = e; if (e.delay) { var kD = this; setTimeout(function () { kD._doStart() }, e.delay) } else { this._doStart() } this._pauseTime = 0 } fL.INFINITE = "INFINITE"; fL.prototype._doStart = function () { if (this._isPausing) { var e = performance.now() || new Date().getTime(); this._pauseTime += e - this._isPausing; this._isPausing = undefined } if (window.requestAnimationFrame) { var i = this; i._timer = window.requestAnimationFrame(function (T) { i._loop(T) }) } else { this._beginTime = new Date().getTime(); if (this._options.duration === fL.INFINITE) { this._endTime = null } else { this._endTime = this._beginTime + this._options.duration } this._loop() } }; fL.prototype._loop = function (kC) { var kF = this; kC = kC || new Date().getTime(); kC = kC - this._pauseTime; if (!this._beginTime) { this._beginTime = kC } if (!this._endTime && typeof this._options.duration === "number") { this._endTime = this._beginTime + this._options.duration } if (kF._endTime !== null && kC >= kF._endTime) { if (kF._options.dropLastAnimation === false) { kF._options.render(kF._options.transition(1), 1, kC) } if (typeof kF._options.finish === "function") { kF._options.finish(kC, this) } for (var kE = 0, e = kF._callbacks.length; kE < e; kE++) { kF._callbacks[kE]() } return } var kD; if (typeof kF._options.duration === "number") { kD = (kC - kF._beginTime) / kF._options.duration; kF.schedule = kF._options.transition(kD) } else { kD = kC - kF._beginTime; kF.schedule = 0 } kF._options.render(kF.schedule, kD, kC); if (!kF.terminative) { if (window.requestAnimationFrame) { kF._timer = requestAnimationFrame(function T(i) { kF._loop(i) }) } else { kF._timer = setTimeout(function () { kF._loop() }, 1000 / kF._options.fps) } } }; fL.prototype.stop = function (i, e) { this.terminative = true; if (this._timer) { if (window.cancelAnimationFrame) { cancelAnimationFrame(this._timer) } else { clearTimeout(this._timer) } this._timer = null; if (typeof this._options.onStop === "function") { this._options.onStop(e) } } if (i) { this._endTime = this._beginTime; this._loop() } }; fL.prototype.pause = function () { if (!this._isPausing) { this.stop(); this.terminative = undefined; this._isPausing = performance.now() || new Date().getTime() } }; fL.prototype.cancel = function () { this.stop() }; fL.prototype.append = function (e) { this._callbacks.push(e); return this }; gS = { _p1: 1, _p2: 1 * 1.525, linear: function (e) { return e }, reverse: function (e) { return 1 - e }, easeInQuad: function (e) { return e * e }, easeInCubic: function (e) { return Math.pow(e, 3) }, easeInBiquad: function (e) { return Math.pow(e, 4) }, easeInBack: function (e) { return e * e * ((gS._p1 + 1) * e - gS._p1) }, easeOutQuad: function (e) { return -(e * (e - 2)) }, easeOutCubic: function (e) { return Math.pow((e - 1), 3) + 1 }, easeOutBiquad: function (e) { return 1 - Math.pow((e - 1), 4) }, easeOutBack: function (e) { return ((e = e - 1) * e * ((gS._p1 + 1) * e + gS._p1) + 1) }, easeInOutQuad: function (e) { if (e < 0.5) { return e * e * 2 } else { return -2 * (e - 2) * e - 1 } }, easeInOutCubic: function (e) { if (e < 0.5) { return Math.pow(e, 3) * 4 } else { return Math.pow(e - 1, 3) * 4 + 1 } }, easeInOutBiquad: function (e) { if (e < 0.5) { return Math.pow(e, 4) * 8 } else { return 1 - (Math.pow(e - 1, 4) * 8) } }, easeInOutSine: function (e) { return (1 - Math.cos(Math.PI * e)) / 2 } }; gS.ease = (function () { var e = new cu(0.4, 0, 0.6, 1); return function (i) { return e.solve(i) } })(); gS["ease-in"] = gS.easeInQuad; gS["ease-out"] = gS.easeOutQuad; var dx = { start: function (kI) { var kC = kI.el; var e = kI.style; var i = kI.startValue; var kF = kI.endValue; var kD = kI.duration || 1400; var kE = kI.transition || gS.linear; var kH = kI.callback; var kG = kF - i; var T = kI.unit || ""; return new fL({ fps: 60, duration: kD, transition: kE, render: function (kJ) { kC.style[e] = i + kG * kJ + T }, finish: function () { kH && kH() } }) } }; function s(kD, T) { dh.call(this); this.keyframes = kD; var e = { duration: 1000, delay: 0, transition: gS.linear, interation: 1 }; if (T) { for (var kC in T) { e[kC] = T[kC] } } this._options = e } s.inherits(dh, "ViewAnimation"); s.prototype._start = function (kE) { var T = this; T.map = kE; var kD = new fW("onanimationstart"); T.dispatchEvent(kD); this._initStatus(T.map); var kC = this._options.duration; var i = this._options.interation; var kF = this._options.transition; var kG = 0; T.poiStatus = T.map._displayOptions.poi; if (T.poiStatus) { T.map.setDisplayOptions({ poi: false }) } T.map.viewAnimationTime = new Date().getTime(); this.animation = new fL({ duration: kC, transition: kF, start: function (e) { }, render: function (kH, e) { if (kH === 0) { T._initStatus(T.map) } else { T._setViewByRate(kH) } }, finish: function (kI, kH) { if (++kG < i || i === "INFINITE") { var kJ = new fW("onanimationiterations"); T.dispatchEvent(kJ); delete kH._beginTime; delete kH._endTime; kH._doStart() } else { var kJ = new fW("onanimationend"); T.dispatchEvent(kJ); delete T.map.viewAnimationTime; T.map.setDisplayOptions({ poi: T.poiStatus }) } } }) }; s.prototype._getTotalDuration = function (e, i) { if (e === fL.INFINITE) { return fL.INFINITE } else { return e * i } }; s.prototype._initStatus = function (e) { if (this.keyframes[0]) { e.setCenter(this.keyframes[0].center, { noAnimation: true }); e.setZoom(this.keyframes[0].zoom, { noAnimation: true }); e.setTilt(this.keyframes[0].tilt, { noAnimation: true }); e.setHeading(this.keyframes[0].heading, { noAnimation: true }) } }; s.prototype._setViewByRate = function (kC) { for (var e = 0; e < this.keyframes.length - 1; e++) { var kD = this.keyframes[e]; var T = this.keyframes[e + 1]; if (kC >= kD.percentage && kC < T.percentage) { this.map.setHeading(this._getHeadingDelta(kD, T, kC), { noAnimation: true }); this.map.setTilt(this._getTiltDelta(kD, T, kC), { noAnimation: true }); this.map.setCenter(this._getCenterDelta(kD, T, kC), { noAnimation: true }); this.map.setZoom(this._getZoomDelta(kD, T, kC), { noAnimation: true }) } } }; s.prototype._getHeadingDelta = function (T, i, e) { var kD = (e - T.percentage) / (i.percentage - T.percentage); var kC = T.heading + (i.heading - T.heading) * kD; return kC }; s.prototype._getTiltDelta = function (T, i, e) { var kD = (e - T.percentage) / (i.percentage - T.percentage); var kC = T.tilt + (i.tilt - T.tilt) * kD; return kC }; s.prototype._getCenterDelta = function (T, i, e) { var kD = (e - T.percentage) / (i.percentage - T.percentage); var kC = T.center.add(i.center.sub(T.center).mult(kD)); return kC }; s.prototype._getZoomDelta = function (kC, T, i) { var kD = (i - kC.percentage) / (T.percentage - kC.percentage); var e = kC.zoom + (T.zoom - kC.zoom) * kD; return e }; s.prototype._pause = function (e) { this.animation.pause() }; s.prototype._continue = function (e) { this.animation._doStart() }; s.prototype._cancel = function (T) { T.setDisplayOptions({ poi: this.poiStatus }); this.animation.cancel(); delete T.viewAnimationTime; var i = new fW("onanimationcancel"); this.dispatchEvent(i) }; var cR = undefined; var fG = { is64Bit: function () { if (/Windows/.test(navigator.userAgent)) { if (/Win64; x64/.test(navigator.userAgent)) { return true } else { if (/WOW64/.test(navigator.userAgent)) { return true } else { return false } } } return true }, isIOS112: function ba(e) { return /11_2/.test(navigator.userAgent) }, canUseWebAssembly: function (i) { if (cR !== undefined) { i && i(cR); return } if (window.WebAssembly && this.is64Bit()) { if (window.disableWebAssembly === true) { cR = false; i && i(cR) } else { if (!cC()) { cR = true; i && i(cR) } else { if (this.isIOS112()) { cR = false; i && i(cR) } else { var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]); WebAssembly.instantiate(e).then(function (T) { cR = true; i && i(cR) }, function (T) { cR = false; i && i(cR) }) } } } } else { cR = false; i && i(cR) } } }; var aL = {}; bG.Utils = aL; function kt(e) { return e.style } function im(i) { if (e9.Browser.ie > 0) { i.unselectable = "on"; i.selectstart = function () { return false }; i.onmousedown = function (T) { T.preventDefault(); return false } } else { var e = kt(i); e.MozUserSelect = "none"; e.WebkitUserSelect = "none"; i.addEventListener("mousedown", function (T) { T.preventDefault() }, false) } } function aV(e) { return e && e.parentNode && e.parentNode.nodeType !== 11 } function bS(i, e) { if (!i) { return null } i.insertAdjacentHTML("beforeEnd", e); return i.lastChild } function f1(T, i) { var kC = document.createElement("div"); kC.innerHTML = i; var e = kC.childNodes[0]; return T.parentNode.insertBefore(e, T) } function al(i) { i = i || window.event; i.stopPropagation ? i.stopPropagation() : i.cancelBubble = true } function d(i) { i = i || window.event; i.preventDefault ? i.preventDefault() : i.returnValue = false; return false } function hI(i) { al(i); return d(i) } function hb() { var e = document.documentElement; var i = document.body; if (e && (e.scrollTop || e.scrollLeft)) { return [e.scrollTop, e.scrollLeft] } else { if (i) { return [i.scrollTop, i.scrollLeft] } else { return [0, 0] } } } function iK(kD) { if (!kD) { return } kD.onload = kD.onerror = null; var T = kD.attributes, kC, e, kE; if (T) { e = T.length; for (kC = 0; kC < e; kC += 1) { kE = T[kC].name; if (typeof kD[kE] === "function") { kD[kE] = null } } } T = kD.children; if (T) { e = T.length; for (kC = 0; kC < e; kC += 1) { iK(kD.children[kC]) } } } function f4(i, kF, kE) { var kD = kF.lng - kE.lng; var kC = kF.lat - kE.lat; if (kD === 0) { return Math.abs(i.lng - kF.lng) } if (kC === 0) { return Math.abs(i.lat - kF.lat) } var T = kC / kD; var e = kF.lat - T * kF.lng; return Math.abs(T * i.lng - i.lat + e) / Math.sqrt(T * T + 1) } function cr(i, e) { if (!i || !e) { return } return Math.round(Math.sqrt(Math.pow(i.x - e.x, 2) + Math.pow(i.y - e.y, 2))) } function eF(i, e) { if (!i || !e) { return 0 } return Math.round(Math.sqrt(Math.pow(i.lng - e.lng, 2) + Math.pow(i.lat - e.lat, 2))) } function fV(kH, T, kD) { var kE = (kD.lng - T.lng) * (kH.lng - T.lng) + (kD.lat - T.lat) * (kH.lat - T.lat); if (kE <= 0) { return eF(kH, T) } var e = (kD.lng - T.lng) * (kD.lng - T.lng) + (kD.lat - T.lat) * (kD.lat - T.lat); if (kE >= e) { return eF(kH, kD) } var i = kE / e; var kG = T.lng + (kD.lng - T.lng) * i; var kF = T.lat + (kD.lat - T.lat) * i; const kC = { lng: kG, lat: kF }; return eF(kH, kC) } function fm(T, i) { var e = Math.round((T.x + i.x) / 2); var kC = Math.round((T.y + i.y) / 2); return new fv(e, kC) } function jJ(e, T) { var i = []; T = T || function (kD) { return kD }; for (var kC in e) { i.push(kC + "=" + T(e[kC])) } return i.join("&") } function b6(T, i, kE) { var kF = document.createElement(T); if (kE) { kF = document.createElementNS(kE, T) } i = i || {}; for (var kC in i) { var kD = { "for": "htmlFor", "class": "cssClass" }[kC] || kC; if (kC === "style") { kF.style.cssText = i[kC]; continue } if (kC === "class") { e9.ac(kF, i[kC]); continue } if (kF.setAttribute) { kF.setAttribute(kD, i[kC]) } else { try { kF[kD] = i[kC] } catch (kF) { } } } return kF } function cq(e) { if (e.currentStyle) { return e.currentStyle } else { if (e.ownerDocument && e.ownerDocument.defaultView) { return e.ownerDocument.defaultView.getComputedStyle(e, null) } } } function b0(e) { return typeof e === "function" } function gt(e) { return e === void 0 } function j0(e, i) { return Object.prototype.hasOwnProperty.call(e, i) } function h(kD, kE) { if (gt(kD.length)) { for (var kC in kD) { if (j0(kD, kC)) { kE.call(null, kC, kD[kC]) } } } else { var T = kD.length; if (T) { for (var e = 0; e < T; e++) { kE.call(null, e, kD[e]) } } } } function au(i, e) { if (!e) { return i } h(e, function (T, kC) { i[T] = kC }); return i } var hq = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; function du(kD) { var T = ""; var kK; var kI; var kG = ""; var kJ; var kH; var kF; var kE = ""; var kC = 0; var e = /[^A-Za-z0-9+/=]/g; if (!kD || e.exec(kD)) { return kD } kD = kD.replace(/[^A-Za-z0-9+/=]/g, ""); do { kJ = hq.indexOf(kD.charAt(kC++)); kH = hq.indexOf(kD.charAt(kC++)); kF = hq.indexOf(kD.charAt(kC++)); kE = hq.indexOf(kD.charAt(kC++)); kK = (kJ << 2) | (kH >> 4); kI = ((kH & 15) << 4) | (kF >> 2); kG = ((kF & 3) << 6) | kE; T = T + String.fromCharCode(kK); if (kF !== 64) { T = T + String.fromCharCode(kI) } if (kE !== 64) { T = T + String.fromCharCode(kG) } kK = kI = kG = ""; kJ = kH = kF = kE = "" } while (kC < kD.length); return T } function jH(e) { return btoa(encodeURIComponent(e)) } function gc(e) { return decodeURIComponent(atob(e)) } (function (e) { if (!e.Utils) { e.Utils = {} } var i = e.Utils; i.format = (function () { function T(kF, kE, kG) { var kD = kG[+kE]; return typeof (kD) === "function" ? kD(kE) : kD } function kC(kF, kE, kG) { var kI = kE; var kJ = []; var kD = kE.split(":"); if (kD.length === 2) { kI = kD[0]; kJ.push(kD[1]) } var kH = typeof (kG[kI]); if (kH === "function") { return kG[kI].apply(undefined, kJ) } else { if (kH === "undefined") { return kF } else { return String(kG[kI]) } } } return function (kD, kE) { var kG = kE.splice ? T : kC; var kF = kD.splice ? kD.join("") : kD; return kF.replace(/{([a-zA-Z0-9_$:.]+)}/g, function (kI, kH) { return kG(kI, kH, kE) }) } })(); i.ErrorMonitor = function (kC, T, kD) { }; fG.canUseWebAssembly(function (T) { i.canUseWebAssembly = T }) })(bG); function b5() { return (cC() || id() || fo()) } function cC() { var e = navigator.userAgent; if (e.indexOf("iPhone") > -1 || e.indexOf("iPad") > -1) { return true } return false } function id() { var e = navigator.userAgent; if (e.indexOf("Android") > -1) { return true } return false } function fo() { var e = navigator.userAgent; if (e.indexOf("Harmony") > -1) { return true } return false } function iX(e) { return e * Math.PI / 180 } function fl(e) { return e / Math.PI * 180 } function bK(e, kD) { var kC = Math.pow(10, kD); if (typeof e === "number") { return Math.round(e * kC) / kC } for (var T = 0; T < e.length; T++) { e[T] = bK(e[T], kD) } return e } function ck(T, i, e) { if (T < i) { T = i } else { if (T > e) { T = e } } return T } function eq(e, i) { while (e < 0) { e += i } return e % i } function ia(i, e) { return (i >= 0 && e >= 0) || (i < 0 && e < 0) } function O(i) { if (i._gl) { return i._gl } var e = { alpha: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, stencil: false }; var T = i.getContext("webgl", e) || i.getContext("experimental-webgl", e); i._gl = T; return T } function iU(kC, T) { for (var e = 0; e < T.length; e++) { e9.on(kC, T[e], al) } } function e3(i, T, e) { T[e] = i.getUniformLocation(T, e) } function b8(kD, kE, e, T, i) { var kC = ""; switch (i) { case "mat4": kD.uniformMatrix4fv(kE[e], false, T); return; case "v3": kC = "uniform3fv"; break; case "f": kC = "uniform1f"; break; case "i": kC = "uniform1i"; break }if (kC === "") { throw "error" } kD[kC](kE[e], T) } function hV(kK, e) { while (kK < 0) { kK += 360 } kK = kK % 360; var kC = e.width; var kJ = e.height; var kF = kC; var T = kJ; if (kK < 90) { var i = Math.sin(iX(kK)) * kC; var kH = Math.sin(iX(kK)) * kJ; var kI = Math.cos(iX(kK)) * kC; var kE = Math.cos(iX(kK)) * kJ; var kF = Math.ceil(kI + kH); var T = Math.ceil(i + kE) } else { if (kK < 180) { var kK = kK - 90; var i = Math.sin(iX(kK)) * kC; var kH = Math.sin(iX(kK)) * kJ; var kI = Math.cos(iX(kK)) * kC; var kE = Math.cos(iX(kK)) * kJ; var kF = Math.ceil(i + kE); var T = Math.ceil(kI + kH) } else { if (kK < 270) { var kK = kK - 180; var i = Math.sin(iX(kK)) * kC; var kH = Math.sin(iX(kK)) * kJ; var kI = Math.cos(iX(kK)) * kC; var kE = Math.cos(iX(kK)) * kJ; var kF = Math.ceil(kI + kH); var T = Math.ceil(i + kE) } else { var kK = kK - 270; var i = Math.sin(iX(kK)) * kC; var kH = Math.sin(iX(kK)) * kJ; var kI = Math.cos(iX(kK)) * kC; var kE = Math.cos(iX(kK)) * kJ; var kF = Math.ceil(i + kE); var T = Math.ceil(kI + kH) } } } var kG = kF - kC; var kD = T - kJ; return [0 - kG / 2, 0 - kD / 2, kC + kG / 2, kJ + kD / 2] } function cj(e) { if (e.toDataURL() === cj._blankData) { return true } return false } function Y(kD, kC, T) { var i = [T.lng - kD.lng, T.lat - kD.lat]; var e = [kC.lng - kD.lng, kC.lat - kD.lat]; return i[0] * e[1] - i[1] * e[0] } function jl(kE, kD, T) { var e; var kF; var kC; var i; if (kE.lng < kD.lng) { e = kE.lng; kC = kD.lng } else { e = kD.lng; kC = kE.lng } if (kE.lat < kD.lat) { kF = kE.lat; i = kD.lat } else { kF = kD.lat; i = kE.lat } if (T.lng < e || T.lng > kC || T.lat < kF || T.lat > i) { return false } return true } function jx(kG, kF, kE, kC) { var kD = Y(kE, kC, kG); var T = Y(kE, kC, kF); var i = Y(kG, kF, kE); var e = Y(kG, kF, kC); if (kD * T < 0 && i * e < 0) { return true } else { if (kD === 0 && jl(kE, kC, kG)) { return true } else { if (T === 0 && jl(kE, kC, kF)) { return true } else { if (i === 0 && jl(kG, kF, kE)) { return true } else { if (e === 0 && jl(kG, kF, kC)) { return true } else { return false } } } } } } function hY(T, i) { var e = i.parentNode; if (e.lastChild === i) { e.appendChild(T) } else { e.insertBefore(T, i.nextSibling) } } function d2(kI, kJ) { if (kJ === 0) { return kI } var kH = 0; var kF = 0; if (!kI) { throw "异常" } if (kI.length === 0) { return [] } for (var kD = 1, T = kI.length - 1; kD < T; kD++) { var kG = f4(kI[kD], kI[0], kI[kI.length - 1]); if (kG > kH) { kF = kD; kH = kG } } var e = []; if (kH >= kJ) { var kL = kI.slice(0, kF); var kK = kI.slice(kF, kI.length); var kE = d2(kL, kJ); var kC = d2(kK, kJ); for (var kD = 0, T = kE.length; kD < T; kD++) { e.push(kE[kD]) } for (var kD = 0, T = kC.length; kD < T; kD++) { e.push(kC[kD]) } } else { e.push(kI[0]); e.push(kI[kI.length - 1]) } return e } function iY(kC, kD) { if (kC.length < 2) { return kC } const T = [kC[0]]; for (var e = 1; e < kC.length; e++) { if (eF(T[T.length - 1], kC[e]) >= kD) { T.push(kC[e]) } } return T } function r(e) { if (Math.log2) { return Math.log2(e) } return Math.log(e) / Math.LN2 } function dl(T, i, e) { return Math.min(e, Math.max(i, T)) } function at(e, i) { if (!i) { return e } var kE = i[0]; var kD = i[1]; var kC = i[2]; var T = i[3]; var kG = []; var kF = []; kG[0] = T * e[0] + kC * e[2]; kG[1] = e[1]; kG[2] = -kC * e[0] + T * e[2]; kF[0] = kG[0]; kF[1] = kD * kG[1] - kE * kG[2]; kF[2] = kE * kG[1] + kD * kG[2]; return kF } var p = Math.PI / 180; var g3 = 180 / Math.PI; function fI(T) { var i = (T - Date.UTC(2000, 0, 1, 12)) / 86400000 / 36525; var e = (d3.utcDay.floor(T) - T) / 86400000 * 360 - 180; return [e - fy(i) * g3, d9(i) * g3] } function fy(kC) { var kD = bx(kC); var i = eh(kC); var T = iS(kC); var kE = Math.tan(iR(kC) / 2); kE *= kE; return kE * Math.sin(2 * T) - 2 * kD * Math.sin(i) + 4 * kD * kE * Math.sin(i) * Math.cos(2 * T) - 0.5 * kE * kE * Math.sin(4 * T) - 1.25 * kD * kD * Math.sin(2 * i) } function d9(e) { return Math.asin(Math.sin(iR(e)) * Math.sin(bC(e))) } function bC(e) { return kn(e) - (0.00569 + 0.00478 * Math.sin((125.04 - 1934.136 * e) * p)) * p } function kn(e) { return iS(e) + jC(e) } function eh(e) { return (357.52911 + e * (35999.05029 - 0.0001537 * e)) * p } function iS(i) { var e = (280.46646 + i * (36000.76983 + i * 0.0003032)) % 360; return (e < 0 ? e + 360 : e) / 180 * Math.PI } function jC(i) { var e = eh(i); return (Math.sin(e) * (1.914602 - i * (0.004817 + 0.000014 * i)) + Math.sin(e + e) * (0.019993 - 0.000101 * i) + Math.sin(e + e + e) * 0.000289) * p } function iR(e) { return dD(e) + 0.00256 * Math.cos((125.04 - 1934.136 * e) * p) * p } function dD(e) { return (23 + (26 + (21.448 - e * (46.815 + e * (0.00059 - e * 0.001813))) / 60) / 60) * p } function bx(e) { return 0.016708634 - e * (0.000042037 + 1.267e-7 * e) } function gu() { return window.devicePixelRatio || 1 } function i5(T) { var i; var e; var kC; if (T >= 0) { kC = Math.floor(T / 65536) * 65536; i = kC; e = T - kC } else { kC = Math.floor(-T / 65536) * 65536; i = -kC; e = T + kC } return [i, e] } function cN(e) { if (e.lng >= 0 && e.lat >= 0) { return new cG(e.lng - 10000000, e.lat - 6000000) } if (e.lng >= 0 && e.lat < 0) { return new cG(e.lng - 10000000, e.lat + 6000000) } if (e.lng < 0 && e.lat >= 0) { return new cG(e.lng + 10000000, e.lat - 6000000) } if (e.lng < 0 && e.lat < 0) { return new cG(e.lng + 10000000, e.lat + 6000000) } } var iy = null; if (window.performance && window.performance.now) { iy = function () { return performance.now() } } else { if (Date.now) { iy = function () { return Date.now() } } else { iy = function () { return (new Date).getTime() } } } function h9(kC, e, i) { var T = "mouseWheel"; if (e9.Platform.macintosh) { if (!isNaN(kC) && (kC < 10 || kC !== 120) && (e % 1 === 0 && e < 5)) { T = "padScroll" } if (e9.Browser.firefox && (e % 1 === 0 && e < 5 && i === 0)) { T = "padScroll" } } if (e9.Browser.safari && kC === 12) { T = "mouseWheel" } return T } function bT(kL, kG) { var kK = kL[0]; var kJ = kL[1]; var kC = false; for (var kF = 0, kE = kG.length - 2; kF < kG.length; kF += 2) { var kI = kG[kF]; var kD = kG[kF + 1]; var kH = kG[kE]; var T = kG[kE + 1]; var e = ((kD > kJ) !== (T > kJ)) && (kK < (kH - kI) * (kJ - kD) / (T - kD) + kI); if (e) { kC = !kC } kE = kF } return kC } function aw(kD, kF) { kF = kF || []; var e = kF.length; var T = 0; var kE = false; for (var kC = 0; kC < e; kC++) { T = (kC === e - 1) ? 0 : T + 1; if ((kF[kC].lat !== kF[T].lat) && (((kD.lat >= kF[kC].lat) && (kD.lat < kF[T].lat)) || ((kD.lat >= kF[T].lat) && (kD.lat < kF[kC].lat))) && (kD.lng < (kF[T].lng - kF[kC].lng) * (kD.lat - kF[kC].lat) / (kF[T].lat - kF[kC].lat) + kF[kC].lng)) { kE = !kE } } return kE } function d0(T, e, i, kC) { kC = kC || 0.4; if (T > i) { T = Math.pow(T - i + 1, kC) + i - 1 } else { if (T < e) { T = e - Math.pow(e - T + 1, kC) + 1 } } return T } function e5(kG) { var kE = ""; for (var T = 0; T < kG.length; T++) { var kH = kG.charCodeAt(T) << 1; var e = kH.toString(2); var kD = e.length; var kK = e; if (kD < 8) { kK = "00000000" + e; kK = kK.substr(e.length, 8) } kE += kK } var kI = 5 - kE.length % 5; var kC = []; for (var T = 0; T < kI; T++) { kC[T] = "0" } kE = kC.join("") + kE; var kJ = []; for (var T = 0; T < kE.length / 5; T++) { var kH = kE.substr(T * 5, 5); var kF = parseInt(kH, 2) + 50; kJ.push(String.fromCharCode(kF)) } return kJ.join("") + kI.toString() } function kd(T, i) { var e = bG.TILE_VERSION || window.TILE_VERSION; if (!e || !e[T] || !e[T][i] || !e[T][i].version || !e[T][i].updateDate) { e = E.tvc } return { ver: e[T][i].version, udt: e[T][i].updateDate } } function bH() { var e = bG.MSV || window.MSV; if (!e || !e.mapstyle || !e.mapstyle.updateDate || !e.mapstyle.version) { e = E.msv } return { ver: e.mapstyle.version, udt: e.mapstyle.updateDate } } function dI(e, kD) { var kC = e.slice(0); for (var T = 0; T < kC.length; T++) { kC[T] += kD } return kC } var hk = null; function hA(e) { if (hk) { return } e.fire(new fW("onloadtile")); hk = setTimeout(function () { hk = null }, 1000) } function aO() { if (G("//map.baidu.com") || G("//maps.baidu.com") || G("//ditu.baidu.com")) { return true } return false } aL.inMapHost = aO(); if (typeof window._inMapHost === "boolean") { aL.inMapHost = window._inMapHost } function G(i) { var T = window.location; var e = document.createElement("a"); e.href = i; return e.hostname === T.hostname && e.port === T.port && e.protocol === T.protocol } var d8 = [72.685732, 0.193351, 136.10888, 54.392257]; var e8 = [72.6892532, 0.1939743381, 136.1168614, 54.392257]; var v = [72.69566833, 0.1999420909, 136.1232863, 54.39791217]; var iT = 158; var dw = [98.789081, 122.948721, 107.857301, 118.082148, 119.126627, 128.021934, 79.939914, 99.021873, 119.912937, 122.084572, 127.906381, 130.933385, 106.496057, 108.066113, 119.818772, 126.367919, 111.789929, 119.311401, 100.742164, 102.220151, 99.853589, 100.781289, 97.522631, 98.834615, 99.092638, 99.892947, 122.905967, 123.761867, 123.716213, 125.494726, 123.723977, 124.755034, 125.475833, 126.398284, 125.471687, 126.065118, 130.817003, 133.605851, 127.900156, 128.656536, 128.646633, 129.625389, 132.88057, 134.104549, 117.365548, 119.230813, 116.073074, 117.416898, 114.406274, 116.123791, 116.479038, 119.591534, 110.566812, 111.851324, 74.465162, 79.993155, 82.858046, 91.345214, 85.71485, 98.969834, 127.651377, 129.532029, 129.462275, 130.209769, 133.716214, 134.731053, 134.366834, 135.103133, 130.854579, 131.32966, 115.499125, 117.530421, 115.765224, 116.734157, 108.524336, 110.601747, 121.351282, 124.612037, 126.151954, 127.332751, 91.273562, 95.604179, 79.87318, 82.935667, 76.413314, 78.336484, 78.275229, 79.993668, 83.956612, 85.725267, 85.500637, 89.346601, 97.990127, 98.94176, 106.641956, 108.599215, 111.386259, 111.810312, 111.578597, 111.803167, 115.99273, 117.010413, 116.24461, 116.675246, 119.422198, 119.909078, 120.646056, 121.38098, 120.335038, 120.662183, 124.579855, 125.773243, 126.207803, 126.774849, 95.565331, 102.037736, 95.576121, 96.158028, 95.556699, 97.799055, 91.296205, 93.348146, 93.321994, 94.690522, 89.339313, 90.540241, 82.263039, 82.882528, 78.335615, 80.023512, 76.623947, 78.352608, 73.495149, 74.48155, 74.846872, 76.479412, 91.560058, 94.871116, 88.759515, 89.235995, 83.237883, 83.965264, 82.292123, 83.246813, 81.876477, 83.253307, 80.75212, 81.463265, 86.463409, 88.267232, 102.199623, 104.225963, 112.153727, 116.823265, 108.965663, 113.021145, 111.166575, 117.972799]; var dv = [22.548416, 42.276971, 17.227969, 22.7346, 41.292761, 50.741667, 30.365133, 42.324913, 21.701924, 22.69335, 42.4176, 48.936335, 21.429059, 22.648399, 50.650499, 52.914825, 42.20449, 45.199078, 21.13391, 22.568612, 21.441033, 22.583349, 23.73862, 25.298628, 22.00409, 22.563095, 38.97849, 41.338631, 40.287973, 41.330108, 39.732801, 40.343252, 40.966852, 41.323446, 40.719312, 41.05937, 44.869472, 48.009884, 41.336325, 42.443362, 42.008104, 42.434713, 45.873151, 48.205746, 45.132322, 46.784582, 45.133383, 46.392803, 45.148771, 45.740273, 47.478161, 50.064393, 42.216229, 43.461282, 37.014302, 40.662281, 42.219985, 47.31417, 27.726965, 30.466651, 48.911271, 49.642488, 48.831706, 49.434487, 46.941762, 48.37425, 47.651781, 48.463782, 42.851964, 44.905396, 47.598273, 48.438467, 48.409141, 48.901651, 42.22756, 42.906402, 52.821047, 53.578094, 50.701837, 51.654278, 42.292419, 44.392214, 42.295918, 45.385017, 34.680866, 37.027803, 30.743515, 37.066586, 28.245649, 30.406053, 47.270872, 48.497371, 25.238932, 27.778469, 42.215754, 42.540416, 43.427677, 44.689208, 44.685587, 44.994131, 48.878657, 49.318659, 49.281099, 49.624515, 50.710468, 51.306809, 52.90717, 53.331981, 52.903016, 53.107959, 52.900867, 53.250033, 51.638073, 52.400678, 42.229657, 42.691928, 43.061242, 43.891083, 42.663095, 43.074222, 44.37174, 45.180155, 44.375135, 44.974219, 47.3035, 48.053221, 45.352401, 46.807875, 40.563053, 42.040289, 40.581871, 41.405172, 38.516328, 40.178756, 35.790476, 37.02337, 26.825605, 27.761303, 27.197399, 27.74932, 29.147561, 30.37813, 29.570893, 30.062042, 30.045026, 30.380952, 29.998038, 30.385203, 48.487385, 49.16832, 22.395733, 22.598229, 7.441114, 11.501436, 3.767491, 9.000793, 12.642067, 17.406563]; var cg = [98.795985, 122.960792, 107.867379, 118.093451, 119.139658, 128.035888, 79.948212, 99.029524, 119.923388, 122.094977, 127.918527, 130.94789, 106.50606, 108.076783, 119.8329, 126.382207, 111.803567, 119.324928, 100.749858, 102.227985, 99.860885, 100.788921, 97.529435, 98.841564, 99.100017, 99.90035, 122.917416, 123.774367, 123.728314, 125.507211, 123.736065, 124.767299, 125.488463, 126.410675, 125.484326, 126.07764, 130.830784, 133.620042, 127.912178, 128.668957, 128.658937, 129.638599, 132.894179, 134.119086, 117.379378, 119.244569, 116.086736, 117.431212, 114.420233, 116.137458, 116.492775, 119.605527, 110.579401, 111.86488, 74.468228, 80.001908, 82.867432, 91.353788, 85.721075, 98.976964, 127.664757, 129.546833, 129.476893, 130.22449, 133.730358, 134.745235, 134.381034, 135.1178, 130.868117, 131.34409, 115.513245, 117.544751, 115.779271, 116.748045, 108.536254, 110.614326, 121.365534, 124.626434, 126.165992, 127.347013, 91.281869, 95.611754, 79.879648, 82.945041, 76.413314, 78.345207, 78.275229, 80.002329, 83.956612, 85.734098, 85.510186, 89.356499, 97.997001, 98.948845, 106.653208, 108.610811, 111.400183, 111.824179, 111.592224, 111.817136, 116.00682, 117.024631, 116.258574, 116.689291, 119.436876, 119.922961, 120.659806, 121.395479, 120.349116, 120.676014, 124.59389, 125.787788, 126.221756, 126.788962, 95.572955, 102.046581, 95.583772, 96.165551, 95.564318, 97.806095, 91.30446, 93.356438, 93.330319, 94.698145, 89.349129, 90.548677, 82.268802, 82.892025, 78.335615, 80.032266, 76.625755, 78.361413, 73.498248, 74.490992, 74.846872, 76.488771, 91.563521, 94.878444, 88.768214, 89.244787, 83.247076, 83.974127, 82.29595, 83.256003, 81.885315, 83.26249, 80.760619, 81.472404, 86.470983, 88.276988, 102.207537, 104.234614, 112.164795, 116.833667, 108.965663, 113.032246, 111.166575, 117.983363]; var ce = [22.551183, 42.284787, 17.227969, 22.738314, 41.300981, 50.749638, 30.368087, 42.332701, 21.705055, 22.696452, 42.426047, 48.944674, 21.432184, 22.651387, 50.657409, 52.92296, 42.212192, 45.206905, 21.137031, 22.57186, 21.444502, 22.586566, 23.741571, 25.301472, 22.006806, 22.56637, 38.985114, 41.346531, 40.295617, 41.338581, 39.740021, 40.351012, 40.974644, 41.331562, 40.726852, 41.067192, 44.877158, 48.018285, 41.344597, 42.451798, 42.016305, 42.443235, 45.880906, 48.214001, 45.140027, 46.792775, 45.141083, 46.400433, 45.156418, 45.748281, 47.485889, 50.071879, 42.223667, 43.469487, 37.019867, 40.668675, 42.226823, 47.321605, 27.72944, 30.469853, 48.919002, 49.650614, 48.840188, 49.443166, 46.949801, 48.382798, 47.660603, 48.472692, 42.859946, 44.913298, 47.605896, 48.445914, 48.41698, 48.909667, 42.23507, 42.914193, 52.8281, 53.585952, 50.709311, 51.662219, 42.29968, 44.399225, 42.302746, 45.391958, 34.680866, 37.03377, 30.743515, 37.07228, 28.245649, 30.408935, 47.277693, 48.504255, 25.241528, 27.780726, 42.223363, 42.548418, 43.435888, 44.696952, 44.693193, 45.00187, 48.886267, 49.326755, 49.288642, 49.632304, 50.717486, 51.314369, 52.914204, 53.33964, 52.910094, 53.115926, 52.908382, 53.258095, 51.64533, 52.408305, 42.236825, 42.699126, 43.068466, 43.898632, 42.670403, 43.082219, 44.379045, 45.187742, 44.382336, 44.981379, 47.310362, 48.06019, 45.359099, 46.814439, 40.569751, 42.047741, 40.587956, 41.41263, 38.519192, 40.185033, 35.790476, 37.029005, 26.825605, 27.763896, 27.199658, 27.751649, 29.150192, 30.381073, 29.573886, 30.065162, 30.047775, 30.384089, 30.001277, 30.388525, 48.494118, 49.173841, 22.398528, 22.601198, 7.441114, 11.505968, 3.767491, 9.005209, 12.642067, 17.410886]; var ag = 95; var db = [110.3961374, 105.0743788, 96.8991824, 95.61810411, 93.82412598, 91.3892353, 91.38931858, 89.08325955, 87.22469808, 86.26278402, 85.17353, 85.23741211, 82.86627441, 81.90481038, 79.59687147, 80.39829237, 79.93319363, 77.80279948, 75.2557704, 73.49357829, 73.1892532, 73.87758816, 74.4064738, 74.10215224, 75.46409695, 76.77739692, 78.28299615, 78.15499485, 78.37920654, 78.89145345, 79.69282199, 81.19938178, 81.80830295, 83.89093424, 85.94149523, 87.86447266, 89.03414958, 90.05918132, 91.10026937, 92.15733832, 93.74361735, 95.82597331, 97.95655545, 97.12363037, 98.2129739, 99.2068571, 101.6587874, 102.5239084, 102.2356106, 105.0249238, 106.0992342, 107.8617093, 111.6439372, 109.591869, 112.284586, 117.7961157, 118.9495128, 114.2076584, 118.693565, 123.1475225, 122.730705, 120.9361393, 123.4207441, 122.3787782, 122.1385425, 121.5904281, 121.1773763, 120.6805404, 120.2483355, 122.795807, 122.8759077, 121.3060262, 122.1392177, 123.7418799, 126.4177599, 128.5647409, 129.7194884, 131.2259136, 131.9950494, 133.6289931, 135.6168614, 131.3875545, 130.8743365, 128.6303223, 126.0997773, 124.4015375, 122.22161, 119.6586483, 119.7866827, 118.5685878, 116.5177976, 114.819101, 119.0812964, 116.453265, 111.7431171]; var c9 = [43.2190351, 42.38053385, 43.17417589, 44.42226915, 45.09863634, 45.56708116, 47.33599718, 48.68832709, 49.62448486, 48.9482175, 48.4800472, 47.33564399, 47.43948676, 46.03452067, 45.20221788, 43.34563043, 42.32965739, 41.39690972, 40.82972331, 39.95567654, 39.25892877, 38.36098768, 38.05441569, 37.16878445, 36.38899414, 35.36126817, 34.30953451, 32.58503879, 31.56975694, 30.77800266, 30.43559814, 29.7744892, 30.0931977, 28.71103299, 27.70739665, 27.5775472, 27.01096137, 27.77857883, 27.50707954, 26.50328315, 26.70387804, 27.95548557, 27.29428901, 23.64685493, 23.62310601, 21.67493381, 20.77751465, 21.32070991, 22.1824113, 22.31232964, 22.51316054, 16.80037679, 13.19749864, 0.6939743381, 1.541660428, 10.50208252, 15.58926975, 17.89090007, 19.94928467, 22.18490153, 25.37285292, 25.61456434, 30.62532552, 31.08099284, 31.89238173, 32.50092692, 32.80325765, 34.25546956, 35.15486138, 36.90170139, 37.8348272, 37.941604, 38.6480797, 38.96797201, 40.98146918, 41.25573296, 42.07218153, 42.49132813, 44.65259766, 44.69330702, 48.62286865, 48.09383952, 49.19628499, 50.03402317, 53.27678901, 53.62976345, 53.89420546, 52.98933322, 52.01872884, 50.23210259, 50.18807048, 47.49769857, 47.34362712, 46.50502143, 45.24770128]; var eQ = [98.7895, 122.954182, 107.860913, 118.087007, 119.133165, 128.029533, 79.941749, 99.023087, 119.916883, 122.08841, 127.912143, 130.941471, 106.499502, 108.070244, 119.826245, 126.375818, 111.797006, 119.318387, 100.743285, 102.221517, 99.854448, 100.782445, 97.522928, 98.835028, 99.093518, 99.893783, 122.910927, 123.767769, 123.721954, 125.50077, 123.729657, 124.760724, 125.481902, 126.404079, 125.477737, 126.071019, 130.824331, 133.613395, 127.905767, 128.662524, 128.652527, 129.6321, 132.887552, 134.11249, 117.37297, 119.237999, 116.080154, 117.424589, 114.413586, 116.130948, 116.486264, 119.598927, 110.5728, 111.858437, 74.465162, 79.995337, 82.860821, 91.347291, 85.716024, 98.970481, 127.658331, 129.540202, 129.470528, 130.21808, 133.723748, 134.738785, 134.374555, 135.111443, 130.861475, 131.337438, 115.506627, 117.538123, 115.772783, 116.741632, 108.529656, 110.60782, 121.358945, 124.619773, 126.159424, 127.340582, 91.275275, 95.605228, 79.874427, 82.938601, 76.413314, 78.338763, 78.275229, 79.995765, 83.956612, 85.727511, 85.503554, 89.349858, 97.990418, 98.942257, 106.646704, 108.604437, 111.393667, 111.817723, 111.585811, 111.810645, 116.000232, 117.018216, 116.252108, 116.682705, 119.430384, 119.916417, 120.653168, 121.38883, 120.342727, 120.669383, 124.587426, 125.781376, 126.215282, 126.782323, 95.566367, 102.040026, 95.577158, 96.159009, 95.557772, 97.799728, 91.298032, 93.350057, 93.323794, 94.691771, 89.342471, 90.542019, 82.264229, 82.885485, 78.335615, 80.025844, 76.623947, 78.355027, 73.495149, 74.484473, 74.846872, 76.482208, 91.560117, 94.871859, 88.761692, 89.23822, 83.240549, 83.967602, 82.292367, 83.2495, 81.878825, 83.256003, 80.75421, 81.465955, 86.465421, 88.270356, 102.201019, 104.228033, 112.158282, 116.827153, 108.965663, 113.025767, 111.166575, 117.97687]; var eP = [22.545421, 42.279053, 17.226272, 22.731982, 41.294917, 50.743316, 30.361986, 42.326603, 21.699185, 22.690751, 42.419757, 48.938435, 21.426505, 22.64567, 50.651745, 52.916705, 42.20641, 45.201064, 21.131326, 22.565685, 21.438288, 22.580379, 23.735785, 25.295582, 22.001087, 22.560315, 38.979333, 41.340757, 40.28938, 41.332289, 39.734164, 40.344718, 40.968803, 41.325813, 40.721073, 41.061503, 44.871533, 48.012179, 41.338366, 42.445601, 42.010343, 42.436934, 45.875217, 48.208327, 45.134237, 46.786509, 45.135376, 46.394665, 45.150734, 45.742257, 47.480099, 50.065931, 42.217982, 43.46329, 37.014057, 40.662848, 42.221079, 47.315558, 27.723432, 30.46385, 48.913298, 49.644555, 48.83396, 49.436824, 46.944059, 48.376613, 47.654503, 48.466331, 42.854333, 44.907682, 47.600253, 48.440245, 48.410926, 48.903468, 42.229292, 42.908294, 52.822466, 53.58012, 50.703491, 51.656037, 42.29378, 44.393379, 42.296912, 45.385809, 34.679282, 37.027699, 30.740622, 37.066377, 28.241967, 30.403134, 47.271949, 48.49848, 25.235818, 27.774976, 42.217425, 42.542102, 43.429763, 44.691016, 44.687044, 44.995758, 48.880431, 49.320551, 49.282865, 49.626267, 50.711607, 51.308382, 52.908547, 53.333963, 52.904419, 53.109706, 52.902338, 53.251938, 51.639701, 52.402205, 42.231045, 42.693581, 43.062756, 43.892771, 42.664519, 43.075927, 44.372942, 45.1815, 44.376327, 44.975476, 47.304623, 48.054453, 45.353174, 46.808493, 40.563653, 42.041556, 40.582164, 41.4064, 38.51618, 40.179105, 35.789745, 37.023144, 26.825402, 27.757641, 27.193806, 27.745766, 29.144229, 30.375186, 29.567889, 30.059102, 30.041938, 30.378006, 29.995047, 30.382338, 48.48834, 49.169021, 22.392816, 22.595333, 7.439914, 11.500161, 3.766676, 9.000793, 12.640512, 17.406563]; var fU = 3000; var ha = 0.00002; var g9 = 0.000003; var ji = 0.0174532925194; var h1 = 0.0065; var h0 = 0.006; var dR = 40000; var fH = 0; var jD = 1; var aB = 2; var ip = 3; var fA = 4; var hE = 1e-10; var i0 = 6370996.81; var fY = 100000000; function hN(T, kD, i, kC) { var e = arguments.length; this.ll = {}; this.ru = {}; if (e === 0) { } else { if (e === 4) { this.normalize(T, kD, i, kC) } } } hN.prototype.contains = function (e) { if (e.lng > this.ll.lng && e.lng < this.ru.lng && e.lat > this.ll.lat && e.lat < this.ru.lat) { return ip } if (Math.abs(e.lng - this.ll.lng) < hE || Math.abs(e.lng - this.ru.lng) < hE || Math.abs(e.lat - this.ll.lat) < hE || Math.abs(e.y - this.ru.lat) > hE) { return aB } return fH }; hN.prototype.normalize = function (i, kC, e, T) { if (i > e) { this.ll.lng = e; this.ru.lng = i } else { this.ll.lng = i; this.ru.lng = e } if (kC > T) { this.ll.lat = T; this.ru.lat = kC } else { this.ll.lat = kC; this.ru.lat = T } }; function eH(i, kC, e, T) { this.sp = { lng: i, lat: kC }; this.ep = { lng: e, lat: T }; this.mbr = new hN(i, kC, e, T) } function iA(kC, e, kE, kD) { for (var T = 0; T < kD; T = T + 2) { if (kC.lng >= e[T] && kC.lng <= e[T + 1] && kC.lat >= kE[T] && kC.lat <= kE[T + 1]) { return true } } return false } function gA(kH) { var i = kH.lng; var kG = kH.lat; var kC = Math.sqrt(i * i + kG * kG); var kE = Math.atan2(kG, i); var T = kC + gM(kG); var kD = kE + gL(i); var e = T * Math.cos(kD); var kF = T * Math.sin(kD); return { lng: e + h1, lat: kF + h0 } } function a5(kH) { var i = kH.lng - h1; var kG = kH.lat - h0; var kC = Math.sqrt(i * i + kG * kG); var kE = Math.atan2(kG, i); var T = kC - gM(kG); var kD = kE - gL(i); var e = T * Math.cos(kD); var kF = T * Math.sin(kD); return { lng: e, lat: kF } } function gM(e) { return Math.sin(e * fU * ji) * ha } function gL(e) { return Math.cos(e * fU * ji) * g9 } function av(T, i, e) { return ((i.lng - T.lng) * (e.lat - T.lat) - (e.lng - T.lng) * (i.lat - T.lat)) } function h6(i, e) { return Math.abs(i - e) <= hE } function gT(kC, T) { var i = kC.lat * ji; var kH = kC.lng * ji; var e = T.lat * ji; var kG = T.lng * ji; var kE = Math.cos(i) * Math.cos(e); var kD = Math.cos(kH) * Math.cos(kG); var kJ = Math.sin(i) * Math.sin(e); var kI = Math.sin(kH) * Math.sin(kG); var kK = kE * kD + kE * kI + kJ; if (kK < -1) { kK = -1 } else { if (kK > 1) { kK = 1 } } var kF = Math.acos(kK) * i0; return kF } function l(kG, kF) { var i = kG.lat * ji; var e = kF.lat * ji; var kC = kG.lng * ji; var T = kF.lng * ji; var kE = i - e; var kD = kC - T; var kH = Math.sin(kE / 2) * Math.sin(kE / 2) + Math.cos(i) * Math.cos(e) * Math.sin(kD / 2) * Math.sin(kD / 2); return 2 * Math.asin(Math.sqrt(kH)) * i0 } function gR(kH, T) { var kJ = bI(kH, T); var kI = 180; var kG = 90; var kF = -180; var kD = -90; var kE = T.sp; var kC = T.ep; kI = kE.lng < kC.lng ? kE.lng : kC.lng; kG = kE.lat < kC.lat ? kE.lat : kC.lat; kF = kE.lng < kC.lng ? kE.lng : kC.lng; kD = kE.lat < kC.lat ? kE.lat : kC.lat; if (kJ.lng <= kF && kJ.lng >= kI && kJ.lng <= kD && kJ.lat >= kG) { return gT(kH, kJ) } else { var i = l(kH, T.sp); var e = l(kH, T.ep); return i < e ? i : e } } function a7(i, e) { } function bM(i, kC, e, T) { return Math.sqrt((i - e) * (i - e) + (kC - T) * (kC - T)) } function bI(kN, kF) { var kE = kN.lng; var kM = kN.lat; var kD = kF.sp.lng; var kL = kF.sp.lat; var T = kF.ep.lng; var kJ = kF.ep.lat; var kK = kJ - kL; var kI = kD - T; if (h6(kK, 0) && h6(kI, 0)) { return kF.sp } var kH = T * kL - kD * kJ; var kG = kI * kE - kK * kM; var e = kK * kK - kI * kI; var kC = kI * kG - kK * kH; var i = kK * kG + kI * kH; return { lng: kC / e, lat: -i / e } } function bQ(kC) { var T = 0; for (var e = 0; e < ag; ++e) { if (c9[e] <= kC.lat) { if (c9[(e + 1) % ag] > kC.lat) { if (av({ lng: db[e], lat: c9[e] }, { lng: db[(e + 1) % ag], lat: c9[(e + 1) % ag] }, kC) > 0) { ++T } } } else { if (c9[(e + 1) % ag] <= kC.lat) { if (av({ lng: db[e], lat: c9[e] }, { lng: db[(e + 1) % ag], lat: c9[(e + 1) % ag] }, kC) < 0) { --T } } } } return T === 0 ? fH : ip } function kh(kC) { var kF = {}; if (kC.lng < e8[0] - 0.4 || kC.lat < e8[1] - 0.4 || kC.lng > e8[2] + 0.4 || kC.lat > e8[3] + 0.4) { kF.lng = kC.lng; kF.lat = kC.lat; return kF } else { if (iA(kC, eQ, eP, iT)) { kF = gA(kC); return kF } } var e = 0; var kI = dR; var T = 0; var kG = new hN(); var kH = 1; if (bQ(kC) === fH) { for (var kE = 0; kE < ag; ++kE) { var kD = new eH(db[kE], c9[kE], db[(kE + 1) % ag], c9[(kE + 1) % ag]); kG.ll.lng = kD.mbr.ll.lng - 0.5; kG.ll.lat = kD.mbr.ll.lat - 0.5; kG.ru.lng = kD.mbr.ru.lng + 0.5; kG.ru.lat = kD.mbr.ru.lat + 0.5; if (kG.contains(kC) === fH) { continue } T = gR(kC, kD); if (T < kI) { kI = T } } if (kI < dR) { e = (dR - kI) / dR; kH = 2 } } else { kH = 3; e = 1 } var kJ = gA(kC); kF = { lng: kC.lng + (kJ.lng - kC.lng) * e, lat: kC.lat + (kJ.lat - kC.lat) * e }; return kF } function fa(i) { var T = {}; if (i.lng < v[0] - 0.4 || i.lat < v[1] - 0.4 || i.lng > v[2] + 0.4 || i.lat > v[3] + 0.4) { T.lng = i.lng; T.lat = i.lat; return T } else { if (iA(i, cg, ce, iT)) { T = a5(i); return T } } var e = kh(i); if (i.lng === e.lng && i.lat === e.lng) { T.lng = i.lng; T.lat = i.lat; return T } return decryptPt1(i, kh) } function iQ(i, e) { if (e === 3 && i instanceof cG) { var T = kh(i); return new cG(T.lng, T.lat) } else { return i } } function eS(i, e) { if (e === 3 && i instanceof cG) { var T = fa(i); return new cG(T.lng, T.lat) } else { if (e === 5 && i instanceof cG) { return new cG(i.lng, i.lat) } else { return i } } } function gb(i, e) { switch (e) { case BMAP_COORD_GCJ02: var T = gcoord.transform([i.lng, i.lat], gcoord.GCJ02, gcoord.BD09LL); return new cG(T[0], T[1]); case BMAP_COORD_WGS84: var T = gcoord.transform([i.lng, i.lat], gcoord.WGS84, gcoord.BD09LL); return new cG(T[0], T[1]); case 3: var T = gcoord.transform([i.lng, i.lat], gcoord.GCJ02, gcoord.BD09LL); return new cG(T[0], T[1]); default: return i } } function js(i, e) { switch (e) { case BMAP_COORD_GCJ02: var T = gcoord.transform([i.lng, i.lat], gcoord.BD09LL, gcoord.GCJ02); return new cG(T[0], T[1]); case BMAP_COORD_WGS84: var T = gcoord.transform([i.lng, i.lat], gcoord.BD09LL, gcoord.WGS84); return new cG(T[0], T[1]); case 3: var T = gcoord.transform([i.lng, i.lat], gcoord.BD09LL, gcoord.GCJ02); return new cG(T[0], T[1]); default: return i } } function q(kE) { if (!kE) { kE = {} } var kF = JSON.stringify(kE); var kD = 0, T, kC, e; if (kF.length === 0) { return kD } for (T = 0, e = kF.length; T < e; T++) { kC = kF.charCodeAt(T); kD = ((kD << 5) - kD) + kC; kD |= 0 } return kD } function dc() { var i = new Date().getTime(); var e = "xxxyxxxy".replace(/[xy]/g, function (kC) { var T = (i + Math.random() * 16) % 16 | 0; i = Math.floor(i / 16); return (kC == "x" ? T : (T & 3 | 8)).toString(16) }); return e } function bj(e, i) { return Math.atan2(i, e) * 180 / Math.PI } function dt(kF, T, i) { var e = [], kE = []; e[0] = kF[0] - T[0]; e[1] = kF[1] - T[1]; kE[0] = i[0] - T[0]; kE[1] = i[1] - T[1]; var kD = e[0] * kE[0] + e[1] * kE[1]; var kC = Math.sqrt((e[0] * e[0]) + (e[1] * e[1])) * Math.sqrt(kE[0] * kE[0]) + Math.sqrt(kE[1] * kE[1]); return Math.acos(kD / kC) / Math.PI * 180 } function g5(kG, T, i) { var e = [], kF = []; e[0] = kG[0] - T[0]; e[1] = kG[1] - T[1]; kF[0] = i[0] - T[0]; kF[1] = i[1] - T[1]; var kD = e[0] * kF[1] - e[1] * kF[0]; var kE = e[0] * kF[0] + e[1] * kF[1]; var kC = Math.atan2(kD, kE); return kC * 180 / Math.PI } var b9 = 0; function gj() { return b9++ } function bp(i, kE) { var T = i.toLowerCase(); var kC = T.lastIndexOf("?"); var e = T.lastIndexOf("#"); var kD = Math.max(kC, e); if (kD === -1) { return i + "?" + kE } return i + "&" + kE } function a1(i, e, T, kC) { return (i || 0) << 24 | (e || 0) << 16 | (T || 0) << 8 | (kC || 0) } function gH(kD) { if (kD instanceof Array && kD.length >= 3) { var kC = kD[0] || 0; var T = kD[1] || 0; var e = kD[2] || 0; var i = kD[3] || 1 } else { var kC = (kD) & 255; var T = (kD >> 8) & 255; var e = (kD >> 16) & 255; var i = (kD >> 24) & 255 } if (!kD) { return 0 } return kC + T * 256 + e * 65536 - 1 } function k(e) { var i = true; var T = e.charAt(0); switch (T) { case "\n": return "\\n"; break; case "\r": return "\\r"; break; case "'": return "\\'"; break; case '"': return '\\"'; break; case "&": return "\\&"; break; case "\\": return "\\\\"; break; case "\t": return "\\t"; break; case "\b": return "\\b"; break; case "\f": return "\\f"; break; case "/": return "\\x2F"; break; case "<": return "\\x3C"; break; case ">": return "\\x3E"; break; default: i = false; break }if (!i) { return e } } function b(kD) { var T = kD; var kC = ""; var e = 0; for (e = 0; e < T.length; e++) { kC = kC + k(T.charAt(e)) } return kC } function bb() { if (!URL) { return { origin: "", protocol: "https:" } } try { var kC = window.location.href; var i = new URL(kC); return i } catch (T) { return { origin: "", protocol: "https:" } } } function jL() { var T = function (kQ, kP) { var kO = { "\x6c\x78\x61\x78\x78": "\x78\x65\x61", "\x61\x65\x65\x6d\x78": "\x61\x65\x61\x69", "\x64\x64\x61\x78\x6d": function (kY, kX) { return kY(kX) }, "\x68\x6d\x61\x65\x61": "\x64\x61\x65", "\x78\x65\x64\x65\x63": "\x6d\x64\x61", "\x63\x61\x61\x78\x61": function (kY, kX) { return kY + kX }, "\x63\x61\x61\x68\x69": function (kY, kX) { return kY(kX) }, "\x6c\x61\x65\x78\x6d": function (kZ, kY, kX) { return kZ(kY, kX) }, "\x78\x69\x61\x61\x63": function (kX, kY) { return kX(kY) }, "\x65\x6d\x6c\x69\x65": function (kY, kX) { return kY(kX) }, "\x68\x6c\x65\x61\x61": function (kY, kX) { return kY + kX }, "\x64\x63\x61\x61\x68": function (kY, kX) { return kY(kX) }, "\x69\x61\x6d\x6c\x6d": function (kY, kX) { return kY < kX } }; var kN = "\x31\x2e\x31\x2e\x32"; function kM(kZ, kY) { var kX = kO["\x6c\x78\x61\x78\x78"]; while (kX !== kO["\x61\x65\x65\x6d\x78"]) { switch (kX) { case "\x61\x69\x6c": return k0; case "\x6d\x64\x61": for (var k3 = 0; k3 < k1; k3++) { var k2 = kO["\x64\x64\x61\x78\x6d"](kY, kZ[k3]); k0["\x70\x75\x73\x68"](k2) } kX = "\x61\x69\x6c"; break; case "\x78\x65\x61": var k1 = kZ["\x6c\x65\x6e\x67\x74\x68"]; kX = kO["\x68\x6d\x61\x65\x61"]; break; case kO["\x68\x6d\x61\x65\x61"]: var k0 = []; kX = kO["\x78\x65\x64\x65\x63"]; break } } } var kL, kK, kJ, kI, kH, kG = decodeURIComponent, kF = "\x43\x68\x61\x72", kE = ""; var kD = [T]; kL = "\x64\x65"; kK = "\x66\x72"; kJ = "\x6f"; kH = kO["\x63\x61\x61\x78\x61"](kK + kJ, "\x6d"); kI = kO["\x68\x6c\x65\x61\x61"]("\x43\x6f", kL); var kC = function (kX) { return kO["\x63\x61\x61\x78\x61"](kX, kE)["\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72"][kH + kF + kI](kX) }; var kW = function (kX) { var kY = { "\x65\x61\x6c\x68\x69": function (k0, kZ) { return kO["\x63\x61\x61\x68\x69"](k0, kZ) } }; return kO["\x6c\x61\x65\x78\x6d"](kM, kX, function (kZ) { return kY["\x65\x61\x6c\x68\x69"](kC, kZ) }) }; var kS = kW["\x63\x61\x6c\x6c"](kC, [39, 34, 37, 96, 60, 120, 97, 65, 98, 66, 99, 67, 100, 68, 101, 69, 102, 70, 103, 110, 109, 111, 112, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]); var kR = kM([28782, 27702, 26416, 25167, 24183], function (kX) { return kO["\x78\x69\x61\x61\x63"](kG, kX) }); var kV = kW["\x63\x61\x6c\x6c"](kR, [22354, 22749, 24415, 23346, 22257, 22688, 24306, 25174, 23595, 25547, 22984, 25690, 22212, 27547, 21594, 27210, 23090, 29193, 22394, 29368, 29532, 29459, 29530, 24146, 24500, 26352, 27441, 28788, 29370, 27673, 26925, 25249, 24430]), kU = {}; kR = kO["\x64\x63\x61\x61\x68"](kW, kR); var kT = new RegExp(kR["\x6a\x6f\x69\x6e"]("\x7c")); for (var kL = 0; kO["\x69\x61\x6d\x6c\x6d"](kL, kS["\x6c\x65\x6e\x67\x74\x68"]); kL++) { kU[kV[kL]] = kS[kL] } kP = kO["\x6c\x61\x65\x78\x6d"](kM, kP["\x73\x70\x6c\x69\x74"](kE), function (kX) { return kU[kX] || kX })["\x6a\x6f\x69\x6e"](kE); return kM(kP["\x73\x70\x6c\x69\x74"](kT), function (kX) { return kO["\x65\x6d\x6c\x69\x65"](kG, kX) }) }(this, "\x6c\u545a\u72b8\u577a\x74\x68\u624f\u545a\u735c\u5ef2\u735c\u545a\u6c36\x69\u5ef2\u545a\u545a\u58a0\u5e77\u56c4\u58a0\u59c8\x6c\x69\u6c36\u545a\u56c4\u58a0\u59c8\u545a\u6c36\u56c4\u56c4\u545a\u545a\u59c8\u5e77\x73\x75\u5c2b\x73\x74\x72\u624f\u59c8\u58a0\u56c4\u5ef2\u735c\u624f\x69\u72b8\u56c4\u545a\u58a0\x4f\u5a32\u6c36\x68\u58a0\u545a\u545a\u735c\u5e77\u58a0\x6c\u545a\x6c\x6c\u5e77\x68\u5ef2\u5ef2\u6c36\u735c\u545a\u735c\u6730\x48\u5e52\u6256\u5f6e\x50\u62a1\x50\u692d\x59\u6c19\u6256\u63cb\x51\x4f\u5e52\u706e\u59c8\x69\x6c\u6c36\x6c\u58a0\u59c8\u706e\u545a\u5ef2\u5ef2\u624f\u7209\u72ba\x4c\u66f0\x4f\u6c19\x52\u6c19\u6256\u6b9b\u62a1\u5f6e\u5f6e\u5e52\x4f\u5e77\u56c4\x6c\u545a\u56c4\x69\u6730\u59c8\u545a\u545a\u545a\u706e\u545a\u58a0\x6c\u5ef2\u735c\u6730\u5f5f\u66f0\u6c19\x73\x69\u577a\u72b8\u5f5f\u6b31\u6b9b\u6730\x73\x75\u5c2b\x73\x74\x72\x69\u72b8\u577a\u706e\u5ef2\u58a0\u545a\x6c\u56c4"); (function (kE, kD) { var kC = function (kF) { while (--kF) { kE.push(kE.shift()) } }; kC(++kD) }(T, 491)); var i = function (kE, kD) { kE = kE - 0; var kC = T[kE]; return kC }; function e(kH) { var kG = { "\x64\x6c\x65\x64\x69": function (kK, kJ) { return kK !== kJ }, "\x65\x78\x6c\x61\x6d": i("0x0"), "\x61\x78\x65\x6c\x64": function (kJ, kK) { return kJ - kK }, "\x65\x6d\x61\x6d\x65": i("0x1"), "\x69\x61\x65\x65\x78": i("0x2"), "\x64\x78\x63\x6c\x69": i("0x3"), "\x65\x64\x78\x63\x65": i("0x4"), "\x64\x68\x63\x6d\x68": function (kK, kJ) { return kK(kJ) }, "\x64\x64\x65\x65\x63": function (kK, kJ) { return kK(kJ) }, "\x63\x78\x64\x61\x6d": function (kK, kJ) { return kK + kJ }, "\x68\x78\x65\x65\x6d": i("0x5"), "\x78\x6c\x65\x6c\x6c": i("0x6") }; var kF = i("0x5"); while (kG[i("0x7")](kF, i("0x8"))) { switch (kF) { case kG[i("0x9")]: return i("0xa") + kD[i("0xb")](kG[i("0xc")](kD[i("0xd")], 12)); case kG[i("0xe")]: var kE = kG[i("0xf")]; kF = kG[i("0x10")]; break; case kG[i("0x11")]: var kD = kG["\x64\x68\x63\x6d\x68"](md5, kG[i("0x12")](md5, kC + kI) + kE); kF = kG[i("0x9")]; break; case kG[i("0x10")]: var kC = kH[i("0x13")](kG[i("0x14")](kH[i("0x15")]("\x3f"), 1)); kF = i("0x4"); break; case kG[i("0x16")]: var kI = kG[i("0x17")]; kF = kG["\x65\x6d\x61\x6d\x65"]; break } } } return e } function hm() { } e9.extend(hm, { Request: { INITIAL: -1, WAITING: 0, LOADED: 1, COMPLETED: 2 }, Dependency: { poly: ["marker"], layer: ["poly"], hotspot: ["poly"], infowindow: ["marker", "hotspot"], simpleInfowindow: ["marker"], tools: ["marker", "poly"], mapgl: ["glcommon", "poly"], earth: ["glcommon"], control: ["scommon"], scommon: [], localSearch: ["scommon"], otherSearch: ["scommon"], route: ["scommon"], buslineSearch: ["route"], autocomplete: ["scommon"], mvtParse: ["marker", "poly", "style"] }, MD5Mapping: { control: "1lfago", marker: "qq1ls1", poly: "5zjkhf", layer: "$layer$", infowindow: "i2swpx", simpleInfowindow: "he5ylx", hotspot: "lpf1oh", menu: "jvnmb2", tools: "fb4waz", oppc: "acznxq", oppcgl: "qq52dh", mapgl: "wfmjge", markeranimation: "04w4lb", earth: "houkkw", glcommon: "1irkda", localSearch: "vememq", scommon: "rf0agk", otherSearch: "fy3zyc", route: "4dduxo", buslineSearch: "elw34s", autocomplete: "bkx5d2", style: "1kcgp1", mvtParse: "xkubak" }, Config: { baseUrl: window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"] ? window._BMapSecurityConfig["serviceHost"] + "/getmodules?v=1.0&type=webgl" : E.apiHost + "/getmodules?v=1.0&type=webgl", jsModPath: (aL.inMapHost ? "" : E.mapHost) + "/res/newui/", timeout: 5000 }, delayFlag: false, Module: { modules: {}, modulesNeedToLoad: [] }, _getMd5ModsStr: function (kE) { var kD = []; for (var kG = 0, T = kE.length; kG < T; kG++) { var kF = kE[kG]; var e = this.MD5Mapping[kF]; var kC = "$" + kF + "$"; if (e !== kC) { kD.push(kF + "_" + e) } } return kD.join(",") }, load: function (i, kE, kC) { var e = this.getModuleInfo(i); if (e.status === this.Request.COMPLETED) { if (kC === true) { kE() } } else { if (e.status === this.Request.INITIAL) { this.combine(i); this.addToLoadQueue(i); var T = this; if (T.delayFlag === false) { T.delayFlag = true; setTimeout(function () { var kF = T.Config.baseUrl + "&mod=" + T._getMd5ModsStr(T.Module.modulesNeedToLoad); g4.load(kF); T.Module.modulesNeedToLoad.length = 0; T.delayFlag = false }, 1) } e.status = this.Request.WAITING; function kD(kH) { var kG = T.getModuleInfo(i); if (kG.status !== T.Request.COMPLETED) { if (window.map && window.map.fire) { var kF = new fW("onmod_timeout"); kF.timeout = kH / 1000; kF.moduleName = i; window.map.fire(kF) } } } setTimeout(kD, this.Config.timeout, this.Config.timeout); setTimeout(kD, this.Config.timeout * 2, this.Config.timeout * 2) } if (kE) { e.callbacks.push(kE) } } }, combine: function (e) { if (e && this.Dependency[e]) { var kC = this.Dependency[e]; for (var T = 0; T < kC.length; T++) { this.combine(kC[T]); if (!this.Module.modules[kC[T]]) { this.addToLoadQueue(kC[T]) } } } }, addToLoadQueue: function (e) { var i = this.getModuleInfo(e); if (i.status === this.Request.INITIAL) { i.status = this.Request.WAITING; this.Module.modulesNeedToLoad.push(e) } }, run: function (T, kC) { var kG = this.getModuleInfo(T); var kJ = this.Dependency[T]; if (kJ) { for (var kE = 0; kE < kJ.length; kE++) { var kF = this.getModuleInfo(kJ[kE]); if (kF.status !== this.Request.COMPLETED) { kF.modsNeedToRun.push({ name: T, code: kC }); return } } } try { eval(kC) } catch (kH) { return } kG.status = this.Request.COMPLETED; for (var kE = 0, kD = kG.callbacks.length; kE < kD; kE++) { kG.callbacks[kE]() } kG.callbacks.length = 0; for (kE = 0; kE < kG.modsNeedToRun.length; kE++) { var kI = kG.modsNeedToRun[kE]; this.run(kI.name, kI.code) } kG.modsNeedToRun.length = 0 }, getModuleInfo: function (i) { var e; if (!this.Module.modules[i]) { this.Module.modules[i] = { status: this.Request.INITIAL, callbacks: [], modsNeedToRun: [] } } e = this.Module.modules[i]; return e } }); window._jsload = function (kD, kE) { var i = hm.getModuleInfo(kD); i.status = hm.Request.LOADED; if (kE !== "") { hm.run(kD, kE) } else { if (window.map && window.map.fire) { var e = new fW("ongetmodules_fail"); e.moduleName = kD; window.map.fire(e) } var T = document.createElement("script"); var kC = hm.MD5Mapping[kD]; T.src = hm.Config.jsModPath + kD + "_" + kC + ".js"; document.getElementsByTagName("head")[0].appendChild(T) } }; function c7() { this._timeData = {} } var bE; if (typeof window !== "undefined") { bE = window } else { bE = self } c7.prototype.mark = function (e) { this._timeData[e] = this._getTime() }; c7.prototype.getMark = function (e) { return this._timeData[e] }; c7.prototype.getTime = function (i, e) { return parseFloat((this._timeData[e] - this._timeData[i]).toFixed(2)) }; c7.prototype.print = function () { }; c7.prototype.clear = function () { this._timeData = {} }; if (bE.performance && bE.performance.now) { c7.prototype._getTime = function () { return performance.now() } } else { c7.prototype._getTime = function () { return Date.now() } } !function (i, T) { T(i.d3 = i.d3 || {}) }(window, function (lf) { function lx(lE, lF, T, lD) { function e(i) { return lE(i = new Date(+i)), i } return e.floor = e, e.ceil = function (i) { return lE(i = new Date(i - 1)), lF(i, 1), lE(i), i }, e.round = function (i) { var lG = e(i), lH = e.ceil(i); return lH - i > i - lG ? lG : lH }, e.offset = function (i, lG) { return lF(i = new Date(+i), null == lG ? 1 : Math.floor(lG)), i }, e.range = function (lH, i, lG) { var lI = []; if (lH = e.ceil(lH), lG = null == lG ? 1 : Math.floor(lG), !(i > lH && lG > 0)) { return lI } do { lI.push(new Date(+lH)) } while (lF(lH, lG), lE(lH), i > lH); return lI }, e.filter = function (i) { return lx(function (lG) { for (; lE(lG), !i(lG);) { lG.setTime(lG - 1) } }, function (lG, lH) { for (; --lH >= 0;) { for (; lF(lG, 1), !i(lG);) { } } }) }, T && (e.count = function (i, lG) { return lh.setTime(+i), ll.setTime(+lG), lE(lh), lE(ll), Math.floor(T(lh, ll)) }, e.every = function (i) { return i = Math.floor(i), isFinite(i) && i > 0 ? i > 1 ? e.filter(lD ? function (lG) { return lD(lG) % i === 0 } : function (lG) { return e.count(0, lG) % i === 0 }) : e : null }), e } function lm(e) { return lx(function (i) { i.setDate(i.getDate() - (i.getDay() + 7 - e) % 7), i.setHours(0, 0, 0, 0) }, function (i, T) { i.setDate(i.getDate() + 7 * T) }, function (i, T) { return (T - i - (T.getTimezoneOffset() - i.getTimezoneOffset()) * lg) / lu }) } function le(e) { return lx(function (i) { i.setUTCDate(i.getUTCDate() - (i.getUTCDay() + 7 - e) % 7), i.setUTCHours(0, 0, 0, 0) }, function (i, T) { i.setUTCDate(i.getUTCDate() + 7 * T) }, function (i, T) { return (T - i) / lu }) } var lh = new Date, ll = new Date, ls = lx(function () { }, function (i, T) { i.setTime(+i + T) }, function (i, T) { return T - i }); ls.every = function (e) { return e = Math.floor(e), isFinite(e) && e > 0 ? e > 1 ? lx(function (i) { i.setTime(Math.floor(i / e) * e) }, function (i, T) { i.setTime(+i + T * e) }, function (i, T) { return (T - i) / e }) : ls : null }; var lB = ls.range, lz = 1000, lg = 60000, lw = 3600000, lo = 86400000, lu = 604800000, kI = lx(function (e) { e.setTime(Math.floor(e / lz) * lz) }, function (i, T) { i.setTime(+i + T * lz) }, function (i, T) { return (T - i) / lz }, function (e) { return e.getUTCSeconds() }), ly = kI.range, ln = lx(function (e) { e.setTime(Math.floor(e / lg) * lg) }, function (i, T) { i.setTime(+i + T * lg) }, function (i, T) { return (T - i) / lg }, function (e) { return e.getMinutes() }), kQ = ln.range, la = lx(function (i) { var T = i.getTimezoneOffset() * lg % lw; 0 > T && (T += lw), i.setTime(Math.floor((+i - T) / lw) * lw + T) }, function (i, T) { i.setTime(+i + T * lw) }, function (i, T) { return (T - i) / lw }, function (e) { return e.getHours() }), lt = la.range, k0 = lx(function (e) { e.setHours(0, 0, 0, 0) }, function (i, T) { i.setDate(i.getDate() + T) }, function (i, T) { return (T - i - (T.getTimezoneOffset() - i.getTimezoneOffset()) * lg) / lo }, function (e) { return e.getDate() - 1 }), kH = k0.range, kX = lm(0), kZ = lm(1), kD = lm(2), kV = lm(3), kK = lm(4), ld = lm(5), lk = lm(6), kF = kX.range, lc = kZ.range, kO = kD.range, k9 = kV.range, lp = kK.range, lb = ld.range, lA = lk.range, lr = lx(function (e) { e.setDate(1), e.setHours(0, 0, 0, 0) }, function (i, T) { i.setMonth(i.getMonth() + T) }, function (i, T) { return T.getMonth() - i.getMonth() + 12 * (T.getFullYear() - i.getFullYear()) }, function (e) { return e.getMonth() }), lC = lr.range, kU = lx(function (e) { e.setMonth(0, 1), e.setHours(0, 0, 0, 0) }, function (i, T) { i.setFullYear(i.getFullYear() + T) }, function (i, T) { return T.getFullYear() - i.getFullYear() }, function (e) { return e.getFullYear() }); kU.every = function (e) { return isFinite(e = Math.floor(e)) && e > 0 ? lx(function (i) { i.setFullYear(Math.floor(i.getFullYear() / e) * e), i.setMonth(0, 1), i.setHours(0, 0, 0, 0) }, function (i, T) { i.setFullYear(i.getFullYear() + T * e) }) : null }; var kN = kU.range, li = lx(function (e) { e.setUTCSeconds(0, 0) }, function (i, T) { i.setTime(+i + T * lg) }, function (i, T) { return (T - i) / lg }, function (e) { return e.getUTCMinutes() }), k2 = li.range, k1 = lx(function (e) { e.setUTCMinutes(0, 0, 0) }, function (i, T) { i.setTime(+i + T * lw) }, function (i, T) { return (T - i) / lw }, function (e) { return e.getUTCHours() }), kY = k1.range, kW = lx(function (e) { e.setUTCHours(0, 0, 0, 0) }, function (i, T) { i.setUTCDate(i.getUTCDate() + T) }, function (i, T) { return (T - i) / lo }, function (e) { return e.getUTCDate() - 1 }), kT = kW.range, kS = le(0), kR = le(1), kP = le(2), kM = le(3), kL = le(4), kG = le(5), kE = le(6), kC = kS.range, k8 = kR.range, lv = kP.range, lj = kM.range, lq = kL.range, k7 = kG.range, k6 = kE.range, k5 = lx(function (e) { e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0) }, function (i, T) { i.setUTCMonth(i.getUTCMonth() + T) }, function (i, T) { return T.getUTCMonth() - i.getUTCMonth() + 12 * (T.getUTCFullYear() - i.getUTCFullYear()) }, function (e) { return e.getUTCMonth() }), k4 = k5.range, kJ = lx(function (e) { e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0) }, function (i, T) { i.setUTCFullYear(i.getUTCFullYear() + T) }, function (i, T) { return T.getUTCFullYear() - i.getUTCFullYear() }, function (e) { return e.getUTCFullYear() }); kJ.every = function (e) { return isFinite(e = Math.floor(e)) && e > 0 ? lx(function (i) { i.setUTCFullYear(Math.floor(i.getUTCFullYear() / e) * e), i.setUTCMonth(0, 1), i.setUTCHours(0, 0, 0, 0) }, function (i, T) { i.setUTCFullYear(i.getUTCFullYear() + T * e) }) : null }; var k3 = kJ.range; lf.timeInterval = lx, lf.timeMillisecond = ls, lf.timeMilliseconds = lB, lf.utcMillisecond = ls, lf.utcMilliseconds = lB, lf.timeSecond = kI, lf.timeSeconds = ly, lf.utcSecond = kI, lf.utcSeconds = ly, lf.timeMinute = ln, lf.timeMinutes = kQ, lf.timeHour = la, lf.timeHours = lt, lf.timeDay = k0, lf.timeDays = kH, lf.timeWeek = kX, lf.timeWeeks = kF, lf.timeSunday = kX, lf.timeSundays = kF, lf.timeMonday = kZ, lf.timeMondays = lc, lf.timeTuesday = kD, lf.timeTuesdays = kO, lf.timeWednesday = kV, lf.timeWednesdays = k9, lf.timeThursday = kK, lf.timeThursdays = lp, lf.timeFriday = ld, lf.timeFridays = lb, lf.timeSaturday = lk, lf.timeSaturdays = lA, lf.timeMonth = lr, lf.timeMonths = lC, lf.timeYear = kU, lf.timeYears = kN, lf.utcMinute = li, lf.utcMinutes = k2, lf.utcHour = k1, lf.utcHours = kY, lf.utcDay = kW, lf.utcDays = kT, lf.utcWeek = kS, lf.utcWeeks = kC, lf.utcSunday = kS, lf.utcSundays = kC, lf.utcMonday = kR, lf.utcMondays = k8, lf.utcTuesday = kP, lf.utcTuesdays = lv, lf.utcWednesday = kM, lf.utcWednesdays = lj, lf.utcThursday = kL, lf.utcThursdays = lq, lf.utcFriday = kG, lf.utcFridays = k7, lf.utcSaturday = kE, lf.utcSaturdays = k6, lf.utcMonth = k5, lf.utcMonths = k4, lf.utcYear = kJ, lf.utcYears = k3, Object.defineProperty(lf, "__esModule", { value: !0 }) }); function fj(e) { this._elemType = e; this._objCollection = {} } fj.prototype.get = function () { var i = null; for (var e in this._objCollection) { if (this._objCollection[e] && this._objCollection[e]._free === true) { this._objCollection[e]._free = false; return this._objCollection[e] } } i = b6(this._elemType); e = bG.getGUID("obj_pool_"); this._objCollection[e] = i; return i }; fj.prototype.free = function (e) { if (!e) { return } e._free = true; if (e.tagName.toLowerCase() === "img") { e.src = ""; e.crossOrigin = null; e.onload = e.onerror = null } }; fj.prototype.clear = function () { for (var e in this._objCollection) { if (this._objCollection[e] && this._objCollection[e].tagName.toLowerCase === "img") { this._objCollection[e].onload = this._objCollection[e].onerror = null } } this._objCollection = {} }; var it = { get: function (i, kD, e, T) { var kC = new XMLHttpRequest(); kC.open("GET", i, true); kC.timeout = 10000; kC.ontimeout = function () { T && T() }; kC.onreadystatechange = function (kE) { if (this.readyState === 4) { if (this.status === 200) { kD && kD(kC.responseText) } else { e && e() } } }; kC.send() }, post: function (i, kE, kD, e, T) { var kC = new XMLHttpRequest(); kC.open("POST", i, true); kC.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); kC.timeout = 10000; kC.ontimeout = function () { T && T() }; kC.onreadystatechange = function (kF) { if (this.readyState === 4) { if (this.status === 200) { kD && kD(kC.responseText, kE) } else { e && e() } } }; kC.send(kE); return kC } }; var g4 = (function (e) { function i(kE, T, kD) { if (kE.indexOf("v=") === -1) { kE += "&v=gl" } var kC = b6("script", { src: kE, type: "text/javascript", charset: "utf-8" }); if (kC.addEventListener) { kC.addEventListener("load", function (kG) { var kF = kG.target; kF.parentNode.removeChild(kF); T && T() }, false); kC.addEventListener("error", function (kG) { if (kG) { var kF = kG.target; kF && kF.parentNode && kF.parentNode.removeChild(kF) } kD && kD(null) }, false) } else { if (kC.attachEvent) { kC.attachEvent("onreadystatechange", function (kG) { var kF = window.event.srcElement; if (kF && (kF.readyState === "loaded" || kF.readyState === "complete")) { kF.parentNode.removeChild(kF) } T && T() }) } } e.getElementsByTagName("head")[0].appendChild(kC) } return { load: function (kF, T, kC) { if (typeof kF === "string") { i(kF, T, kC) } else { if (kF.length > 0) { var kE = kF.length; for (var kD = 0; kD < kE; kD++) { i(kF[kD], function () { kE--; if (kE === 0 && T) { T() } }) } } } } } })(window.document); function il() { } il.instances = {}; il.getInstance = function (i, T) { if (il.instances[i]) { return il.instances[i] } var e = new kx(i, T); il.instances[i] = e; return e }; function kx(e, i) { this._name = e; this._baseZoom = 18; this._opts = { tileSize: 256 }; e9.extend(this._opts, i || {}) } kx.mapZoomBaseIndex = [8, 8, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]; kx.baseScaleZoom = [19, 17, 15, 12, 10, 9, 7, 5, 3]; kx.baseScaleZoomMercatorSize = [512, 2048, 4096, 32768, 65536, 262144, 1048576, 4194304, 8388608]; kx.mapZoomBaseZoomMapping = [3, 3, 3, 3, 5, 5, 7, 7, 9, 9, 10, 12, 12, 12, 15, 15, 17, 17, 19, 19, 19, 19, 19, 19, 19, 19]; kx.mapZoomStartZoomMapping = [3, 3, 3, 3, 4, 4, 6, 6, 8, 8, 10, 11, 11, 11, 14, 14, 16, 16, 18, 18, 18, 18, 18, 18, 18, 18]; kx.baseScaleTileSize = [1024, 1024, 512, 512, 256, 512, 512, 512, 256]; kx.mapZoomTileSize = [256, 256, 256, 256, 256, 512, 256, 512, 256, 512, 256, 256, 512, 1024, 256, 512, 512, 1024, 512, 1024, 2048, 4096, 4096 * 2, 4096 * 2 * 2, 4096 * 2 * 2 * 2, 4096 * 2 * 2 * 2 * 2]; kx.baseZoomInfo = { "3": [3], "5": [4, 5], "7": [6, 7], "9": [8, 9], "10": [10], "12": [11, 12, 13], "15": [14, 15], "17": [16, 17], "19": [18, 19, 20, 21, 22, 23, 24, 25] }; kx.prototype = { getName: function () { return this._name }, getTileSize: function (e) { e = Math.floor(e); if (e < 3) { e = 3 } if (this._name === "na") { return kx.mapZoomTileSize[e] } return this._opts.tileSize }, getBaseTileSize: function (i) { i = Math.floor(i); if (this._name === "na") { var e = kx.mapZoomBaseZoomMapping[i]; return kx.mapZoomTileSize[e] } return this._opts.tileSize }, getDataZoom: function (e) { e = Math.floor(e); if (this._name === "na") { return kx.mapZoomBaseZoomMapping[e] } return e }, getZoomUnits: function (e) { return Math.pow(2, (this._baseZoom - e)) }, getMercatorSize: function (T, i) { if (this._name === "na") { T = Math.floor(T); var e = kx.mapZoomBaseIndex[T]; return kx.baseScaleZoomMercatorSize[e] } return this._opts.tileSize * this.getZoomUnits(i) }, getBaseZoom: function () { return this._baseZoom }, getParentTile: function (kC, kI, kH, T, i) { if (this._name === "na") { var kD = kx.baseZoomInfo[kH]; T--; if (kD.indexOf(T) > -1) { return { col: kC, row: kI, zoom: kH, useZoom: T } } else { var kF = kx.mapZoomBaseIndex[kH]; var kE = kx.baseScaleZoom[kF + 1]; if (!kE) { return null } var kG = this.getFactorByZooms(kE, kH); var e = kx.baseZoomInfo[kE]; return { col: Math.floor(kC / kG), row: Math.floor(kI / kG), zoom: kE, useZoom: e[e.length - 1] } } return null } if (kH - 1 < i) { return null } return { col: Math.floor(kC / 2), row: Math.floor(kI / 2), zoom: kH - 1, useZoom: kH - 1 } }, getChildTiles: function (kD, kF, e, T, kM, kS) { if (this._name === "na") { var kC = kx.baseZoomInfo[e]; T += kS; if (kC.indexOf(T) > -1) { return [{ col: kD, row: kF, zoom: e, useZoom: T }] } else { var kQ = 0; var kN = e; while (kQ < kS) { var kR = kx.mapZoomBaseIndex[kN]; var kH = kx.baseScaleZoom[kR - 1]; if (!kH) { return null } var kI = kx.baseZoomInfo[kH]; if (kI[kS - 1]) { var kJ = []; var kL = this.getFactorByZooms(e, kH); var i = kD * kL; var kK = kF * kL; for (var kP = 0; kP < kL; kP++) { var kE = i + kP; for (var kO = 0; kO < kL; kO++) { var kG = kK + kO; kJ.push({ col: kE, row: kG, zoom: kH, useZoom: kI[kS - 1] }) } } return kJ } kQ += kI.length; if (kS === kI.length) { kN = kH } } } return null } var kJ = []; if (e + kS > kM) { return null } var kL = Math.pow(2, kS); var i = kD * kL; var kK = kF * kL; var kH = e + kS; var kJ = []; for (var kP = 0; kP < 2; kP++) { var kE = i + kP; for (var kO = 0; kO < 2; kO++) { var kG = kK + kO; kJ.push({ col: kE, row: kG, zoom: kH, useZoom: kH }) } } return kJ }, getFactorByZooms: function (i, kC) { var T = kx.mapZoomBaseIndex[i]; var kD = kx.mapZoomBaseIndex[kC]; var e = kx.baseScaleZoomMercatorSize[T]; var kE = kx.baseScaleZoomMercatorSize[kD]; return e / kE } }; var df = {}; var ad = ["swiftshader", "microsoft basic render driver"]; var hH = ["intel", "nvidia", "amd", "apple", "geforce"]; function gV(e) { e = e.toLowerCase(); if (ad.indexOf(e) >= 0) { return true } if (e.indexOf("mobile") >= 0) { return true } return false } function cI(T) { T = T.toLowerCase(); for (var e = 0; e < hH.length; e++) { if (T.indexOf(hH[e]) >= 0) { return true } } return false } function kv(e) { if (!e) { return false } if (gV(e)) { return false } if (cI(e)) { return true } return false } df.ifEnableEarth = function (i) { var e = df.ifEnableEarth; if (!i && typeof e._enable === "boolean") { return e._enable } if (df.ifSupportWebGL()) { e._enable = true; return true } e._enable = false; return false }; df.ifEnableWebGLMap = function (i) { var e = df.ifEnableWebGLMap; if (!i && typeof e._enable === "boolean") { return e._enable } if (df.ifSupportWebGL()) { if (aL.inMapHost) { e._enable = true; return true } else { if (window.Blob || window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder) { e._enable = true; return true } else { e._enable = false; return false } } } e._enable = false; return false }; df.params = {}; df.ifSupportWebGL = function () { var i = df.ifSupportWebGL; if (typeof i._supportWebGL === "boolean") { return i._supportWebGL } if (!window.WebGLRenderingContext) { i._supportWebGL = false; return false } var T = document.createElement("canvas"); T.width = 300; T.height = 150; var kD = null; var kJ = { alpha: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, stencil: false }; try { kD = T.getContext("webgl", kJ) || T.getContext("experimental-webgl", kJ) } catch (kF) { i._supportWebGL = false } if (kD === null) { i._supportWebGL = false } else { i._supportWebGL = true; var kH = kD.getExtension("WEBGL_debug_renderer_info"); var kG = ""; if (kH) { kG = kD.getParameter(kH.UNMASKED_RENDERER_WEBGL); if (kv(kG) === true) { i._supportWebGL = true } var kI = kD.getParameter(kH.UNMASKED_VENDOR_WEBGL); i._renderer = kG; i._vendor = kI } if (!kH && e9.Browser.firefox) { i._supportWebGL = true } if (!kH && e9.Platform.macintosh) { i._supportWebGL = true } if (kD.drawingBufferWidth !== T.width || kD.drawingBufferHeight !== T.height) { i._supportWebGL = false } if (kD.getParameter(kD.MAX_VERTEX_TEXTURE_IMAGE_UNITS) < 4) { i._supportWebGL = false } var kC = kD.getParameter(kD.MAX_TEXTURE_SIZE); df.params.maxTextureSize = kC; if (kC < 4096) { i._supportWebGL = false } var kE = kD.getParameter(kD.MAX_TEXTURE_IMAGE_UNITS); if (kE < 8) { i._supportWebGL = false } if (kD.getShaderPrecisionFormat && !kD.getShaderPrecisionFormat(kD.FRAGMENT_SHADER, kD.HIGH_FLOAT)) { hQ.sendMessage(a1(4, 246, 1, 1), ["monitor", "ShaderPrecision", "sys_" + kG]); return i._supportWebGL } if (!kD.getShaderPrecisionFormat || !kD.getShaderPrecisionFormat(kD.FRAGMENT_SHADER, kD.HIGH_FLOAT)) { hQ.sendMessage(a1(4, 246, 1, 1), ["monitor", "ShaderPrecision", "sys_" + kG]); return i._supportWebGL } if (!kD.getShaderPrecisionFormat || kD.getShaderPrecisionFormat(kD.FRAGMENT_SHADER, kD.HIGH_FLOAT).precision < 23) { i._supportWebGL = false } } return i._supportWebGL }; df.ifSupportCanvas2d = function () { var kD = df.ifSupportCanvas2d; if (typeof kD.supportCanvas2d === "boolean") { return kD.supportCanvas2d } var T = document.createElement("canvas"); var i = null; try { i = T.getContext("2d") } catch (kC) { kD.supportCanvas2d = false } if (i === null) { kD.supportCanvas2d = false } else { kD.supportCanvas2d = true } return kD.supportCanvas2d }; df.ifCanvas2dInBlackList = function () { return true }; df.ifEnableCanvas2dMap = function () { return false; var i = navigator.userAgent; var e = 0; var kC = 0; var kD = 0; if (/macintosh/ig.test(i)) { var T = 0; if (/(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(i) && !/chrome/i.test(i)) { T = parseInt((RegExp["\x241"] || RegExp["\x242"]), 10) } if (T > 0) { return false } return true } if (/windows nt (\d+\.\d)/ig.test(i)) { kC = parseFloat(RegExp.$1); if (kC >= 6.1) { if (/chrome\/(\d+\.\d)/i.test(i)) { e = parseFloat(RegExp.$1); if (e >= 31) { return true } } if (/MSIE (\d+(\.\d+)?)/.test(i)) { kD = parseFloat(RegExp.$1); if (kD >= 10) { return true } } if (/Firefox/.test(i)) { return true } if (/rv:11.0/ig.test(i)) { return true } if (/edge/ig.test(i)) { return true } } } return false }; df.ifSupportCSS3 = function (kG, i) { var kF = document.createElement("div"); var kE = "Webkit Moz O ms".split(" "); var e = kE.length; var T = ""; var kC = kF.style; if (kG in kC) { T = kG } kG = kG.replace(/^[a-z]/, function (kH) { return kH.toUpperCase() }); while (e--) { var kD = kE[e] + kG; if (kD in kC) { T = kD; break } } if (i) { return T } else { return T.length > 0 ? true : false } }; df.isModernBrowser = df.ifSupportCanvas2d() && df.ifSupportCSS3("transform"); function aC(i, e) { this._size = i; this._curSize = 0; this._cache = {}; this._least = null; this._most = null; this._options = { clearCallback: null, removeOldCallback: null }; e = e || {}; for (var T in e) { this._options[T] = e[T] } this._getDataTimes = 0; this._hitTimes = 0 } aC.prototype.setData = function (kC, kE) { var i = this._cache; var T = this._size; if (T === 0) { return } var e = this._curSize; if (e === T) { this._removeOld() } var kD; if (!i[kC]) { kD = { key: kC, data: kE, older: null, newwer: null }; i[kC] = kD; if (this._least === null) { this._least = kD } if (this._most === null) { this._most = kD } this._curSize++ } else { kD = i[kC]; kD.data = kE; if (this._most === kD) { return } kD.older && (kD.older.newer = kD.newer); kD.newer && (kD.newer.older = kD.older); if (this._least === kD) { this._least = kD.newer } } if (this._most && this._most !== kD) { this._most.newer = kD; kD.older = this._most; this._most = kD; kD.newer = null } }; aC.prototype.getData = function (e) { var i = this._cache[e]; this._getDataTimes++; if (i) { this._hitTimes++; var T = i.data; if (this._most === i) { return T } i.older && (i.older.newer = i.newer); i.newer && (i.newer.older = i.older); if (this._least === i) { this._least = i.newer } this._most.newer = i; i.older = this._most; i.newer = null; this._most = i; return T } return null }; aC.prototype.getAllData = function () { return this._cache }; aC.prototype.getHitRate = function () { return this._hitTimes / this._getDataTimes }; aC.prototype.removeData = function (i) { var e = this._cache; var T = e[i]; if (!T) { return } if (this._options.clearCallback) { this._options.clearCallback(T.data, T.key) } T.older && (T.older.newer = T.newer); T.newer && (T.newer.older = T.older); if (this._least === T) { this._least = T.newer } if (this._most === T) { this._most = T.older } delete e[i]; this._curSize-- }; aC.prototype._removeOld = function () { var e = this._cache; var kC = Math.round(this._size * 0.6); var T = 0; while (this._least && T < kC) { var i = this._least; this._least = i.newer; i.newer && (i.newer.older = null); if (this._options.clearCallback) { this._options.clearCallback(i.data, i.key) } delete e[i.key]; T++ } this._curSize -= T; if (this._options.removeOldCallback) { this._options.removeOldCallback() } }; aC.prototype.clear = function () { var e = this._cache; var i = this._least; if (this._options.clearCallback) { while (i) { this._options.clearCallback(i.data, i.key); i = i.newer } } this._least = this._most = null; this._cache = {}; this._curSize = 0 }; aC.prototype.forEach = function (e) { var i = this._least; while (i) { e(i.data); i = i.newer } }; aC.prototype.clearExcept = function (i) { var e = this._cache; var T = this._least; while (T) { if (!i[T.key]) { if (this._options.clearCallback) { this._options.clearCallback(T.data, T.key) } T.older && (T.older.newer = T.newer); T.newer && (T.newer.older = T.older); if (this._least === T) { this._least = T.newer } if (this._most === T) { this._most = T.older } delete e[T.key]; this._curSize-- } T = T.newer } }; !function (T, i) { "object" == typeof bG && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (T = "undefined" != typeof globalThis ? globalThis : T || self).gcoord = i() }(this, (function () { var lg = function () { return (lg = Object.assign || function (ll) { for (var i, T = 1, ln = arguments.length; T < ln; T++) { for (var lm in i = arguments[T]) { Object.prototype.hasOwnProperty.call(i, lm) && (ll[lm] = i[lm]) } } return ll }).apply(this, arguments) }, k1 = Math.sin, k3 = Math.cos, k7 = Math.sqrt, k6 = Math.abs, lk = Math.PI, lc = 6378245, k0 = 0.006693421622965823; function lf(T, i) { return T >= 72.004 && T <= 137.8347 && i >= 0.8293 && i <= 55.8271 } function li(ln, lm) { var lq, i, ls, T = (ls = 300 + (lq = ln - 105) + 2 * (i = lm - 35) + 0.1 * lq * lq + 0.1 * lq * i + 0.1 * k7(k6(lq)), ls += 2 * (20 * k1(6 * lq * lk) + 20 * k1(2 * lq * lk)) / 3, (ls += 2 * (20 * k1(lq * lk) + 40 * k1(lq / 3 * lk)) / 3) + 2 * (150 * k1(lq / 12 * lk) + 300 * k1(lq / 30 * lk)) / 3), ll = function (lv, lu) { var lt = 2 * lv - 100 + 3 * lu + 0.2 * lu * lu + 0.1 * lv * lu + 0.2 * k7(k6(lv)); return lt += 2 * (20 * k1(6 * lv * lk) + 20 * k1(2 * lv * lk)) / 3, lt += 2 * (20 * k1(lu * lk) + 40 * k1(lu / 3 * lk)) / 3, lt + 2 * (160 * k1(lu / 12 * lk) + 320 * k1(lu * lk / 30)) / 3 }(ln - 105, lm - 35), lp = lm / 180 * lk, lo = k1(lp), lr = k7(lo = 1 - k0 * lo * lo); return [T = 180 * T / (lc / lr * k3(lp) * lk), ll = 180 * ll / (lc * (1 - k0) / (lo * lr) * lk)] } function k9(ll) { var i = ll[0], T = ll[1]; if (!lf(i, T)) { return [i, T] } var lm = li(i, T); return [i + lm[0], T + lm[1]] } function k2(ln) { var lr = ln[0], T = ln[1]; if (!lf(lr, T)) { return [lr, T] } for (var ll = [lr, T], lp = ll[0], lm = ll[1], lq = k9([lp, lm]), lo = lq[0] - lr, ls = lq[1] - T; k6(lo) > 0.000001 || k6(ls) > 0.000001;) { lo = (lq = k9([lp -= lo, lm -= ls]))[0] - lr, ls = lq[1] - T } return [lp, lm] } var ld = Math.sin, le = Math.cos, kK = Math.atan2, lh = Math.sqrt, kZ = 3000 * Math.PI / 180; function k5(ll) { var i = ll[0] - 0.0065, T = ll[1] - 0.006, ln = lh(i * i + T * T) - 0.00002 * ld(T * kZ), lm = kK(T, i) - 0.000003 * le(i * kZ); return [ln * le(lm), ln * ld(lm)] } function kO(ll) { var i = ll[0], T = ll[1], ln = lh(i * i + T * T) + 0.00002 * ld(T * kZ), lm = kK(T, i) + 0.000003 * le(i * kZ); return [ln * le(lm) + 0.0065, ln * ld(lm) + 0.006] } var kW = 180 / Math.PI, kF = Math.PI / 180, kH = 6378137, lj = 20037508.342789244; function kT(i) { return [i[0] * kW / kH, (0.5 * Math.PI - 2 * Math.atan(Math.exp(-i[1] / kH))) * kW] } function k8(ll) { var i = Math.abs(ll[0]) <= 180 ? ll[0] : ll[0] - 360 * (ll[0] < 0 ? -1 : 1), T = [kH * i * kF, kH * Math.log(Math.tan(0.25 * Math.PI + 0.5 * ll[1] * kF))]; return T[0] > lj && (T[0] = lj), T[0] < -lj && (T[0] = -lj), T[1] > lj && (T[1] = lj), T[1] < -lj && (T[1] = -lj), T } var kS, kR, kQ, kY, kN, kC, kX = Math.abs, la = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0], kM = [75, 60, 45, 30, 15, 0], kE = [[1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2], [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]], lb = [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]]; function kL(lm, T, ll) { var lo = kX(T) / ll[9], ln = ll[0] + ll[1] * kX(lm), i = ll[2] + ll[3] * lo + ll[4] * Math.pow(lo, 2) + ll[5] * Math.pow(lo, 3) + ll[6] * Math.pow(lo, 4) + ll[7] * Math.pow(lo, 5) + ll[8] * Math.pow(lo, 6); return [ln *= lm < 0 ? -1 : 1, i *= T < 0 ? -1 : 1] } function k4(ll) { for (var i = ll[0], T = ll[1], ln = [], lm = 0; lm < kM.length; lm++) { if (kX(T) > kM[lm]) { ln = lb[lm]; break } } return kL(i, T, ln) } function kJ(ll) { for (var i = ll[0], T = ll[1], ln = [], lm = 0; lm < la.length; lm++) { if (T >= la[lm]) { ln = kE[lm]; break } } return kL(i, T, ln) } function kI(T, i) { if (!T) { throw new Error(i) } } function kU(i) { return !!i && "[object Array]" === Object.prototype.toString.call(i) } function kP(i) { return !isNaN(Number(i)) && null !== i && !kU(i) } function kG() { for (var ll = [], i = 0; i < arguments.length; i++) { ll[i] = arguments[i] } var T = ll.length - 1; return function () { for (var lm = [], lo = 0; lo < arguments.length; lo++) { lm[lo] = arguments[lo] } for (var ln = T, e = ll[T].apply(null, lm); ln--;) { e = ll[ln].call(null, e) } return e } } function kD(lC, lr, lt) { if (void 0 === lt && (lt = !1), null !== lC) { for (var lw, lv, lF, ly, lq, lB, lE, lx, ls = 0, lz = 0, lA = lC.type, lm = "FeatureCollection" === lA, lD = "Feature" === lA, lp = lm ? lC.features.length : 1, lu = 0; lu < lp; lu++) { lq = (lx = !!(lE = lm ? lC.features[lu].geometry : lD ? lC.geometry : lC) && "GeometryCollection" === lE.type) ? lE.geometries.length : 1; for (var lo = 0; lo < lq; lo++) { var ln = 0, T = 0; if (null !== (ly = lx ? lE.geometries[lo] : lE)) { var ll = ly.type; switch (ls = !lt || "Polygon" !== ll && "MultiPolygon" !== ll ? 0 : 1, ll) { case null: break; case "Point": if (!1 === lr(lB = ly.coordinates, lz, lu, ln, T)) { return !1 } lz++, ln++; break; case "LineString": case "MultiPoint": for (lB = ly.coordinates, lw = 0; lw < lB.length; lw++) { if (!1 === lr(lB[lw], lz, lu, ln, T)) { return !1 } lz++, "MultiPoint" === ll && ln++ } "LineString" === ll && ln++; break; case "Polygon": case "MultiLineString": for (lB = ly.coordinates, lw = 0; lw < lB.length; lw++) { for (lv = 0; lv < lB[lw].length - ls; lv++) { if (!1 === lr(lB[lw][lv], lz, lu, ln, T)) { return !1 } lz++ } "MultiLineString" === ll && ln++, "Polygon" === ll && T++ } "Polygon" === ll && ln++; break; case "MultiPolygon": for (lB = ly.coordinates, lw = 0; lw < lB.length; lw++) { for (T = 0, lv = 0; lv < lB[lw].length; lv++) { for (lF = 0; lF < lB[lw][lv].length - ls; lF++) { if (!1 === lr(lB[lw][lv][lF], lz, lu, ln, T)) { return !1 } lz++ } T++ } ln++ } break; case "GeometryCollection": for (lw = 0; lw < ly.geometries.length; lw++) { if (!1 === kD(ly.geometries[lw], lr, lt)) { return !1 } } break; default: throw new Error("Unknown Geometry Type") } } } } } } !function (i) { i.WGS84 = "WGS84", i.WGS1984 = "WGS84", i.EPSG4326 = "WGS84", i.GCJ02 = "GCJ02", i.AMap = "GCJ02", i.BD09 = "BD09", i.BD09LL = "BD09", i.Baidu = "BD09", i.BMap = "BD09", i.BD09MC = "BD09MC", i.BD09Meter = "BD09MC", i.EPSG3857 = "EPSG3857", i.EPSG900913 = "EPSG3857", i.EPSG102100 = "EPSG3857", i.WebMercator = "EPSG3857", i.WM = "EPSG3857" }(kC || (kC = {})); var kV = { WGS84: { to: (kS = {}, kS[kC.GCJ02] = k9, kS[kC.BD09] = kG(kO, k9), kS[kC.BD09MC] = kG(k4, kO, k9), kS[kC.EPSG3857] = k8, kS) }, GCJ02: { to: (kR = {}, kR[kC.WGS84] = k2, kR[kC.BD09] = kO, kR[kC.BD09MC] = kG(k4, kO), kR[kC.EPSG3857] = kG(k8, k2), kR) }, BD09: { to: (kQ = {}, kQ[kC.WGS84] = kG(k2, k5), kQ[kC.GCJ02] = k5, kQ[kC.EPSG3857] = kG(k8, k2, k5), kQ[kC.BD09MC] = k4, kQ) }, EPSG3857: { to: (kY = {}, kY[kC.WGS84] = kT, kY[kC.GCJ02] = kG(k9, kT), kY[kC.BD09] = kG(kO, k9, kT), kY[kC.BD09MC] = kG(k4, kO, k9, kT), kY) }, BD09MC: { to: (kN = {}, kN[kC.WGS84] = kG(k2, k5, kJ), kN[kC.GCJ02] = kG(k5, kJ), kN[kC.EPSG3857] = kG(k8, k2, k5, kJ), kN[kC.BD09] = kJ, kN) } }; return lg(lg({}, kC), { CRSTypes: kC, transform: function (lp, ln, lo) { if (kI(!!lp, "The args[0] input coordinate is required"), kI(!!ln, "The args[1] original coordinate system is required"), kI(!!lo, "The args[2] target coordinate system is required"), ln === lo) { return lp } var lr = kV[ln]; kI(!!lr, "Invalid original coordinate system: " + ln); var lq = lr.to[lo]; kI(!!lq, "Invalid target coordinate system: " + lo); var T = typeof lp; if (kI("string" === T || "object" === T, "Invalid input coordinate type: " + T), "string" === T) { try { lp = JSON.parse(lp) } catch (ln) { throw new Error("Invalid input coordinate: " + lp) } } var lm = !1; kU(lp) && (kI(lp.length >= 2, "Invalid input coordinate: " + lp), kI(kP(lp[0]) && kP(lp[1]), "Invalid input coordinate: " + lp), lp = lp.map(Number), lm = !0); var ll = lq; return lm ? ll(lp) : (kD(lp, (function (ls) { var i; i = ll(ls), ls[0] = i[0], ls[1] = i[1] })), lp) } }) })); var hW = { ColorRefTable: { aliceblue: ["#f0f8ff", "rgb(240,248,255)"], antiquewhite: ["#faebd7", "rgb(250,235,215)"], aqua: ["#00ffff", "rgb(0,255,255)"], aquamarine: ["#7fffd4", "rgb(127,255,212)"], azure: ["#f0ffff", "rgb(240,255,255)"], beige: ["#f5f5dc", "rgb(245,245,220)"], bisque: ["#ffe4c4", "rgb(255,228,196)"], black: ["#000000", "rgb(0,0,0)"], blanchedalmond: ["#ffebcd", "rgb(255,235,205)"], blue: ["#0000ff", "rgb(0,0,255)"], blueviolet: ["#8a2be2", "rgb(138,43,226)"], brown: ["#a52a2a", "rgb(165,42,42)"], burlywood: ["#deb887", "rgb(222,184,135)"], cadetblue: ["#5f9ea0", "rgb(95,158,160)"], chartreuse: ["#7fff00", "rgb(127,255,0)"], chocolate: ["#d2691e", "rgb(210,105,30)"], coral: ["#ff7f50", "rgb(255,127,80)"], cornflowerblue: ["#6495ed", "rgb(100,149,237)"], cornsilk: ["#fff8dc", "rgb(255,248,220)"], crimson: ["#dc143c", "rgb(220,20,60)"], cyan: ["#00ffff", "rgb(0,255,255)"], darkblue: ["#00008b", "rgb(0,0,139)"], darkcyan: ["#008b8b", "rgb(0,139,139)"], darkgoldenrod: ["#b8860b", "rgb(184,134,11)"], darkgray: ["#a9a9a9", "rgb(169,169,169)"], darkgreen: ["#006400", "rgb(0,100,0)"], darkgrey: ["#a9a9a9", "rgb(169,169,169)"], darkkhaki: ["#bdb76b", "rgb(189,183,107)"], darkmagenta: ["#8b008b", "rgb(139,0,139)"], darkolivegreen: ["#556b2f", "rgb(85,107,47)"], darkorange: ["#ff8c00", "rgb(255,140,0)"], darkorchid: ["#9932cc", "rgb(153,50,204)"], darkred: ["#8b0000", "rgb(139,0,0)"], darksalmon: ["#e9967a", "rgb(233,150,122)"], darkseagreen: ["#8fbc8f", "rgb(143,188,143)"], darkslateblue: ["#483d8b", "rgb(72,61,139)"], darkslategray: ["#2f4f4f", "rgb(47,79,79)"], darkslategrey: ["#2f4f4f", "rgb(47,79,79)"], darkturquoise: ["#00ced1", "rgb(0,206,209)"], darkviolet: ["#9400d3", "rgb(148,0,211)"], deeppink: ["#ff1493", "rgb(255,20,147)"], deepskyblue: ["#00bfff", "rgb(0,191,255)"], dimgray: ["#696969", "rgb(105,105,105)"], dimgrey: ["#696969", "rgb(105,105,105)"], dodgerblue: ["#1e90ff", "rgb(30,144,255)"], firebrick: ["#b22222", "rgb(178,34,34)"], floralwhite: ["#fffaf0", "rgb(255,250,240)"], forestgreen: ["#228b22", "rgb(34,139,34)"], fuchsia: ["#ff00ff", "rgb(255,0,255)"], gainsboro: ["#dcdcdc", "rgb(220,220,220)"], ghostwhite: ["#f8f8ff", "rgb(248,248,255)"], gold: ["#ffd700", "rgb(255,215,0)"], goldenrod: ["#daa520", "rgb(218,165,32)"], gray: ["#808080", "rgb(128,128,128)"], green: ["#008000", "rgb(0,128,0)"], greenyellow: ["#adff2f", "rgb(173,255,47)"], grey: ["#808080", "rgb(128,128,128)"], honeydew: ["#f0fff0", "rgb(240,255,240)"], hotpink: ["#ff69b4", "rgb(255,105,180)"], indianred: ["#cd5c5c", "rgb(205,92,92)"], indigo: ["#4b0082", "rgb(75,0,130)"], ivory: ["#fffff0", "rgb(255,255,240)"], khaki: ["#f0e68c", "rgb(240,230,140)"], lavender: ["#e6e6fa", "rgb(230,230,250)"], lavenderblush: ["#fff0f5", "rgb(255,240,245)"], lawngreen: ["#7cfc00", "rgb(124,252,0)"], lemonchiffon: ["#fffacd", "rgb(255,250,205)"], lightblue: ["#add8e6", "rgb(173,216,230)"], lightcoral: ["#f08080", "rgb(240,128,128)"], lightcyan: ["#e0ffff", "rgb(224,255,255)"], lightgoldenrodyellow: ["#fafad2", "rgb(250,250,210)"], lightgray: ["#d3d3d3", "rgb(211,211,211)"], lightgreen: ["#90ee90", "rgb(144,238,144)"], lightgrey: ["#d3d3d3", "rgb(211,211,211)"], lightpink: ["#ffb6c1", "rgb(255,182,193)"], lightsalmon: ["#ffa07a", "rgb(255,160,122)"], lightseagreen: ["#20b2aa", "rgb(32,178,170)"], lightskyblue: ["#87cefa", "rgb(135,206,250)"], lightslategray: ["#778899", "rgb(119,136,153)"], lightslategrey: ["#778899", "rgb(119,136,153)"], lightsteelblue: ["#b0c4de", "rgb(176,196,222)"], lightyellow: ["#ffffe0", "rgb(255,255,224)"], lime: ["#00ff00", "rgb(0,255,0)"], limegreen: ["#32cd32", "rgb(50,205,50)"], linen: ["#faf0e6", "rgb(250,240,230)"], magenta: ["#ff00ff", "rgb(255,0,255)"], maroon: ["#800000", "rgb(128,0,0)"], mediumaquamarine: ["#66cdaa", "rgb(102,205,170)"], mediumblue: ["#0000cd", "rgb(0,0,205)"], mediumorchid: ["#ba55d3", "rgb(186,85,211)"], mediumpurple: ["#9370db", "rgb(147,112,219)"], mediumseagreen: ["#3cb371", "rgb(60,179,113)"], mediumslateblue: ["#7b68ee", "rgb(123,104,238)"], mediumspringgreen: ["#00fa9a", "rgb(0,250,154)"], mediumturquoise: ["#48d1cc", "rgb(72,209,204)"], mediumvioletred: ["#c71585", "rgb(199,21,133)"], midnightblue: ["#191970", "rgb(25,25,112)"], mintcream: ["#f5fffa", "rgb(245,255,250)"], mistyrose: ["#ffe4e1", "rgb(255,228,225)"], moccasin: ["#ffe4b5", "rgb(255,228,181)"], navajowhite: ["#ffdead", "rgb(255,222,173)"], navy: ["#000080", "rgb(0,0,128)"], oldlace: ["#fdf5e6", "rgb(253,245,230)"], olive: ["#808000", "rgb(128,128,0)"], olivedrab: ["#6b8e23", "rgb(107,142,35)"], orange: ["#ffa500", "rgb(255,165,0)"], orangered: ["#ff4500", "rgb(255,69,0)"], orchid: ["#da70d6", "rgb(218,112,214)"], palegoldenrod: ["#eee8aa", "rgb(238,232,170)"], palegreen: ["#98fb98", "rgb(152,251,152)"], paleturquoise: ["#afeeee", "rgb(175,238,238)"], palevioletred: ["#db7093", "rgb(219,112,147)"], papayawhip: ["#ffefd5", "rgb(255,239,213)"], peachpuff: ["#ffdab9", "rgb(255,218,185)"], peru: ["#cd853f", "rgb(205,133,63)"], pink: ["#ffc0cb", "rgb(255,192,203)"], plum: ["#dda0dd", "rgb(221,160,221)"], powderblue: ["#b0e0e6", "rgb(176,224,230)"], purple: ["#800080", "rgb(128,0,128)"], red: ["#ff0000", "rgb(255,0,0)"], rosybrown: ["#bc8f8f", "rgb(188,143,143)"], royalblue: ["#4169e1", "rgb(65,105,225)"], saddlebrown: ["#8b4513", "rgb(139,69,19)"], salmon: ["#fa8072", "rgb(250,128,114)"], sandybrown: ["#f4a460", "rgb(244,164,96)"], seagreen: ["#2e8b57", "rgb(46,139,87)"], seashell: ["#fff5ee", "rgb(255,245,238)"], sienna: ["#a0522d", "rgb(160,82,45)"], silver: ["#c0c0c0", "rgb(192,192,192)"], skyblue: ["#87ceeb", "rgb(135,206,235)"], slateblue: ["#6a5acd", "rgb(106,90,205)"], slategray: ["#708090", "rgb(112,128,144)"], slategrey: ["#708090", "rgb(112,128,144)"], snow: ["#fffafa", "rgb(255,250,250)"], springgreen: ["#00ff7f", "rgb(0,255,127)"], steelblue: ["#4682b4", "rgb(70,130,180)"], tan: ["#d2b48c", "rgb(210,180,140)"], teal: ["#008080", "rgb(0,128,128)"], thistle: ["#d8bfd8", "rgb(216,191,216)"], tomato: ["#ff6347", "rgb(255,99,71)"], turquoise: ["#40e0d0", "rgb(64,224,208)"], violet: ["#ee82ee", "rgb(238,130,238)"], wheat: ["#f5deb3", "rgb(245,222,179)"], white: ["#ffffff", "rgb(255,255,255)"], whitesmoke: ["#f5f5f5", "rgb(245,245,245)"], yellow: ["#ffff00", "rgb(255,255,0)"], yellowgreen: ["#9acd32", "rgb(154,205,50)"] }, regGroup: { hex: /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, rgb: /rgb\(\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*\)/, rgba: /rgba\(\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(0|1|0\.[1-9])\s*\)/ }, parseHexToRgbaArray: function (kE) { var kF = kE.replace("#", ""); if (kF.length === 3) { kF += "f" } else { if (kF.length === 6) { kF += "ff" } } var e = []; var kD = kF.length; var kC = kD === 8 ? 2 : 1; for (var T = 0; T < kD; T = T + kC) { if (kC === 2) { e.push(parseInt(kF.slice(T, T + 2), 16)) } else { e.push(parseInt(kF.slice(T, T + 1) + kF.slice(T, T + 1), 16)) } } return e }, parseRgbaStrToArray: function (i) { var e = [0, 0, 0, 255]; if (i.indexOf("rgba(") === 0) { var kC = i.replace("rgba(", "").replace(")", ""); var T = kC.split(","); e[0] = parseInt(T[0], 10); e[1] = parseInt(T[1], 10); e[2] = parseInt(T[2], 10); e[3] = Math.round(parseFloat(T[3]) * 255) } else { if (i.indexOf("rgb(") === 0) { var kC = i.replace("rgb(", "").replace(")", ""); var kD = kC.split(","); e[0] = parseInt(kD[0], 10); e[1] = parseInt(kD[1], 10); e[2] = parseInt(kD[2], 10); e[3] = 255 } } return e }, parseHexAndOpacityToRgbaArray: function (kD, kE) { var T = []; var kH = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/; var kG = kD.toLowerCase(); if (kH.test(kG)) { if (kG.length === 4) { var e = "#"; for (var kF = 1; kF < 4; kF++) { e += kG.slice(kF, kF + 1).concat(kG.slice(kF, kF + 1)) } kG = e } for (var kC = 1; kC < 7; kC += 2) { T.push(parseInt(kG.slice(kC, kC + 2), 16)) } T.push(kE) } return T }, parseCSSColor: function (e) { if (e.indexOf("#") === 0) { return hW.parseHexToRgbaArray(e) } return hW.parseRgbaStrToArray(e) }, rgbToHSV: function (kD) { var e = kD[0] / 255; var T = kD[1] / 255; var kE = kD[2] / 255; var kH = Math.max(e, T, kE); var kC = Math.min(e, T, kE); var kG = kH - kC; var i; if (kG === 0) { i = 0 } else { if (kH === e) { i = 60 * (((T - kE) / kG) % 6) } else { if (kH === T) { i = 60 * ((kE - e) / kG + 2) } else { if (kH === kE) { i = 60 * ((e - T) / kG + 4) } } } } var kI = kH === 0 ? 0 : (kG / kH); var kF = kH; while (i < 0) { i += 360 } return [i, kI, kF] }, hsvToRGB: function (kC) { var kG = kC[2] * kC[1]; var T = kG * (1 - Math.abs((kC[0] / 60) % 2 - 1)); var i = kC[2] - kG; var kD = kC[0]; var kF; var kE; var e; if (kD >= 0 && kD < 60) { kF = kG; kE = T; e = 0 } else { if (kD >= 60 && kD < 120) { kF = T; kE = kG; e = 0 } else { if (kD >= 120 && kD < 180) { kF = 0; kE = kG; e = T } else { if (kD >= 180 && kD < 240) { kF = 0; kE = T; e = kG } else { if (kD >= 240 && kD < 300) { kF = T; kE = 0; e = kG } else { if (kD >= 300 && kD < 360) { kF = kG; kE = 0; e = T } } } } } } kF = (kF + i) * 255 > 255 ? 255 : (kF + i) * 255; kE = (kE + i) * 255 > 255 ? 255 : (kE + i) * 255; e = (e + i) * 255 > 255 ? 255 : (e + i) * 255; return [Math.round(kF), Math.round(kE), Math.round(e)] }, formatColorCssToRgbaArray: function (kE, T, kC) { kC = (typeof kC !== "boolean") ? true : kC; if (typeof kE !== "string") { return kC ? [0, 0, 0, 1] : [0, 0, 0, 255] } var i = (kE || "Black").trim().toLowerCase(); var e = []; var kD = hW.ColorRefTable[i]; if (kD !== undefined) { i = kD[0] } e = hW.parseCSSColor(i); if (T !== undefined && !isNaN(Number(T))) { T = Number(T); e[3] = hW.fitTo(T, 0, 1) } else { e[3] = Number((e[3] / 255).toFixed(2)) } if (!kC) { e[3] = Math.floor(e[3] * 255) } return e }, fitTo: function (T, i, e) { if (T < i) { T = i } else { if (T > e) { T = e } } return T }, generateColorRamp: function (e, kI, kJ, kC, kO) { kJ = kJ || []; kC = kC || "#ccc"; kO = kO || 1; const T = document.createElement("canvas"); const kP = T.getContext("2d"); T.width = 256; T.height = kO; const kE = kI[0]; const kL = kI[kI.length - 1]; if (e.length === kI.length) { const kM = kP.createLinearGradient(0, 0, 256, 1); for (var kH = 0; kH < e.length; ++kH) { var kN = (kI[kH] - kE) / (kL - kE); kM.addColorStop(kN, e[kH]) } kP.fillStyle = kM; kP.fillRect(0, 0, 256, kO) } else { if (e.length - kI.length === -1) { var kG = 0; var kD = 1; for (var kH = 0; kH < e.length; ++kH) { var kK = (kI[kD] - kE) / (kL - kE); var kN = Math.floor(kK * 256); kP.fillStyle = e[kH]; kP.fillRect(kG, 0, kN, kO); kG = kN; kD++ } } else { kP.fillStyle = kC || "#ccc"; kP.fillRect(0, 0, 256, kO) } } if (e.length - kI.length <= -1 && kJ.length === 2) { kP.fillStyle = kC || "#ccc"; var kK = (kJ[0] - kE) / (kL - kE); var kN = Math.floor(kK * 256); kP.fillRect(0, 0, kN, kO); kK = (kJ[1] - kE) / (kL - kE); kN = Math.floor(kK * 256); kP.fillRect(kN, 0, 255, kO) } var kF = new Uint8Array(new Uint8ClampedArray(kP.getImageData(0, 0, 256, kO).data)); return { canvas: T, data: kF, width: 256, height: kO } }, validateColor: function (e, i) { return hW.regGroup[i].test(e) }, convert2rgba: function (e, i) { if (i === undefined) { i = 1 } if (hW.validateColor(e, "rgba")) { return e } if (hW.validateColor(e, "rgb")) { e = e.replace(/rgb/g, "rgba"); e = e.replace(/\)/, "," + i + ")"); return e } var T = hW.formatColorCssToRgbaArray(e, i, true); return "rgba(" + T.join(",") + ")" } }; (function (kE) { function kO(kT, kW) { var kV = (kT & 65535) + (kW & 65535); var kU = (kT >> 16) + (kW >> 16) + (kV >> 16); return (kU << 16) | (kV & 65535) } function kN(kT, kU) { return (kT << kU) | (kT >>> (32 - kU)) } function kI(kY, kV, kU, kT, kX, kW) { return kO(kN(kO(kO(kV, kY), kO(kT, kW)), kX), kU) } function e(kV, kU, kZ, kY, kT, kX, kW) { return kI((kU & kZ) | (~kU & kY), kV, kU, kT, kX, kW) } function kF(kV, kU, kZ, kY, kT, kX, kW) { return kI((kU & kY) | (kZ & ~kY), kV, kU, kT, kX, kW) } function kL(kV, kU, kZ, kY, kT, kX, kW) { return kI(kU ^ kZ ^ kY, kV, kU, kT, kX, kW) } function kR(kV, kU, kZ, kY, kT, kX, kW) { return kI(kZ ^ (kU | ~kY), kV, kU, kT, kX, kW) } function T(k3, kY) { k3[kY >> 5] |= 128 << (kY % 32); k3[((kY + 64) >>> 9 << 4) + 14] = kY; var kV; var kX; var kW; var kU; var kT; var k2 = 1732584193; var k1 = -271733879; var k0 = -1732584194; var kZ = 271733878; for (kV = 0; kV < k3.length; kV += 16) { kX = k2; kW = k1; kU = k0; kT = kZ; k2 = e(k2, k1, k0, kZ, k3[kV], 7, -680876936); kZ = e(kZ, k2, k1, k0, k3[kV + 1], 12, -389564586); k0 = e(k0, kZ, k2, k1, k3[kV + 2], 17, 606105819); k1 = e(k1, k0, kZ, k2, k3[kV + 3], 22, -1044525330); k2 = e(k2, k1, k0, kZ, k3[kV + 4], 7, -176418897); kZ = e(kZ, k2, k1, k0, k3[kV + 5], 12, 1200080426); k0 = e(k0, kZ, k2, k1, k3[kV + 6], 17, -1473231341); k1 = e(k1, k0, kZ, k2, k3[kV + 7], 22, -45705983); k2 = e(k2, k1, k0, kZ, k3[kV + 8], 7, 1770035416); kZ = e(kZ, k2, k1, k0, k3[kV + 9], 12, -1958414417); k0 = e(k0, kZ, k2, k1, k3[kV + 10], 17, -42063); k1 = e(k1, k0, kZ, k2, k3[kV + 11], 22, -1990404162); k2 = e(k2, k1, k0, kZ, k3[kV + 12], 7, 1804603682); kZ = e(kZ, k2, k1, k0, k3[kV + 13], 12, -40341101); k0 = e(k0, kZ, k2, k1, k3[kV + 14], 17, -1502002290); k1 = e(k1, k0, kZ, k2, k3[kV + 15], 22, 1236535329); k2 = kF(k2, k1, k0, kZ, k3[kV + 1], 5, -165796510); kZ = kF(kZ, k2, k1, k0, k3[kV + 6], 9, -1069501632); k0 = kF(k0, kZ, k2, k1, k3[kV + 11], 14, 643717713); k1 = kF(k1, k0, kZ, k2, k3[kV], 20, -373897302); k2 = kF(k2, k1, k0, kZ, k3[kV + 5], 5, -701558691); kZ = kF(kZ, k2, k1, k0, k3[kV + 10], 9, 38016083); k0 = kF(k0, kZ, k2, k1, k3[kV + 15], 14, -660478335); k1 = kF(k1, k0, kZ, k2, k3[kV + 4], 20, -405537848); k2 = kF(k2, k1, k0, kZ, k3[kV + 9], 5, 568446438); kZ = kF(kZ, k2, k1, k0, k3[kV + 14], 9, -1019803690); k0 = kF(k0, kZ, k2, k1, k3[kV + 3], 14, -187363961); k1 = kF(k1, k0, kZ, k2, k3[kV + 8], 20, 1163531501); k2 = kF(k2, k1, k0, kZ, k3[kV + 13], 5, -1444681467); kZ = kF(kZ, k2, k1, k0, k3[kV + 2], 9, -51403784); k0 = kF(k0, kZ, k2, k1, k3[kV + 7], 14, 1735328473); k1 = kF(k1, k0, kZ, k2, k3[kV + 12], 20, -1926607734); k2 = kL(k2, k1, k0, kZ, k3[kV + 5], 4, -378558); kZ = kL(kZ, k2, k1, k0, k3[kV + 8], 11, -2022574463); k0 = kL(k0, kZ, k2, k1, k3[kV + 11], 16, 1839030562); k1 = kL(k1, k0, kZ, k2, k3[kV + 14], 23, -35309556); k2 = kL(k2, k1, k0, kZ, k3[kV + 1], 4, -1530992060); kZ = kL(kZ, k2, k1, k0, k3[kV + 4], 11, 1272893353); k0 = kL(k0, kZ, k2, k1, k3[kV + 7], 16, -155497632); k1 = kL(k1, k0, kZ, k2, k3[kV + 10], 23, -1094730640); k2 = kL(k2, k1, k0, kZ, k3[kV + 13], 4, 681279174); kZ = kL(kZ, k2, k1, k0, k3[kV], 11, -358537222); k0 = kL(k0, kZ, k2, k1, k3[kV + 3], 16, -722521979); k1 = kL(k1, k0, kZ, k2, k3[kV + 6], 23, 76029189); k2 = kL(k2, k1, k0, kZ, k3[kV + 9], 4, -640364487); kZ = kL(kZ, k2, k1, k0, k3[kV + 12], 11, -421815835); k0 = kL(k0, kZ, k2, k1, k3[kV + 15], 16, 530742520); k1 = kL(k1, k0, kZ, k2, k3[kV + 2], 23, -995338651); k2 = kR(k2, k1, k0, kZ, k3[kV], 6, -198630844); kZ = kR(kZ, k2, k1, k0, k3[kV + 7], 10, 1126891415); k0 = kR(k0, kZ, k2, k1, k3[kV + 14], 15, -1416354905); k1 = kR(k1, k0, kZ, k2, k3[kV + 5], 21, -57434055); k2 = kR(k2, k1, k0, kZ, k3[kV + 12], 6, 1700485571); kZ = kR(kZ, k2, k1, k0, k3[kV + 3], 10, -1894986606); k0 = kR(k0, kZ, k2, k1, k3[kV + 10], 15, -1051523); k1 = kR(k1, k0, kZ, k2, k3[kV + 1], 21, -2054922799); k2 = kR(k2, k1, k0, kZ, k3[kV + 8], 6, 1873313359); kZ = kR(kZ, k2, k1, k0, k3[kV + 15], 10, -30611744); k0 = kR(k0, kZ, k2, k1, k3[kV + 6], 15, -1560198380); k1 = kR(k1, k0, kZ, k2, k3[kV + 13], 21, 1309151649); k2 = kR(k2, k1, k0, kZ, k3[kV + 4], 6, -145523070); kZ = kR(kZ, k2, k1, k0, k3[kV + 11], 10, -1120210379); k0 = kR(k0, kZ, k2, k1, k3[kV + 2], 15, 718787259); k1 = kR(k1, k0, kZ, k2, k3[kV + 9], 21, -343485551); k2 = kO(k2, kX); k1 = kO(k1, kW); k0 = kO(k0, kU); kZ = kO(kZ, kT) } return [k2, k1, k0, kZ] } function kM(kU) { var kV; var kT = ""; var kW = kU.length * 32; for (kV = 0; kV < kW; kV += 8) { kT += String.fromCharCode((kU[kV >> 5] >>> (kV % 32)) & 255) } return kT } function kH(kU) { var kW; var kT = []; kT[(kU.length >> 2) - 1] = undefined; for (kW = 0; kW < kT.length; kW += 1) { kT[kW] = 0 } var kV = kU.length * 8; for (kW = 0; kW < kV; kW += 8) { kT[kW >> 5] |= (kU.charCodeAt(kW / 8) & 255) << (kW % 32) } return kT } function kG(kT) { return kM(T(kH(kT), kT.length * 8)) } function kS(kV, kY) { var kU; var kX = kH(kV); var kT = []; var kW = []; var kZ; kT[15] = kW[15] = undefined; if (kX.length > 16) { kX = T(kX, kV.length * 8) } for (kU = 0; kU < 16; kU += 1) { kT[kU] = kX[kU] ^ 909522486; kW[kU] = kX[kU] ^ 1549556828 } kZ = T(kT.concat(kH(kY)), 512 + kY.length * 8); return kM(T(kW.concat(kZ), 512 + 128)) } function kQ(kW) { var kV = "0123456789abcdef"; var kU = ""; var kT; var kX; for (kX = 0; kX < kW.length; kX += 1) { kT = kW.charCodeAt(kX); kU += kV.charAt((kT >>> 4) & 15) + kV.charAt(kT & 15) } return kU } function kJ(kT) { return unescape(encodeURIComponent(kT)) } function kC(kT) { return kG(kJ(kT)) } function kK(kT) { return kQ(kC(kT)) } function i(kT, kU) { return kS(kJ(kT), kJ(kU)) } function kP(kT, kU) { return kQ(i(kT, kU)) } function kD(kU, kV, kT) { if (!kV) { if (!kT) { return kK(kU) } return kC(kU) } if (!kT) { return kP(kV, kU) } return i(kV, kU) } if (typeof define === "function" && define.amd) { define(function () { return kD }) } else { if (typeof module === "object" && module.exports) { module.exports = kD } else { kE.md5 = kD } } })(this); var cT = { levels: { INFO: "info", WARNING: "warning", ERROR: "error" }, category: { JS: "js", RESOURCE: "resource", AJAX: "ajax" }, config: { jsError: true, resourceError: true, ajaxError: true }, hosts: "api.map.baidu.com|webmap0.bdimg.com|maponline0.bdimg.com|", ignoreUrl: "api.map.baidu.com/images/blank.gif", sender: true, collections: [], sendError: function () { }, init: function (i, e, T) { this.hosts += i ? i : ""; au && au(this.config, e); this.sender = true; if (T) { this.sender = false } this.hosts = this.urlScope(this.hosts); this.sendError = this.notifyError(); var kC = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {}; this.config.jsError && this.handleJavaScriptError(kC); this.config.resourceError && this.handleResourceError(kC); this.config.ajaxError && this.handleAjaxError(kC) }, handleJavaScriptError: function (T) { var e = this; var i = T.onerror; T.onerror = function (kG, kF, kC, kE, kD) { if (e.isFetch(e.category.JS) && e.hostExit(kF)) { if (kD && kD.stack) { e.sendError({ title: kG, msg: kD.stack, category: e.category.JS, level: e.levels.ERROR }) } else { if (typeof kG === "string") { e.sendError({ title: kG, msg: JSON.stringify({ resourceUrl: kF, rowNum: kC, colNum: kE }), category: "js", level: e.levels.ERROR }) } } } if (i && b0(i)) { i && i.apply(T, arguments) } } }, handleResourceError: function (i) { var e = this; i.addEventListener("error", function (kE) { if (kE) { var kF = kE.target || kE.srcElement; var kD = kF instanceof HTMLScriptElement || kF instanceof HTMLLinkElement || kF instanceof HTMLImageElement; if (!kD) { if (!i.onerror) { var T = kE.filename || null; if (!e.isFetch(e.category.JS) || !e.hostExit(T)) { return } if (kE.error && kE.error.stack) { e.sendError({ title: kE.message, msg: kE.error.stack, category: e.category.JS, level: e.levels.ERROR }) } else { if (typeof kE.message === "string") { e.sendError({ title: kE.message, msg: JSON.stringify({ resourceUrl: T, rowNum: kE.lineno, colNum: kE.cowno }), category: e.category.JS, level: e.levels.ERROR }) } } } return } var kC = kF.src || kF.href; if (e.isFetch(e.category.RESOURCE) && e.hostExit(kC)) { e.sendError({ title: kF.nodeName, msg: kC, category: e.category.RESOURCE, level: e.levels.ERROR }) } } }, true) }, handleAjaxError: function (kE) { var e = this; var kD = kE.location.protocol; if (kD === "file:") { return } if (!kE.XMLHttpRequest) { return } var i = kE.XMLHttpRequest; var T = i.prototype.send; var kC = function (kG) { if (kG && kG.currentTarget && kG.currentTarget.status !== 200) { var kF = kG.target.responseURL; if (e.isFetch(e.category.AJAX) && e.hostExit(kF)) { e.sendError({ title: kF, msg: JSON.stringify({ response: kG.target.response, responseURL: kF, status: kG.target.status, statusText: kG.target.statusText }), category: e.category.AJAX, level: e.levels.ERROR }) } } }; i.prototype.send = function () { if (this["addEventListener"]) { this["addEventListener"]("error", kC); this["addEventListener"]("load", kC); this["addEventListener"]("abort", kC) } else { var kF = this["onreadystatechange"]; this["onreadystatechange"] = function (kG) { if (this.readyState === 4) { kC(kG) } kF && kF.apply(this, arguments) } } return T.apply(this, arguments) } }, notifyError: function (T) { var i = T || 1000; this._idleWorkerTicker = (function (kC) { return function () { kC.runJob() } })(this); var e = this; return function (kD) { if (kD.url) { if (!e.isFetch(kD.category)) { return } var kC = kD.url || ""; if (!e.hostExit(kC)) { return } delete kD.url } if (!navigator.onLine) { return } e.collections.push(kD); e.checkJob(i) } }, runJob: function () { if (this.collections.length === 0) { clearInterval(this.idleWork); this.idleWork = null; return } var kD = this.collections.slice(0, 2); var T = jH(JSON.stringify({ dataset: kD })); var kC = new Date().getTime(); if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var i = eG.apiIMG + "/blank.gif?product=jsapi&v=gl&l=" + T + "&t=" + kC } else { var i = eG.apiIMG + "/blank.gif?product=jsapi&v=gl&l=" + T + "&ak=" + eZ + "&t=" + kC } if (this.sender) { try { var kF = document.createElement("div"); kF.style = "width:0;height:0;visibility: hidden;opacity: 0;z-index:-999;background-image: url(" + i + ");"; document.querySelector("BODY").appendChild(kF); setTimeout(function () { document.querySelector("BODY").removeChild(kF) }) } catch (kE) { } } this.collections.splice(0, 2); if (this.collections.length === 0) { clearInterval(this.idleWork); this.idleWork = null } }, checkJob: function (e) { if (!this.idleWork && this._idleWorkerTicker) { this.idleWork = setInterval(this._idleWorkerTicker, e) } }, urlScope: function (kC) { var T = {}; var kE = Object.keys(E); if (E && kE.length > 0) { for (var kD in E) { if (E[kD] && (typeof E[kD] !== "function")) { T[kD] = E[kD] } } } try { var kG = JSON.stringify(T); if (kG.length > 2) { return kC + "|" + kG } else { return kC } } catch (kF) { return kC } }, hostExit: function (i) { try { if (i && i.indexOf("//") === 0) { i = window.location.protocol + i } var T = new URL(i); if (!T || !T.host) { return false } var kD = T.host + T.pathname; if (this.ignoreUrl.indexOf(kD) === -1 && this.hosts.indexOf(T.host) > -1) { return true } return false } catch (kC) { return false } }, isFetch: function (e) { return this.config[e + "Error"] || false } }; bG.fetchDebug = cT; var hQ = { device: { PC: 0, NA: 1 }, config: { mask: ["FFFFFFFF"], open: true, reset: 60 * 60 * 1000 }, url: E.apiHost + "?qt=jsapi_log", startTime: Date.now(), mark: {}, records: {}, sendMessage: function (e, i) { }, init: function (i, T) { this.kill(); var e = this; this.config.open = !!i; T = T || {}; if (T.reset) { this.config.reset = T.reset } this.sendMessage = (function (kD) { var kC = kD || 1000; e._idleWorkerTicker = (function (kE) { return function () { kE.runJob() } })(e); return function (kE, kF) { if (window.navigator && !navigator.onLine) { return } if (Date.now() - e.startTime > e.config.reset) { e.startTime = Date.now(); e.mark = {}; e.records = {} } if (!e.mark[kE]) { e.mark[kE] = true; e.records[kE] = kF } e.checkJob(kC) } })(T.timers) }, runJob: function () { if (Object.keys(this.records).length === 0) { clearInterval(this.idleWork); this.idleWork = null; return } var kE = Object.keys(this.records); var kC = kE[0]; var T = new Date().getTime(); var kD = "logCbk" + Math.floor(Math.random() * 10000000000); bG[kD] = function (e) { delete bG[kD] }; if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var i = this.url + "&bmapgl2=1&device=" + (b5() ? this.device.NA : this.device.PC) + "&module=" + (this.records[kC][0] || "") + "&func=" + (this.records[kC][1] || "") + "&subfunc=" + (this.records[kC][2] || "") + "&t=" + T + "&callback=" + fF + "." + kD } else { var i = this.url + "&ak=" + eZ + "&bmapgl2=1&device=" + (b5() ? this.device.NA : this.device.PC) + "&module=" + (this.records[kC][0] || "") + "&func=" + (this.records[kC][1] || "") + "&subfunc=" + (this.records[kC][2] || "") + "&t=" + T + "&callback=" + fF + "." + kD } i += jL()(i); if (this.config.open) { try { g4.load(i); delete this.records[kC] } catch (kF) { } } if (Object.keys(this.records).length === 0) { clearInterval(this.idleWork); this.idleWork = null } }, checkJob: function (e) { if (!this.idleWork && this._idleWorkerTicker) { this.idleWork = setInterval(this._idleWorkerTicker, e) } }, kill: function () { if (this.idleWork) { clearInterval(this.idleWork); this.idleWork = null } this._idleWorkerTicker = null; this.mark = {}; this.records = {} } }; hQ.init(true, { reset: 20 * 60 * 1000 }); bG.WKT = (function () { var i = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/; var e = new RegExp("^" + i.source + "(\\s" + i.source + "){1,}"); return { parse: function (kH) { var kK = kH.split(";"); var kS = kK.pop(); var kP = (kK.shift() || "").split("=").pop(); var kO = 0; function kE(kU) { var kT = kS.substring(kO).match(kU); if (!kT) { return null } else { kO += kT[0].length; return kT[0] } } function kD(kT) { if (kT && kP.match(/\d+/)) { kT.crs = { type: "name", properties: { name: "urn:ogc:def:crs:EPSG::" + kP } } } return kT } function kF() { kE(/^\s*/) } function kJ() { kF(); var kX = 0; var kV = []; var kT = [kV]; var kW = kV; var kU; while (kU = kE(/^(\()/) || kE(/^(\))/) || kE(/^(,)/) || kE(e)) { if (kU === "(") { kT.push(kW); kW = []; kT[kT.length - 1].push(kW); kX++ } else { if (kU === ")") { if (kW.length === 0) { return null } kW = kT.pop(); if (!kW) { return null } kX--; if (kX === 0) { break } } else { if (kU === ",") { kW = []; kT[kT.length - 1].push(kW) } else { if (!kU.split(/\s/g).some(isNaN)) { Array.prototype.push.apply(kW, kU.split(/\s/g).map(parseFloat)) } else { return null } } } } kF() } if (kX !== 0) { return null } return kV } function kN() { var kU = []; var kT; var kV; while (kV = kE(e) || kE(/^(,)/)) { if (kV === ",") { kU.push(kT); kT = [] } else { if (!kV.split(/\s/g).some(isNaN)) { if (!kT) { kT = [] } Array.prototype.push.apply(kT, kV.split(/\s/g).map(parseFloat)) } } kF() } if (kT) { kU.push(kT) } else { return null } return kU.length ? kU : null } function kM() { if (!kE(/^(point(\sz)?)/i)) { return null } kF(); if (!kE(/^(\()/)) { return null } var kT = kN(); if (!kT) { return null } kF(); if (!kE(/^(\))/)) { return null } return { type: "Point", coordinates: kT[0] } } function kQ() { if (!kE(/^(multipoint)/i)) { return null } kF(); var kU = kS.substring(kS.indexOf("(") + 1, kS.length - 1).replace(/\(/g, "").replace(/\)/g, ""); kS = "MULTIPOINT (" + kU + ")"; var kT = kJ(); if (!kT) { return null } kF(); return { type: "MultiPoint", coordinates: kT } } function kG() { if (!kE(/^(multilinestring)/i)) { return null } kF(); var kT = kJ(); if (!kT) { return null } kF(); return { type: "MultiLineString", coordinates: kT } } function kC() { if (!kE(/^(linestring(\sz)?)/i)) { return null } kF(); if (!kE(/^(\()/)) { return null } var kT = kN(); if (!kT) { return null } if (!kE(/^(\))/)) { return null } return { type: "LineString", coordinates: kT } } function kI() { if (!kE(/^(polygon(\sz)?)/i)) { return null } kF(); var kT = kJ(); if (!kT) { return null } return { type: "Polygon", coordinates: kT } } function kR() { if (!kE(/^(multipolygon)/i)) { return null } kF(); var kT = kJ(); if (!kT) { return null } return { type: "MultiPolygon", coordinates: kT } } function T() { var kT = []; var kU; if (!kE(/^(geometrycollection)/i)) { return null } kF(); if (!kE(/^(\()/)) { return null } while (kU = kL()) { kT.push(kU); kF(); kE(/^(,)/); kF() } if (!kE(/^(\))/)) { return null } return { type: "GeometryCollection", geometries: kT } } function kL() { return kM() || kC() || kI() || kQ() || kG() || kR() || T() } return kD(kL()) }, stringify: function (T) { if (T.type === "Feature") { T = T.geometry } function kE(kH) { return kH.join(" ") } function kC(kH) { return kH.map(kE).join(", ") } function kD(kH) { return kH.map(kC).map(kF).join(", ") } function kG(kH) { return kH.map(kD).map(kF).join(", ") } function kF(kH) { return "(" + kH + ")" } switch (T.type) { case "Point": return "POINT (" + kE(T.coordinates) + ")"; case "LineString": return "LINESTRING (" + kC(T.coordinates) + ")"; case "Polygon": return "POLYGON (" + kD(T.coordinates) + ")"; case "MultiPoint": return "MULTIPOINT (" + kC(T.coordinates) + ")"; case "MultiPolygon": return "MULTIPOLYGON (" + kG(T.coordinates) + ")"; case "MultiLineString": return "MULTILINESTRING (" + kD(T.coordinates) + ")"; case "GeometryCollection": return "GEOMETRYCOLLECTION (" + T.geometries.map(stringify).join(", ") + ")"; default: throw new Error("stringify requires a valid GeoJSON Feature or geometry object as input") } } } })(); var kl = { request: function (kK, kG, kC, kN, kE) { var kH = new Date()["getTime"](); var kJ = (Math.random() * 100000)["toFixed"](0); bG._rd["_cbk" + kJ] = function (kO) { if (kO.result && kO.result["error"] && kO.result["error"] === 202) { alert("该AK因为恶意行为已经被管理员封禁！"); return } if (kO.result && kO.result["error"] && kO.result["error"] === 403) { if (hj !== null) { hj.update("未获得百度地图商用授权，可能导致部分地图请求失败，请刷新后重试。") } return } kC = kC || {}; kK && kK(kO, kC); delete bG._rd["_cbk" + kJ] }; kN = kN || ""; var kM; var kD; if (kC && kC.useEncodeURI) { kM = jJ(kG, encodeURI); kD = jJ(kG) } else { kM = jJ(kG, encodeURIComponent); kD = jJ(kG) } if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var i = window._BMapSecurityConfig["serviceHost"] + kN + "?" + kM + "&ie=utf-8&oue=1&fromproduct=jsapi"; var kI = window._BMapSecurityConfig["serviceHost"] + kN + "?" + kD + "&ie=utf-8&oue=1&fromproduct=jsapi" } else { var i = E.apiHost + "/" + kN + "?" + kM + "&ie=utf-8&oue=1&fromproduct=jsapi"; var kI = E.apiHost + "/" + kN + "?" + kD + "&ie=utf-8&oue=1&fromproduct=jsapi" } if (!kE) { i += "&res=api"; kI += "&res=api" } i += "&callback=" + fF + "._rd._cbk" + kJ; kI += "&callback=" + fF + "._rd._cbk" + kJ; var kF = window.___abvk ? window.___abvk : kl.getSeckeyCidItem("SECKEY_ABVK"); var e = kl.getSeckeyCidItem("BMAP_SECKEY"); var kL = encodeURIComponent(kF + "," + e); var T = kF + "," + e; if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { i += "&v=gl&seckey=" + kL + "&timeStamp=" + kH; kI += "&v=gl&seckey=" + T + "&timeStamp=" + kH } else { i += "&ak=" + eZ + "&v=gl&seckey=" + kL + "&timeStamp=" + kH; kI += "&ak=" + eZ + "&v=gl&seckey=" + T + "&timeStamp=" + kH } i += jL()(kI); g4.load(i) }, getSeckeyCidItem: function (e) { if (localStorage) { return localStorage.getItem(e) ? localStorage.getItem(e) : -1 } if (sessionStorage) { return sessionStorage.getItem(e) ? sessionStorage.getItem(e) : -1 } } }; window.srqtimer = null; window.firstTime = true; window.srqcount = 0; bG._rd = {}; var jg = (function () { var kP = {}; var kO = "HIGH"; var kI = "FOCUS"; var T = {}; var kC; function i(kQ) { var kV = kQ || []; for (var kW = 0; kW < kV.length; kW++) { var kZ = kV[kW]; var kY = []; for (var kU = 0; kU < kZ.length; kU++) { var kR = kZ[kU]; kY.push(new cG(kR[0], kR[1])) } var kS = new i3(kY); var kX = new fW("onbeforeaddoverlay", kS); kX.overlay = kS; kX.isLayerMask = true; kC.dispatchEvent(kX); kS._i(kC); kM(kO, kS); if (kC.config.highRegion) { if (kC.config.highRegion.lineOpt) { var kT = new bu(kY, kC.config.highRegion.lineOpt); kC.addOverlay(kT) } if (kC.config.highRegion.focusOpt) { kM(kI, kS) } } } } function e(kQ) { var kR = new fW("onbeforeaddoverlay", kQ); kR.overlay = kQ; kR.isLayerMask = true; kC.dispatchEvent(kR); kQ._i(kC); kM(kI, kQ) } function kK(kQ) { kL(kI, kQ) } function kM(kQ, kR) { if (kR) { if (!kG(kQ)) { kP[kQ] = [] } kP[kQ].push(kR) } kE(kQ) } function kL(kR, kS) { if (kS) { if (kG(kR)) { for (var kQ = 0; kQ < kP[kR].length; kQ++) { if (kP[kR][kQ] === kS) { kP[kR].splice(kQ, 1); break } } } } else { delete kP[kR] } kE(kR) } function kE(kU) { if (kG(kU)) { var kV = []; for (var kT = 0; kT < kN(kU).length; kT++) { var kS = kN(kU)[kT]; var kQ = kS.getFillStyleForGL(); var kW = kS.buildFillVertex(hX); var kR = [kQ, kW[0], kW[1]]; kR.hashCode = kS.hashCode; kR.hasMultipleParts = kS.hasMultipleParts; kV.push(kR) } T[kU] = kV } else { delete T[kU] } } function kH(kQ) { return T[kQ] } function kG(kQ) { return kP[kQ] ? true : false } function kN(kQ) { return kP[kQ] } function kJ(kQ, kR) { if (kP[kQ]) { kP[kQ].visible = kR } } function kD(kQ) { kC = kQ } function kF() { kP[kO] = []; kP[kI] = []; kP = {}; T = {} } return { HIGH: kO, FOCUS: kI, kill: kF, setMap: kD, dataProcessFromHigh: i, addFocusMask: e, removeFocusMask: kK, getMask: kN, getRender: kH, setVisible: kJ } })(); var dq = { request: function (i, kH) { var kD = new Date()["getTime"](); var kG = (Math.random() * 100000).toFixed(0); if (kH) { BMapGL._rd["_cbk" + kG] = function (kJ) { kH && kH(kJ); delete BMapGL._rd["_cbk" + kG] }; i += "&callback=BMapGL._rd._cbk" + kG } function kE(kK) { var kJ; var kL = new RegExp("(^| )" + kK + "=([^;]*)(;|$)"); if (kJ = document.cookie.match(kL)) { return unescape(kJ[2]) } else { return -1 } } if (i.indexOf("v=") === -1) { i += "&v=gl" } var kC = window.___abvk ? window.___abvk : this.getSeckeyCidItem("SECKEY_ABVK"); var e = this.getSeckeyCidItem("BMAP_SECKEY"); var kI = encodeURIComponent(kC + "," + e); var T = kC + "," + e; signUrl = i + "&seckey=" + T + "&timeStamp=" + kD; i += "&seckey=" + kI + "&timeStamp=" + kD; i += jL()(signUrl); var kF = b6("script", { src: i, type: "text/javascript", charset: "utf-8" }); if (kF.addEventListener) { kF.addEventListener("load", function (kK) { var kJ = kK.target; kJ.parentNode.removeChild(kJ) }, false); kF.addEventListener("error", function (kJ) { kH && kH([, , , , ,]) }, false) } else { if (kF.attachEvent) { kF.attachEvent("onreadystatechange", function (kK) { var kJ = window.event.srcElement; if (kJ && (kJ.readyState == "loaded" || kJ.readyState == "complete")) { kJ.parentNode.removeChild(kJ) } }) } } document.getElementsByTagName("head")[0].appendChild(kF); kF = null }, getSeckeyCidItem: function (e) { if (localStorage) { return localStorage.getItem(e) ? localStorage.getItem(e) : -1 } if (sessionStorage) { return sessionStorage.getItem(e) ? localStorage.getItem(e) : -1 } } }; function gZ() { this._map = null; this._container; this._type = "control"; this.blockInfoWindow = true; this._visible = true } gZ.inherits(dh, "Control"); e9.extend(gZ.prototype, { initialize: function (e) { this._map = e; if (this._container) { if (this._opts && this._opts.container) { this._opts.container.appendChild(this._container) } else { e.container.appendChild(this._container) } return this._container } return }, _i: function (e) { if (!this._container && this.initialize && b0(this.initialize)) { this._container = this.initialize(e) } this._opts = this._opts || { printable: false }; this._setStyle(); this._setPosition(); if (this._container) { this._container._jsobj = this } }, _setStyle: function () { var i = this._container; if (i) { var e = i.style; e.position = "absolute"; e.zIndex = this._cZIndex || "10"; e.MozUserSelect = "none"; if (!this._opts.printable) { e9.ac(i, "BMap_noprint") } e9.on(i, "contextmenu", hI) } }, remove: function () { this._map = null; if (!this._container) { return } this._container.parentNode && this._container.parentNode.removeChild(this._container); this._container._jsobj = null; this._container = null }, _render: function (e) { if (this._opts && this._opts.container) { this._container = bS(this._opts.container, '<div unselectable="on"></div>') } else { var i = '<div unselectable="on"></div>'; if (e && e.config.autoSafeArea && cC()) { this._safeAreaContainer = bS(this._map.container, i); this._safeAreaContainer.style.position = "absolute"; this._safeAreaContainer.style.bottom = "env(safe-area-inset-bottom)"; this._container = bS(this._safeAreaContainer, i) } else { this._container = bS(this._map.container, i) } } if (this._visible === false) { this._container.style.display = "none" } return this._container }, _setPosition: function () { this.setAnchor(this._opts.anchor) }, setAnchor: function (kC) { if (this.anchorFixed || typeof kC !== "number" || isNaN(kC) || kC < BMAP_ANCHOR_TOP_LEFT || kC > BMAP_ANCHOR_BOTTOM_RIGHT) { kC = this.defaultAnchor } this._opts.offset = this._opts.offset || this.defaultOffset; var T = this._opts.anchor; this._opts.anchor = kC; if (!this._container) { return } var kE = this._container; var e = this._opts.offset.width; var kD = this._opts.offset.height; kE.style.left = kE.style.top = kE.style.right = kE.style.bottom = "auto"; switch (kC) { case BMAP_ANCHOR_TOP_LEFT: kE.style.top = kD + "px"; kE.style.left = e + "px"; break; case BMAP_ANCHOR_TOP_RIGHT: kE.style.top = kD + "px"; kE.style.right = e + "px"; break; case BMAP_ANCHOR_BOTTOM_LEFT: kE.style.bottom = kD + "px"; kE.style.left = e + "px"; break; case BMAP_ANCHOR_BOTTOM_RIGHT: kE.style.bottom = kD + "px"; kE.style.right = e + "px"; break; default: break }var i = ["TL", "TR", "BL", "BR"]; e9.rc(this._container, "anchor" + i[T]); e9.ac(this._container, "anchor" + i[kC]) }, getAnchor: function () { return this._opts.anchor }, setOffset: function (e) { if (!e) { return } this._opts = this._opts || {}; this._opts.offset = new jo(e.width, e.height); if (!this._container) { return } this.setAnchor(this._opts.anchor) }, getOffset: function () { return this._opts.offset }, getDom: function () { return this._container }, show: function () { if (this._visible === true) { return } this._visible = true; if (this._container) { this._container.style.display = "" } this.dispatchEvent(new fW("onshow")) }, hide: function () { if (this._visible === false) { return } this._visible = false; if (this._container) { this._container.style.display = "none" } this.dispatchEvent(new fW("onhide")) }, isPrintable: function () { return !!this._opts.printable }, isVisible: function () { if (!this._container && !this._map) { return false } return !!this._visible }, _asyncLoadCode: function () { var e = this; hm.load("control", function () { if (e._asyncDraw) { e._asyncDraw() } }) } }); var es = { TOP_LEFT: 0, TOP_RIGHT: 1, BOTTOM_LEFT: 2, BOTTOM_RIGHT: 3 }; bG.ControlAnchor = es; window.BMAP_ANCHOR_TOP_LEFT = 0; window.BMAP_ANCHOR_TOP_RIGHT = 1; window.BMAP_ANCHOR_BOTTOM_LEFT = 2; window.BMAP_ANCHOR_BOTTOM_RIGHT = 3; function gn(e) { gZ.call(this); e = e || {}; this._opts = { printable: false }; e9.extend(this._opts, e); this._copyrightCollection = []; this.defaultAnchor = BMAP_ANCHOR_BOTTOM_LEFT; this.defaultOffset = new jo(5, 2); this.setAnchor(e.anchor); this._canShow = true; this.sateMapStyle = false; this.blockInfoWindow = false; this._asyncLoadCode() } gn.inherits(gZ, "CopyrightControl"); e9.extend(gn.prototype, { initialize: function (e) { this._map = e; return this._container }, addCopyright: function (kC) { var e = { minZoom: 0, bounds: null, content: "", mapType: "" }; for (var T in kC) { e[T] = kC[T] } if (this._map) { var kF = e.minZoom; if (kF === -1 || kF < this._map.getMinZoom() || kF > this._map.getMaxZoom()) { e.minZoom = this._map.getMinZoom() } if (e.mapType !== "" && !ev[e.mapType]) { e.mapType = BMAPGL_NORMAL_MAP } } var kD = this.getCopyright(kC.id); if (kD) { for (var kE in e) { kD[kE] = e[kE] } } else { this._copyrightCollection.push(e) } }, getCopyright: function (kC) { for (var T = 0, e = this._copyrightCollection.length; T < e; T++) { if (this._copyrightCollection[T].id === kC) { return this._copyrightCollection[T] } } }, addSateMapStyle: function () { this.sateMapStyle = true; if (this._container) { e9.ac(this._container, "BMap_cpyCtrl_w") } }, removeSateMapStyle: function () { this.sateMapStyle = false; if (this._container) { e9.rc(this._container, "BMap_cpyCtrl_w") } } }); function bB(e) { gZ.call(this); e = e || {}; this.canCheckSize = e.canCheckSize === false ? false : true; this.curCityName = ""; this.curCityCode = ""; this.defaultOffset = new jo(10, 10); this.defaultAnchor = es.TOP_LEFT; this.onChangeBefore = []; this.onChangeAfter = []; this.onChangeSuccess = []; this._opts = { printable: false, offset: e.offset || this.defaultOffset, anchor: e.anchor || this.defaultAnchor, expand: !!(e.expand) }; if (e.onChangeBefore && b0(e.onChangeBefore)) { this.onChangeBefore.push(e.onChangeBefore) } if (e.onChangeAfter && b0(e.onChangeAfter)) { this.onChangeAfter.push(e.onChangeAfter) } if (e.onChangeSuccess && b0(e.onChangeSuccess)) { this.onChangeSuccess.push(e.onChangeSuccess) } this.setAnchor(e.anchor); this._asyncLoadCode(); hQ.sendMessage(a1(4, 5, 3), ["control", "city"]) } bB.inherits(gZ, "CityListControl"); e9.extend(bB.prototype, { initialize: function (e) { this._map = e; return this._container } }); function kB(e) { gZ.call(this); e = e || {}; this._opts = { printable: false }; this._opts = e9.extend(e9.extend(this._opts, { unit: "metric" }), e); this.defaultAnchor = BMAP_ANCHOR_BOTTOM_LEFT; this.defaultOffset = new jo(81, 18); if (b5()) { this.defaultOffset = new jo(75, 10) } this.setAnchor(e.anchor); this._units = { metric: { name: "metric", conv: 1, incon: 1000, u1: "米", u2: "公里" }, us: { name: "us", conv: 3.2808, incon: 5280, u1: "英尺", u2: "英里" } }; this.sateMapStyle = false; if (!this._units[this._opts.unit]) { this._opts.unit = "metric" } this._scaleText = null; this._numberArray = {}; this._asyncLoadCode() } window.BMAP_UNIT_METRIC = "metric"; window.BMAP_UNIT_IMPERIAL = "us"; kB.inherits(gZ, "ScaleControl"); e9.extend(kB.prototype, { initialize: function (e) { this._map = e; return this._container }, setUnit: function (e) { this._opts.unit = this._units[e] && this._units[e].name || this._opts.unit }, getUnit: function () { return this._opts.unit }, addSateMapStyle: function () { this.sateMapStyle = true; var e = this._container; if (e) { e9.ac(e.children[0], "dark") } }, removeSateMapStyle: function () { this.sateMapStyle = false; var e = this._container; if (e) { e9.rc(e.children[0], "dark") } } }); window.BMAP_NAVIGATION_CONTROL_LARGE = 0; window.BMAP_NAVIGATION_CONTROL_SMALL = 1; window.BMAP_NAVIGATION_CONTROL_PAN = 2; window.BMAP_NAVIGATION_CONTROL_ZOOM = 3; window.BMAP_NAVIGATION_CONTROL_ANIM = 4; function j6(e) { gZ.call(this); e = e || {}; this._opts = { printable: false }; e9.extend(this._opts, e); this.controlHeight = [{ width: 65, height: 227, zoomHeight: 227, zoomWidth: 37, sliderHeight: 180 }, { width: 65, height: 47, zoomHeight: (this._opts.forceNew === true) ? 56 : 47, zoomWidth: 37, sliderHeight: 0 }, { width: 37, height: 57, zoomHeight: 0, zoomWidth: 0, sliderHeight: 0 }, { width: 26, height: 56, zoomHeight: 56, zoomWidth: 6, sliderHeight: 0 }, { width: 56, height: 47, zoomHeight: 47, zoomWidth: 37, sliderHeight: 180 }]; this.defaultAnchor = BMAP_ANCHOR_TOP_LEFT; this.defaultOffset = new jo(10, 10); this.setAnchor(e.anchor); this.setType(e.type); this._maxTotalZoomLv = 19; this._minZoomLevel = -1; this._maxZoomLevel = -1; this._totalZoomLv = -1; this._sliderInterval = 10; this._sliderHeight = 180; this._minBarY = 1; this._maxBarY = -1; this._curBarY = -1; this._zoomDom = null; this._zoomBtnDom = null; this._sliderDom = null; this._sliderBaseDom = null; this._cZIndex = "1100"; this._asyncLoadCode() } j6.inherits(gZ, "NavigationControl"); e9.extend(j6.prototype, { initialize: function (e) { this._map = e; return this._container }, setType: function (e) { if (typeof e == "number" && e >= BMAP_NAVIGATION_CONTROL_LARGE && e <= BMAP_NAVIGATION_CONTROL_ANIM) { this._opts.type = e } else { this._opts.type = BMAP_NAVIGATION_CONTROL_LARGE } }, getType: function () { return this._opts.type } }); function A(i) { gZ.call(this); i = i || {}; this._opts = { printable: false }; this.defaultAnchor = BMAP_ANCHOR_TOP_RIGHT; this.defaultOffset = new jo(10, 10); this.setAnchor(i.anchor); this._opts = e9.extend(e9.extend(this._opts, { offset: this.defaultOffset, enableSwitch: true }), i); var e = this; hm.load("control", function () { e._asyncDraw() }) } A.inherits(gZ, "MapTypeControl"); e9.extend(A.prototype, { initialize: function (e) { this._map = e; return this._container }, showStreetLayer: function (e) { this._map.showStreetLayer(e) } }); function jB(e) { gZ.call(this); e = e || {}; this._opts = {}; this._opts = e9.extend(this._opts, e); this._zoomInDisabled = false; this._zoomOutDisabled = false; this._zoomInTapped = false; this._zoomOutTapped = false; this.defaultAnchor = es.BOTTOM_RIGHT; this.defaultOffset = new jo(15, 20); this.setAnchor(e.anchor); this._asyncLoadCode() } jB.inherits(gZ, "ZoomControl"); e9.extend(jB.prototype, { initialize: function (e) { this._map = e; return this._container } }); function gF(e) { gZ.call(this); e = e || {}; this._opts = { autoZoom: true, autoViewport: true }; this._opts = e9.extend(this._opts, e); this.defaultAnchor = es.BOTTOM_LEFT; this.defaultOffset = new jo(10, 50); this.watchPosition = this._opts.watchPosition || false; this.useCompass = this._opts.useCompass || false; this.locMarker = null; this.locLevel = 16; this.setAnchor(this._opts.anchor); this.onLocationStart = e.onLocationStart || null; this._asyncLoadCode() } gF.inherits(gZ, "LocationControl"); e9.extend(gF.prototype, { initialize: function (e) { this._map = e; return this._container }, startLocation: function () { this._startLocationCalled = true }, stopLocationTrace: function () { }, setOptions: function (e) { e = e || {}; e9.extend(this._opts, e) } }); function bJ(e) { gZ.call(this); e = e || {}; this._opts = {}; this._opts = e9.extend(this._opts, e); this.defaultAnchor = es.BOTTOM_LEFT; this.defaultOffset = new jo(5, 15); if (b5()) { this.defaultOffset = new jo(10, 10) } this.setAnchor(e.anchor) } bJ.inherits(gZ, "LogoControl"); e9.extend(bJ.prototype, { initialize: function (i) { this._map = i; var e = this._container = document.createElement("div"); e.innerHTML = '<img src="' + E.apiHost + '/images/logo_hd.png"  style="height:21px;width:62px;"/>'; i.getContainer().appendChild(e); return e } }); function ax(e, i) { this._map = e; this._indoorInfo = i; this._visible = true; this._adjustVisible = true; this._isMobile = b5(); this._sizeConfig = { FLOOR_BTN_HEIGHT: this._isMobile ? 35 : 26, SWITCH_ARROW_HEIGHT: this._isMobile ? 20 : 15 }; this._init() } ax.prototype._init = function () { this._render(); this._bindDom(); this._bind(); this._adjustDisplayHeight(); var e = new fW("onindoor_bar_show"); e.uid = this._indoorInfo.uid; e.floors = this._indoorInfo.floors; this._map.dispatchEvent(e) }; ax.prototype._render = function () { if (!this._indoorInfo) { return } var kG = this._isMobile; var e = this._div = b6("div"); e9.ac(e, "floor-select-container"); kG && e9.ac(e, "mobile"); kG && e9.ac(e, "all-border-radius"); var i = this._btnTop = b6("button"); e9.ac(i, "floor-switch-top"); e9.ac(i, "top-border-radius"); var kE = b6("div"); e9.ac(kE, "floor-switch-top-icon"); i.appendChild(kE); var kD = this._btnBottom = b6("button"); var T = b6("div"); e9.ac(T, "floor-switch-bottom-icon"); kD.appendChild(T); e9.ac(kD, "floor-switch-bottom"); e9.ac(kD, "bottom-border-radius"); var kC = this._floorsContainer = b6("div"); e9.ac(kC, "floors-container"); kC.appendChild(this._createFloorsDom()); this._div.appendChild(i); this._div.appendChild(kC); this._div.appendChild(kD); var kH = 0; if (this._btnTop.style.display === "") { kH = 2 * this._sizeConfig.SWITCH_ARROW_HEIGHT } this._div.style.height = parseInt(this._floorsContainer.style.height, 10) + kH + "px"; this._map.getContainer().appendChild(this._div); if (!kG) { var kF = this; setTimeout(function () { kF._div.style.right = "20px" }, 20) } }; ax.prototype._createFloorsDom = function () { if (!this._indoorInfo) { return } var T = this._ol = b6("ol"); var kE = this._indoorInfo.currentFloor; for (var kD = this._indoorInfo.floors.length - 1; kD >= 0; kD--) { var kF = this._indoorInfo.floors[kD].floorName; var e = b6("li"); var kC = b6("button"); e9.ac(kC, "btn-select-floor"); if (kD === kE) { e9.ac(kC, "selected") } kC.setAttribute("data-floor", kD); kC.innerHTML = kF; e.appendChild(kC); T.appendChild(e) } return T }; ax.prototype._updateUI = function () { if (!this._ol) { this._render(); this._bind(); this._adjustDisplayHeight(); return } this._ol = null; this._ol = this._createFloorsDom(); this._floorsContainer.innerHTML = ""; this._floorsContainer.appendChild(this._ol); this._adjustDisplayHeight() }; ax.prototype._bindDom = function () { var e = this; e9.on(this._floorsContainer, "click", function (kC) { var T = kC.target || kC.srcElement; if (T.tagName.toLowerCase() === "button") { e._map.showIndoor(e._indoorInfo.uid, parseInt(T.getAttribute("data-floor"), 10)); var i = new fW("onindoor_bar_click"); i.uid = e._indoorInfo.uid; e._map.dispatchEvent(i) } }); e9.on(this._floorsContainer, "mouseover", function (T) { var i = T.target; if (i.tagName.toLowerCase() === "button") { e9.ac(i, "hover") } }); e9.on(this._floorsContainer, "mouseout", function (T) { var i = T.target; if (i.tagName.toLowerCase() === "button") { e9.rc(i, "hover") } }); e9.on(this._floorsContainer, "touchstart", function (T) { var i = T.target; if (i.tagName.toLowerCase() === "button") { e9.ac(i, "onmousedown") } }); e9.on(this._floorsContainer, "touchend", function (T) { var i = T.target; if (i.tagName.toLowerCase() === "button") { e9.rc(i, "onmousedown") } }); e9.on(this._btnTop, "mouseover", function (i) { if (this._disable) { return } e9.ac(this, "hover") }); e9.on(this._btnTop, "mouseout", function (i) { e9.rc(this, "hover") }); e9.on(this._btnBottom, "mouseover", function (i) { if (this._disable) { return } e9.ac(this, "hover") }); e9.on(this._btnBottom, "mouseout", function (i) { e9.rc(this, "hover") }); e9.on(this._btnTop, "touchstart", function (i) { if (this.className.indexOf("disable") > -1) { return } e9.ac(this, "onmousedown") }); e9.on(this._btnTop, "touchend", function (i) { e9.rc(this, "onmousedown") }); e9.on(this._btnBottom, "touchstart", function (i) { if (this.className.indexOf("disable") > -1) { return } e9.ac(this, "onmousedown") }); e9.on(this._btnBottom, "touchend", function (i) { e9.rc(this, "onmousedown") }); e9.on(this._btnTop, "click", function (i) { e._setBarSliderTop(parseInt(e._ol.style.top, 10) + 26) }); e9.on(this._btnBottom, "click", function (i) { e._setBarSliderTop(parseInt(e._ol.style.top, 10) - 26) }); e9.on(this._div, "mousemove", al); e9.on(this._div, "wheel", hI); e9.on(this._div, "mousewheel", hI); this._map.addEventListener("resize", function () { e._adjustDisplayHeight() }) }; ax.prototype._adjustDisplayHeight = function () { if (!this._indoorInfo) { return } var kE = this._map.getSize().height; var kF = this._sizeConfig.FLOOR_BTN_HEIGHT; var kG = kE - 291 - 100; if (this._isMobile) { kG = kE - 12 - 108 - this._map.config.bottomOffset } var e = this._indoorInfo.floors.length; var T = e * kF; var kC = e; var kI = 0; var kJ = this._floorsContainer.children[0]; if (T > kG) { this._showArrow = true; e9.rc(kJ.children[0].children[0], "top-border-radius"); e9.rc(kJ.children[e - 1].children[0], "bottom-border-radius") } else { this._showArrow = false; e9.ac(kJ.children[0].children[0], "top-border-radius"); e9.ac(kJ.children[e - 1].children[0], "bottom-border-radius") } while (T > kG) { if (kC === 0) { break } kC--; kI = 2 * this._sizeConfig.SWITCH_ARROW_HEIGHT; T = kC * kF + kI } this._currentDisplayHeight = T; if (kC < 3) { this._setAdjustVisbile(false) } else { this._setAdjustVisbile(true) } this._floorsContainer.style.height = kC * kF + "px"; var kD = this._indoorInfo.currentFloor; var i = e - kD; var kH = kD - 1; this._div.style.height = parseInt(this._floorsContainer.style.height, 10) + kI + "px"; var kK = -(e - (kD + Math.round(kC / 2))) * kF; this._setBarSliderTop(kK); if (kC < e) { e9.show(this._btnTop); e9.show(this._btnBottom) } else { e9.hide(this._btnTop); e9.hide(this._btnBottom); this._setBarSliderTop(0) } if (this._isMobile) { this._div.style.bottom = 108 + this._map.config.bottomOffset + "px" } }; ax.prototype._setBarSliderTop = function (kC) { var T = 26; var i = this._indoorInfo.floors.length; var e = i * T; if (this._currentDisplayHeight) { if (this._showArrow) { e = this._currentDisplayHeight - 30 } else { e = this._currentDisplayHeight } } if (e - kC >= i * T) { kC = e - i * T; e9.ac(this._btnBottom, "disable"); e9.rc(this._btnBottom, "hover"); this._btnBottom._disable = true } else { e9.rc(this._btnBottom, "disable"); this._btnBottom._disable = false } if (kC >= 0) { kC = 0; e9.ac(this._btnTop, "disable"); e9.rc(this._btnTop, "hover"); this._btnTop._disable = true } else { e9.rc(this._btnTop, "disable"); this._btnTop._disable = false } this._ol.style.top = kC + "px" }; ax.prototype._setAdjustVisbile = function (e) { if (this._adjustVisible === e) { return } this._adjustVisible = e; if (e && this._visible) { this._div.style.right = "20px" } else { this._div.style.right = "-30px" } }; ax.prototype._bind = function () { var i = this._map; var e = this; i.on("indoor_status_changed", function (kG) { if (e._visible === false) { return } var T = e._ol; var kE = kG.uid; if (!kE) { return } var kF = kG.floor; for (var kD = 0; kD < T.children.length; kD++) { var kC = T.children[kD].children[0]; if (parseInt(kC.getAttribute("data-floor"), 10) === kF) { e9.ac(kC, "selected") } else { e9.rc(kC, "selected") } } }); i.on("zoomend", function (T) { if (this.getZoom() < 17) { e._setAdjustVisbile(false) } else { e._setAdjustVisbile(true) } }) }; ax.prototype.setInfo = function (e) { if (this._indoorInfo && this._indoorInfo.uid === e.uid) { return } this._indoorInfo = e; this._updateUI() }; ax.prototype.show = function () { if (this._visible === true) { return } this._visible = true; if (!this._isMobile) { this._div.style.right = "20px" } else { this._div.style.display = "" } var e = new fW("onindoor_bar_show"); e.uid = this._indoorInfo.uid; e.floors = this._indoorInfo.floors; this._map.dispatchEvent(e) }; ax.prototype.hide = function () { if (this._visible === false) { return } this._visible = false; if (!this._isMobile) { this._div.style.right = "-30px" } else { this._div.style.display = "none" } }; function fb(e) { this._opts = e || {}; this.defaultOffset = new jo(2, 80); this.defaultAnchor = BMAP_ANCHOR_TOP_RIGHT; if (this._opts.anchor === undefined) { this.setAnchor(this.defaultAnchor) } else { this.setAnchor(this._opts.anchor) } this._firstAnimation = true } fb.inherits(gZ, "NavigationControl3D"); e9.extend(fb.prototype, { initialize: function (T) { this._map = T; this._createDom(); this._bindDom(); this._bind(); if (!b5()) { this._headingControl = new i2(this._map, this._div) } this._tiltControl = new c1(this._map, this._div); this._render(); var i = this._map.getMapType(); var e = this; if (i === "B_EARTH_MAP" || this._map._renderType === "webgl") { e._div.style.opacity = "1"; e._div.style.visibility = "visible" } else { e._div.style.opacity = "0"; e._div.style.visibility = "hidden" } return this._container }, _createDom: function () { var i = this._div = document.createElement("div"); this._container = i; var e = i.style; e.position = "absolute"; e.zIndex = 5; e.width = "52px"; e.height = "82px"; e.right = "-3px"; e.bottom = "79px"; e.opacity = "0"; e.visibility = "hidden"; e.WebkitTransition = e.transition = "opacity .3s ease-out,visibility .3s ease-out" }, _render: function () { var e = document.getElementById("map-operate"); if (e) { e.appendChild(this._div) } else { this._map.getContainer().appendChild(this._div) } }, _bindDom: function () { this._div.addEventListener("mousemove", al) }, _bind: function () { if (this._map._renderType === "webgl") { return } var e = this; this._map.on("maptypechange", function () { if (this.mapType === "B_EARTH_MAP") { if (e._firstAnimation) { e._firstAnimation = false; setTimeout(function () { e._div.style.opacity = "1"; e._div.style.visibility = "visible" }, 300) } else { e._div.style.opacity = "1"; e._div.style.visibility = "visible" } } else { e._div.style.opacity = "0"; e._div.style.visibility = "hidden" } }) } }); function i2(T, i) { this._map = T; this._target = T; var kC = T.temp.originMapType || T.mapType; if (kC === "B_EARTH_MAP" && T._earth) { this._target = T._earth } this._outContainer = i || T.getContainer(); this._imgRatio = gu() >= h5.HIGH_RES_MIN_RATIO ? 2 : 1; this._imgPath = E.imgPath + "earth-navi-control-pc4" + (this._imgRatio === 2 ? "-2x.png" : ".png"); this._enabled = true; var e = this; this._setHeadingOptions = { callback: function () { e._target.setLock(false) } }; this._init() } e9.extend(i2.prototype, { _init: function () { this._createDom(); this._render(); this._bindDom(); this._bind(); this._updateUI(); this._checkEnable() }, _checkEnable: function () { if (this._target.getZoom() >= this._target._enableHeadingZoom) { this.enable() } else { this.disable() } }, _createDom: function () { var i = this._div = b6("div"); var e = i.style; e.position = "absolute"; e.zIndex = 5; e.top = "0"; e.left = "0"; e.width = "52px"; e.height = "54px"; e.background = "url(" + this._imgPath + ") no-repeat"; e.backgroundSize = "266px auto"; this._rotateCCW = this._createButton(); this._rotateCCW.title = "逆时针转动"; e = this._rotateCCW.style; e.left = "2px"; e.top = "5px"; e.zIndex = "1"; e.width = "15px"; e.height = "42px"; e.backgroundPosition = "-75px -5px"; this._rotateCW = this._createButton(); this._rotateCW.title = "顺时针转动"; e = this._rotateCW.style; e.right = "2px"; e.top = "5px"; e.zIndex = "1"; e.width = "15px"; e.height = "42px"; e.backgroundPosition = "-75px -5px"; e.WebkitTransform = e.transform = "scaleX(-1)"; this._compass = this._createButton(); this._compass.title = "恢复正北方向"; e = this._compass.style; e.left = "19px"; e.top = "4px"; e.width = "14px"; e.height = "44px"; e.backgroundPosition = "-56px -4px"; e.WebkitTransform = e.transform = "rotate(0deg)"; this._div.appendChild(this._rotateCCW); this._div.appendChild(this._compass); this._div.appendChild(this._rotateCW); this._domRendered = true }, _createButton: function () { var e = b6("button"); var i = e.style; i.position = "absolute"; i.outline = "none"; i.border = "none"; i.background = "url(" + this._imgPath + ") no-repeat"; i.backgroundSize = "266px auto"; i.cursor = "pointer"; return e }, _render: function () { this._outContainer.appendChild(this._div) }, enable: function () { this._enabled = true; if (this._domRendered) { this._rotateCCW.style.cursor = "pointer"; this._rotateCCW.style.opacity = 1; this._rotateCW.style.cursor = "pointer"; this._rotateCW.style.opacity = 1; this._compass.style.cursor = "pointer"; this._compass.style.opacity = 1 } }, disable: function () { this._enabled = false; if (this._domRendered) { this._rotateCCW.style.cursor = ""; this._rotateCCW.style.opacity = 0.4; this._rotateCW.style.cursor = ""; this._rotateCW.style.opacity = 0.4; this._compass.style.cursor = ""; this._compass.style.opacity = 0.4 } }, _bindDom: function () { iU(this._div, ["mousedown", "click", "dblclick"]); var i = this._map; var e = this; this._rotateCW.addEventListener("click", function () { if (e._isOperating || e._enabled === false) { return } if (e._target.getLock()) { return } if (e._target.getHeading() === 360) { e._target.setHeading(0) } e._target.setLock(true); e._target.setHeading(e._target.getHeading() + 90, e._setHeadingOptions); i.fire(new fW("onrotatecwclick")) }, false); this._rotateCCW.addEventListener("click", function () { if (e._isOperating || e._enabled === false) { return } if (e._target.getLock()) { return } if (e._target.getHeading() === -360) { e._target.setHeading(0) } e._target.setLock(true); e._target.setHeading(e._target.getHeading() - 90, e._setHeadingOptions); i.fire(new fW("onrotateccwclick")) }, false); this._rotateCW.addEventListener("mouseover", function () { if (e._enabled === false) { return } this.style.backgroundPosition = "-89px -5px" }, false); this._rotateCW.addEventListener("mouseout", function () { if (e._enabled === false) { return } this.style.backgroundPosition = "-75px -5px" }, false); this._rotateCCW.addEventListener("mouseover", function () { if (e._enabled === false) { return } this.style.backgroundPosition = "-89px -5px" }, false); this._rotateCCW.addEventListener("mouseout", function () { if (e._enabled === false) { return } this.style.backgroundPosition = "-75px -5px" }, false); this._compass.addEventListener("click", function () { if (e._isOperating || e._enabled === false) { return } if (e._target.getLock()) { return } e._target.setLock(true); var T = false; if (e._target.getTilt() !== 0) { T = true; e._target.setTilt(0, e._setHeadingOptions) } if (e._target.getHeading() % 360 !== 0) { T = true; e._target.resetHeading(e._setHeadingOptions) } if (!T) { e._target.setLock(false) } i.fire(new fW("oncompassclick")) }, false) }, _bind: function () { var e = this; this._bindTarget(this._target); if (this._map._renderType === "webgl") { this._map.addEventListener("maptypechange", function (i) { if (this.mapType === "B_EARTH_MAP") { e._target = e._map._earth } else { e._target = e._map } e._bindTarget(e._target); e._checkEnable() }) } }, _bindTarget: function (i) { if (i === this._map && this._mapBinded) { return } if (i === this._map._earth && this._earthBinded) { return } var e = this; i.addEventListener("heading_changed", function (T) { e._updateUI() }); i.addEventListener("animation_start", function (T) { e._isOperating = true }); i.addEventListener("animation_end", function (T) { e._isOperating = false }); i.on("load", function () { e._checkEnable() }); i.on("zoom_changed", function () { e._checkEnable() }); if (i === this._map) { this._mapBinded = true } else { this._earthBinded = true } }, _updateUI: function () { var e = this._target.getHeading(); var i = this._compass.style; i.WebkitTransform = i.transform = "rotate(" + e + "deg)" }, hide: function () { this._div.style.display = "none" }, show: function () { this._div.style.display = "block" } }); function c1(T, i) { this._map = T; this._target = T; var kC = T.temp.originMapType || T.mapType; if (kC === "B_EARTH_MAP" && T._earth) { this._target = T._earth } this._outContainer = i || T.getContainer(); this._imgRatio = gu() >= h5.HIGH_RES_MIN_RATIO ? 2 : 1; this._imgPath = E.imgPath + "gl-navi-control-pc4" + (this._imgRatio === 2 ? "-2x.png" : ".png"); this._enabled = true; var e = this; this._setTiltOptions = { callback: function () { e._target.setLock(false) } }; this._init() } e9.extend(c1.prototype, { _init: function () { this._createDom(); this._render(); this._bindDom(); this._bind(); this._checkEnable() }, _checkEnable: function () { if (this._target.getZoom() >= this._target._enableTiltZoom) { this.enable() } else { this.disable() } }, _createDom: function () { var e = this._div = b6("button"); e.title = "倾斜"; var i = e.style; i.position = "absolute"; i.zIndex = 5; i.outline = "none"; i.border = "none"; i.cursor = "pointer"; i.width = "26px"; i.height = "26px"; i.top = "56px"; i.right = "13px"; i.background = "url(" + this._imgPath + ") no-repeat #fff"; i.backgroundSize = "266px auto"; i.backgroundPosition = "-110px 1px"; i.boxShadow = "1px 2px 1px rgba(0, 0, 0, 0.15)" }, enable: function () { this._enabled = true; if (this._div) { this._div.style.cursor = "pointer" } this._updateUI() }, disable: function () { this._enabled = false; if (this._div) { this._div.style.cursor = "" } this._updateUI() }, _render: function () { this._outContainer.appendChild(this._div) }, _bindDom: function () { var e = this; this._div.addEventListener("mousedown", function (kC) { if (!e._enabled) { return } if (e._target.getLock()) { return } var i = e._target.getTilt(); var T; if (i === e._map.getCurrentMaxTilt()) { T = "out" } else { if (i === 0) { T = "in" } else { T = e._preTrend ? e._preTrend : "in" } } e._curTrend = T; e._clickTimer = setTimeout(function () { e._map.fire(new fW("ontiltmsdown")); e._tiltAni = new fL({ duration: 9999999, render: function (kD) { i = e._target.getTilt(); if (T === "in" && i < e._map.getCurrentMaxTilt()) { e._target.setTilt(i + 1, { noAnimation: true }) } else { if (T === "out" && i > 0) { e._target.setTilt(i - 1, { noAnimation: true }) } } }, finish: function () { e._tiltAni = null } }); e._clickTimer = null }, 200); kC.stopPropagation() }, false); this._div.addEventListener("mouseup", function (i) { if (!e._enabled) { return } if (e._tiltAni) { e._tiltAni.stop() } e._preTrend = e._curTrend }, false); this._div.addEventListener("click", function (kC) { if (!e._enabled) { return } if (!e._clickTimer) { return } if (e._target.getLock()) { return } clearTimeout(e._clickTimer); e._map.fire(new fW("ontiltclick")); var i = e._target.getTilt(); e._target.setLock(true); kC.stopPropagation(); var T = e._map.getCurrentMaxTilt(); if (e._curTrend === "in") { e._target.setTilt(T, e._setTiltOptions) } else { if (e._curTrend === "out") { e._target.setTilt(0, e._setTiltOptions) } else { if (i < T) { e._target.setTilt(T, e._setTiltOptions) } else { e._target.setTilt(0, e._setTiltOptions) } } } }, false); this._div.addEventListener("mouseover", function (i) { if (!e._enabled) { return } e._mouseOver = true; e._updateUI() }, false); this._div.addEventListener("mouseout", function (i) { if (!e._enabled) { return } e._mouseOver = false; e._updateUI() }, false); iU(this._div, ["mousedown", "click", "dblclick"]) }, _bind: function () { var e = this; var i = this._map; this._bindTarget(this._target); if (this._map._renderType === "webgl") { this._map.addEventListener("maptypechange", function (T) { if (this.mapType === "B_EARTH_MAP") { e._target = e._map._earth } else { e._target = e._map } e._bindTarget(e._target); e._checkEnable() }) } }, _bindTarget: function (i) { if (i === this._map && this._mapBinded) { return } if (i === this._map._earth && this._earthBinded) { return } var e = this; i.on("load", function () { e._checkEnable() }); i.on("zoom_changed", function () { e._checkEnable() }); i.on("tilt_changed", function () { e._updateUI() }); if (i === this._map) { this._mapBinded = true } else { this._earthBinded = true } }, _updateUI: function () { var T = this._target.getTilt(); var i = 0; var kC = 0; var e = 0; if (T > 0) { i = 78 } if (this._mouseOver) { e = 52 } if (this._enabled === false) { kC = 26; e = 0; i = 0 } var kD = "-" + (110 + i + kC + e) + "px 1px"; this._div && (this._div.style.backgroundPosition = kD); if (this._enabled) { if (T > 0) { this._div && (this._div.title = "恢复") } else { this._div && (this._div.title = "倾斜") } } else { this._div && (this._div.title = "请放大地图后操作") } }, hide: function () { this._div.style.display = "none" }, show: function () { this._div.style.display = "block" } }); function hG(i) { dh.call(this); this._opts = { container: null, cursor: "default", marker: true }; this._opts = e9.extend(this._opts, i); this._type = "contextmenu"; this._map = null; this._container; this._left = 0; this._top = 0; this._items = []; this._rItems = []; this._dividers = []; this._enable = true; this.curPixel = null; this.curPoint = null; this._isOpen = false; var e = this; hm.load("menu", function () { e._draw() }); hQ.sendMessage(a1(4, 5, 2), ["control", "menu"]) } hG.inherits(dh, "ContextMenu"); e9.extend(hG.prototype, { initialize: function (i, e) { this._map = i; this._overlay = e || null }, remove: function () { this._map = this._overlay = null }, addItem: function (kD, e) { if (!kD || kD._type != "menuitem" || kD._text == "" || kD._width <= 0) { return } for (var kC = 0, T = this._items.length; kC < T; kC++) { if (this._items[kC] === kD) { return } } if (e === undefined || e > this._items.length - 1) { e = -1 } kD._insertIndex = e; if (e === -1) { this._items.push(kD); this._rItems.push(kD) } else { this._items.splice(e, 0, kD); this._rItems.splice(e, 0, kD) } }, removeItem: function (kC) { if (!kC || kC._type != "menuitem") { return } for (var T = 0, e = this._items.length; T < e; T++) { if (this._items[T] === kC) { this._items[T].remove(); this._items.splice(T, 1); delete kC._insertIndex; e-- } } for (var T = 0, e = this._rItems.length; T < e; T++) { if (this._rItems[T] === kC) { this._rItems[T].remove(); this._rItems.splice(T, 1); delete kC._insertIndex; e-- } } }, addSeparator: function (e) { if (e === undefined || e > this._items.length - 1) { e = -1 } var i = { _type: "divider", _dIndex: this._dividers.length, _insertIndex: e }; this._dividers.push({ dom: null }); if (e === -1) { this._items.push(i) } else { this._items.splice(e, 0, i) } }, removeSeparator: function (T) { if (!this._dividers[T]) { return } for (var kC = 0, e = this._items.length; kC < e; kC++) { if (this._items[kC] && this._items[kC]._type == "divider" && this._items[kC]._dIndex == T) { this._items.splice(kC, 1); e-- } if (this._items[kC] && this._items[kC]._type == "divider" && this._items[kC]._dIndex > T) { this._items[kC]._dIndex-- } } this._dividers.splice(T, 1) }, getDom: function () { return this._container }, show: function () { if (this._isOpen == true) { return } this._isOpen = true }, hide: function () { if (this._isOpen == false) { return } this._isOpen = false }, setCursor: function (e) { if (!e) { return } this._opts.cursor = e }, getItem: function (e) { return this._rItems[e] }, enable: function () { this._enable = true }, disable: function () { this._enable = false } }); function ii(T, kC, i) { if (!T || !kC || typeof kC != "function") { return } dh.call(this); this._opts = { width: 100, id: "" }; i = i || {}; this._opts.width = (i.width * 1) ? i.width : 100; this._opts.id = i.id ? i.id : ""; this._text = T + ""; this._callback = kC; this._map = null; this._type = "menuitem"; this._contextmenu = null; this._container = null; this._enabled = true; var e = this; hm.load("menu", function () { e._draw() }) } ii.inherits(dh, "MenuItem"); e9.extend(ii.prototype, { initialize: function (e, i) { this._map = e; this._contextmenu = i }, remove: function () { this._contextmenu = null; this._map = null }, setText: function (e) { if (!e) { return } this._text = e + "" }, getDom: function () { return this._container }, enable: function () { this._enabled = true }, disable: function () { this._enabled = false } }); function ik(e, i) { this.setSouthWest(e); this.setNorthEast(i) } e9.extend(ik.prototype, { isEmpty: function () { return this.sw === null && this.ne === null }, equals: function (e) { if (!e || e.isEmpty() || this.isEmpty()) { return false } return this.sw.equals(e.sw) && this.ne.equals(e.ne) }, containsBounds: function (e) { if (!e || e.isEmpty() || this.isEmpty()) { return false } return (e.sw.lng > this.sw.lng && e.ne.lng < this.ne.lng && e.sw.lat > this.sw.lat && e.ne.lat < this.ne.lat) }, getCenter: function () { if (this.isEmpty()) { return null } if (Math.abs(this.sw.lng - this.ne.lng) <= dL.HALF_SIZE) { return new cG((this.sw.lng + this.ne.lng) / 2, (this.sw.lat + this.ne.lat) / 2) } else { var i = this.sw.lng; var T = this.ne.lng; if (i < 0) { i += dL.HALF_SIZE * 2 } else { T += dL.HALF_SIZE * 2 } var e = (i + T) / 2; if (e > dL.HALF_SIZE) { e -= dL.HALF_SIZE * 2 } return new cG(e, (this.sw.lat + this.ne.lat) / 2) } }, intersects: function (T) { if (!T || T.isEmpty() || this.isEmpty()) { return null } if (Math.max(T.sw.lng, T.ne.lng) < Math.min(this.sw.lng, this.ne.lng) || Math.min(T.sw.lng, T.ne.lng) > Math.max(this.sw.lng, this.ne.lng) || Math.max(T.sw.lat, T.ne.lat) < Math.min(this.sw.lat, this.ne.lat) || Math.min(T.sw.lat, T.ne.lat) > Math.max(this.sw.lat, this.ne.lat)) { return null } var kD = Math.max(this.sw.lng, T.sw.lng); var i = Math.min(this.ne.lng, T.ne.lng); var kC = Math.max(this.sw.lat, T.sw.lat); var e = Math.min(this.ne.lat, T.ne.lat); return new ik(new cG(kD, kC), new cG(i, e)) }, setMinMax: function () { this.minX = this.sw ? this.sw.lng : null; this.minY = this.sw ? this.sw.lat : null; this.maxX = this.ne ? this.ne.lng : null; this.maxY = this.ne ? this.ne.lat : null }, containsPoint: function (e) { if (!e) { return } return (e.lng >= this.sw.lng && e.lng <= this.ne.lng && e.lat >= this.sw.lat && e.lat <= this.ne.lat) }, extend: function (e) { if (!e) { return } var i = e.lng; var T = e.lat; if (!this.sw) { this.sw = e.clone() } if (!this.ne) { this.ne = e.clone() } if (this.sw.lng > i) { this.sw.lng = i } if (this.ne.lng < i) { this.ne.lng = i } if (this.sw.lat > T) { this.sw.lat = T } if (this.ne.lat < T) { this.ne.lat = T } }, getMin: function () { return this.sw }, getMax: function () { return this.ne }, getSouthWest: function () { return this.sw }, getNorthEast: function () { return this.ne }, setSouthWest: function (e) { this.sw = e ? e.clone() : null }, setNorthEast: function (e) { this.ne = e ? e.clone() : null }, clone: function () { return new ik(this.sw, this.ne) }, toSpan: function () { if (this.isEmpty()) { return new jo(0, 0) } return new jo(Math.abs(this.ne.lng - this.sw.lng), Math.abs(this.ne.lat - this.sw.lat)) }, div: function (e) { if (!e || e.isEmpty() || this.isEmpty()) { return 0 } return ((this.ne.lng - this.sw.lng) * (this.ne.lat - this.sw.lat)) / ((e.ne.lng - e.sw.lng) * (e.ne.lat - e.sw.lat)) }, makeNormalizedPoint: function (e) { this.normalizedTopLeft = this.pointTopLeft.clone(); this.normalizedTopRight = this.pointTopRight.clone(); this.normalizedBottomRight = this.pointBottomRight.clone(); this.normalizedBottomLeft = this.pointBottomLeft.clone(); while (e < 0) { e += 360 } e = e % 360; if (e >= 0 && e < 90 || e >= 270 && e < 360) { if (this.normalizedTopRight.lng < this.normalizedTopLeft.lng) { this.normalizedTopRight.lng += h5.WORLD_SIZE_MC } if (this.normalizedBottomRight.lng < this.normalizedBottomLeft.lng) { this.normalizedBottomRight.lng += h5.WORLD_SIZE_MC } } else { if (this.normalizedTopLeft.lng < this.normalizedTopRight.lng) { this.normalizedTopLeft.lng += h5.WORLD_SIZE_MC } if (this.normalizedBottomLeft.lng < this.normalizedBottomRight.lng) { this.normalizedBottomLeft.lng += h5.WORLD_SIZE_MC } } }, toString: function () { return "Bounds" } }); function cG(e, i) { if (isNaN(e)) { e = du(e); e = isNaN(e) ? 0 : e } if (typeof e === "string") { e = parseFloat(e) } if (isNaN(i)) { i = du(i); i = isNaN(i) ? 0 : i } if (typeof i === "string") { i = parseFloat(i) } this.lng = e; this.lat = i } cG.prototype.equals = function (i) { if (!i) { return false } var kC = Math.abs(this.lat - i.lat); var T = Math.abs(this.lng - i.lng); var e = 1e-8; if (kC < e && T < e) { return true } return false }; cG.prototype.similar = function (i) { if (!i) { return false } var kC = Math.abs(this.lat - i.lat); var T = Math.abs(this.lng - i.lng); var e = 0.00001; if (kC < e && T < e) { return true } return false }; cG.prototype.clone = function () { return new cG(this.lng, this.lat) }; cG.prototype.add = function (e) { return new cG(this.lng + e.lng, this.lat + e.lat) }; cG.prototype.sub = function (e) { return new cG(this.lng - e.lng, this.lat - e.lat) }; cG.prototype.mult = function (e) { return new cG(this.lng * e, this.lat * e) }; cG.prototype.div = function (e) { return new cG(this.lng / e, this.lat / e) }; cG.prototype.mag = function () { return Math.sqrt(this.lng * this.lng + this.lat * this.lat) }; cG.prototype.toString = function () { return "Point" }; cG.serialize = function (i, e) { return [i.lng, i.lat] }; cG.deserialize = function (e) { return new cG(e[0], e[1]) }; cG.prototype.toGeoJSON = function () { var i = "Point"; var T = [this.lng, this.lat]; var e = { type: "Feature", geometry: { type: i, coordinates: T }, properties: this.properties }; return e }; function jy() { } e9.extend(jy, { EARTHRADIUS: 6370996.81, MCBAND: [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0], LLBAND: [86, 60, 45, 30, 15, 0], MC2LL: [[1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2], [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]], LL2MC: [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]], getDistanceByMC: function (kE, kC) { if (!kE || !kC) { return 0 } var i; var kD; var e; var T; kE = this.convertMC2LL(kE); if (!kE) { return 0 } i = iX(kE.lng); kD = iX(kE.lat); kC = this.convertMC2LL(kC); if (!kC) { return 0 } e = iX(kC.lng); T = iX(kC.lat); return this.getDistance(i, e, kD, T) }, getDistanceByLL: function (kE, kC) { if (!kE || !kC) { return 0 } kE.lng = this.getLoop(kE.lng, -180, 180); kE.lat = this.getRange(kE.lat, -80, 84); kC.lng = this.getLoop(kC.lng, -180, 180); kC.lat = this.getRange(kC.lat, -80, 84); var i; var e; var kD; var T; i = iX(kE.lng); kD = iX(kE.lat); e = iX(kC.lng); T = iX(kC.lat); return this.getDistance(i, e, kD, T) }, proximityCovertMC2LL: function (e) { if (e === null) { return e } if (e.lng < 180 && e.lng > -180 && e.lat < 90 && e.lat > -90) { return e } return this.convertMC2LL(e) }, convertMC2LL: function (e) { if (e === null) { return e } if (!e) { return new cG(0, 0) } var T; var kD; T = new cG(Math.abs(e.lng), Math.abs(e.lat)); for (var kC = 0; kC < this.MCBAND.length; kC++) { if (T.lat >= this.MCBAND[kC]) { kD = this.MC2LL[kC]; break } } var kE = this.convertor(e, kD); return new cA(kE.lat, kE.lng) }, convertLL2MC: function (kF) { if (!kF) { return new cG(0, 0) } var kH = kF.lat; var kC = kF.lng; kC = this.getLoop(kF.lng, -180, 180); kH = ck(kH, -85, 85); var kE; for (var kD = 0; kD < this.LLBAND.length; kD++) { if (kH >= this.LLBAND[kD]) { kE = this.LL2MC[kD]; break } } if (!kE) { for (kD = 0; kD < this.LLBAND.length; kD++) { if (kH <= -this.LLBAND[kD]) { kE = this.LL2MC[kD]; break } } } var T = new cG(kC, kH); var kG = this.convertor(T, kE); var e = new cG(kG.lng, kG.lat); e.latLng = new cA(kF.lat, kF.lng); return e }, convertor: function (T, kC) { if (!T || !kC) { return } var e = kC[0] + kC[1] * Math.abs(T.lng); var i = Math.abs(T.lat) / kC[9]; var kD = kC[2] + kC[3] * i + kC[4] * i * i + kC[5] * i * i * i + kC[6] * i * i * i * i + kC[7] * i * i * i * i * i + kC[8] * i * i * i * i * i * i; e *= (T.lng < 0 ? -1 : 1); kD *= (T.lat < 0 ? -1 : 1); return new cG(e, kD) }, getDistance: function (i, e, kC, T) { return this.EARTHRADIUS * Math.acos((Math.sin(kC) * Math.sin(T) + Math.cos(kC) * Math.cos(T) * Math.cos(e - i))) }, getRange: function (T, i, e) { if (i != null) { T = Math.max(T, i) } if (e != null) { T = Math.min(T, e) } return T }, getLoop: function (T, i, e) { while (T > e) { T -= e - i } while (T < i) { T += e - i } return T }, tileToBoundRange: function (T) { var i = T.col; var kJ = T.row; var kI = T.baseTileSize; var kG = Math.pow(2, (18 - T.zoom)); var kE = { lbx: i * kI, lby: kJ * kI, rtx: (i + 1) * kI, rty: (kJ + 1) * kI }; var e = { lbx: kE.lbx * kG, lby: kE.lby * kG, rtx: kE.rtx * kG, rty: kE.rty * kG }; var kH = new cG(e.lbx, e.lby); var kD = new cG(e.rtx, e.rty); var kC = this.convertMC2LL(kH); var kF = this.convertMC2LL(kD); return { MC: new ik(kH, kD), LL: new ik(kC, kF) } } }); e9.extend(jy.prototype, { lnglatToMercator: function (e) { return jy.convertLL2MC(e) }, lngLatToPoint: function (e) { var i = jy.convertLL2MC(e); return new fv(i.lng, i.lat) }, mercatorToLnglat: function (e) { return jy.convertMC2LL(e) }, pointToLngLat: function (i) { var e = new cG(i.x, i.y); var T = jy.convertMC2LL(e); return new cA(T.lat, T.lng) }, pointToPixel: function (i, kE, kD, kC) { if (!i) { return } i = this.lnglatToMercator(i); var T = this.getZoomUnits(kE); var e = Math.round((i.lng - kD.lng) / T + kC.width / 2); var kF = Math.round((kD.lat - i.lat) / T + kC.height / 2); return new fv(e, kF) }, mercatorToPixel: function (kE, kD, kC, T) { if (!kE) { return } var i = this.getZoomUnits(kD); var e = Math.round((kE.lng - kC.lng) / i + T.width / 2); var kF = Math.round((kC.lat - kE.lat) / i + T.height / 2); return new fv(e, kF) }, pixelToPoint: function (kC, kF, kE, kD) { if (!kC) { return } var i = this.getZoomUnits(kF); var T = kE.lng + i * (kC.x - kD.width / 2); var kG = kE.lat - i * (kC.y - kD.height / 2); var e = new cG(T, kG); return this.mercatorToLnglat(e) }, tileToBound: function (kC, kG) { var i = kC.col; var kJ = kC.row; var kI = kC.baseTileSize; var kH = this.getZoomUnits(kC.zoom); var T = { x: Math.round(kG.lng / kH), y: Math.round(kG.lat / kH) }; var kE = { lbx: i * kI, lby: kJ * kI, rtx: (i + 1) * kI, rty: (kJ + 1) * kI }; var e = { lbx: kG.lng + (kE.lbx - T.x) * kH, lby: kG.lat + (kE.lby - T.y) * kH, rtx: kG.lng + (kE.rtx - T.x) * kH, rty: kG.lat + (kE.rty - T.y) * kH }; var kD = jy.convertMC2LL(new cG(e.lbx, e.lby)); var kF = jy.convertMC2LL(new cG(e.rtx, e.rty)); return { MC: new ik(new cG(e.lbx, e.lby), new cG(e.rtx, e.rty)), LL: new ik(kD, kF) } }, getZoomUnits: function (e) { return Math.pow(2, (18 - e)) }, setCoordType: function (e) { this.coordsType = e } }); function dL() { } e9.extend(dL, { RADIUS: 6378137, EXTENT4326: [-180, -90, 180, 90], WORLD_EXTENT: [-180, -85, 180, 85], HALF_SIZE: 20037508.342789244, METERS_PER_UNIT: 111319.49079327358, EXTENT3857: [-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244], MAX_SAFE_Y: 238107693.26496765, origin: [-20037508.342789244, 20037508.342789244], size: 156543.03392804097, gridSize: [256, 256], resolutions: [156543.03392804097, 78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395, 0.29858214173896974, 0.14929107086948487, 0.07464553543474244, 0.03732276771737122], gridScaleFrom3857ToBDMC: 0.5971642834779395, gridScaleFromBDMCTo3857: 1.674581061974954, calcResolutions: function (i) { if (this.resolutions.length - 1 < i) { this.resolutions = []; for (var e = 0; e < i; ++e) { this.resolutions.push(this.size / Math.pow(2, e)) } } return this.resolutions }, forEachTileCoord: function (kI, kH, T, kF) { var e = this.getTileRangeForExtentFactory(kI, kH, T); for (var kD = e.minX, kG = e.maxX; kD <= kG; ++kD) { for (var kC = e.minY, kE = e.maxY; kC <= kE; ++kC) { kF([kH, kD, kC]) } } }, getTileRangeForExtentFactory: function (T, kD, i, kC) { var e; switch (i.source) { case "BD09MC": if (i.target === "EPSG3857") { e = this.getBDTileRangeForExtentAndZ(T, kD, kC) } else { e = this.getTileRangeForExtentAndZ(T, kD, kC) } break; case "EPSG3857": e = this.getTileRangeForExtentAndZ(T, kD, kC); break; default: e = this.getTileRangeForExtentAndZ(T, kD, kC); break }return e }, getBDTileRangeForExtentAndZ: function (T, kD, kC) { var i = [0, 0, 0]; this.getBDTileCoordForXYAndZ_(T[0], T[1], kD, false, i); var e = i[1]; var kE = i[2]; this.getBDTileCoordForXYAndZ_(T[2], T[3], kD, true, i); return this.createOrUpdateTileRange(e, i[1], kE, i[2], kC) }, getTileRangeForExtentAndZ: function (T, kD, kC) { var i = [0, 0, 0]; this.getTileCoordForXYAndZ_(T[0], T[3], kD, false, i); var e = i[1]; var kE = i[2]; this.getTileCoordForXYAndZ_(T[2], T[1], kD, true, i); return this.createOrUpdateTileRange(e, i[1], kE, i[2], kC) }, getBDTileCoordForXYAndZ_: function (e, kG, kE, kD, kC) { var kF = 256 * Math.pow(2, (18 - kE)); var T = e / kF; var i = kG / kF; if (kD) { T = Math.ceil(T) - 1; i = Math.ceil(i) - 1 } else { T = Math.floor(T); i = Math.floor(i) } return this.createOrUpdateTileCoord(kE, T, i, kC) }, getTileCoordForXYAndZ_: function (kJ, kI, kG, kH, e) { var kK = this.origin; var i = (this.resolutions.length === 0 ? this.calcResolutions(21)[kG] : this.resolutions[kG]); var kM = this.gridSize; var kC = kH ? 0.5 : 0; var T = kH ? 0.5 : 0; var kL = Math.floor((kJ - kK[0]) / i + kC); var kE = Math.floor((kK[1] - kI) / i + T); var kF = kL / kM[0]; var kD = kE / kM[1]; if (kH) { kF = Math.ceil(kF) - 1; kD = Math.ceil(kD) - 1 } else { kF = Math.floor(kF); kD = Math.floor(kD) } return this.createOrUpdateTileCoord(kG, kF, kD, e) }, getTileCoordForCoordAndZ: function (T, i, e) { return this.getTileCoordForXYAndZ_(T[0], T[1], i, false, e) }, getTileRangeExtent: function (T, kF) { var kG = this.origin; if (this.resolutions.length === 0) { this.calcResolutions(23) } var kD = this.resolutions[T[0]]; var kH = this.gridSize; var kE = kG[0] + T[1] * kH[0] * kD; var kC = kG[1] - (T[2] + 1) * kH[1] * kD; var i = kE + kH[0] * kD; var e = kC + kH[1] * kD; return this.createOrUpdateTileRange(kE, i, kC, e, kF) }, getTileLeftBottomMCPoint: function (kD, T) { var i = this.origin; if (this.resolutions.length === 0) { this.calcResolutions(23) } var kC = this.resolutions[kD[0]]; var kF = this.gridSize; var e = i[0] + kD[1] * kF[0] * kC; var kG = i[1] - (kD[2] + 1) * kF[1] * kC; var kE = gcoord.transform([e, kG], gcoord.EPSG3857, gcoord.BD09MC); return kE }, getRangeExtent: function (i, kK, kG, kM, kC) { var kH = this.calPiexlResolution(kM, kC); var kF = kK / 2 * kH; var kI = kG / 2 * kH; var kE = i[0] - kF; var T = i[0] + kF; var kD = i[1] - kI; var e = i[1] + kI; var kJ = gcoord.transform([kE, kD], gcoord[kC.target], gcoord[kC.source]); var kL = gcoord.transform([T, e], gcoord[kC.target], gcoord[kC.source]); return this.createOrUpdateTileRange(kJ[0], kL[0], kJ[1], kL[1]) }, getMousePoint: function (kF, kE, i, kD, T) { var kC = ky(kF, kE); return this.calLngLatByMapViewPixelInverse(kC.clientPos, i, kE.width, kE.height, kD, T) }, calLngLatByMapViewPixelInverse: function (kC, e, i, kJ, kK, T) { var kF = this.calPiexlResolution(kK, T); var kE = kC.x - i / 2; var kD = kC.y - kJ / 2; var kH = e[0] + kE * kF; var kG = e[1] - kD * kF; var kI = gcoord.transform([kH, kG], gcoord[T.target], gcoord[T.source]); return kI }, calPiexlResolution: function (T, i) { var e; switch (i.target) { case "BD09MC": e = Math.pow(2, (18 - T)); break; case "EPSG3857": e = this.resolutions[Math.floor(T)]; break; default: e = Math.pow(2, (18 - T)); break }return e }, getXYZCellPixelCoor: function (kF, kD, kC, i) { var kH = this.gridSize; var kG; var kE; switch (i.source) { case "GCJ02": case "EPSG3857": var T = Math.pow(2, kC - 1) - (kD + 1); var e = kF - Math.pow(2, kC - 1); kG = e * kH[0]; kE = T * kH[1]; break; case "BD09MC": if (i.target === "EPSG3857") { kG = kF * kH[0]; kE = kD * kH[1] } else { var T = Math.pow(2, kC - 1) - (kD + 1); var e = kF - Math.pow(2, kC - 1); kG = e * kH[0]; kE = T * kH[1] } default: break }return { x: kG, y: kE } }, mcToPixel: function (i) { var T = this.resolutions[Math.floor(zoom)]; var e = i.lng / T; var kC = i.lat / T; return [e, kC] }, getBaiduCellPixelCoor: function (e, kC, T) { var i = 256; return { x: e * i, y: kC * i } }, getRelativePixelCoor: function (kE, kC) { var i = this.origin; var kD = kE[0]; var T = this.resolutions[Math.floor(kD)]; var kF = this.gridSize; var e = i[0] / T + kE[1] * kF[0]; var kG = i[1] / T - (kE[2] + 1) * kF[1]; return [kC[0] - e, kC[1] - kG] }, getPointPixelCoor: function (e, kH, i) { var kF; var kE; var T = Math.pow(2, (18 - kH)); var kC = this.resolutions[Math.floor(kH)]; var kD = jy.convertMC2LL(e); switch (i.source) { case "GCJ02": var kG = gcoord.transform([kD.lng, kD.lat], gcoord.BD09LL, gcoord.GCJ02); kG = gcoord.transform(kG, gcoord.WGS84, gcoord.EPSG3857); kF = kG[0] / kC; kE = kG[1] / kC; break; case "BD09LL": case "EPSG3857": var kG = gcoord.transform([kD.lng, kD.lat], gcoord.BD09LL, gcoord.EPSG3857); kF = kG[0] / kC; kE = kG[1] / kC; break; case "BD09MC": kF = e.lng / T; kE = e.lat / T; if (i.target === "BD09MC") { kF *= dL.gridScaleFromBDMCTo3857; kE *= dL.gridScaleFromBDMCTo3857 } default: break }return [kF, kE] }, getResolutionScale: function (i, e) { var T; switch (e.target) { case "BD09MC": T = this.gridScaleFrom3857ToBDMC; break; case "EPSG3857": T = this.gridScaleFromBDMCTo3857; break; default: T = this.gridScaleFrom3857ToBDMC; break }return T }, getBaiduResolutionScale: function (T) { var i = this.resolutions[Math.floor(T)]; var e = Math.pow(2, (18 - T)); var kC = e / i; return kC }, getTileCoordCenter: function (T) { var e = this.origin; if (this.resolutions.length === 0) { this.calcResolutions(23) } var i = this.resolutions[T[0]]; var kC = this.gridSize; return [e[0] + (T[1] + 0.5) * kC[0] * i, e[1] - (T[2] + 0.5) * kC[1] * i,] }, transformBDmcPoint: function (kD, i) { i = i || {}; var T = i.source || "EPSG3857"; var kC = jy.convertMC2LL(new cG(kD.lng, kD.lat)); var e; switch (T) { case "GCJ02": e = gcoord.transform([kC.lng, kC.lat], gcoord.BD09LL, gcoord.GCJ02); e = gcoord.transform(e, gcoord.WGS84, gcoord.EPSG3857); break; case "EPSG3857": e = gcoord.transform([kC.lng, kC.lat], gcoord.BD09LL, gcoord.EPSG3857); break; case "BD09MC": if (i.target === "EPSG3857") { e = gcoord.transform([kC.lng, kC.lat], gcoord.BD09LL, gcoord.EPSG3857) } else { e = [kD.lng, kD.lat] } break; default: e = gcoord.transform([kC.lng, kC.lat], gcoord.BD09LL, gcoord[T]); break }return e }, transformPointArr: function (e, i, T) { return gcoord.transform(e, gcoord[i || "BD09LL"], gcoord[T || "BD09MC"]) }, getTilesLoop: function (T, e) { var i = Math.pow(2, T); while (e > i - 1) { e = e - i } while (e < 0) { e = e + i } return e }, getLoopBox: function (e, kC) { var i = this.HALF_SIZE * 2; if (e[0] > 0 && kC[2] < 0) { kC[2] = kC[2] + i } else { if (e[0] < 0 && kC[0] > 0) { kC[0] = kC[0] - i } } return kC }, createOrUpdateTileCoord: function (T, e, kC, i) { if (i !== undefined) { i[0] = T; i[1] = e; i[2] = kC; return i } else { return [T, e, kC] } }, createOrUpdateTileRange: function (e, kC, kD, T, i) { if (i !== undefined) { i.minX = e; i.maxX = kC; i.minY = kD; i.maxY = T; return i } else { return { minX: e, maxX: kC, minY: kD, maxY: T } } }, fromEPSG4326: function (T, kH, kF) { var kD = T.length; var kE = kF > 1 ? kF : 2; var e = kH; if (e === undefined) { if (kE > 2) { e = T.slice() } else { e = new Array(kD) } } for (var kC = 0; kC < kD; kC += kE) { e[kC] = (this.HALF_SIZE * T[kC]) / 180; var kG = this.RADIUS * Math.log(Math.tan((Math.PI * (+T[kC + 1] + 90)) / 360)); if (kG > this.MAX_SAFE_Y) { kG = this.MAX_SAFE_Y } else { if (kG < -this.MAX_SAFE_Y) { kG = -this.MAX_SAFE_Y } } e[kC + 1] = kG } return e }, toEPSG4326: function (T, kG, kF) { var kD = T.length; var kE = kF > 1 ? kF : 2; var e = kG; if (e === undefined) { if (kE > 2) { e = T.slice() } else { e = new Array(kD) } } for (var kC = 0; kC < kD; kC += kE) { e[kC] = (180 * T[kC]) / this.HALF_SIZE; e[kC + 1] = (360 * Math.atan(Math.exp(T[kC + 1] / this.RADIUS))) / Math.PI - 90 } return e }, findParentGridAndPosition: function (kC, kM, kL, kG, kH, kJ, kF) { if (kL - 1 < 0) { return false } var kN = kC; var kI = kM; var T = kL; for (var kE = 1; kE <= kF; kE++) { var e = this.findParent(kN, kI, T, kE); if (!e) { return false } var kK = this.getTileKey(e); var kD = kG.getData(kK); if (kD && kD.status === "ready") { if (kH[kK]) { continue } kJ.setData(kD, this.drawIndex, 0); kH[kK] = true; return true } kN = e.col; kI = e.row; T = e.zoom } }, findParent: function (i, kD, T, kC) { if (T - 1 < 0) { return null } var e = i % 2; var kE = kD % 2; return { col: Math.floor(i / 2), row: Math.floor(kD / 2), sonX: e, sonY: kE, thumbLB: [e * 0.5, 1 - kE * 0.5 - 0.5], thumbRT: [e * 0.5 + 0.5, 1 - kE * 0.5], radio: Math.pow(2, kC), zoom: T - 1, useZoom: T - 1 } }, getTileKey: function (e, kC) { kC = kC || {}; var i = typeof kC.useZoom === "number" ? kC.useZoom : e.useZoom; var T = e.style || this.mapStyleId || "default"; return this.mapType + "_" + T + "_" + e.col + "_" + e.row + "_" + e.zoom + "_" + i }, lon2tile: function (i, e) { return (Math.floor((i + 180) / 360 * Math.pow(2, e))) }, lat2tile: function (T, i) { var e = Math.tan(T * Math.PI / 180) + 1 / Math.cos(T * Math.PI / 180); return (Math.floor((1 - Math.log(e) / Math.PI) / 2 * Math.pow(2, i))) }, tile2long: function (e, i) { return (e / Math.pow(2, i) * 360 - 180) }, tile2lat: function (T, e) { var i = Math.PI - 2 * Math.PI * T / Math.pow(2, e); return (180 / Math.PI * Math.atan(0.5 * (Math.exp(i) - Math.exp(-i)))) } }); function cA(i, e) { if (i < -90) { i = -90 } else { if (i > 90) { i = 90 } } while (e < -180) { e += 360 } while (e > 180) { e -= 360 } e = e || 0; i = i || 0; cG.call(this, e, i) } cA.inherits(cG, "LatLng"); e9.extend(cA.prototype, { equals: function (e) { return (this.lat === e.lat && this.lng === e.lng) }, clone: function () { return new cA(this.lat, this.lng) }, add: function (e) { return new cA(this.lng + e.lng, this.lat + e.lat) }, sub: function (e) { return new cA(this.lat - e.lat, this.lng - e.lng) }, mult: function (e) { return new cA(this.lng * e, this.lat * e) }, div: function (e) { return new cA(this.lng / e, this.lat / e) }, mag: function () { return Math.sqrt(this.lng * this.lng + this.lat * this.lat) }, getLngSpan: function (e) { var i = this.lng; var T = Math.abs(e - i); if (T > 180) { T = 360 - T } return T }, toString: function () { return "LatLng" }, toGeoJSON: function () { var i = "Point"; var T = [this.lng, this.lat]; var e = { type: "Feature", geometry: { type: i, coordinates: T }, properties: this.properties }; return e } }); function cP(e, i) { if (e && !i) { i = e } this._sw = this._ne = null; this._swLng = this._swLat = null; this._neLng = this._neLat = null; if (e) { this._sw = new cA(e.lat, e.lng); this._ne = new cA(i.lat, i.lng); this._swLng = e.lng; this._swLat = e.lat; this._neLng = i.lng; this._neLat = i.lat } } e9.extend(cP.prototype, { isEmpty: function () { return !this._sw || !this._ne }, equals: function (e) { if (this.isEmpty()) { return false } return this.getSouthWest().equals(e.getSouthWest()) && this.getNorthEast().equals(e.getNorthEast()) }, getSouthWest: function () { return this._sw }, getNorthEast: function () { return this._ne }, containsBounds: function (e) { if (this.isEmpty() || e.isEmpty()) { return false } return (e._swLng > this._swLng && e._neLng < this._neLng && e._swLat > this._swLat && e._neLat < this._neLat) }, getCenter: function () { if (this.isEmpty()) { return null } return new cA((this._swLat + this._neLat) / 2, (this._swLng + this._neLng) / 2) }, intersects: function (T) { if (Math.max(T._swLng, T._neLng) < Math.min(this._swLng, this._neLng) || Math.min(T._swLng, T._neLng) > Math.max(this._swLng, this._neLng) || Math.max(T._swLat, T._neLat) < Math.min(this._swLat, this._neLat) || Math.min(T._swLat, T._neLat) > Math.max(this._swLat, this._neLat)) { return false } var kD = Math.max(this._swLng, T._swLng); var i = Math.min(this._neLng, T._neLng); var kC = Math.max(this._swLat, T._swLat); var e = Math.min(this._neLat, T._neLat); this._sw = new cA(kC, kD); this._ne = new cA(e, i); this._swLng = kD; this._swLat = kC; this._neLng = i; this._neLat = e; return true }, containsPoint: function (e) { if (this.isEmpty()) { return false } return (e.lng >= this._swLng && e.lng <= this._neLng && e.lat >= this._swLat && e.lat <= this._neLat) }, extend: function (e) { var i = e.lng; var T = e.lat; if (!this._sw) { this._sw = new cA(0, 0) } if (!this._ne) { this._ne = new cA(0, 0) } if (!this._swLng || this._swLng > i) { this._sw.lng = this._swLng = i } if (!this._neLng || this._neLng < i) { this._ne.lng = this._neLng = i } if (!this._swLat || this._swLat > T) { this._sw.lat = this._swLat = T } if (!this._neLat || this._neLat < T) { this._ne.lat = this._neLat = T } }, toSpan: function () { if (this.isEmpty()) { return new cA(0, 0) } return new cA(Math.abs(this._neLat - this._swLat), Math.abs(this._neLng - this._swLng)) }, union: function (i) { if (i.isEmpty()) { return false } var e = i.getSouthWest(); var T = i.getNorthEast(); if (this._swLat > e.lat) { this._swLat = e.lat } if (this._swLng > e.lng) { this._swLng = e.lng } if (this._neLat < T.lat) { this._neLat = T.lat } if (this._neLng < T.lng) { this._neLng = T.lng } this._sw = new cA(this._swLat, this._swLng); this._ne = new cA(this._neLat, this._neLng); return true }, toString: function () { return this._swLat + ", " + this._swLng + ", " + this._neLat + ", " + this._neLng } }); window.COORDINATES_WGS84 = 1; window.COORDINATES_WGS84_MC = 2; window.COORDINATES_GCJ02 = 3; window.COORDINATES_GCJ02_MC = 4; window.COORDINATES_BD09 = 5; window.COORDINATES_BD09_MC = 6; window.COORDINATES_MAPBAR = 7; window.COORDINATES_51 = 8; function f7() { } f7.inherits(dh, "Convertor"); e9.extend(f7.prototype, { translate: function (i, kD, kC, T) { kD = kD || 1; kC = kC || 5; if (i.length > 10) { T && T({ status: 25 }); return } if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var e = window._BMapSecurityConfig["serviceHost"] + "?qt=coords&coords="; e9.each(i, function (kE) { e += kE.lng + "," + kE.lat + ";" }); e = e.replace(/;$/gi, ""); e = e + "&from=" + kD + "&to=" + kC + "&v=gl&type=webgl" } else { var e = E.apiHost + "?qt=coords&coords="; e9.each(i, function (kE) { e += kE.lng + "," + kE.lat + ";" }); e = e.replace(/;$/gi, ""); e = e + "&from=" + kD + "&to=" + kC + "&v=gl&type=webgl&ak=" + eZ } dq.request(e, function (kF) { data = kF.content; if (typeof data !== "undefined" && data !== null && data.status === 0) { var kE = []; e9.each(data.result, function (kG) { kE.push(new cG(kG.x, kG.y)) }); delete data.result; data.points = kE } else { if (kF.result && kF.result.error) { data = { status: kF.result.errror, message: "访问错误，请参考错误状态码https://lbsyun.baidu.com/index.php?title=webapi/appendix" } } } T && T(data) }) } }); var ep = { idle: 0, freeze: 1, zooming: 2, dragging: 3, moving: 4, readyToDrag: 5, readyToPinch: 6, pinching: 7, stdMapCtrlDrag: 8, KEY_LEFT: 37, KEY_UP: 38, KEY_RIGHT: 39, KEY_DOWN: 40, arrowOpCodes: { 37: 1, 38: 2, 39: 4, 40: 8 } }; var am = { _map: null, _html: "<div class='BMap_opMask' unselectable='on'></div>", _maskElement: null, _cursor: "default", inUse: false, show: function (e) { if (!this._map) { this._map = e } this.inUse = true; if (!this._maskElement) { this._createMask(e) } this._maskElement.style.display = "block" }, _createMask: function (i) { if (!this._map) { this._map = i } if (!this._map) { return } var e = this._maskElement = bS(this._map.container, this._html); e9.on(e, "mouseup", function (T) { if (T.button == 2) { hI(T) } }); e9.on(e, "contextmenu", hI); e.style.display = "none" }, getDrawPoint: function (kC, kF, kD) { kC = window.event || kC; var i = kC.offsetX || kC.layerX || 0; var kE = parseInt(kC.offsetY) || parseInt(kC.layerY) || 0; var T = kC.target || kC.srcElement; if (T != am.getDom(this._map) && kF == true) { while (T && T != this._map.container) { if (!(T.clientWidth == 0 && T.clientHeight == 0 && T.offsetParent && T.offsetParent.nodeName.toLowerCase() == "td")) { i += T.offsetLeft; kE += T.offsetTop } T = T.offsetParent } } if (T != am.getDom(this._map) && T != this._map.container) { return } if (typeof i === "undefined" || typeof kE === "undefined") { return } if (isNaN(i) || isNaN(kE)) { return } if (kD) { i = i + kD.x; kE = kE + kD.y } return this._map.pixelToPointIn(new fv(i, kE)) }, hide: function () { if (!this._map) { return } this.inUse = false; if (this._maskElement) { this._maskElement.style.display = "none" } }, getDom: function (e) { if (!this._maskElement) { this._createMask(e) } return this._maskElement }, setCursor: function (e) { this._cursor = e || "default"; if (this._maskElement) { this._maskElement.style.cursor = this._cursor } } }; function aU() { this._type = "overlay" } aU.inherits(e9.BaseClass, "Overlay"); aU.getZIndex = function (i, e) { i = i * 1; if (!i) { return 0 } if (e) { i = jy.convertMC2LL(new cG(0, i)).lat } return (i * -100000) << 1 }; e9.extend(aU.prototype, { _i: function (kF) { this._map = kF; if (!this.domElement && b0(this.initialize)) { this.domElement = this.initialize(kF); if (this.domElement) { this.domElement.style.WebkitUserSelect = "none"; if (this.enableDraggingMap !== undefined && !this.enableDraggingMap && !(this instanceof u)) { var kE = ["mouseout", "mouseover", "click", "keydown", "selectstart"]; var T = (window.PointerEvent || window.MSPointerEvent) && (navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0); var e = ["mousedown"]; if (T) { if (window.PointerEvent) { e = ["pointerdown"] } else { if (window.MSPointerEvent) { e = ["MSPointerDown"] } } } for (var kC = 0; kC < e.length; kC++) { kE.push(e[kC]) } var kD = this; e9.each(kE, function (i) { e9.on(kD.domElement, i, al) }) } } } this.draw() }, initialize: function (e) { throw "initialize方法未实现" }, draw: function () { throw "draw方法未实现" }, remove: function () { if (this.domElement && this.domElement.parentNode) { this.domElement.parentNode.removeChild(this.domElement) } this.domElement = null; this.dispatchEvent(new fW("onremove")) }, hide: function () { this._visible = false; e9.hide(this.domElement) }, show: function () { this._visible = true; e9.show(this.domElement) }, isVisible: function () { return this._visible }, getMap: function () { return this._map }, dispose: function () { e9.BaseClass.prototype.decontrol.call(this) } }); function eM() { e9.BaseClass.call(this); aU.call(this); this._visible = true; this._visibleInternal = true; this.zIndex = 0; this.infoWindow = null; this._dblclickTime = 0 } eM.inherits(aU, "OverlayInternal"); e9.extend(eM.prototype, { initialize: function (e) { this.map = e; e9.BaseClass.call(this, this.hashCode); return null }, draw: function () { }, remove: function () { this.decontrol(); aU.prototype.remove.call(this) }, destroy: function () { }, hide: function () { this._visible = false }, show: function () { this._visible = true }, getDom: function () { return this.domElement }, getContainer: function () { return this.domElement }, setClassName: function () { }, setConfig: function (i) { if (!i) { return } for (var e in i) { if (i.hasOwnProperty(e)) { this._config[e] = i[e] } } }, getPoint: function (T, kC) { if (!T) { return this.point } else { var e = kC ? kC.width : 0; var kD = kC ? kC.height : 0; if (this.map) { var i = this.map.pointToPixelIn(this.point); if (this._config && this._config.offset) { i.x = i.x + this._config.offset.width + e; i.y = i.y + this._config.offset.height + kD } else { i.x = i.x + e; i.y = i.y + kD } return this.map.pixelToPointIn(i) } } }, setZIndex: function (e) { this.zIndex = e }, isVisible: function () { if (!this.domElement) { return false } return !!this._visible }, enableMassClear: function () { this._config.enableMassClear = true }, disableMassClear: function () { this._config.enableMassClear = false }, showInternal: function () { this._visibleInternal = true }, hideInternal: function (e) { this._visibleInternal = false; this._hideInternalReason = e }, addContextMenu: function (e) { this._menu = e }, removeContextMenu: function (e) { this._menu = null } }); function aS(e) { this.map = e; this._overlays = {}; this._overlayArray = []; this._customOverlays = []; e._overlays = this._overlays; e._overlayArray = this._overlayArray; e._customOverlays = this._customOverlays; this._zoomingOrMoving = false; this._init() } aS.prototype._init = function () { if (this.map._renderType !== "webgl") { this._createOverlayContainers() } else { this._createWebGLOverlayContainers() } this._bind() }; aS.prototype._createOverlayContainers = function () { var e = this.map; e.temp.overlayDiv = e.overlayDiv = this._createOverlayDiv(e.platform, 200); e.temp.overlayDivEx = e.overlayDivEx = this._createOverlayDiv(e.platform, 50); e._panes.floatPane = this._createOverlayDiv(e.temp.overlayDiv, 800); e._panes.markerMouseTarget = this._createOverlayDiv(e.temp.overlayDiv, 700); e._panes.floatShadow = this._createOverlayDiv(e.temp.overlayDiv, 600); e._panes.labelPane = this._createOverlayDiv(e.temp.overlayDiv, 500); e._panes.markerPane = this._createOverlayDiv(e.temp.overlayDiv, 400); if (e.isCanvasMap()) { e._panes.mapPane = this._createOverlayDiv(e.temp.overlayDivEx, 50) } else { e._panes.mapPane = this._createOverlayDiv(e.temp.overlayDiv, 200) } }; aS.prototype._createWebGLOverlayContainers = function () { var e = this.map; e.temp.overlayDiv = e.overlayDiv = this._createOverlayDiv(e.platform, 200); e._panes.floatPane = this._createOverlayDiv(e.temp.overlayDiv, 800); e._panes.markerMouseTarget = this._createOverlayDiv(e.temp.overlayDiv, 700); e._panes.floatShadow = this._createOverlayDiv(e.temp.overlayDiv, 600); e._panes.labelPane = this._createOverlayDiv(e.temp.overlayDiv, 500); e._panes.markerPane = this._createOverlayDiv(e.temp.overlayDiv, 400) }; aS.prototype._createOverlayDiv = function (e, kC) { var T = b6("div"); var i = T.style; i.position = "absolute"; i.top = i.left = i.width = i.height = "0"; i.zIndex = kC; e.appendChild(T); return T }; aS.prototype._bind = function () { var kD = this.map; var kC = this; function i(kF) { kC.draw(kF) } if (kD._renderType !== "webgl") { kD.addEventListener("load", i); kD.addEventListener("moveend", i); kD.addEventListener("resize", i); kD.addEventListener("zoomend", i); kD.addEventListener("zooming_inner", i) } else { kD.on("update", i) } kD.on("destroy", function () { kD._overlays = {}; kD._overlayArray = []; kD._customOverlays = []; kD.overlayDiv = null; kD.overlayDivEx = null; var kF = Object.keys(kD._panes); for (var kG = 0; kG < kF.length; kG++) { kD._panes[kF[kG]] = null } var kH = Object.keys(kD.temp); for (var kG = 0; kG < kH.length; kG++) { kD.temp[kH[kG]] = null } }); kD.addEventListener("zoomend", function (kF) { if (this.mapType === "B_EARTH_MAP") { if (this._earth.getZoom() < this._earth.zoomForNight + 1) { this.temp.overlayDiv.style.display = "none"; if (this.temp.overlayDivEx) { this.temp.overlayDivEx.style.display = "none" } } else { if (this.temp.overlayDiv.style.display === "none") { this.temp.overlayDiv.style.display = ""; if (this.temp.overlayDivEx) { this.temp.overlayDivEx.style.display = "" } if (this.temp.infoWin && this.temp.infoWin.isOpen()) { this.temp.infoWin.redraw() } } } } }); kD.addEventListener("oncenterandzoom", function (kF) { kC.draw(kF); if (this.mapType === "B_EARTH_MAP") { if (this._earth.getZoom() < this._earth.zoomForNight + 1) { this.temp.overlayDiv.style.display = "none"; if (this.temp.overlayDivEx) { this.temp.overlayDivEx.style.display = "none" } } else { if (this.temp.overlayDiv.style.display === "none") { this.temp.overlayDiv.style.display = ""; if (this.temp.overlayDivEx) { this.temp.overlayDivEx.style.display = "" } if (this.temp.infoWin && this.temp.infoWin.isOpen()) { this.temp.infoWin.redraw() } } } } }); kD.addEventListener("maptypechange", function (kF) { if (this.mapType === "B_EARTH_MAP") { if (this._panes.mapPane) { this._panes.mapPane.style.display = "none" } if (this._earth.getZoom() < this._earth.zoomForNight + 1) { this.temp.overlayDiv.style.display = "none"; if (this.temp.overlayDivEx) { this.temp.overlayDivEx.style.display = "none" } } else { if (this.temp.overlayDiv.style.display === "none") { this.temp.overlayDiv.style.display = ""; if (this.temp.overlayDivEx) { this.temp.overlayDivEx.style.display = "" } if (this.temp.infoWin && this.temp.infoWin.isOpen()) { this.temp.infoWin.redraw() } } } if (this._panes.markerPane) { this._panes.markerPane.style.display = "none" } } else { if (this._panes.mapPane) { this._panes.mapPane.style.display = "" } if (this._panes.markerPane) { this._panes.markerPane.style.display = "" } if (this.temp.overlayDiv.style.display === "none") { this.temp.overlayDiv.style.display = ""; if (this.temp.overlayDivEx) { this.temp.overlayDivEx.style.display = "" } if (this.temp.infoWin && this.temp.infoWin.isOpen()) { this.temp.infoWin.redraw() } } } kC.draw(kF) }); kD.on("earthstatuschange", function kE(kF) { kC.draw(kF) }); kD.addEventListener("addoverlay", function (kJ) { var kG = kJ.target; if (kG instanceof eM) { if (!kC._overlays[kG.hashCode]) { kC._overlays[kG.hashCode] = kG; kC._overlayArray.push(kG) } } else { var kI = false; for (var kH = 0, kF = kC._customOverlays.length; kH < kF; kH++) { if (kC._customOverlays[kH] === kG) { kI = true; break } } if (!kI) { kC._customOverlays.push(kG) } } }); kD.addEventListener("removeoverlay", function (kI) { var kG = kI.target; if (kG instanceof eM) { delete kC._overlays[kG.hashCode]; for (var kH = 0; kH < kC._overlayArray.length; kH++) { if (kC._overlayArray[kH] === kG) { kC._overlayArray.splice(kH, 1); break } } } else { for (var kH = 0, kF = kC._customOverlays.length; kH < kF; kH++) { if (kC._customOverlays[kH] === kG) { kC._customOverlays.splice(kH, 1); break } } } }); kD.addEventListener("clearoverlays", function (kH) { this.closeInfoWindow(); this.closeSimpleInfoWindow(); for (var kG in kC._overlays) { if (kC._overlays[kG]._config.enableMassClear) { this.removeOverlay(kC._overlays[kG]) } } for (var kF = kC._customOverlays.length - 1; kF >= 0; kF--) { if (kC._customOverlays[kF].enableMassClear !== false) { this.removeOverlay(kC._customOverlays[kF]); kC._customOverlays.splice(kF, 1) } } }); kD.addEventListener("infowindowopen", function (kG) { var kF = this.infoWindow; if (kF) { e9.hide(kF.popDom); e9.hide(kF.shadowDom) } }); function T() { if (this.getMapType() === "B_EARTH_MAP" || this._renderType === "webgl") { if (kC._zoomingOrMoving === false) { this._panes.markerMouseTarget.style.display = "none"; kC._zoomingOrMoving = true } } } function e(kH) { if (this.getMapType() === "B_EARTH_MAP" || this._renderType === "webgl") { if (kC._zoomingOrMoving === true) { if (this._panes.markerMouseTarget) { this._panes.markerMouseTarget.style.display = "" } kC._zoomingOrMoving = false; for (var kG = 0; kG < kC._overlayArray.length; kG++) { var kF = kC._overlayArray[kG]; if (kF instanceof ke === true) { kF.draw(kH) } } } } } kD.addEventListener("tilt_changed", e); kD.addEventListener("heading_changed", e); kD.addEventListener("movestart", T); kD.addEventListener("moveend", e); kD.addEventListener("zoomstart", T); kD.addEventListener("zoomend", e); kD.addEventListener("animation_start", T); kD.addEventListener("animation_end", e); kD.addEventListener("displayoptions_changed", function (kF) { if (this._displayOptions.overlay === false) { this.temp.overlayDiv.style.display = "none" } else { this.temp.overlayDiv.style.display = "" } }) }; aS.prototype.draw = function (kF) { kF = kF || {}; if (this.map.getMapType() === "B_EARTH_MAP") { for (var kD = 0; kD < this._overlayArray.length; kD++) { var T = this._overlayArray[kD]; if (T instanceof iV === true) { continue } if (this._zoomingOrMoving) { if (T instanceof ke === true) { continue } } T.draw(kF) } } else { for (var kD = 0, kC = this._overlayArray.length; kD < kC; kD++) { var T = this._overlayArray[kD]; if (this._zoomingOrMoving && T instanceof ke === true) { continue } T.draw(kF) } } e9.each(this._customOverlays, function (e) { e.draw(kF); if (!(e instanceof bU)) { hQ.sendMessage(a1(4, 2, 12), ["overlay", "user_custom"]) } }); if (this.map.temp.infoWin) { this.map.temp.infoWin.setPosition(kF.center, kF.zoom) } if (this.map.getMapType() !== "B_EARTH_MAP" && this.map._renderType !== "webgl") { if (bG.DrawerSelector) { var kE = bG.DrawerSelector.getDrawer(this.map); kE.setPalette() } } }; bG.register(function (e) { e._overlayMgr = new aS(e) }); function iV(e) { eM.call(this); this._config = { strokeColor: "#000", strokeWeight: 2, strokeOpacity: 1, strokeStyle: "solid", dashArray: null, strokeLineCap: "round", strokeLineJoin: "round", enableMassClear: true, getParseTolerance: null, getParseCacheIndex: null, enableParse: true, enableEditing: false, mouseOverTolerance: 5, geodesic: false, linkRight: false, clip: true, texture: null, textureSize: null, textureZoomWithMap: false, textureRepeat: true, zIndex: 0 }; this.setConfig(e); if (this._config.zIndex !== undefined) { this.zIndex = this._config.zIndex } if (this._config.strokeOpacity < 0 || this._config.strokeOpacity > 1) { this._config.strokeOpacity = 1 } if (this._config.fillOpacity < 0 || this._config.fillOpacity > 1) { this._config.fillOpacity = 1 } if (this._config.strokeStyle !== "solid" && this._config.strokeStyle !== "dashed" && this._config.strokeStyle !== "dotted") { this._config.strokeStyle = "solid" } this.domElement = null; this._bounds = new ik(); this.points = []; this.greatCirclePoints = []; this._parseCache = []; this._holesCache = []; this._parseCacheGL = []; this._parseCacheGLRaw = []; this._areaCacheGL = []; this._strokeStyleInfoForGL = [[]]; this._fillStyleInfoForGL = ""; this.vertexMarkers = []; this._temp = {} } iV.JOININDEX = { miter: 0, round: 1, bevel: 2 }; iV.CAPINDEX = { round: 0, butt: 1, square: 2 }; iV.inherits(eM, "Graph"); iV.getGraphPoints = function (i) { var e = []; if (!i || i.length === 0) { return e } if (typeof i === "string") { var T = i.split(";"); e9.each(T, function (kD) { var kC = kD.split(","); e.push(new cG(kC[0], kC[1])) }) } if (i.constructor === Array && i.length > 0) { e = i } return e }; iV.parseTolerance = { 0: [0.09, 0.005, 0.0001, 0.00001], 1: [9000, 500, 20, 1] }; e9.extend(iV.prototype, { initialize: function (e) { this.map = e; return null }, draw: function () { }, setPoints: function (e) { this._clearCache(); this.points = iV.getGraphPoints(e).slice(0); this._calcBounds() }, setPathIn: function (e) { this.setPoints(e) }, _calcBounds: function () { if (!this.points) { return } var e = this; e._bounds = new ik(); if (!this.hasMultipleParts) { e9.each(this.points, function (i) { e._bounds.extend(i) }) } else { e9.each(this.points, function (i) { e9.each(i, function (T) { e._bounds.extend(T) }) }) } }, getPoints: function () { return this.points }, getPathIn: function () { return this.points }, setPointAt: function (i, e) { if (!e || !this.points[i]) { return } this._clearCache(); this.points[i] = new cG(e.lng, e.lat); this._calcBounds() }, setPositionAt: function (i, e) { if (!e || !this.points[i]) { return } var T = jy.convertLL2MC(e); this.setPointAt(i, T) }, setOptions: function (i) { i = i || {}; for (var e in i) { if (i.hasOwnProperty(e)) { this._config[e] = i[e] } } }, setStrokeColor: function (e) { this._config.strokeColor = e }, getStrokeColor: function () { return this._config.strokeColor }, setStrokeLineCap: function (e) { this._config.strokeLineCap = e }, getStrokeLineCap: function () { return this._config.strokeLineCap }, setStrokeLineJoin: function (e) { this._config.strokeLineJoin = e }, getStrokeLineJoin: function () { return this._config.strokeLineJoin }, setStrokeWeight: function (e) { if (e > 0) { this._config.strokeWeight = e } }, getStrokeWeight: function () { return this._config.strokeWeight }, setStrokeOpacity: function (e) { if (!e || e > 1 || e < 0) { return } this._config.strokeOpacity = e }, getStrokeOpacity: function () { return this._config.strokeOpacity }, setFillOpacity: function (e) { if (e > 1 || e < 0) { return } this._config.fillOpacity = e }, getFillOpacity: function () { return this._config.fillOpacity }, setStrokeStyle: function (e) { if (e !== "solid" && e !== "dashed" && e !== "dotted") { return } this._config.strokeStyle = e }, getStrokeStyle: function () { return this._config.strokeStyle }, setFillColor: function (e) { this._config.fillColor = e || "" }, getFillColor: function () { return this._config.fillColor }, getBoundsIn: function () { this._bounds.setMinMax(); return this._bounds }, getBounds: function () { var e = this.getBoundsIn(); var i = new ik(jy.convertMC2LL(e.getSouthWest()), jy.convertMC2LL(e.getNorthEast())); i.setMinMax(); return i }, remove: function () { if (this.map) { this.map.removeEventListener("onmousemove", this._graphMouseEvent); this.map.removeEventListener("onclick", this._graphClickEvent) } eM.prototype.remove.call(this); this._clearCache(); var e = new fW("onlineupdate"); e.action = "remove"; e.overlay = this; this.fire(e) }, enableEditing: function () { if (this.points.length < 2) { return } this._config.enableEditing = true; var e = this; hm.load("poly", function () { e.addVertexs() }, true) }, disableEditing: function () { this._config.enableEditing = false; var e = this; hm.load("poly", function () { e.clearVertexs() }, true) }, getLength: function () { if (typeof this._length === "number") { return this._length } if (typeof this._config.totalLength === "number") { this._length = this._config.totalLength; return this._length } var T = 0; if (this.points.length <= 1) { this._length = 0; return T } for (var e = 0; e < this.points.length - 1; e++) { T += eF(this.points[e], this.points[e + 1]) } this._length = T; return T }, getParsedPoints: function () { var e = this._simplification(this.points); if (this.hasMultipleParts) { return e } return [e] }, _simplification: function (kG) { var e = this.map; var kF = this.getParseCacheIndex(e.getZoom()); var kI; if (this._parseCache[kF]) { kI = this._parseCache[kF] } else { var kD = kG; if (this.greatCirclePoints.length > 0) { kD = this.greatCirclePoints } var kE = this.getParseTolerance(e.getZoom(), 1); if (!this.hasMultipleParts) { var kH = d2(kD, kE); kH = iY(kH, kE) } else { var kH = []; for (var T = 0; T < kD.length; T++) { var kC = d2(kD[T], kE); kC = iY(kC, kE); kH.push(kC) } } kI = this._parseCache[kF] = kH } return kI }, _clearCache: function () { this._length = null; this._parseCache.length = 0; this._parseCacheGL.length = 0; this._parseCacheGLRaw.length = 0; this._areaCacheGL.length = 0 }, canRenderDataBeMerged: function () { var e = this._config; if (e.texture) { return false } return true } }); if (e9.Browser.ie && document.namespaces && !document.namespaces.olv) { document.namespaces.add("olv", "urn:schemas-microsoft-com:vml") } function bz(kE, kC, kL) { var kI = false, kG = false, kJ = false, kN = new fv(kE.x, kE.y), kM = new fv(kC.x, kC.y), kD = fX(kN, kL), T = fX(kM, kL), kK; var kP, kO; var kH = kL.minX, kF = kL.minY, i = kL.maxX, e = kL.maxY; do { if (kD.all == 0 && T.all == 0) { kI = true; kJ = true } else { if ((kD.all & T.all) != 0) { kJ = true } else { if (kD.all != 0) { kK = kD } else { kK = T } if (kK.top) { kP = kN.x + (kM.x - kN.x) * (kF - kN.y) / (kM.y - kN.y); kO = kF } else { if (kK.bottom) { kP = kN.x + (kM.x - kN.x) * (e - kN.y) / (kM.y - kN.y); kO = e } else { if (kK.right) { kO = kN.y + (kM.y - kN.y) * (i - kN.x) / (kM.x - kN.x); kP = i } else { if (kK.left) { kO = kN.y + (kM.y - kN.y) * (kH - kN.x) / (kM.x - kN.x); kP = kH } } } } kG = true; if (kK.all == kD.all) { kN.x = Math.round(kP); kN.y = Math.round(kO); kD = fX(kN, kL) } else { kM.x = Math.round(kP); kM.y = Math.round(kO); T = fX(kM, kL) } } } } while (!kJ); if (kI) { return { pixel0: new fv(kN.x, kN.y), pixel1: new fv(kM.x, kM.y), clip: kG ? true : false } } } function fX(i, kD) { var T = { top: 0, bottom: 0, right: 0, left: 0, all: 0 }; var e = i.x, kC = i.y; if (kC < kD.minY) { T.top = 8; T.all += T.top } else { if (kC > kD.maxY) { T.bottom = 4; T.all += T.bottom } } if (e > kD.maxX) { T.right = 2; T.all += T.right } else { if (e < kD.minX) { T.left = 1; T.all += T.left } } return T } function dS(e) { e = e.replace(/,/gm, " "); e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"); e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"); e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2"); e = e.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"); e = e.replace(/([0-9])([+\-])/gm, "$1 $2"); e = e.replace(/(\.[0-9]*)(\.)/gm, "$1 $2"); e = e.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 "); e = dS.compressSpaces(e); e = dS.trim(e); this.PathParser = new (function (i) { this.tokens = i.split(" "); this.reset = function () { this.i = -1; this.command = ""; this.previousCommand = ""; this.start = new dS.Point(0, 0); this.control = new dS.Point(0, 0); this.current = new dS.Point(0, 0); this.points = []; this.angles = [] }; this.isEnd = function () { return this.i >= this.tokens.length - 1 }; this.isCommandOrEnd = function () { if (this.isEnd()) { return true } return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null }; this.isRelativeCommand = function () { switch (this.command) { case "m": case "l": case "h": case "v": case "c": case "s": case "q": case "t": case "a": case "z": return true; break }return false }; this.getToken = function () { this.i++; return this.tokens[this.i] }; this.getScalar = function () { return parseFloat(this.getToken()) }; this.nextCommand = function () { this.previousCommand = this.command; this.command = this.getToken() }; this.getPoint = function () { var T = new dS.Point(this.getScalar(), this.getScalar()); return this.makeAbsolute(T) }; this.getAsControlPoint = function () { var T = this.getPoint(); this.control = T; return T }; this.getAsCurrentPoint = function () { var T = this.getPoint(); this.current = T; return T }; this.getReflectedControlPoint = function () { if (this.previousCommand.toLowerCase() != "c" && this.previousCommand.toLowerCase() != "s" && this.previousCommand.toLowerCase() != "q" && this.previousCommand.toLowerCase() != "t") { return this.current } var T = new dS.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y); return T }; this.makeAbsolute = function (T) { if (this.isRelativeCommand()) { T.x += this.current.x; T.y += this.current.y } return T }; this.addMarker = function (kC, kD, T) { if (T != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null) { this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(T) } this.addMarkerAngle(kC, kD == null ? null : kD.angleTo(kC)) }; this.addMarkerAngle = function (kC, T) { this.points.push(kC); this.angles.push(T) }; this.getMarkerPoints = function () { return this.points }; this.getMarkerAngles = function () { for (var kC = 0; kC < this.angles.length; kC++) { if (this.angles[kC] == null) { for (var T = kC + 1; T < this.angles.length; T++) { if (this.angles[T] != null) { this.angles[kC] = this.angles[T]; break } } } } return this.angles } })(e); this.bounds = function () { return this.draw(null) }; this.draw = function (kW) { var kY = this.PathParser; kY.reset(); var kJ = new dS.BoundingBox(); if (kW != null) { kW.beginPath() } while (!kY.isEnd()) { kY.nextCommand(); switch (kY.command) { case "M": case "m": var kT = kY.getAsCurrentPoint(); kY.addMarker(kT); kJ.addPoint(kT.x, kT.y); if (kW != null) { kW.moveTo(kT.x, kT.y) } kY.start = kY.current; while (!kY.isCommandOrEnd()) { var kT = kY.getAsCurrentPoint(); kY.addMarker(kT, kY.start); kJ.addPoint(kT.x, kT.y); if (kW != null) { kW.lineTo(kT.x, kT.y) } } break; case "L": case "l": while (!kY.isCommandOrEnd()) { var k2 = kY.current; var kT = kY.getAsCurrentPoint(); kY.addMarker(kT, k2); kJ.addPoint(kT.x, kT.y); if (kW != null) { kW.lineTo(kT.x, kT.y) } } break; case "H": case "h": while (!kY.isCommandOrEnd()) { var kC = new dS.Point((kY.isRelativeCommand() ? kY.current.x : 0) + kY.getScalar(), kY.current.y); kY.addMarker(kC, kY.current); kY.current = kC; kJ.addPoint(kY.current.x, kY.current.y); if (kW != null) { kW.lineTo(kY.current.x, kY.current.y) } } break; case "V": case "v": while (!kY.isCommandOrEnd()) { var kC = new dS.Point(kY.current.x, (kY.isRelativeCommand() ? kY.current.y : 0) + kY.getScalar()); kY.addMarker(kC, kY.current); kY.current = kC; kJ.addPoint(kY.current.x, kY.current.y); if (kW != null) { kW.lineTo(kY.current.x, kY.current.y) } } break; case "C": case "c": while (!kY.isCommandOrEnd()) { var k0 = kY.current; var kE = kY.getPoint(); var kF = kY.getAsControlPoint(); var kL = kY.getAsCurrentPoint(); kY.addMarker(kL, kF, kE); kJ.addBezierCurve(k0.x, k0.y, kE.x, kE.y, kF.x, kF.y, kL.x, kL.y); if (kW != null) { kW.bezierCurveTo(kE.x, kE.y, kF.x, kF.y, kL.x, kL.y) } } break; case "S": case "s": while (!kY.isCommandOrEnd()) { var k0 = kY.current; var kE = kY.getReflectedControlPoint(); var kF = kY.getAsControlPoint(); var kL = kY.getAsCurrentPoint(); kY.addMarker(kL, kF, kE); kJ.addBezierCurve(k0.x, k0.y, kE.x, kE.y, kF.x, kF.y, kL.x, kL.y); if (kW != null) { kW.bezierCurveTo(kE.x, kE.y, kF.x, kF.y, kL.x, kL.y) } } break; case "Q": case "q": while (!kY.isCommandOrEnd()) { var k0 = kY.current; var kF = kY.getAsControlPoint(); var kL = kY.getAsCurrentPoint(); kY.addMarker(kL, kF, kF); kJ.addQuadraticCurve(k0.x, k0.y, kF.x, kF.y, kL.x, kL.y); if (kW != null) { kW.quadraticCurveTo(kF.x, kF.y, kL.x, kL.y) } } break; case "T": case "t": while (!kY.isCommandOrEnd()) { var k0 = kY.current; var kF = kY.getReflectedControlPoint(); kY.control = kF; var kL = kY.getAsCurrentPoint(); kY.addMarker(kL, kF, kF); kJ.addQuadraticCurve(k0.x, k0.y, kF.x, kF.y, kL.x, kL.y); if (kW != null) { kW.quadraticCurveTo(kF.x, kF.y, kL.x, kL.y) } } break; case "A": case "a": while (!kY.isCommandOrEnd()) { var k0 = kY.current; var kI = kY.getScalar(); var kH = kY.getScalar(); var T = kY.getScalar() * (Math.PI / 180); var kK = kY.getScalar(); var kG = kY.getScalar(); var kL = kY.getAsCurrentPoint(); var k5 = new dS.Point(Math.cos(T) * (k0.x - kL.x) / 2 + Math.sin(T) * (k0.y - kL.y) / 2, -Math.sin(T) * (k0.x - kL.x) / 2 + Math.cos(T) * (k0.y - kL.y) / 2); var kX = Math.pow(k5.x, 2) / Math.pow(kI, 2) + Math.pow(k5.y, 2) / Math.pow(kH, 2); if (kX > 1) { kI *= Math.sqrt(kX); kH *= Math.sqrt(kX) } var kP = (kK == kG ? -1 : 1) * Math.sqrt(((Math.pow(kI, 2) * Math.pow(kH, 2)) - (Math.pow(kI, 2) * Math.pow(k5.y, 2)) - (Math.pow(kH, 2) * Math.pow(k5.x, 2))) / (Math.pow(kI, 2) * Math.pow(k5.y, 2) + Math.pow(kH, 2) * Math.pow(k5.x, 2))); if (isNaN(kP)) { kP = 0 } var kO = new dS.Point(kP * kI * k5.y / kH, kP * -kH * k5.x / kI); var kD = new dS.Point((k0.x + kL.x) / 2 + Math.cos(T) * kO.x - Math.sin(T) * kO.y, (k0.y + kL.y) / 2 + Math.sin(T) * kO.x + Math.cos(T) * kO.y); var kV = function (k6) { return Math.sqrt(Math.pow(k6[0], 2) + Math.pow(k6[1], 2)) }; var kR = function (k7, k6) { return (k7[0] * k6[0] + k7[1] * k6[1]) / (kV(k7) * kV(k6)) }; var k3 = function (k7, k6) { return (k7[0] * k6[1] < k7[1] * k6[0] ? -1 : 1) * Math.acos(kR(k7, k6)) }; var k4 = k3([1, 0], [(k5.x - kO.x) / kI, (k5.y - kO.y) / kH]); var kN = [(k5.x - kO.x) / kI, (k5.y - kO.y) / kH]; var kM = [(-k5.x - kO.x) / kI, (-k5.y - kO.y) / kH]; var k1 = k3(kN, kM); if (kR(kN, kM) <= -1) { k1 = Math.PI } if (kR(kN, kM) >= 1) { k1 = 0 } var kU = 1 - kG ? 1 : -1; var kZ = k4 + kU * (k1 / 2); var i = new dS.Point(kD.x + kI * Math.cos(kZ), kD.y + kH * Math.sin(kZ)); kY.addMarkerAngle(i, kZ - kU * Math.PI / 2); kY.addMarkerAngle(kL, kZ - kU * Math.PI); kJ.addPoint(kL.x, kL.y); if (kW != null) { var kR = kI > kH ? kI : kH; var kS = kI > kH ? 1 : kI / kH; var kQ = kI > kH ? kH / kI : 1; kW.translate(kD.x, kD.y); kW.rotate(T); kW.scale(kS, kQ); kW.arc(0, 0, kR, k4, k4 + k1, 1 - kG); kW.scale(1 / kS, 1 / kQ); kW.rotate(-T); kW.translate(-kD.x, -kD.y) } } break; case "Z": case "z": if (kW != null) { kW.closePath() } kY.current = kY.start } } return kJ }; this.getMarkers = function () { var kC = this.PathParser.getMarkerPoints(); var kE = this.PathParser.getMarkerAngles(); var kD = []; for (var T = 0; T < kC.length; T++) { kD.push([kC[T], kE[T]]) } return kD } } dS.trim = function (e) { return e.replace(/^\s+|\s+$/g, "") }; dS.compressSpaces = function (e) { return e.replace(/[\s\r\t\n]+/gm, " ") }; dS.Point = function (e, i) { this.x = e; this.y = i }; dS.Point.prototype.angleTo = function (e) { return Math.atan2(e.y - this.y, e.x - this.x) }; dS.Point.prototype.applyTransform = function (e) { var i = this.x * e[0] + this.y * e[2] + e[4]; var T = this.x * e[1] + this.y * e[3] + e[5]; this.x = i; this.y = T }; dS.BoundingBox = function (i, kC, e, T) { this.x1 = Number.NaN; this.y1 = Number.NaN; this.x2 = Number.NaN; this.y2 = Number.NaN; this.x = function () { return this.x1 }; this.y = function () { return this.y1 }; this.width = function () { return this.x2 - this.x1 }; this.height = function () { return this.y2 - this.y1 }; this.addPoint = function (kD, kE) { if (kD != null) { if (isNaN(this.x1) || isNaN(this.x2)) { this.x1 = kD; this.x2 = kD } if (kD < this.x1) { this.x1 = kD } if (kD > this.x2) { this.x2 = kD } } if (kE != null) { if (isNaN(this.y1) || isNaN(this.y2)) { this.y1 = kE; this.y2 = kE } if (kE < this.y1) { this.y1 = kE } if (kE > this.y2) { this.y2 = kE } } }; this.addX = function (kD) { this.addPoint(kD, null) }; this.addY = function (kD) { this.addPoint(null, kD) }; this.addBoundingBox = function (kD) { this.addPoint(kD.x1, kD.y1); this.addPoint(kD.x2, kD.y2) }; this.addQuadraticCurve = function (kI, kH, kE, kD, kK, kJ) { var kG = kI + 2 / 3 * (kE - kI); var kF = kH + 2 / 3 * (kD - kH); var kM = kG + 1 / 3 * (kK - kI); var kL = kF + 1 / 3 * (kJ - kH); this.addBezierCurve(kI, kH, kG, kM, kF, kL, kK, kJ) }; this.addBezierCurve = function (kQ, kP, kH, kF, kM, kK, kS, kR) { var kI = [kQ, kP], kG = [kH, kF], kE = [kM, kK], kD = [kS, kR]; this.addPoint(kI[0], kI[1]); this.addPoint(kD[0], kD[1]); for (jN = 0; jN <= 1; jN++) { var kT = function (kX) { return Math.pow(1 - kX, 3) * kI[jN] + 3 * Math.pow(1 - kX, 2) * kX * kG[jN] + 3 * (1 - kX) * Math.pow(kX, 2) * kE[jN] + Math.pow(kX, 3) * kD[jN] }; var kV = 6 * kI[jN] - 12 * kG[jN] + 6 * kE[jN]; var kW = -3 * kI[jN] + 9 * kG[jN] - 9 * kE[jN] + 3 * kD[jN]; var kU = 3 * kG[jN] - 3 * kI[jN]; if (kW == 0) { if (kV == 0) { continue } var kO = -kU / kV; if (0 < kO && kO < 1) { if (jN == 0) { this.addX(kT(kO)) } if (jN == 1) { this.addY(kT(kO)) } } continue } var kJ = Math.pow(kV, 2) - 4 * kU * kW; if (kJ < 0) { continue } var kN = (-kV + Math.sqrt(kJ)) / (2 * kW); if (0 < kN && kN < 1) { if (jN == 0) { this.addX(kT(kN)) } if (jN == 1) { this.addY(kT(kN)) } } var kL = (-kV - Math.sqrt(kJ)) / (2 * kW); if (0 < kL && kL < 1) { if (jN == 0) { this.addX(kT(kL)) } if (jN == 1) { this.addY(kT(kL)) } } } }; this.isPointInBox = function (kD, kE) { return (this.x1 <= kD && kD <= this.x2 && this.y1 <= kE && kE <= this.y2) }; this.addPoint(i, kC); this.addPoint(e, T) }; function ft(i, e) { this.id = bG.getGUID("symbol_icon_"); this.size = (i instanceof jo) ? i : new jo(2, 2); this.anchor = (e instanceof jo) ? e : new jo(this.size.width / 2, this.size.height / 2); this.data = null; this.offset = this.anchor; this.imageSize = this.size; this.imageOffset = new jo(0, 0); this.style = { scale: 1, rotation: 0 }; this.srcSetObject = {}; this._initOptions = { size: this.size, scale: this.style.scale, rotation: this.style.rotation }; this.overlay = null; this.isReDraw = false } ft.prototype.add = function () { const e = document.createElement("canvas"); e.width = this.size.width; e.height = this.size.height; this.context = e.getContext("2d") }; ft.prototype.remove = function () { if (this.context) { this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height); this.context.canvas.width = 0; this.context.canvas.height = 0 } this.context = null; this.data = null }; ft.prototype.render = function (e) { return true }; ft.prototype.resetInitOptions = function () { this._initOptions = new jo(this.size.width, this.size.height); this._initOptions.scale = this.style.scale; this._initOptions.rotation = this.style.rotation }; ft.prototype.update = function () { var e = this.overlay; if (e) { if (e.domElement) { var kC = (this.style.scale - this._initOptions.scale) / this._initOptions.scale; if (kC >= 0) { kC = kC + 1 } else { kC = 1 + kC } var i = this._initOptions.rotation === 0 ? this.style.rotation : (this.style.rotation - this._initOptions.rotation); while (i < 0) { i += 360 } var T = e.domElement.style; T.width = this._initOptions.width + "px"; T.height = this._initOptions.height + "px"; T.transform = "rotate(" + i + "deg) scale(" + kC + ")" } if (!this.isReDraw) { this._refresh(e) } } }; ft.prototype._refresh = function (e) { e.textureCoord = e.textureCoordGLMap = null; var i = new fW("onstatus_change"); i.overlay = e; i.action = "setIcon"; i.imageUrlChanged = true; setTimeout(function () { e.fire(i) }, 100) }; ft.prototype.generateRenderData = function () { var i = this.offset = this.anchor; var e = this.size; var T = []; T.push(-i.width, i.height - e.height, 0); T.push(e.width - i.width, i.height - e.height, 0); T.push(e.width - i.width, i.height, 0); T.push(-i.width, i.height - e.height, 0); T.push(e.width - i.width, i.height, 0); T.push(-i.width, i.height, 0); return { vertex: T } }; ft.prototype.getCurrentImageUrl = function () { return this.id }; ft.prototype.getRenderData = function () { this._renderData = this.generateRenderData(); return this._renderData }; ft.prototype.toString = function () { return "Symbol" }; var fJ = { 14: "m-0.00573,-10c-5.51975,0 -9.99427,4.47453 -9.99427,9.99428c0,5.51974 4.47452,9.99425 9.99427,9.99425c5.51972,0 9.99426,-4.47452 9.99426,-9.99425c0,-5.51975 -4.47453,-9.99428 -9.99426,-9.99428zm0,17.92491c-4.37412,0 -7.93132,-3.55788 -7.93132,-7.93063c0,-4.37345 3.5572,-7.93134 7.93132,-7.93134c4.37411,0 7.93062,3.55721 7.93062,7.93134c0,4.37412 -3.55789,7.93063 -7.93062,7.93063zm-0.00068,-15.4088c-0.38027,0 -0.68696,0.30807 -0.68696,0.68765l0,6.34078l-4.15752,1.81815c-0.34794,0.15266 -0.50611,0.55837 -0.35344,0.90632c0.11278,0.25787 0.36445,0.4119 0.6292,0.4119c0.09214,0 0.18635,-0.01857 0.27575,-0.05845l4.55635,-1.99279c0.00344,-0.00137 0.00619,-0.00275 0.00894,-0.00412l0.00275,-0.00138c0.01032,-0.00413 0.01581,-0.01376 0.02545,-0.01719c0.07151,-0.03576 0.13821,-0.07771 0.19185,-0.1341c0.02337,-0.02338 0.03644,-0.05364 0.05431,-0.08045c0.03301,-0.04401 0.06946,-0.08733 0.0894,-0.14028c0.0165,-0.04126 0.01787,-0.08596 0.02613,-0.12997c0.00894,-0.04469 0.02614,-0.08389 0.02614,-0.1286l0,-6.7905c0,-0.37889 -0.30807,-0.68697 -0.68833,-0.68697z", 13: "m-0.00706,-9.5c-5.24281,0 -9.49294,4.25065 -9.49294,9.49294c0,5.24331 4.25014,9.49294 9.49294,9.49294c5.24281,0 9.49294,-4.24964 9.49294,-9.49294c0,-5.2423 -4.25013,-9.49294 -9.49294,-9.49294zm3.08857,3.85997c0.61044,0 1.10279,0.96873 1.10279,2.16271s-0.49384,2.1647 -1.10279,2.1647c-0.60844,0 -1.10228,-0.96873 -1.10228,-2.16372s0.49434,-2.16369 1.10228,-2.16369zm-6.28628,0c0.60844,0 1.10228,0.96873 1.10228,2.16271s-0.49284,2.1647 -1.10228,2.1647s-1.10277,-0.96873 -1.10277,-2.16372s0.49383,-2.16369 1.10277,-2.16369zm3.21167,12.16493c-1.87667,0 -3.63373,-1.14814 -5.14663,-3.14239c1.56571,1.02156 3.27993,1.59064 5.07786,1.59064c1.90905,0 3.72343,-0.63985 5.36539,-1.78497c-1.54429,2.11685 -3.35767,3.33672 -5.29662,3.33672l-0.00001,0z", 12: "m9.27295,5.92958l-2.64443,-4.57961c-0.79727,-1.37992 -2.10131,-3.63983 -2.8986,-5.01973l-2.64441,-4.57858c-0.79782,-1.38093 -2.10186,-1.38093 -2.89913,0l-2.64335,4.57858c-0.79728,1.3799 -2.10188,3.63981 -2.89916,5.01973l-2.64387,4.57961c-0.79728,1.38101 -0.14472,2.50988 1.44983,2.50988l16.37221,0c1.59561,0 2.24711,-1.12887 1.45091,-2.50988l0,0zm-8.88166,0.70811l-1.56837,0l0,-1.50484l1.56837,0l0,1.50484zm-0.07527,-2.61447l-1.41621,0l-0.14044,-6.44231l1.68427,0l-0.12761,6.44231l0,0z", 11: "m8.08295,-6.56414l-3.59319,0l0,-1.43586l-8.98155,0l0,1.43586l-3.59321,0c-1.0569,0 -1.915,0.85509 -1.915,1.91159l0,9.92258c0,1.05357 0.8581,1.91158 1.915,1.91158l16.16796,0c1.05692,0 1.91501,-0.85801 1.91501,-1.91158l0,-9.92258c0,-1.0565 -0.85809,-1.91159 -1.91501,-1.91159l0,0zm-8.08397,12.66884c-3.20143,0 -5.80643,-2.60031 -5.80643,-5.79596c0,-3.19569 2.605,-5.79891 5.80643,-5.79891s5.80789,2.60322 5.80789,5.79891c0,3.19565 -2.60794,5.79596 -5.80789,5.79596zm0,-9.6804c-2.15036,0 -3.89142,1.7394 -3.89142,3.88444c0,2.14503 1.74252,3.8844 3.89142,3.8844c2.1489,0 3.89141,-1.73937 3.89141,-3.8844c0,-2.14503 -1.74105,-3.88444 -3.89141,-3.88444z", 10: "m0,-10c-0.20885,0 -0.39491,0.08583 -0.55177,0.24149c-0.15674,0.15536 -0.28646,0.37838 -0.39429,0.65665c-0.21586,0.55655 -0.34853,1.33844 -0.42114,2.27477c-0.07231,0.93446 -0.08474,2.02273 -0.05447,3.18765c-2.58175,1.05925 -7.81787,3.24648 -8.23854,3.73474c-0.56001,0.65029 -0.37908,1.3954 -0.15331,1.89002l8.608,-1.75235c0.18202,2.28374 0.4407,4.5455 0.66615,6.31771c-0.8418,0.24646 -2.41323,0.73303 -2.73754,1.03474c-0.4469,0.41562 -0.4469,1.75793 -0.4469,1.75793l3.52318,-0.28665c0.08286,0.57874 0.13486,0.9163 0.13486,0.9163l0.00511,0.03042l0.02778,0l0.06486,0l0.02778,0l0.00511,-0.03042c0,0 0.05185,-0.33756 0.13486,-0.9163l3.52424,0.28665c0,0 0,-1.34231 -0.44688,-1.75793c-0.32446,-0.30172 -1.89697,-0.7895 -2.73847,-1.0358c0.22484,-1.76681 0.4832,-4.02001 0.66507,-6.29634l8.50712,1.73203c0.22561,-0.49462 0.40765,-1.23973 -0.15237,-1.89002c-0.41538,-0.48221 -5.52504,-2.62071 -8.1386,-3.69423c0.03119,-1.17999 0.01971,-2.28285 -0.05353,-3.22816l0,-0.00233c-0.07263,-0.93523 -0.20545,-1.71635 -0.42114,-2.27244c-0.10784,-0.27827 -0.23634,-0.50114 -0.3932,-0.65665c-0.15689,-0.15567 -0.34293,-0.24149 -0.55195,-0.24149l0,0l0,0l0,0l0.00001,0l0,0l-0.00003,0.00001z", 3: "m-10,0l10,-10l10,10l-10,10l-10,-10z", 5: "M0,0 L-5,-15 0,-10 5,-15 z", 6: "M0,0 L5,15 0,10 -5,15z", 7: "M-5,-15 L0,0 5,-15", 8: "M-5,15 L0,0 5,15", 9: "m0,-24c-4.4183,0 -8,3.58167 -8,8c0,1.42102 0.3816,2.75 1.0312,3.90601c0.1079,0.19202 0.221,0.38098 0.3438,0.56299l6.625,11.53101l6.625,-11.53101c0.102,-0.151 0.19,-0.31097 0.281,-0.46899l0.063,-0.09399c0.649,-1.15601 1.031,-2.48499 1.031,-3.90601c0,-4.41833 -3.582,-8 -8,-8zm0,4c2.209,0 4,1.79089 4,4c0,2.20898 -1.791,4 -4,4c-2.2091,0 -4,-1.79102 -4,-4c0,-2.20911 1.7909,-4 4,-4z" }; var cf = { BMap_Symbol_SHAPE_CIRCLE: 1, BMap_Symbol_SHAPE_RECTANGLE: 2, BMap_Symbol_SHAPE_RHOMBUS: 3, BMap_Symbol_SHAPE_STAR: 4, BMap_Symbol_SHAPE_BACKWARD_CLOSED_ARROW: 5, BMap_Symbol_SHAPE_FORWARD_CLOSED_ARROW: 6, BMap_Symbol_SHAPE_BACKWARD_OPEN_ARROW: 7, BMap_Symbol_SHAPE_FORWARD_OPEN_ARROW: 8, BMap_Symbol_SHAPE_POINT: 9, BMap_Symbol_SHAPE_PLANE: 10, BMap_Symbol_SHAPE_CAMERA: 11, BMap_Symbol_SHAPE_WARNING: 12, BMap_Symbol_SHAPE_SMILE: 13, BMap_Symbol_SHAPE_CLOCK: 14 }; function dU(i, e) { ft.call(this); e = e || {}; this.style = { anchor: e.anchor || new jo(0, 0), fillColor: e.fillColor || "#000", fillOpacity: e.fillOpacity || 0, scale: e.scale || 1, rotation: e.rotation || 0, strokeColor: e.strokeColor || "#000", strokeOpacity: e.strokeOpacity === undefined ? 1 : e.strokeOpacity, strokeWeight: e.strokeWeight }; this._type = (typeof i === "number") ? i : "UserDefined"; this._anchor = this.style.anchor; this._originOffset = new jo(0, 0); this.anchor = new jo(0, 0); this._rawPath = i; this._buildPath(true) } dU.inherits(ft, "SVGSymbol"); dU.generateKey = function (kC, i) { if (!kC) { return null } if (parseInt(kC)) { kC = parseInt(kC) } if (typeof kC === "number") { if (!fJ[kC] && ![0, 1, 2, 0, 4][kC]) { return null } } var e = { anchor: i.anchor || new jo(0, 0), fillColor: i.fillColor || "#000", fillOpacity: i.fillOpacity || 0, scale: i.scale || 1, rotation: i.rotation || 0, strokeColor: i.strokeColor || "#000", strokeOpacity: i.strokeOpacity === undefined ? 1 : i.strokeOpacity, strokeWeight: i.strokeWeight }; var T = q({ path: kC, style: e }); return "symbol_svg_icon_" + T }; e9.extend(dU.prototype, { _buildPath: function (kN) { var kH = this; var kJ = kH._rawPath; if (parseInt(kJ)) { kJ = parseInt(kJ) } if (fJ[kJ]) { kJ = fJ[kJ] } kH.id = dU.generateKey(kJ, kH.style); if (!kH.id) { return } switch (kJ) { case cf.BMap_Symbol_SHAPE_CIRCLE: var kK = kH._calSize(2), kI = kK, kS = kH.style.scale, kD = kH._anchor; this.size = new jo(kK, kI); this.anchor = new jo(kK / 2 + kD.width * kS, kI / 2 + kD.height * kS); kH.path = cf.BMap_Symbol_SHAPE_CIRCLE; break; case cf.BMap_Symbol_SHAPE_RECTANGLE: var kK = kH._calSize(4), kI = kH._calSize(2), kD = kH._anchor, kP = kH.style.strokeWeight !== undefined ? kH.style.strokeWeight : kH.style.scale, kS = kH.style.scale; this.size = new jo(kK, kI); this._originOffset = new jo(Math.floor(-kP / 2), Math.floor(-kP / 2)); this.anchor = new jo(kK / 2 + kD.width * kS, kI / 2 + kD.height * kS); kH.path = cf.BMap_Symbol_SHAPE_RECTANGLE; break; case cf.BMap_Symbol_SHAPE_STAR: var kK = kH._calSize(20), kI = kK, kD = kH._anchor, kS = kH.style.scale; this.size = new jo(kK, kI); this.anchor = new jo(kK / 2 + kD.width * kS, kI / 2 + kD.height * kS); kH.path = cf.BMap_Symbol_SHAPE_STAR; break; default: var kJ = new dS(kJ), kC = kJ.bounds(), kM = kH.style.rotation * Math.PI / 180, kP = kH.style.strokeWeight !== undefined ? kH.style.strokeWeight : kH.style.scale, kS = kH.style.scale, kD = kH._anchor; var kR = new jo(Math.floor(kC.x1 * kS - kP / 2), Math.floor(kC.y1 * kS - kP / 2)), e = { topleft: new fv(Math.floor(kC.x1 * kS - kP / 2) - kS * kD.width, Math.floor(kC.y1 * kS - kP / 2) - kS * kD.height), bottomleft: new fv(Math.floor(kC.x1 * kS - kP / 2) - kS * kD.width, Math.ceil(kC.y2 * kS - kP / 2) - kS * kD.height), topright: new fv(Math.ceil(kC.x2 * kS + kP / 2) - kS * kD.width, Math.floor(kC.y1 * kS - kP / 2) - kS * kD.height), bottomright: new fv(Math.ceil(kC.x2 * kS + kP / 2) - kS * kD.width, Math.ceil(kC.y2 * kS + kP / 2) - kS * kD.height) }, i = {}, kQ = [], kG = []; var kO = e.topleft.x === 0 ? 0 : Math.atan(e.topleft.y / e.topleft.x), T = kO + kM; for (var kL in e) { var kF = Math.cos(kM) * e[kL].x - Math.sin(kM) * e[kL].y, kE = Math.sin(kM) * e[kL].x + Math.cos(kM) * e[kL].y; i[kL] = new fv(kF, kE); kQ.push(kF); kG.push(kE) } xmax = Math.max.apply(Math, kQ), ymax = Math.max.apply(Math, kG), xmin = Math.min.apply(Math, kQ), ymin = Math.min.apply(Math, kG); this.size = new jo(Math.ceil(xmax - xmin), Math.ceil(ymax - ymin)); this.anchor = new jo(-xmin, -ymin); this._originOffset = new jo(xmin - i.topleft.x, ymin - i.topleft.y); this._innerOffset = new fv(kR.width, kR.height); this._rotationAngle = kM; kH.path = kJ; break }this.imageSize = new jo(this.size.width, this.size.height); this.offset = this.anchor; if (kN) { this.resetInitOptions() } }, _calSize: function (e) { if (this.style.strokeWeight) { return e * this.style.scale + this.style.strokeWeight % 3 + this.style.strokeWeight } else { return e * this.style.scale + this.style.scale + this.style.scale % 2 } }, render: function (T) { var kI = this, kC = this.style.scale, kJ, kK = this.size; if (this.context) { kJ = this.context; if (this.context.canvas.width / 2 !== this.size.width || this.context.canvas.height / 2 !== this.size.height) { this.context.canvas.width = this.size.width * 2; this.context.canvas.height = this.size.height * 2 } kJ.clearRect(0, 0, this.size.width * 2, this.size.height * 2); kJ.fillStyle = hW.convert2rgba(kI.style.fillColor, kI.style.fillOpacity); kJ.strokeStyle = hW.convert2rgba(kI.style.strokeColor, kI.style.strokeOpacity); kJ.save() } else { return false } kJ.scale(2, 2); kJ.lineCap = "round"; kJ.lineJoin = "round"; kJ.lineWidth = kI.style.strokeWeight || kC; if (kI._originOffset) { kJ.translate(-kI._originOffset.width, -kI._originOffset.height) } if (kI._rotationAngle) { kJ.rotate(kI._rotationAngle) } if (kI._innerOffset) { kJ.translate(-kI._innerOffset.x, -kI._innerOffset.y) } switch (kI.path) { case cf.BMap_Symbol_SHAPE_CIRCLE: kJ.arc(kK.width / 2, kK.height / 2, kC, 0, 2 * Math.PI); break; case cf.BMap_Symbol_SHAPE_RECTANGLE: kJ.rect(0, 0, 4 * kC, 2 * kC); break; case cf.BMap_Symbol_SHAPE_STAR: kJ.beginPath(); var kE = kK.width / 2, kG = kC * 10; var kD = (2 * Math.PI) / 10; for (var kF = 11; kF != 0; kF--) { var e = kG * (kF % 2 + 1) / 2; var kH = kD * kF; kJ.lineTo((e * Math.sin(kH)) + kE, (e * Math.cos(kH)) + kE) } kJ.closePath(); break; default: kJ.lineWidth = kJ.lineWidth / kC; kJ.scale(kC, kC); kI.path.draw(kJ) }kJ.fill(); kJ.stroke(); kJ.restore(); this.data = kJ.getImageData(0, 0, this.size.width * 2, this.size.height * 2); return true }, setPath: function (e) { this._rawPath = e; this._buildPath(); this.update() }, setAnchor: function (e) { this._anchor = this.style.anchor = e; this._buildPath(); this.update() }, setRotation: function (e) { this.style.rotation = e; this._buildPath(); this.update() }, setScale: function (e) { this.style.scale = e; this._buildPath(); this.update() }, setStrokeWeight: function (e) { this.style.strokeWeight = e; this._buildPath(); this.update() }, setStrokeColor: function (e) { e = hW.convert2rgba(e, this.style.strokeOpacity); this.style.strokeColor = e; this._buildPath(); this.update() }, setStrokeOpacity: function (e) { this.style.strokeOpacity = e; this._buildPath(); this.update() }, setFillOpacity: function (e) { this.style.fillOpacity = e; this._buildPath(); this.update() }, setFillColor: function (e) { this.style.fillColor = e; this._buildPath(); this.update() } }); bG.SymbolShapeType = cf; function jS(kE, kC, T) { if (!kE || !kC) { return } this.imageUrl = null; this.imageDom = null; if (typeof kE === "string") { this.imageUrl = kE } else { this.imageDom = kE; if (!this.imageDom.id) { this.imageDom.id = bG.getGUID("icon_dom_") } } this.size = kC; var kD = new jo(Math.floor(kC.width / 2), Math.floor(kC.height / 2)); var i = { offset: kD, imageOffset: new jo(0, 0) }; T = T || {}; for (var e in T) { i[e] = T[e] } if (T.anchor) { i.offset = T.anchor } this.anchor = this.offset = i.offset; this.imageOffset = i.imageOffset; this.infoWindowOffset = T.infoWindowOffset || this.offset; this.printImageUrl = T.printImageUrl || ""; this.imageSize = T.imageSize || this.size; this.srcSetObject = {}; this.setImageSrcset(T.srcset || T.srcSet) } jS.prototype.setImageUrl = function (e) { if (!e) { return } this.imageUrl = e; this._renderData = null }; jS.prototype.getCurrentImageUrl = function () { if (window.devicePixelRatio > 1 && this.srcSetObject["2x"]) { return this.srcSetObject["2x"] } return this.imageUrl }; jS.prototype.setPrintImageUrl = function (e) { if (!e) { return } this.printImageUrl = e }; jS.prototype.setSize = function (e) { if (!e) { return } this.size = new jo(e.width, e.height); this._renderData = null }; jS.prototype.setOffset = function (e) { if (!e) { return } this.anchor = this.offset = new jo(e.width, e.height); this._renderData = null }; jS.prototype.setAnchor = function (e) { this.setOffset(e) }; jS.prototype.setImageOffset = function (e) { if (!e) { return } this.imageOffset = new jo(e.width, e.height); this._renderData = null }; jS.prototype.setInfoWindowOffset = function (e) { if (!e) { return } this.infoWindowOffset = new jo(e.width, e.height) }; jS.prototype.setImageSize = function (e) { if (!e) { return } this.imageSize = new jo(e.width, e.height) }; jS.prototype.setImageSrcset = function (T) { var e = ""; if (!T) { return } for (var i in T) { if (T.hasOwnProperty(i)) { this.srcSetObject[i] = T[i]; e = T[i] + " " + i + "," } } this.srcSet = e }; jS.prototype.toString = function () { return "Icon" }; jS.prototype.generateRenderData = function (kE) { var T = this.offset; var e = this.size; var kG = this.imageOffset; var kF = []; kF.push(-T.width, T.height - e.height, 0); kF.push(e.width - T.width, T.height - e.height, 0); kF.push(e.width - T.width, T.height, 0); kF.push(-T.width, T.height - e.height, 0); kF.push(e.width - T.width, T.height, 0); kF.push(-T.width, T.height, 0); if (kE !== 0) { for (var kD = 0; kD < kF.length; kD += 3) { var kC = vec2.fromValues(kF[kD], kF[kD + 1]); vec2.rotate(kC, kC, [0, 0], iX(-kE)); kF[kD] = kC[0]; kF[kD + 1] = kC[1] } } return { vertex: kF } }; jS.prototype.getRenderData = function (e) { this._renderData = this.generateRenderData(e); return this._renderData }; function ef(T, i) { e9.BaseClass.call(this); this.content = T; this.map = null; this._config = { width: 0, height: 0, maxWidth: 600, offset: new jo(0, 0), title: "", maxContent: "", enableMaximize: false, enableAutoPan: true, enableCloseOnClick: true, margin: [10, 10, 40, 10], collisions: [[10, 10], [10, 10], [10, 10], [10, 10]], ifMaxScene: false, canScroll: false, onClosing: function () { return true } }; this.setConfig(i); if (this._config.width !== 0) { if (this._config.width < 220) { this._config.width = 220 } if (this._config.width > 730) { this._config.width = 730 } } if (this._config.height !== 0) { if (this._config.height < 60) { this._config.height = 60 } if (this._config.height > 650) { this._config.height = 650 } } if (this._config.maxWidth !== 0) { if (this._config.maxWidth < 220) { this._config.maxWidth = 220 } if (this._config.maxWidth > 730) { this._config.maxWidth = 730 } } this.isWinMax = false; this.IMG_PATH = E.imgPath; this.overlay = null; hQ.sendMessage(a1(4, 2, 10), ["overlay", "infowindow"]); var e = this; hm.load("infowindow", function () { e._draw() }) } ef.inherits(e9.BaseClass, "InfoWindow"); e9.extend(ef.prototype, { setWidth: function (e) { e = e * 1; if (!e && e !== 0 || isNaN(e) || e < 0) { return } if (e !== 0) { if (e < 220) { e = 220 } if (e > 730) { e = 730 } } this._config.width = e }, setHeight: function (e) { e = e * 1; if (!e && e !== 0 || isNaN(e) || e < 0) { return } if (e !== 0) { if (e < 60) { e = 60 } if (e > 650) { e = 650 } } this._config.height = e }, setMaxWidth: function (e) { e = e * 1; if (!e && e !== 0 || isNaN(e) || e < 0) { return } if (e !== 0) { if (e < 220) { e = 220 } if (e > 730) { e = 730 } } this._config.maxWidth = e }, setTitle: function (e) { this._config.title = e || "" }, setContent: function (e) { this.content = e || "" }, getContent: function () { return this.content }, setMaxContent: function (e) { this._config.maxContent = e || "" }, redraw: function () { }, enableAutoPan: function () { this._config.enableAutoPan = true }, disableAutoPan: function () { this._config.enableAutoPan = false }, enableCloseOnClick: function () { this._config.enableCloseOnClick = true }, disableCloseOnClick: function () { this._config.enableCloseOnClick = false }, enableMaximize: function () { this._config.enableMaximize = true }, disableMaximize: function () { this._config.enableMaximize = false }, show: function () { this._visible = true }, hide: function () { this._visible = false }, close: function () { this.hide() }, dispose: function () { e9.BaseClass.prototype.decontrol.call(this) }, maximize: function () { this.isWinMax = true }, restore: function () { this.isWinMax = false }, setConfig: function (i) { if (!i) { return } for (var e in i) { if (typeof (this._config[e]) === typeof (i[e])) { this._config[e] = i[e] } } }, isVisible: function () { return this.isOpen() }, isOpen: function () { return false }, getPointIn: function () { if (this.overlay && this.overlay.getPoint) { return this.overlay.getPoint() } }, getTitle: function () { return this._config.title || "" }, getPosition: function () { return this.latLng }, getPoint: function () { var e = this.getPointIn(); return js(jy.convertMC2LL(e), this.map.config.coordType) }, getOffset: function () { return this._config.offset }, dispose: function () { e9.BaseClass.prototype.decontrol.call(this) }, toString: function () { return "InfoWindow" } }); h5.prototype.openInfoWindow = function (kE, e, kC) { var kD = e; var T = (kC && kC.coordType) || BMapGL.coordType; kD = gb(kD, T); kE.latLng = new cA(kD.lat, kD.lng); var i = jy.convertLL2MC(kD); this.openInfoWindowIn(kE, i) }; h5.prototype.closeInfoWindow = function () { var e = this.temp.infoWin || this.temp._infoWin; if (e && e.overlay) { e.overlay.closeInfoWindow() } }; h5.prototype.openInfoWindowIn = function (kC, e) { if (!kC || kC.toString() !== "InfoWindow" || !e || e.toString() !== "Point") { return } var i = this.temp; if (!i.marker) { var T = new jS(E.imgPath + "blank.gif", { width: 1, height: 1 }); i.marker = new ke(e, { icon: T, width: 1, height: 1, offset: new jo(0, 0), infoWindowOffset: new jo(0, 0), clickable: false }); i.marker._fromMap = 1 } else { i.marker.setPoint(e) } this.addOverlay(i.marker); i.marker.show(); i.marker.openInfoWindow(kC) }; eM.prototype.openInfoWindow = function (e) { if (this.map) { this.map.closeInfoWindow(); e._visible = true; this.map.temp._infoWin = e; e.overlay = this; e9.BaseClass.call(e, e.hashCode) } }; eM.prototype.closeInfoWindow = function () { if (this.map && this.map.temp._infoWin) { this.map.temp._infoWin._visible = false; this.map.temp._infoWin.decontrol(); this.map.temp._infoWin = null } }; function bm(T, i) { eM.call(this); this.content = T; this.map = null; this.domElement = null; this._config = { width: 0, offset: new jo(0, 0), styles: { backgroundColor: "#fff", border: "1px solid #f00", padding: "1px", whiteSpace: "nowrap", fontSize: "12px", zIndex: "80", MozUserSelect: "none" }, point: null, enableMassClear: true }; i = i || {}; this.setConfig(i); if (this._config.width < 0) { this._config.width = 0 } this.point = this._config.point; hQ.sendMessage(a1(4, 2, 6), ["overlay", "dom_label"]); var e = this; hm.load("marker", function () { e._draw() }) } bm.inherits(eM, "Label"); e9.extend(bm.prototype, { setPoint: function (e) { if (e && e.toString() === "Point" && !this.getMarker()) { this.point = this._config.point = gb(e, this.coordType) } }, setContent: function (e) { this.content = e }, getContent: function (e) { return this.content }, setOpacity: function (e) { if (e >= 0 && e <= 1) { this._config.opacity = e } }, setOffset: function (e) { if (!e || e.toString() !== "Size") { return } this._config.offset = new jo(e.width, e.height) }, getOffset: function () { return this._config.offset }, setStyle: function (e) { e = e || {}; this._config.styles = e9.extend(this._config.styles, e) }, setStyles: function (e) { this.setStyle(e) }, setTitle: function (e) { this._config.title = e || "" }, getTitle: function () { return this._config.title }, setMarker: function (e) { if (this._marker && this._marker !== e) { this._marker._config.label = null } this._marker = e; if (e) { this.point = this._config.point = e.getPoint() } else { this.point = this._config.point = null } }, getMarker: function () { return this._marker || null }, getPositionIn: function () { return this.getPoint() }, }); function ic(T, i) { var kC = {}; for (var e in i) { if (i.hasOwnProperty(e)) { if (e === "position") { kC.point = jy.convertLL2MC(gb(i[e], BMapGL.coordType)); this.latLng = gb(i[e], BMapGL.coordType) } else { kC[e] = i[e] } } } bm.call(this, T, kC) } ic.inherits(bm, "LabelOut"); e9.extend(ic.prototype, { toString: function () { return "Label" }, setPosition: function (e) { this.latLng = new cA(e.lat, e.lng); var i = jy.convertLL2MC(e); this.setPoint(i) }, getPosition: function () { return js(this.latLng, this.coordType) } }); window.BMAP_ANIMATION_DROP = 1; window.BMAP_ANIMATION_BOUNCE = 2; function ke(e, i) { eM.call(this); i = i || {}; this.delFlag = i.delFlag; this.coordType = i.coordType || BMapGL.coordType; this.point = e; this._rotation = i.rotation || 0; this._rotationOrigin = 0; this.map = null; this._animation = null; this.domElement = null; this.iconDom = null; this.infoWindowDom = null; this.siblingElement = null; this.textureCoord = null; this.textureCoordGLMap = null; this.collisionDetectionFailed = false; this._config = { offset: new jo(0, 0), opacity: 1, icon: null, title: "", infoWindow: null, label: null, zIndex: null, baseZIndex: 0, clickable: true, zIndexFixed: false, isTop: false, enableMassClear: true, enableDragging: false, raiseOnDrag: false, restrictDraggingArea: false, startAnimation: "", enableCollisionDetection: false, rank: 0, enableDraggingMap: false, autoFollowHeadingChanged: false }; this.setOptions(i); if (this._config.zIndex !== undefined) { this.zIndex = this._config.zIndex } this._addlog(); this._isDragging = false; var T = this; hm.load("marker", function () { T._draw() }) } ke.TOP_ZINDEX = aU.getZIndex(-90) + 1000000; ke.DRAG_ZINDEX = ke.TOP_ZINDEX + 1000000; ke._injectMethond = function (e) { e9.extend(ke.prototype, e) }; ke.inherits(eM, "Marker"); e9.extend(ke.prototype, { toString: function () { return "Marker" }, _addlog: function () { var e = 1; var i = "normal"; if (this._config.icon instanceof dU) { e = 2; i = "svg_symbol" } else { if (this._config.icon instanceof ft) { e = 3; i = "custom_symbol" } } hQ.sendMessage(a1(4, 2, 1, e), ["overlay", "marker", i]) }, setOptions: function (e) { this.setConfig(e); if (!e.icon) { this._config.icon = new jS(E.imgPath + "marker_red.png", new jo(23, 25), { offset: new jo(10, 25), infoWindowOffset: new jo(10, 0) }) } }, setIcon: function (e) { if (e) { this._config.icon = e; this.textureCoord = this.textureCoordGLMap = null } }, getIcon: function () { return this._config.icon }, setLabel: function (e) { if (!(e instanceof bm)) { return } this._config.label = e; e._config.enableMassClear = this._config.enableMassClear; e.setPoint(this.point) }, getLabel: function () { return this._config.label }, enableDragging: function () { this._config.enableDragging = true }, disableDragging: function () { this._config.enableDragging = false }, setPoint: function (e) { if (e) { this.point = this._config.point = new cG(e.lng, e.lat); this.latLng = js(jy.convertMC2LL(e), BMapGL.coordType) } }, setPositionIn: function (e) { this.setPoint(e) }, getPositionIn: function () { return this.getPoint() }, setTop: function (i, e) { this._config.isTop = !!i; if (i) { this._addi = e || 0 } }, setTitle: function (e) { this._config.title = e || "" }, getTitle: function () { return b(this._config.title) }, setOffset: function (e) { if (e) { this._config.offset = e } }, getOffset: function () { return this._config.offset }, setAnimation: function (e) { this._animation = e }, setRank: function (e) { this._config.rank = e }, getRank: function () { return this._config.rank }, setRotation: function (e) { while (e < 0) { e += 360 } this._rotation = e % 360 }, setRotationOrigin: function (e) { while (e < 0) { e += 360 } this._rotationOrigin = e % 360 }, getRotation: function () { return this._rotation } }); function u(e, kC) { var i = BMapGL.coordType; if (kC && kC.coordType) { i = kC.coordType } var kD = gb(e, i); this.latLng = new cA(kD.lat, kD.lng); var T = jy.convertLL2MC(kD); ke.call(this, T, kC) } u.inherits(ke, "MarkerOut"); e9.extend(u.prototype, { toString: function () { return "Marker" }, toGeoJSON: function () { var i = "Point"; var T = [this.latLng.lng, this.latLng.lat]; var e = { type: "Feature", geometry: { type: i, coordinates: T }, properties: this.properties }; return e }, updateByGeoJSON: function (T) { var e = new gO(); var kE = e.readFeaturesFromObject(T) || []; for (var kC = 0, kD = kE.length; kC < kD; ++kC) { if (kE[kC] instanceof u) { this.properties = kE[kC].properties; this.setPosition(kE[kC].getPosition()); break } } }, setPosition: function (e) { this.latLng = gb(new cA(e.lat, e.lng), this.coordType); var i = jy.convertLL2MC(this.latLng); this.setPositionIn(i) }, getPosition: function () { return js(this.latLng, this.coordType) }, }); window.BMAP_SHAPE_CIRCLE = 1; window.BMAP_SHAPE_RECT = 2; function er(i, e, T) { eM.call(this, e, T); this.domElement = null; this.point = i; T = T || {}; this._config = {}; this._config.height = e || 0; this._config.size = typeof T.size === "number" ? T.size : 50; this._config.fillOpacity = typeof T.fillOpacity === "number" ? T.fillOpacity : 0.8; this._config.shape = typeof T.shape === "number" ? T.shape : 1; ck(this._config.fillOpacity, 0, 1); if (T.fillColor === "") { this._config.fillColor = "" } else { this._config.fillColor = T.fillColor ? T.fillColor : "#f00" } this._config.icon = (T.icon instanceof jS || T.icon instanceof ft) ? T.icon : ""; this._config.enableMassClear = T.enableMassClear || true; hQ.sendMessage(a1(4, 2, 2), ["overlay", "marker3d"]); var kC = this; hm.load("marker", function () { kC._draw() }) } er.inherits(eM, "Marker3D"); e9.extend(er.prototype, { setPoint: function (e) { var i = this.map.config.coordType; var kC = gb(e, i); this.latLng = this._config.point = new cG(kC.lng, kC.lat); this.point = jy.convertLL2MC(kC); var T = new fW("onstatus_change"); T.overlay = this; T.action = "setPoint"; this.fire(T) }, setPositionIn: function (e) { this.setPoint(e) }, getPositionIn: function () { return this.getPoint() }, setDomAttribute: function (i, T) { var e = new fW("onlineupdate"); e.overlay = this; this.dispatchEvent(e) } }); function eo(i, e, kC) { this.latLng = gb(new cA(i.lat, i.lng), BMapGL.coordType); var T = jy.convertLL2MC(i); er.call(this, T, e, kC) } eo.inherits(er, "Marker3d"); e9.extend(eo.prototype, { toString: function () { return "Marker3D" }, setHeight: function (e) { this._config.height = Number(e); this.draw(); var i = new fW("onlineupdate"); i.overlay = this; this.dispatchEvent(i) }, getHeight: function () { return this._config.height }, setFillOpacity: function (e) { if (e > 1 || e < 0) { return } this._config.fillOpacity = e; this.setDomAttribute("fillopacity", e) }, getFillOpacity: function () { return this._config.fillOpacity }, setFillColor: function (e) { this._config.fillColor = e || ""; this.setDomAttribute("fillcolor", e) }, getFillColor: function () { return this._config.fillColor }, setIcon: function (i) { if (!i || !this.map) { return } this._config.icon = i; if (this._config.icon) { var e = this._config.icon.getCurrentImageUrl(); var kC = i.getCurrentImageUrl() !== e; this._config.icon = i; this.textureCoord = this.textureCoordGLMap = null; this.draw(); var T = new fW("onstatus_change"); T.overlay = this; T.action = "setIcon"; T.imageUrlChanged = kC; this.fire(T) } }, getIcon: function () { return this._config.icon }, setPosition: function (e) { this.latLng = new cA(e.lat, e.lng); var i = jy.convertLL2MC(e); this.setPositionIn(i) }, getPosition: function () { var e = this.getPositionIn(); return js(jy.convertMC2LL(e), BMapGL.coordType) } }); function f8(T, e) { iV.call(this, e); this._normalizedBounds = new ik(); this.setPoints(T); this._addlog(e); var i = this; hm.load("poly", function () { i._draw() }) } f8.inherits(iV, "Polyline"); e9.extend(f8.prototype, { _addlog: function (e) { var i = 1; var T = "normal"; if (e && e.strokeTexture) { i = 2; T = "texture" } hQ.sendMessage(a1(4, 2, 3, i), ["overlay", "polyline", T]) }, getBoundsIn: function (e) { if (!e) { this._bounds.setMinMax(); return this._bounds } this._normalizedBounds.setMinMax(); return this._normalizedBounds }, setPoints: function (kF) { this._clearCache(); this.points = iV.getGraphPoints(kF).slice(0); if (this._config.geodesic === true) { this.greatCirclePoints.length = 0; for (var kD = 0; kD < this.points.length - 1; kD++) { this.calcGreatCirclePoints(this.points[kD], this.points[kD + 1]) } } else { if (this._config.linkRight) { var kG = []; var kE = null; for (var kD = 0; kD < this.points.length - 1; kD++) { if (!kD) { kG.push(this.points[kD]) } var T = kE || this.points[kD]; kE = this.points[kD + 1]; var kC = eF(kE, T); if (kC > 15437726) { if (kE.lng < T.lng) { kE.lng += h5.WORLD_SIZE_MC } else { kE.lng -= h5.WORLD_SIZE_MC } } kG.push(kE) } this.points = kG } } this._calcBounds(); this.draw(); var e = new fW("onlineupdate"); e.overlay = this; this.dispatchEvent(e); if (this._visible && this._config.enableEditing === true && !this._config.geodesic) { this.clearVertexs && this.clearVertexs(); this.addVertexs && this.addVertexs() } }, _calcBounds: function () { if (!this.points) { return } var e = this; e._bounds.setNorthEast(null); e._bounds.setSouthWest(null); if (e.greatCirclePoints && e.greatCirclePoints.length > 0) { e9.each(e.greatCirclePoints, function (i) { e._bounds.extend(i) }) } else { e9.each(e.points, function (i) { e._bounds.extend(i) }) } e._normalizedBounds.setSouthWest(e._bounds.getSouthWest()); e._normalizedBounds.setNorthEast(e._bounds.getNorthEast()); if (e._normalizedBounds.sw.lng < -h5.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > h5.WORLD_SIZE_MC_HALF) { e._normalizedBounds.sw.lng = -h5.WORLD_SIZE_MC_HALF; e._normalizedBounds.ne.lng = h5.WORLD_SIZE_MC_HALF } }, calcGreatCirclePoints: function (kC, T) { var kE = kC.latLng; var kD = T.latLng; if (kE.equals(kD)) { return } var e = jy.getDistance(iX(kE.lng), iX(kE.lat), iX(kD.lng), iX(kD.lat)); if (e < 250000) { return } var kI = Math.round(e / 150000); var kM = this.calcAngularDistance(kE, kD); this.greatCirclePoints.push(kC); var kL = kE.lng; var kK = kC; for (var kF = 0; kF < kI; kF++) { var kH = this.calcMiddlePoint(kE, kD, kF / kI, kM); var kJ = jy.convertLL2MC(kH); var kG = kJ.lng; var kN = eF(kJ, kK); if (kN > 30037726) { if (kJ.lng < kK.lng) { kJ.lng += h5.WORLD_SIZE_MC } else { kJ.lng -= h5.WORLD_SIZE_MC } } this.greatCirclePoints.push(kJ); kK = kJ } var kN = eF(T, kK); if (kN > 30037726) { if (T.lng < kK.lng) { T.lng += h5.WORLD_SIZE_MC } else { T.lng -= h5.WORLD_SIZE_MC } } this.greatCirclePoints.push(T) }, calcMiddlePoint: function (kJ, kI, kK, kO) { var kD = kJ.lat; var kC = kI.lat; var kN = kJ.lng; var kL = kI.lng; var kP = iX(kD); var kM = iX(kC); var i = iX(kN); var e = iX(kL); var kR = Math.sin((1 - kK) * kO) / Math.sin(kO); var kQ = Math.sin(kK * kO) / Math.sin(kO); var kG = kR * Math.cos(kP) * Math.cos(i) + kQ * Math.cos(kM) * Math.cos(e); var kF = kR * Math.cos(kP) * Math.sin(i) + kQ * Math.cos(kM) * Math.sin(e); var kE = kR * Math.sin(kP) + kQ * Math.sin(kM); var T = Math.atan2(kE, Math.sqrt(Math.pow(kG, 2) + Math.pow(kF, 2))); var kH = Math.atan2(kF, kG); return new cG(fl(kH), fl(T)) }, calcAngularDistance: function (kD, i) { var kE = iX(kD.lat); var kC = iX(i.lat); var T = iX(kD.lng); var e = iX(i.lng); return Math.acos(Math.sin(kE) * Math.sin(kC) + Math.cos(kE) * Math.cos(kC) * Math.cos(Math.abs(e - T))) } }); function bu(kD, e) { if (!kD || kD.length === 0) { return } var kC = []; if (e && e.noCoordTrans) { for (var T = 0; T < kD.length; T++) { kC[T] = jy.convertLL2MC(kD[T]) } } else { for (var T = 0; T < kD.length; T++) { kC[T] = jy.convertLL2MC(gb(kD[T], BMapGL.coordType)) } } f8.call(this, kC, e) } bu.inherits(f8, "PolylineOut"); e9.extend(bu.prototype, { toString: function () { return "Polyline" }, toGeoJSON: function () { var kC = "LineString"; var kD = []; var kE = this.getPath(); for (var T = 0; T < kE.length; T++) { kD.push([kE[T].lng, kE[T].lat]) } var e = { type: "Feature", geometry: { type: kC, coordinates: kD }, properties: this.properties }; return e }, updateByGeoJSON: function (T) { var e = new gO(); var kE = e.readFeaturesFromObject(T) || []; for (var kC = 0, kD = kE.length; kC < kD; ++kC) { if (kE[kC] instanceof bu) { this.properties = kE[kC].properties; this.setPath(kE[kC].getPath()); break } } }, setPath: function (kC) { if (!kC || kC.length === 0) { return } var T = []; for (var e = 0; e < kC.length; e++) { T[e] = jy.convertLL2MC(gb(kC[e], BMapGL.coordType)) } this.setPathIn(T); this._mouseEventPixels = null }, getPath: function () { var e = this.getPathIn(); if (!e || e.length === 0) { return [] } var kC = []; for (var T = 0; T < e.length; T++) { kC[T] = js(jy.convertMC2LL(e[T]), BMapGL.coordType) } return kC }, getBounds: function (i) { var e = this.getBoundsIn(i); var T = new ik(js(jy.convertMC2LL(e.getSouthWest()), BMapGL.coordType), js(jy.convertMC2LL(e.getNorthEast(), BMapGL.coordType))); return T } }); function g8(T, kC, e) { iV.call(this, e); this._normalizedBounds = new ik(); this._cps = kC; this._path = T; this.setPoints(T); hQ.sendMessage(a1(4, 2, 7), ["overlay", "bezier"]); var i = this; hm.load("poly", function () { i._draw() }) } g8.inherits(f8, "BezierCurve"); e9.extend(g8.prototype, { getBoundsIn: function (e) { if (!e) { this._bounds.setMinMax(); return this._bounds } this._normalizedBounds.setMinMax(); return this._normalizedBounds }, setPoints: function (e) { this._clearCache(); this.points = iV.getGraphPoints(e).slice(0); this.points = this.calcBezierPoints(this.points, this._cps); this._calcBounds() }, _calcBounds: function () { if (!this.points) { return } var e = this; e._bounds.setNorthEast(null); e._bounds.setSouthWest(null); if (e.greatCirclePoints && e.greatCirclePoints.length > 0) { e9.each(e.greatCirclePoints, function (i) { e._bounds.extend(i) }) } else { e9.each(e.points, function (i) { e._bounds.extend(i) }) } e._normalizedBounds.setSouthWest(e._bounds.getSouthWest()); e._normalizedBounds.setNorthEast(e._bounds.getNorthEast()); if (e._normalizedBounds.sw.lng < -h5.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > h5.WORLD_SIZE_MC_HALF) { e._normalizedBounds.sw.lng = -h5.WORLD_SIZE_MC_HALF; e._normalizedBounds.ne.lng = h5.WORLD_SIZE_MC_HALF } }, getPathIn: function () { return this._path }, setPathIn: function (e) { this._path = e; this.setPoints(e) }, getCpsIn: function () { return this._cps }, setCpsIn: function (e) { this._cps = e; this.setPoints(this._path) }, calcBezierPoints: function (kC, kE) { var T = []; for (var e = 0; e < kC.length - 1; e++) { var kD = [kC[e], kE[e][0], kE[e][1], kC[e + 1]]; T = T.concat((this.bezierbetweenTwoP(kD))) } return T }, bezierbetweenTwoP: function (kE) { var T = 100; var kD = 1 / T; var e = []; for (var kC = 0; kC < T; kC++) { e.push(this.getPointOnCubicBezier(kE, kC * kD)) } return e }, getPointOnCubicBezier: function (kF, kJ) { var i; var kE; var kC; var kK; var kD; var T; var kI; var e; var kH; var kG; kC = 3 * (kF[1].lng - kF[0].lng); kE = 3 * (kF[2].lng - kF[1].lng) - kC; i = kF[3].lng - kF[0].lng - kC - kE; T = 3 * (kF[1].lat - kF[0].lat); kD = 3 * (kF[2].lat - kF[1].lat) - T; kK = kF[3].lat - kF[0].lat - T - kD; kI = kJ * kJ; e = kI * kJ; kH = (i * e) + (kE * kI) + (kC * kJ) + kF[0].lng; kG = (kK * e) + (kD * kI) + (T * kJ) + kF[0].lat; return new cG(kH, kG) } }); function cQ(kD, kF, e) { if (!kD || kD.length === 0) { return } this.userPath = kD; this.userCps = kF; var kC = []; for (var T = 0; T < kD.length; T++) { kC[T] = jy.convertLL2MC(kD[T]) } if (!kF || kF.length === 0) { return } var kE = []; for (var T = 0; T < kF.length; T++) { kE[T] = []; kE[T][0] = jy.convertLL2MC(kF[T][0]); if (kF[T][1]) { kE[T][1] = jy.convertLL2MC(kF[T][1]) } else { kE[T][1] = jy.convertLL2MC(kF[T][0]) } } g8.call(this, kC, kE, e) } cQ.inherits(g8, "BezierCurveOut"); e9.extend(cQ.prototype, { toString: function () { return "BezierCurve" }, setPath: function (kC) { if (!kC || kC.length === 0) { return } this.userPath = kC; var T = []; for (var e = 0; e < kC.length; e++) { T[e] = jy.convertLL2MC(kC[e]) } this.setPathIn(T); this._mouseEventPixels = null }, getPath: function () { return this.userPath; var e = this.getPathIn(); if (!e || e.length === 0) { return [] } var kC = []; for (var T = 0; T < e.length; T++) { kC[T] = jy.convertMC2LL(e[T]) } return kC }, getControlPoints: function () { return this.userCps; var e = this.getCpsIn(); if (!e || e.length === 0) { return [] } var kC = []; for (var T = 0; T < e.length; T++) { kC[T] = []; kC[T][0] = jy.convertMC2LL(e[T][0]); kC[T][1] = jy.convertMC2LL(e[T][1]) } return kC }, setControlPoints: function (kC) { if (!kC || kC.length === 0) { return } this.userCps = kC; var T = []; for (var e = 0; e < kC.length; e++) { T[e] = []; T[e][0] = jy.convertLL2MC(kC[e][0]); if (kC[e][1]) { T[e][1] = jy.convertLL2MC(kC[e][1]) } else { T[e][1] = jy.convertLL2MC(kC[e][0]) } } this.setCpsIn(T) }, getBounds: function (i) { var e = this.getBoundsIn(i); var T = new ik(jy.convertMC2LL(e.getSouthWest()), jy.convertMC2LL(e.getNorthEast())); return T } }); function ex(e, T) { iV.call(this, T); this._normalizedBounds = new ik(); this.setPoints(e); var i = this; hm.load("poly", function () { i._draw() }) } ex.inherits(f8, "PolylineMultipart"); e9.extend(ex.prototype, { setPoints: function (e) { if (!e) { return } this._clearCache(); this.points = this._unifyArgs(e); this._calcBounds() }, _unifyArgs: function (T) { var e = []; var i = []; if (T.constructor === Array) { if (T[0].constructor === cG) { i.push(T) } else { i = T } } else { if (typeof T === "string") { i.push(T) } } e9.each(i, function (kC) { e.push(iV.getGraphPoints(kC)) }); return e }, setPointAt: function (i, e, T) { T = T || 0; if (!e || !this.points[T] || !this.points[T][i]) { return } this._clearCache(); this.points[T][i] = new cG(e.lng, e.lat); this._calcBounds() }, getBoundsIn: function (e) { if (!e) { this._bounds.setMinMax(); return this._bounds } this._normalizedBounds.setMinMax(); return this._normalizedBounds }, _calcBounds: function () { if (!this.points) { return } var e = this; e._bounds.setNorthEast(null); e._bounds.setSouthWest(null); if (e.greatCirclePoints && e.greatCirclePoints.length > 0) { e9.each(e.greatCirclePoints, function (i) { e._bounds.extend(i) }) } else { e9.each(e.points, function (i) { e9.each(i, function (T) { e._bounds.extend(T) }) }) } e._normalizedBounds.setSouthWest(e._bounds.getSouthWest()); e._normalizedBounds.setNorthEast(e._bounds.getNorthEast()); if (e._normalizedBounds.sw.lng < -h5.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > h5.WORLD_SIZE_MC_HALF) { e._normalizedBounds.sw.lng = -h5.WORLD_SIZE_MC_HALF; e._normalizedBounds.ne.lng = h5.WORLD_SIZE_MC_HALF } } }); function hB(T, e) { iV.call(this, e); e = e || {}; if (typeof e.fillOpacity === "number") { this._config.fillOpacity = e.fillOpacity } else { this._config.fillOpacity = 0.6 } ck(this._config.fillOpacity, 0, 1); if (e.fillColor === "") { this._config.fillColor = "" } else { this._config.fillColor = e.fillColor ? e.fillColor : "#fff" } this._parseFillCacheWebGL = []; this.setPoints(T, e); hQ.sendMessage(a1(4, 2, 4), ["overlay", "polygon"]); var i = this; hm.load("poly", function () { i._draw() }) } hB.inherits(iV, "Polygon"); e9.extend(hB.prototype, { setPoints: function (kE) { var kC = []; if (typeof kE === "string" || kE.length === 1 || kE[0] instanceof cG || kE[0] instanceof cA || this instanceof hg || kE.length === 0) { if (kE.length === 1) { kE = kE[0] } var e = this._processSinglePointArray(kE); this._userPoints = e.userPoints; kC = e.innerPoints; this.hasMultipleParts = false } else { this._userPoints = []; for (var kD = 0; kD < kE.length; kD++) { var T = this._processSinglePointArray(kE[kD]); this._userPoints.push(T.userPoints); kC.push(T.innerPoints) } this.hasMultipleParts = true } iV.prototype.setPoints.call(this, kC) }, setPathIn: function (e) { this.setPoints(e) }, _processSinglePointArray: function (e) { var i = iV.getGraphPoints(e).slice(0); innerPoints = i.slice(0); if (innerPoints.length > 1 && !innerPoints[0].equals(innerPoints[innerPoints.length - 1])) { innerPoints.push(new cG(innerPoints[0].lng, innerPoints[0].lat)) } return { userPoints: i, innerPoints: innerPoints } }, setPointAt: function (i, e) { if (!this._userPoints[i]) { return } this._clearCache(); this._userPoints[i] = new cG(e.lng, e.lat); this.points[i] = new cG(e.lng, e.lat); if (i === 0 && !this.points[0].equals(this.points[this.points.length - 1])) { this.points[this.points.length - 1] = new cG(e.lng, e.lat) } this._calcBounds() }, setPositionAt: function (i, e) { if (!this._userPoints[i]) { return } var T = jy.convertLL2MC(e); this.setPointAt(i, T) }, getPoints: function () { var e = this._userPoints; if (e.length === 0) { e = this.points } return e }, getPathIn: function () { return this.getPoints() } }); function i3(T, e) { if (!T || T.length === 0) { return } var i = this.setPath(T, true); hB.call(this, i, e) } i3.inherits(hB, "PolygonOut"); e9.extend(i3.prototype, { toString: function () { return "Polygon" }, toGeoJSON: function () { var kD = "Polygon"; var kE = []; var kG = this.getPath(); if (this.hasMultipleParts) { kD = "Multi" + kD; for (var kC = 0; kC < kG.length; kC++) { var kF = []; for (var T = 0; T < kG[kC].length; T++) { kF.push([kG[kC][T].lng, kG[kC][T].lat]) } kE.push(kF) } } else { for (var kC = 0; kC < kG.length; kC++) { kE.push([kG[kC].lng, kG[kC].lat]) } } var e = { type: "Feature", geometry: { type: kD, coordinates: [kE] }, properties: this.properties }; return e }, updateByGeoJSON: function (T) { var e = new gO(); var kE = e.readFeaturesFromObject(T) || []; for (var kC = 0, kD = kE.length; kC < kD; ++kC) { if (kE[kC] instanceof i3) { this.properties = kE[kC].properties; this.setPath(kE[kC].getPath()); break } } }, setPath: function (kH, T) { if (!kH || kH.length === 0) { return } var kG = []; if (typeof kH === "string" || kH[0] instanceof cG || kH[0] instanceof cA) { var e = this._processSinglePointArray(kH); for (var kF = 0; kF < e.innerPoints.length; kF++) { kG[kF] = jy.convertLL2MC(gb(e.innerPoints[kF], BMapGL.coordType)) } } else { for (var kF = 0; kF < kH.length; kF++) { var kC = this._processSinglePointArray(kH[kF]); var kE = []; for (var kD = 0; kD < kC.innerPoints.length; kD++) { kE[kD] = jy.convertLL2MC(gb(kC.innerPoints[kD], BMapGL.coordType)) } kG.push(kE) } } if (T) { return kG } this.setPathIn(kG); this._mouseEventPixels = null }, getPath: function () { var e = this.getPathIn(); if (!e || e.length === 0) { return [] } var kE = []; if (this.hasMultipleParts) { for (var kC = 0; kC < e.length; kC++) { var kD = []; for (var T = 0; T < e[kC].length; T++) { kD[T] = js(jy.convertMC2LL(e[kC][T]), BMapGL.coordType) } kE.push(kD) } } else { for (var kC = 0; kC < e.length; kC++) { kE[kC] = js(jy.convertMC2LL(e[kC]), BMapGL.coordType) } } return kE } }); function hg(i, e, T) { this.point = i; this.radius = Math.abs(e); hB.call(this, [], T) } hg.parseTolerance = { 0: [0.01, 0.0001, 0.00001, 0.000004], 1: [1000, 10, 1, 0.4] }; hg.inherits(hB, "Circle"); e9.extend(hg.prototype, { initialize: function (e) { this.map = e; this.points = this._getPerimeterPoints(this.point, this.radius); this._calcBounds(); return null }, getPoint: function () { return this.point }, setPoint: function (e) { if (!e) { return } this.point = e; this.latLng = jy.convertMC2LL(e) }, setCenterIn: function (e) { var i = arguments[1]; this.setPoint(e, i) }, setRadius: function (e) { this.radius = Math.abs(e) }, getCenterIn: function () { return this.point }, getRadius: function () { return this.radius }, _getPerimeterPoints: function (e, kJ) { if (!e || !kJ || !this.map) { return [] } var T = this.map; var kG = e.lng; var kE = e.lat; var kP = jy.convertMC2LL(e); kG = kP.lng; kE = kP.lat; var kQ = []; var kL = kJ / jy.EARTHRADIUS; var kI = (Math.PI / 180) * kE; var kO = (Math.PI / 180) * kG; for (var kH = 0; kH < 360; kH += 9) { var kF = (Math.PI / 180) * kH; var kM = Math.asin(Math.sin(kI) * Math.cos(kL) + Math.cos(kI) * Math.sin(kL) * Math.cos(kF)); var kK = Math.atan2(Math.sin(kF) * Math.sin(kL) * Math.cos(kI), Math.cos(kL) - Math.sin(kI) * Math.sin(kM)); var kN = ((kO - kK + Math.PI) % (2 * Math.PI)) - Math.PI; var kD = new cA(kM * (180 / Math.PI), kN * (180 / Math.PI)); kQ.push(jy.convertLL2MC(kD)) } var kC = kQ[0]; kQ.push(new cG(kC.lng, kC.lat)); if (kC) { this._radiusMercator = Math.sqrt(Math.pow(kC.lng - this.point.lng, 2) + Math.pow(kC.lat - this.point.lat, 2)) } else { this._radiusMercator = this.radius } return kQ } }); function aX(i, e, kC) { this.latLng = gb(new cA(i.lat, i.lng), BMapGL.coordType); var T = jy.convertLL2MC(this.latLng); hg.call(this, T, e, kC) } aX.inherits(hg, "CircleOut"); e9.extend(aX.prototype, { toString: function () { return "Circle" }, setCenter: function (e) { this.latLng = gb(new cA(e.lat, e.lng), BMapGL.coordType); var i = jy.convertLL2MC(e); this.setCenterIn(i) }, getCenter: function () { return js(new cA(this.latLng.lat, this.latLng.lng), BMapGL.coordType) }, getPath: function () { var e = this.getPathIn(); if (!e || e.length === 0) { return [] } var kC = []; for (var T = 0; T < e.length; T++) { kC[T] = jy.convertMC2LL(e[T]) } return kC }, toGeoJSON: function () { var kC = "Polygon"; var kD = []; var kE = this.getPath(); for (var T = 0; T < kE.length; T++) { kD.push([kE[T].lng, kE[T].lat]) } var e = { type: "Feature", geometry: { type: kC, coordinates: [kD] }, properties: this.properties }; return e }, updateByGeoJSON: function (e) { } }); function kr(kC, e, i) { iV.call(this, i); i = i || {}; if (typeof i.topFillOpacity === "number") { this._config.topFillOpacity = i.topFillOpacity } else { this._config.topFillOpacity = 0.6 } if (typeof i.sideFillOpacity === "number") { this._config.sideFillOpacity = i.sideFillOpacity } else { this._config.sideFillOpacity = 0.8 } ck(this._config.sideFillOpacity, 0, 1); if (i.topFillColor === "") { this._config.topFillColor = "" } else { this._config.topFillColor = i.topFillColor ? i.topFillColor : "#fff" } if (i.sideFillColor === "") { this._config.sideFillColor = "" } else { this._config.sideFillColor = i.sideFillColor ? i.sideFillColor : "#fff" } this._parseFillCacheWebGL = []; this.setPoints(kC, i); this._config.altitude = e || 0; hQ.sendMessage(a1(4, 2, 5), ["overlay", "prism"]); var T = this; hm.load("poly", function () { T._draw() }) } kr.inherits(iV, "Prism"); e9.extend(kr.prototype, { setPoints: function (kE) { var kC = []; if (typeof kE === "string" || kE[0] instanceof cG || kE[0] instanceof cA || this instanceof hg || kE.length === 0) { var e = this._processSinglePointArray(kE); this._userPoints = e.userPoints; kC = e.innerPoints; this.hasMultipleParts = false } else { this._userPoints = []; for (var kD = 0; kD < kE.length; kD++) { var T = this._processSinglePointArray(kE[kD]); this._userPoints.push(T.userPoints); kC.push(T.innerPoints) } this.hasMultipleParts = true } iV.prototype.setPoints.call(this, kC) }, setPathIn: function (e) { this.setPoints(e) }, _processSinglePointArray: function (e) { var i = iV.getGraphPoints(e).slice(0); innerPoints = i.slice(0); if (innerPoints.length > 1 && !innerPoints[0].equals(innerPoints[innerPoints.length - 1])) { innerPoints.push(new cG(innerPoints[0].lng, innerPoints[0].lat)) } return { userPoints: i, innerPoints: innerPoints } }, setPointAt: function (i, e) { if (!this._userPoints[i]) { return } this._clearCache(); this._userPoints[i] = new cG(e.lng, e.lat); this.points[i] = new cG(e.lng, e.lat); if (i === 0 && !this.points[0].equals(this.points[this.points.length - 1])) { this.points[this.points.length - 1] = new cG(e.lng, e.lat) } this._calcBounds() }, getPoints: function () { var e = this._userPoints; if (e.length === 0) { e = this.points } return e }, getPathIn: function () { return this.getPoints() }, setTopFillOpacity: function (e) { if (e > 1 || e < 0) { return } this._config.topFillOpacity = e; this._setDomAttribute("topfillopacity", e) }, getTopFillOpacity: function () { return this._config.topFillOpacity }, setSideFillOpacity: function (e) { if (e > 1 || e < 0) { return } this._config.sideFillOpacity = e; this._setDomAttribute("sidefillopacity", e) }, getSideFillOpacity: function () { return this._config.sideFillOpacity }, setTopFillColor: function (e) { this._config.topFillColor = e || ""; this._setDomAttribute("topfillcolor", e) }, getTopFillColor: function () { return this._config.topFillColor }, setSideFillColor: function (e) { this._config.sideFillColor = e || ""; this._setDomAttribute("sidefillcolor", e) }, getSideFillColor: function () { return this._config.sideFillColor }, setAltitude: function (e) { this._config.altitude = Number(e); this.draw(); var i = new fW("onlineupdate"); i.overlay = this; this.dispatchEvent(i) }, getAltitude: function () { return this._config.altitude } }); function bA(kG, kE, kH) { if (!kG || kG.length === 0) { return } this.userPath = kG; var e = []; if (typeof kG === "string" || kG[0] instanceof cG || kG[0] instanceof cA) { var kI = this._processSinglePointArray(kG); for (var kD = 0; kD < kI.innerPoints.length; kD++) { e[kD] = jy.convertLL2MC(kI.innerPoints[kD]) } } else { for (var kD = 0; kD < kG.length; kD++) { var kF = this._processSinglePointArray(kG[kD]); var T = []; for (var kC = 0; kC < kF.innerPoints.length; kC++) { T[kC] = jy.convertLL2MC(kF.innerPoints[kC]) } e.push(T) } } kr.call(this, e, kE, kH) } bA.inherits(kr, "PrismOut"); e9.extend(bA.prototype, { toString: function () { return "Prism" }, setPath: function (kC) { if (!kC || kC.length === 0) { return } this.userPath = kC; var T = []; for (var e = 0; e < kC.length; e++) { T[e] = jy.convertLL2MC(kC[e]) } this.setPathIn(T); this._mouseEventPixels = null }, getPath: function () { return this.userPath; var e = this.getPathIn(); if (!e || e.length === 0) { return [] } var kC = []; for (var T = 0; T < e.length; T++) { kC[T] = jy.convertMC2LL(e[T]) } return kC } }); function b7(kD, i) { iV.call(this, i); i = i || {}; this._config.type = i.type || "image"; this._config.url = i.url || ""; this._config.opacity = typeof i.opacity === "number" ? i.opacity : 1; this._config.sysType = i.sysType !== "fixed" ? "geo" : "fixed"; this._config.top = i.top || false; this.isReDraw = i.isReDraw || false; this.drawHook = (i.drawHook instanceof Function) ? i.drawHook : null; ck(this._config.opacity, 0, 1); if (i.type === "image" && i.isPixelMap) { this._config.isPixelMap = i.isPixelMap || false; var T = i.pixelMap || {}; this._config.colors = T.colors || ["#F9F871", "#FFC75F", "#FF9671", "#FF6F91", "#D65DB1", "#845EC2"]; this._config.positions = T.positions || [0, 0.2, 0.4, 0.6, 0.8, 1]; this._config.domain = T.domain || [0, 255]; this._config.clamp = T.clamp || this._config.domain; this._config.noData = (T.noData !== undefined) ? T.noData : -99999; this._config.fomularC = T.fomularC || "float generateValue(vec4 pixel){return pixel.r * 255.;}"; this._config.fomularJS = T.fomularJS || function (kE) { return kE.r }; this._config.maskPng = T.maskPng || null; this._config.maskData = T.maskData || -1; this._config.maskCoord = T.maskCoord || null; this.fHashcode = q({ str: this._config.fomularC }); var e = this.canPixelMap(); if (e) { this.isPixelMap = true; this.setPixelMap() } } this._parseFillCacheWebGL = []; if (this._config.sysType === "fixed") { this.points = kD } else { this.setPoints(kD, i) } if (kD instanceof ik) { this._addlog(i) } var kC = this; hm.load("poly", function () { kC._draw() }) } b7.inherits(iV, "GroundOverlay"); e9.extend(b7.prototype, { _addlog: function (e) { var i = 1; var T = "picture"; if (e) { if (e.type === "canvas" && !e.isReDraw) { i = 2; T = "static_canvas" } else { if (e.type === "canvas" && e.isReDraw) { i = 3; T = "dynamic_canvas" } else { if (e.type === "video") { i = 4; T = "video" } else { if (e.type === "image" && e.isPixelMap) { i = 5; T = "raster" } } } } } hQ.sendMessage(a1(4, 2, 8, i), ["overlay", "ground_box", T]) }, setPoints: function (i) { var e = iV.getGraphPoints(i).slice(0); this.hasMultipleParts = false; iV.prototype.setPoints.call(this, e) }, setPathIn: function (e) { this.setPoints(e) }, getPoints: function () { return this.points }, getPathIn: function () { return this.getPoints() }, canPixelMap: function () { if (this._config.colors && this._config.positions) { return true } return false }, setPixelMap: function () { if (!this._config.isPixelMap || !this.canPixelMap()) { return } var i = this._config.colors; var e = this._config.positions; this.pHashcode = q({ colors: i, positions: e }); this.pixelColorMap = hW.generateColorRamp(i, e) }, setDomain: function (e) { if (e instanceof Array && e.length === 2) { this._config.domain = e; this.doOnceDraw() } }, setClamp: function (e) { if (e instanceof Array && e.length === 2) { this._config.clamp = e; this.doOnceDraw() } }, setMaskPng: function (i) { this._config.maskPng = i; if (this.map) { var e = new fW("hide"); e.overlay = this; this.dispatchEvent(e); var e = new fW("show"); e.overlay = this; this.dispatchEvent(e) } this.doOnceDraw() }, setMaskData: function (e) { this._config.maskData = e; this.doOnceDraw() }, setMaskCoord: function (e) { this._config.maskCoord = e; this.maskUV = null; this.doOnceDraw() }, setNoData: function (e) { this._config.noData = e; this.doOnceDraw() }, setPositions: function (e) { this._config.positions = e; this.setPixelMap(); this.doOnceDraw() }, setColors: function (e) { this._config.colors = e; this.setPixelMap(); this.doOnceDraw() }, setBounds: function (T, kF) { if (T instanceof ik) { var kH = Math.min(T.sw.lng, T.ne.lng); var kE = Math.max(T.sw.lng, T.ne.lng); var kG = Math.min(T.sw.lat, T.ne.lat); var e = Math.max(T.sw.lat, T.ne.lat); var kJ = [new cG(kH, kG), new cG(kE, kG), new cG(kE, e), new cG(kH, e)]; var kC = iV.getGraphPoints(kJ).slice(0); var kD = []; for (var kI = 0; kI < kC.length; kI++) { kD[kI] = jy.convertLL2MC(kC[kI]) } } else { if (T.length === 4) { var kD = T } else { return false } } this.setPoints(kD); if (kF) { return true } this.doOnceDraw() }, setOpacity: function (e) { if (e > 1 || e < 0) { return } this._config.opacity = e; this.doOnceDraw() }, getOpacity: function () { return this._config.opacity }, getImageURL: function () { return this._config.url }, setImage: function (e, T) { this._config.src = e; this._config.url = e; this._texture = null; var i = this; this.imageLoad && this.imageLoad(this._config.src, function (kC, kD) { if (kD) { i._texture = kC; if (T) { i.setBounds(T, true) } i.doOnceDraw() } }) }, setFomular: function (e, i) { if (e && i) { this._config.fomularJS = e; this._config.fomularC = i; this.fHashcode = q({ str: this._config.fomularC }); this.doOnceDraw() } }, setIsPixelMap: function (e) { this.isPixelMap = e; this.doOnceDraw() }, getImagePixel: function (kC) { if (!this._config.isPixelMap || !this.canPixelMap()) { return null } if (!this.getImageMaskPixel(kC)) { return null } if (this.imageObject) { var T = Math.floor((kC.lng - this.points[3].lng) / this.lngMC); var e = Math.floor((-kC.lat + this.points[3].lat) / this.latMC); var i = Math.floor((e * this.imageObject.width + T) * 4); if (T > this.imageObject.width || T < 0) { return null } if (e > this.imageObject.height || e < 0) { return null } if (i + 3 > this.imageObject.data.data.length) { return null } return [this.imageObject.data.data[i], this.imageObject.data.data[i + 1], this.imageObject.data.data[i + 2], this.imageObject.data.data[i + 3],] } return null }, getValue: function (i) { if (this._config.isPixelMap && i && this._config.fomularJS) { if (!(i instanceof Array)) { i = this.getImagePixel(i.point) } var e = this._config.fomularJS({ r: i[0], g: i[1], b: i[2], a: i[3] }); if (e >= this._config.clamp[0] && e <= this._config.clamp[1]) { return e } } return null }, setImageObject: function (T) { var e = document.createElement("canvas"); e.width = T.width; e.height = T.height; var i = e.getContext("2d"); i.drawImage(T, 0, 0, T.width, T.height); this.imageObject = { width: T.width, height: T.height, data: i.getImageData(0, 0, T.width, T.height) }; this.updatePixelMc(); i = null; e = null }, updatePixelMc: function () { if (this.imageObject) { var e = Math.abs(this.points[2].lng - this.points[0].lng); var i = Math.abs(this.points[2].lat - this.points[0].lat); this.lngMC = e / this.imageObject.width; this.latMC = i / this.imageObject.height } }, setMaskImageObject: function (T) { var e = document.createElement("canvas"); e.width = T.width; e.height = T.height; var i = e.getContext("2d"); i.drawImage(T, 0, 0, T.width, T.height); this.imageMaskObject = { width: T.width, height: T.height, data: i.getImageData(0, 0, T.width, T.height) }; i = null; e = null }, getImageMaskPixel: function (e) { if (!this.imageMaskObject) { return true } var kC = this._toOverlayPixelsGL([e]); var kH = this.maskOverlayPixels; var kE = kH[1][0] - kH[0][0]; var kD = kH[1][1] - kH[0][1]; var T = Math.floor((kC[0][0] - kH[0][0]) / kE * this.imageMaskObject.width); var i = Math.floor((-kC[0][1] + kH[1][1]) / kD * this.imageMaskObject.height); var kG = Math.floor((i * this.imageMaskObject.width + T) * 4); if (T > this.imageMaskObject.width || T < 0) { return null } if (i > this.imageMaskObject.height || i < 0) { return null } var kF = this.imageMaskObject.data.data; if (kG + 3 > kF.length) { return false } if (kF[kG + 3] > 0) { if (this._config.maskData > -1 && this._config.maskData !== kF[kG]) { return false } return true } return false }, doOnceDraw: function () { var e = new fW("onlineupdate"); e.overlay = this; this.dispatchEvent(e) }, destroy: function () { this.points = []; this.imageMaskObject = null } }); function ge(kC, kJ) { if (!kC) { return } kJ = kJ || {}; var kE = []; if (kJ.sysType === "fixed") { kE = kC } else { if (kC instanceof ik) { var kG = Math.min(kC.sw.lng, kC.ne.lng); var kD = Math.max(kC.sw.lng, kC.ne.lng); var kF = Math.min(kC.sw.lat, kC.ne.lat); var T = Math.max(kC.sw.lat, kC.ne.lat); var kI = [new cG(kG, kF), new cG(kD, kF), new cG(kD, T), new cG(kG, T)]; var e = iV.getGraphPoints(kI).slice(0); for (var kH = 0; kH < e.length; kH++) { kE[kH] = jy.convertLL2MC(e[kH]) } } else { if (kC.length === 4) { kE = kC } else { return false } } } b7.call(this, kE, kJ) } ge.inherits(b7, "GroundOverlayOut"); e9.extend(ge.prototype, { toString: function () { return "GroundOverlay" } }); function dZ(e, i) { if (!(e instanceof cG)) { return } this.point = e; var e = jy.convertLL2MC(e); this.mc_point = [e.lng, e.lat]; this.size = (i.size instanceof jo) ? i.size : new jo(32, 32); this.scale = i.scale || 1; this.anchor = (i.anchor instanceof jo) ? i.anchor : new jo(0, 0); this.rotation = i.rotation || 0; this.offset = (i.offset instanceof jo) ? i.offset : new jo(0, 0); this.level = i.level || 18; hQ.sendMessage(a1(4, 2, 9), ["overlay", "ground_point"]); var T = this.calBounds(false); ge.call(this, T, i) } dZ.inherits(ge, "GroundPoint"); e9.extend(dZ.prototype, { calBounds: function (kE) { var e = Math.pow(2, 18 - this.level); var T = this.scale * e; var kI = this.size.width / 2 * T; var kP = this.size.height / 2 * T; var kH = this.anchor.width * T; var kO = this.anchor.height * T; var kC = this.offset.width * T; var kJ = this.offset.height * T; var kQ = [[-1, -1], [1, -1], [1, 1], [-1, 1]]; var kD = []; var kK = this.rotation * Math.PI / 180; var kR = mat2.create(); mat2.rotate(kR, kR, kK); for (var kM = 0; kM < kQ.length; kM++) { var kN = kQ[kM][0] * kI - kH; var kL = kQ[kM][1] * kP - kO; var kG = kR[0] * kN + kR[1] * kL; var kF = kR[2] * kN + kR[3] * kL; kD.push(new cG(this.mc_point[0] + kG + kC, this.mc_point[1] + kF + kJ)) } if (kE) { this._mouseEventPixels = null; this.setBounds(kD) } else { return kD } }, setPoint: function (T, i) { if (!(T instanceof cG)) { return } this.point = T; var e = jy.convertLL2MC(T); this.mc_point = [e.lng, e.lat]; if (i || i === undefined) { this.calBounds(true) } return this }, setScale: function (e, i) { this.scale = e; if (i || i === undefined) { this.calBounds(true) } return this }, setSize: function (e, i) { if (options.size instanceof jo) { this.size = e; if (i || i === undefined) { this.calBounds(true) } } return this }, setRotation: function (e, i) { this.rotation = e; if (i || i === undefined) { this.calBounds(true) } return this }, setAnchor: function (e, i) { if (e instanceof jo) { this.anchor = e; if (i || i === undefined) { this.calBounds(true) } } return this }, setOffset: function (e, i) { if (e instanceof jo) { this.offset = e; if (i || i === undefined) { this.calBounds(true) } } return this } }); function bU(i, e) { aU.call(this, e); if (!i || !e.point || !b0(i)) { throw new Error("参数类型错误") } e = e || {}; this.point = gb(e.point, BMapGL.coordType); this.createDom = i; this.offsetX = e.offsetX || 0; this.offsetY = e.offsetY || 0; this.minZoom = e.minZoom || 3; this.maxZoom = e.maxZoom || 21; this.zIndex = e.zIndex || 0; this.nextTick = e.nextTick || false; this.properties = e.properties || {}; this.enableMassClear = e.enableMassClear || false; this.enableDraggingMap = e.enableDraggingMap || false; this.fixBottom = e.fixBottom || false; this.anchors = e.anchors || [0.5, 1]; this.visible = e.visible === undefined ? true : !!e.visible; this.useTranslate = e.useTranslate || false; this.rotationInit = e.rotationInit || 0; this.rotationFlip = e.rotationFlip || false; this.autoFollowHeadingChanged = e.autoFollowHeadingChanged || false; this.synUpdate = e.synUpdate || false; this._rotation = 0; this._rotationOrigin = 0; this._originOpt = e; this.customLayer = null; hQ.sendMessage(a1(4, 2, 11), ["overlay", "dom_custom"]) } bU.inherits(aU, "CustomOverlay"); e9.extend(bU.prototype, { initialize: function (kC) { this.map = kC; this.show(true); this.div = document.createElement("div"); this.div.id = "cus_overlay"; this.div.setAttribute("data-tag-touch", "stop"); if (this.useTranslate) { var e = -this.anchors[0] * 100; var kD = -this.anchors[1] * 100; this.div.style.transform = "translate(" + e + "%," + kD + "%)"; if (this.autoFollowHeadingChanged) { var T = this; kC.addEventListener("heading_changed", function () { T.updateRotation() }); this.updateRotation() } } if (this.synUpdate) { var T = this; this.map.on("ondraw", function (kE) { T.draw() }) } var i = this.createDom(this.properties); this.div.appendChild(i); this.map.getPanes().labelPane.appendChild(this.div); if (this.zIndex !== 0) { this.div.style.zIndex = this.zIndex } return this.div }, isDraw: function () { if (this.map) { var T = this.map.getZoom(); var e = false; var i = this._getPixPos(this.map.getZoom(), this.map.getCenter()); e = i.onBack; if (T < this.minZoom || T > this.maxZoom || e || !this.visible) { this.hide(true); return false } else { this.show(true); return true } } return false }, hide: function (e) { if (!e) { this.visible = false } this._visible = false; e9.hide(this.domElement) }, show: function (e) { if (!e) { this.visible = true } this._visible = true; e9.show(this.domElement) }, draw: function () { if (!this.div || !this.point) { return } if (this.nextTick && this.div.style.position !== "absolute") { this.div.style.opacity = 0; setTimeout(function () { this.div.style.opacity = 1; this.draw() }.bind(this), 0) } if (this.div.children[0]) { var kE = this.div.children[0].clientWidth; var e = this.div.children[0].clientHeight; if (!kE && this.lastClientWidth) { kE = this.lastClientWidth; e = this.lastClientHeight } this.lastClientWidth = kE; this.lastClientHeight = e } var kC = 0; var T = 0; var kD = jy.convertLL2MC(this.point); var i = this.map.pointToOverlayPixelIn(kD, { useRound: false }); if (!this.useTranslate) { kC = this.div.children[0] ? kE * this.anchors[0] : 0; T = this.div.children[0] ? e * this.anchors[1] - (this.fixBottom ? 0 : 25) : 0 } this.div.style.position = "absolute"; this.div.style.left = i.x - kC + this.offsetX + "px"; this.div.style.top = i.y - T + this.offsetY + "px"; this.div.style.boxSizing = "border-box"; if (!this.isDraw()) { return } }, addEventListener: function (T, kD) { if (!this.div || !this.map) { return } var i = this; var kC = this.map; function e(kH) { var kF = new fW("onclick").inherit(kH); kF.type = kH.type; var kG = kH.srcElement || kH.target; var kE = kH.clientX || kH.pageX; var kJ = kH.clientY || kH.pageY; if (kH && kF && kG && kE && kJ) { var kI = e9.Dom.getOffset(kC.container); kF.pixel = new fv(kE - kI.left, kJ - kI.top); kF.latLng = kC.pixelToPoint(kF.pixel) } return kF } switch (T) { case "mouseover": if (this.div.style) { this.div.style.cursor = "pointer" } e9.on(this.div, "mouseover", function (kF) { i.div.style.cursor = "pointer"; var kE = e(kF); i.dispatchEvent(kE); kD(kE) }); break; case "mouseout": e9.on(this.div, "mouseout", function (kF) { var kE = e(kF); i.dispatchEvent(kE); kD(kE) }); break; case "click": if (this.div.style) { this.div.style.cursor = "pointer" } e9.on(this.div, "click", function (kF) { var kE = e(kF); i.dispatchEvent(kE); kD(kE) }); break; default: break } }, setPoint: function (e, kD) { if (e instanceof cG) { if (!kD) { this.div.innerHTML = ""; this.div.appendChild(this.createDom(this.properties)) } this.point = gb(e, BMapGL.coordType); if (this.synUpdate) { this.map.dispatchEvent(new fW("onrefresh")); return } var kC = 0; var T = 0; if (!this.useTranslate) { kC = this.div.clientWidth * this.anchors[0]; T = this.div.clientHeight * this.anchors[1] - (this.fixBottom ? 0 : 25) } var kE = jy.convertLL2MC(this.point); var i = this.map.pointToOverlayPixelIn(kE, { useRound: false }); this.div.style.position = "absolute"; this.div.style.left = i.x - kC + this.offsetX + "px"; this.div.style.top = i.y - T + this.offsetY + "px" } }, setRotation: function (kG) { kG = kG + this.rotationInit; while (kG < 0) { kG += 360 } this._rotation = kG % 360; var kE = 0; var T = this._rotation; if ((this._rotation > 90 && this._rotation < 270) && this.rotationFlip) { kE = 180; T -= 360 } else { kE = 0 } if (this.rotationFlip) { var kI = ((this.div.clientWidth || 0) * this.anchors[0] || 0) - (this._originOpt.offsetY || 0) + (this._originOpt.offsetX || 0); if (Math.abs(this._rotation - 80) <= 10 || Math.abs(this._rotation - 260) <= 10) { this.offsetX = kI } else { if (Math.abs(this._rotation - 100) <= 10 || Math.abs(this._rotation - 280) <= 10) { this.offsetX = -kI } else { this.offsetX = this._originOpt.offsetX || 0 } } } var i = this.div.style.transform; const kD = /translate\(([^)]+)/; const kH = i.match(kD); if (kH) { const kF = kH[1].split(","); const kC = kF[0].trim(); const e = kF[1].trim(); this.div.style.transform = "translate(" + kC + ", " + e + ") rotateZ(" + T + "deg) rotateX(" + kE + "deg)" } else { this.div.style.transform = "rotateZ(" + T + "deg) rotateX(" + kE + "deg)" } }, setRotationOrigin: function (e) { while (e < 0) { e += 360 } this._rotationOrigin = e % 360; this.updateRotation() }, updateRotation: function () { if (!this.map || !this.autoFollowHeadingChanged) { return } var e = (this._rotationOrigin + this.map.getHeading()); this.setRotation(e) }, getRotation: function () { return this._rotation }, getPoint: function () { return js(this.point, BMapGL.coordType) }, setProperties: function (e) { if (e instanceof Object) { Object.assign(this.properties, e); this.div.innerHTML = ""; this.div.appendChild(this.createDom(this.properties)) } }, getProperties: function () { return this.properties }, toString: function () { return "CustomOverlay" }, _getPixPos: function (T, e) { var kC = jy.convertLL2MC(this.point); var i = this.map.pointToOverlayPixelIn(kC, { zoom: T, center: e, fixPosition: true }); return i }, }); var ay = {}; function io(T, i) { e9.BaseClass.call(this); this.content = T; this.map = null; this._config = { width: 0, height: 0, maxWidth: 600, offset: new jo(0, 0), title: "", maxContent: "", enableMaximize: false, enableAutoPan: true, enableCloseOnClick: true, margin: [10, 10, 40, 10], collisions: [[10, 10], [10, 10], [10, 10], [10, 10]], ifMaxScene: false, onClosing: function () { return true } }; this.setConfig(i); if (this._config.width < 50) { this._config.width = 50 } if (this._config.width > 730) { this._config.width = 730 } if (this._config.height != 0) { if (this._config.height < 50) { this._config.height = 50 } if (this._config.height > 650) { this._config.height = 650 } } if (this._config.maxWidth !== 0) { if (this._config.maxWidth < 50) { this._config.maxWidth = 50 } if (this._config.maxWidth > 730) { this._config.maxWidth = 730 } } this.isWinMax = false; this.IMG_PATH = E.imgPath; this.overlay = null; var e = this; hm.load("simpleInfowindow", function () { e._draw() }) } io.inherits(e9.BaseClass, "SimpleInfoWindow"); e9.extend(io.prototype, { setWidth: function (e) { e = e * 1; if (!e && e != 0 || isNaN(e) || e < 0) { return } if (e != 0) { if (e < 50) { e = 50 } if (e > 730) { e = 730 } } this._config.width = e }, setHeight: function (e) { e = e * 1; e -= 10; if (!e && e != 0 || isNaN(e) || e < 0) { return } if (e != 0) { if (e < 50) { e = 50 } if (e > 650) { e = 650 } } this._config.height = e }, setMaxWidth: function (e) { e = e * 1; if (!e && e != 0 || isNaN(e) || e < 0) { return } if (e != 0) { if (e < 50) { e = 50 } if (e > 730) { e = 730 } } this._config.maxWidth = e }, setTitle: function (e) { this._config.title = e || "" }, setContent: function (e) { this.content = e || "" }, setMaxContent: function (e) { this._config.maxContent = e || "" }, redraw: function () { }, enableAutoPan: function () { this._config.enableAutoPan = true }, disableAutoPan: function () { this._config.enableAutoPan = false }, enableCloseOnClick: function () { this._config.enableCloseOnClick = true }, disableCloseOnClick: function () { this._config.enableCloseOnClick = false }, enableMaximize: function () { this._config.enableMaximize = true }, disableMaximize: function () { this._config.enableMaximize = false }, show: function () { this._visible = true }, hide: function () { this._visible = false }, close: function () { this.hide() }, dispose: function () { e9.BaseClass.prototype.decontrol.call(this) }, maximize: function () { this.isWinMax = true }, restore: function () { this.isWinMax = false }, setConfig: function (i) { if (!i) { return } for (var e in i) { if (typeof (this._config[e]) == typeof (i[e])) { this._config[e] = i[e] } } }, isVisible: function () { return this.isOpen() }, isOpen: function () { return false }, getPoint: function () { if (this.overlay && this.overlay.getPoint) { return this.overlay.getPoint() } }, getOffset: function () { return this._config.offset }, dispose: function () { e9.BaseClass.prototype.decontrol.call(this) }, toString: function () { return "SimpleInfoWindow" } }); h5.prototype.openSimpleInfoWindow = function (kC, e) { if (!kC || kC.toString() != "SimpleInfoWindow" || !e || e.toString() != "Point") { return } var i = this.temp; if (!i.marker) { var T = new jS(E.imgPath + "blank.gif", { width: 1, height: 1 }); i.marker = new ke(e, { icon: T, width: 1, height: 1, offset: new jo(0, 0), infoWindowOffset: new jo(0, 0), clickable: false }); i.marker._fromMap = 1 } else { i.marker.setPoint(e) } this.addOverlay(i.marker); i.marker.show(); i.marker.openSimpleInfoWindow(kC) }; h5.prototype.closeSimpleInfoWindow = function () { var e = this.temp.infoWin || this.temp._infoWin; if (e && e.overlay) { e.overlay.closeSimpleInfoWindow() } }; eM.prototype.openSimpleInfoWindow = function (e) { if (this.map) { this.map.closeSimpleInfoWindow(); e._visible = true; this.map.temp._infoWin = e; e.overlay = this; e9.BaseClass.call(e, e.hashCode) } }; eM.prototype.closeSimpleInfoWindow = function () { if (this.map && this.map.temp._infoWin) { this.map.temp._infoWin._visible = false; this.map.temp._infoWin.decontrol(); this.map.temp._infoWin = null } }; function cs(T, e) { iV.call(this, e); e = e || {}; this._config.showRegion = e.showRegion || "inside"; this._config.isBuildingMask = e.isBuildingMask && true; this._config.isPoiMask = e.isPoiMask && true; this._config.isMapMask = e.isMapMask && true; this._config.path = T; this._parseFillCacheWebGL = []; this.setPoints(T, e); hQ.sendMessage(a1(4, 1, 3), ["instance", "custom_mask"]); var i = this; hm.load("poly", function () { i._draw() }) } cs.inherits(iV, "MapMask"); e9.extend(cs.prototype, { setPoints: function (i) { var e = iV.getGraphPoints(i).slice(0); this.hasMultipleParts = false; iV.prototype.setPoints.call(this, e) }, setPathIn: function (e) { this.setPoints(e) }, _processSinglePointArray: function (e) { var i = iV.getGraphPoints(e).slice(0); innerPoints = i.slice(0); if (innerPoints.length > 1 && !innerPoints[0].equals(innerPoints[innerPoints.length - 1])) { innerPoints.push(new cG(innerPoints[0].lng, innerPoints[0].lat)) } return { userPoints: i, innerPoints: innerPoints } }, getPoints: function () { var e = this._userPoints; if (e.length === 0) { e = this.points } return e }, getPathIn: function () { return this.getPoints() } }); function ko(kE, T) { if (!kE || kE.length === 0) { return } var kD = []; if (kE[0] instanceof cG) { var e = this._processSinglePointArray(kE); for (var kC = 0; kC < e.innerPoints.length; kC++) { kD[kC] = jy.convertLL2MC(e.innerPoints[kC]) } } cs.call(this, kD, T) } ko.inherits(cs, "MapMaskOut"); e9.extend(ko.prototype, { toString: function () { return "MapMask" } }); function fv(e, i) { e = isNaN(e) ? 0 : e; i = isNaN(i) ? 0 : i; this.x = e; this.y = i } fv.prototype.equals = function (e) { if (!e) { return false } return e.x === this.x && e.y === this.y }; fv.prototype.clone = function () { return new fv(this.x, this.y) }; fv.prototype.toString = function () { return "Pixel" }; function jo(i, e) { if (typeof i !== "number") { this.width = parseFloat(i) } else { this.width = i } if (typeof e !== "number") { this.height = parseFloat(e) } else { this.height = e } } jo.prototype.equals = function (e) { return !!(e && this.width === e.width && this.height === e.height) }; jo.prototype.toString = function () { return "Size" }; var ku = { B_NORMAL_MAP: { tileUrls: dI(E.tileDomain, E.rasterTilePath), vectorTileUrls: dI(E.tileDomain, E.vectorTilePath), tileSize: 256, baseUnits: 256, zoomLevelMin: 3, zoomLevelMax: 19, minDataZoom: 3, maxDataZoom: 19, minZoom: 3, maxZoom: 19, webgl: { minZoom: 3, maxZoom: 25 }, zoomLevelBase: 18, errorUrl: E.imgPath + "bg.png", bounds: new ik(new cG(-21364736, -11708041.66), new cG(23855104, 12474104.17)), imgExtend: "png" }, B_SATELLITE_MAP: { tileUrls: ["//maponline0.bdimg.com/starpic/?qt=satepc&", "//maponline1.bdimg.com/starpic/?qt=satepc&", "//maponline2.bdimg.com/starpic/?qt=satepc&", "//maponline3.bdimg.com/starpic/?qt=satepc&"], tileSize: 256, baseUnits: 256, zoomLevelMin: 3, zoomLevelMax: 19, minDataZoom: 3, maxDataZoom: 19, minZoom: 3, maxZoom: 19, zoomLevelBase: 18, errorUrl: E.imgPath + "bg.png", bounds: new ik(new cG(-21364736, -10616832), new cG(23855104, 15859712)), imgExtend: "png" }, B_STREET_MAP: { tileUrls: dI(E.tileDomain, E.rasterTilePath), tileSize: 256, baseUnits: 256, zoomLevelMin: 3, zoomLevelMax: 19, minDataZoom: 3, maxDataZoom: 19, minZoom: 3, maxZoom: 19, zoomLevelBase: 18, errorUrl: E.imgPath + "bg.png", bounds: new ik(new cG(-21364736, -10616832), new cG(23855104, 15859712)), imgExtend: "png" }, BMAP_CUSTOM_LAYER: { tileUrls: [""], tileSize: 256, baseUnits: 256, zoomLevelMin: 1, zoomLevelMax: 19, minDataZoom: 3, maxDataZoom: 19, minZoom: 3, maxZoom: 19, zoomLevelBase: 18, errorUrl: E.imgPath + "blank.gif", bounds: new ik(new cG(-21364736, -10616832), new cG(23855104, 15859712)), imgExtend: "png" }, B_EARTH_MAP: { tileUrls: [""], tileSize: 256, baseUnits: 256, zoomLevelMin: 3, zoomLevelMax: 19, minDataZoom: 3, maxDataZoom: 19, minZoom: 3, maxZoom: 19, webgl: { minZoom: 3, maxZoom: 21 }, zoomLevelBase: 18, errorUrl: E.imgPath + "blank.gif", bounds: new ik(new cG(-21364736, -10616832), new cG(23855104, 15859712)), imgExtend: "png" }, B_NONE_MAP: { tileUrls: "", tileSize: 256, baseUnits: 256, zoomLevelMin: 3, zoomLevelMax: 19, minDataZoom: 3, maxDataZoom: 19, minZoom: 3, maxZoom: 19, zoomLevelBase: 18, errorUrl: E.imgPath + "bg.png", bounds: new ik(new cG(-21364736, -11708041.66), new cG(23855104, 12474104.17)), imgExtend: "png" } }; var ev = ku; function cV(kF, kG, T, e, kE) { if (kE && ev[kE]) { this.mapTypeName = kE } else { this.mapTypeName = BMAP_NORMAL_MAP } if (kF && kF instanceof Array) { var kD = true; for (var kC = 0; kC < kF.length; kC++) { if (kF[kC] instanceof ik) { continue } else { kD = false; break } } kD && (this.bounds = kF) } if (typeof kG === "number" && kG >= ev[this.mapTypeName].webgl.minZoom) { if (ev[this.mapTypeName].webgl) { if (kG >= ev[this.mapTypeName].webgl.minZoom) { this.minZoom = kG } else { this.minZoom = ev[this.mapTypeName].webgl.minZoom } } else { if (kG >= ev[this.mapTypeName].minZoom) { this.minZoom = kG } else { this.minZoom = ev[this.mapTypeName].minZoom } } } if (typeof T === "number") { if (ev[this.mapTypeName].webgl) { if (T <= ev[this.mapTypeName].webgl.maxZoom) { this.maxZoom = T } else { this.maxZoom = ev[this.mapTypeName].webgl.maxZoom } } else { if (T <= ev[this.mapTypeName].maxZoom) { this.maxZoom = T } else { this.maxZoom = ev[this.mapTypeName].maxZoom } } } if (this.maxZoom < this.minZoom) { this.maxZoom = null } if (e && typeof e === "function") { this.tileUrlFunction = e } hQ.sendMessage(a1(4, 3, 1, 2), ["layer", "vector", "private"]) } e9.extend(cV.prototype, { addBoundary: function (e) { if (e instanceof ik) { if (this.bounds) { this.bounds.push(e) } else { this.bounds = [e] } } }, setTileUrlFunction: function (e) { if (e && typeof e === "function") { this.tileUrlFunction = e } }, crossPoint: function (e, kC, kD) { if (kD < this.minZoom || kD > this.maxZoom) { return false } var kE = this.containsPoint(e, kD); if (kE) { return kE } for (var T = 0; T < this.bounds.length; T++) { if (this.bounds[T].intersects(kC)) { kE = true; break } } return kE }, containsPoint: function (e, kC) { if (!e || !(e instanceof cG) || !this.isValid()) { return false } var kD = false; if (kC < this.minZoom || kC > this.maxZoom) { return kD } for (var T = 0; T < this.bounds.length; T++) { if (this.bounds[T].containsPoint(e)) { kD = true; break } } return kD }, isValid: function () { return this.bounds && this.minZoom && this.maxZoom && this.tileUrlFunction }, toString: function () { return "PrivateRegionDataModel" } }); function h4(kH, i, kD, T, kC) { this.mgr = kH; this.position = kD; this._cbks = []; this.name = kH.getTileName(T, kC, kH.map.config.style); this.info = T; this._transparentPng = kC.isTransparentPng(); var kI = b6("img"); im(kI); kI.galleryImg = false; var kG = kI.style; kG.position = "absolute"; kG.width = kH.tileSize + "px"; kG.height = kH.tileSize + "px"; kG.left = kD[0] + "px"; kG.top = kD[1] + "px"; this.img = kI; this.src = i; if (eN && kD._offsetX === 0) { kG.opacity = 0; kG.willChange = "opacity" } var kF = this; this.img.onload = function (kQ) { if (!kF.mgr) { return } var kL = kF.mgr; var kJ = kL.bufferTiles; if (kL.bufferNumber > 0) { kJ[kF.name] = kF; kJ.push(kF.name) } var kN = kJ.length - kL.bufferNumber; for (var kO = 0; kN > 0 && kO < kJ.length; kO++) { var kP = kJ[kO]; if (!kL.mapTiles[kP]) { if (kJ[kP]) { kJ[kP].mgr = null; var kM = kJ[kP].img; if (kM.parentNode) { iK(kM); kM.parentNode.removeChild(kM) } kM = null; kJ[kP].img = null; kJ[kP] = null; delete kJ[kP] } kJ.splice(kO, 1); kO--; kN-- } } kF.loaded = true; kL.imgNumber++; if (!aV(kF.img)) { if (kC.tilesDiv) { kC.tilesDiv.appendChild(kF.img) } } var kQ = new fW("onimagechange"); kQ.action = "show"; kQ.tile = kF.name; kL.map.dispatchEvent(kQ); if (eN && kD._offsetX === 0) { var kK = new fL({ fps: 10, duration: 300, render: function (e) { if (kF.img && kF.img.style) { kF.img.style.opacity = e * 1 } }, finish: function () { if (kF.img && kF.img.style) { delete kF.img.style.opacity; kF.img.style.willChange = "auto" } } }) } kF._callCbks() }; this.img.onerror = function (kL) { kF.error = true; kF._callCbks(); if (!kF.mgr) { return } var kJ = kF.mgr; var kK = ev[kC.mapType]; if (kK.errorUrl) { kF.img.src = kK.errorUrl } if (!aV(kF.img)) { if (kC.tilesDiv) { kC.tilesDiv.appendChild(kF.img) } } }; kI = null; var kE = new fW("onimagebefore"); kE.tile = kF.name; kH.map.dispatchEvent(kE) } h4.prototype._addLoadCbk = function (e) { this._cbks.push(e) }; h4.prototype._load = function () { if (FeBrowser.ie <= 6 && FeBrowser.ie > 0 && this._transparentPng) { this.img.src = E.imgPath + "blank.gif" } else { this.img.src = this.src } }; h4.prototype._callCbks = function () { var T = this; for (var e = 0; e < T._cbks.length; e++) { T._cbks[e]() } T._cbks.length = 0 }; var eN = (!e9.Browser.ie || e9.Browser.ie > 8); function jG(e) { this.tileLayers = []; this.map = e; this.bufferNumber = 300; this.mapTiles = []; this.bufferTiles = []; this.config = ev[this.map.mapType]; this.errorUrl = this.config.errorUrl; this.tileSize = this.config.tileSize; this.baseUnits = this.config.baseUnits; this.baseZoomLevel = this.config.zoomLevelBase; this.tileURLs = this.config.tileUrls; this.imgNumber = 0; this.numLoading = 0; this.temp = {} } bG.register(function (i) { if (i._renderType === "webgl") { return } var e = i.tileMgr = new jG(i); i.addEventListener("mousewheel", function (T) { e.mouseWheel(T) }); i.addEventListener("dblclick", function (T) { e.dblClick(T) }); i.addEventListener("rightdblclick", function (T) { e.dblClick(T) }); i.addEventListener("minuspress", function (T) { e.keypress(T) }); i.addEventListener("pluspress", function (T) { e.keypress(T) }); i.addEventListener("load", function (T) { if (this.mapType === BMAP_EARTH_MAP) { return } e.loadTiles() }); i.addEventListener("zoomstartcode", function (T) { if (this.mapType === BMAP_EARTH_MAP) { return } e._zoom(T) }); i.addEventListener("moving", function (T) { if (this.mapType === BMAP_EARTH_MAP) { return } e.moveGridTiles() }); i.addEventListener("resize", function (T) { if (this.mapType === BMAP_EARTH_MAP) { return } e.resizeMap(T) }); i.addEventListener("addtilelayer", function (T) { e.addTileLayer(T) }); i.addEventListener("removetilelayer", function (T) { e.removeTileLayer(T) }) }); e9.extend(jG.prototype, { addTileLayer: function (kC) { var T = this; var i = kC.target; T.tileLayers.push(i); if (T.map.loaded) { T.moveGridTiles() } }, removeTileLayer: function (kJ) { var kK = this; var kH = kJ.target; var kF = kH.mapType; var kE = kK.mapTiles; var kM = kK.bufferTiles; for (var T in kM) { var kC = T.split("-")[1]; if (kC == kF) { delete kM[T] } } for (var T in kE) { var kC = T.split("-")[1]; if (kC == kF) { delete kE[T] } } if (kK.zoomsDiv && kK.zoomsDiv.parentNode) { kK.zoomsDiv.parentNode.removeChild(kK.zoomsDiv); kK.zoomsDiv.innerHTML = "" } var kD = kK.map; if (kD.deepZoom) { var kL = kD.deepZoom.preDeepZoomDiv; if (kL && kL.parentNode) { kL.parentNode.removeChild(kL) } } for (var kI = 0, kG = kK.tileLayers.length; kI < kG; kI++) { if (kH == kK.tileLayers[kI]) { kK.tileLayers.splice(kI, 1) } } kK.moveGridTiles() }, hideDeepZoomDiv: function () { var i = this, T = i.map; if (T.deepZoom) { var e = T.deepZoom.preDeepZoomDiv; if (e && e.style.display != "none") { e.style.display = "none" } } }, getTileLayer: function (kD) { var kC = this; for (var T = 0, e = kC.tileLayers.length; T < e; T++) { tilelayer = kC.tileLayers[T]; if (tilelayer.mapType == kD) { return tilelayer } } return null }, _zoom: function (T) { var i = this; if (i.zoomsDiv && i.zoomsDiv.style.display != "none") { i.zoomsDiv.style.display = "none" } i.hideDeepZoomDiv(); i.moveGridTiles() }, resizeMap: function (i) { this.loaded = false; this.moveGridTiles() }, _checkTilesLoaded: function () { this.numLoading--; var e = this; if (this.numLoading == 0) { if (this._checkLoadedTimer) { clearTimeout(this._checkLoadedTimer); this._checkLoadedTimer = null } this._checkLoadedTimer = setTimeout(function () { if (e.numLoading == 0) { e.map.dispatchEvent(new fW("ontilesloaded")) } e._checkLoadedTimer = null }, 80) } }, getTileName: function (e, T, i) { var kD = T.mapType; var kC = "TILE-" + kD + "-" + i + "-" + e[0] + "-" + e[1] + "-" + e[2]; return kC }, hideTile: function (kC, T) { var i = kC.img; if (aV(i)) { if (kC.loaded) { this.imgNumber-- } if (i.parentNode) { iK(i); i.parentNode.removeChild(i) } } var kD = new fW("onimagechange"); kD.tile = this.getTileName(kC.info, T, this.map.config.style); kD.action = "hide"; delete this.mapTiles[kC.name]; if (!kC.loaded) { iK(i); kC._callCbks(); i = null; kC.img = null; kC.mgr = null } this.map.dispatchEvent(kD) }, loadTiles: function () { var i = this; if (e9.Browser.ie) { try { document.execCommand("BackgroundImageCache", false, true) } catch (T) { } } if (this.zoomsDiv && this.zoomsDiv.style.display != "none") { this.zoomsDiv.style.display = "none" } i.hideDeepZoomDiv(); i.moveGridTiles() }, getCell: function (kD, kC) { var e = this.baseUnits * Math.pow(2, (this.baseZoomLevel - kC)); var T = parseInt(kD.lng / e); var i = parseInt(kD.lat / e); return [T, i, e * (T + 0.5), e * (i + 0.5)] }, moveGridTiles: function () { var kQ = this.map, kZ = kQ.getMapType(), kX = this.tileLayers.length; var kV = kQ.centerPoint; if (kZ !== BMAP_SATELLITE_MAP) { kV = fc.calcLoopCenterPoint(kV) } var kH = kQ.width; var lb = kQ.getZoomUnits(); var kW = lb * kH; var k1 = kV.lng - kW / 2; var kM = kV.lng + kW / 2; var kP = fc.isAddWidth(k1, kM); for (var k3 = 0; k3 < kX; k3++) { var kD = this.tileLayers[k3]; if (kD.baseLayer || kX == 1) { this.tilesDiv = kD.tilesDiv } var kR = ev[kD.mapType]; var kC = kQ.zoomLevel; var k6 = kQ.getZoomUnits(kQ.zoomLevel); var kL = kR.baseUnits * Math.pow(2, (kR.zoomLevelBase - kC)); var kJ = Math.floor(kV.lng / kL); var k2 = Math.floor(kV.lat / kL); var kO = kR.tileSize; var kS = [kJ, k2, (kV.lng - kJ * kL) / kL * kO, (kV.lat - k2 * kL) / kL * kO]; var kK = kP ? kQ.width / 2 * 1.5 : kQ.width / 2; var kN = kS[0] - Math.ceil((kK - kS[2]) / kO); var la = kS[1] - Math.ceil((kQ.height / 2 - kS[3]) / kO); var k4 = kS[0] + Math.ceil((kK + kS[2]) / kO); var kT = kS[1] + Math.ceil((kQ.height / 2 + kS[3]) / kO); var kI = []; for (var k8 = kN; k8 < k4; k8++) { for (var k7 = la; k7 < kT; k7++) { kI.push([k8, k7]); var kY = "id_" + k8 + "_" + k7 + "_" + kC; kI[kY] = true } } if (kD.mapType !== BMAP_SATELLITE_MAP) { kI = fc.calcLoopTiles(kI, kC) } kI.sort((function (i) { return function (ld, le) { return ((0.4 * Math.abs(ld[0] - i[0]) + 0.6 * Math.abs(ld[1] - i[1])) - (0.4 * Math.abs(le[0] - i[0]) + 0.6 * Math.abs(le[1] - i[1]))) } })([kS[0], kS[1]])); var T = this.mapTiles; var e = -kV.lng / k6; var lc = kV.lat / k6; var k0 = [e, lc]; for (var kU in T) { var kF = T[kU]; var k9 = kF.info; if (!k9) { continue } var kY = "id_" + k9[0] + "_" + k9[1] + "_" + k9[2]; if (!kI[kY]) { this.hideTile(kF, kD) } } var kE = -kQ.offsetX + kQ.width / 2; var kG = -kQ.offsetY + kQ.height / 2; kD.tilesDiv.style.left = Math.round(e + kE) - k0[0] + "px"; kD.tilesDiv.style.top = Math.round(lc + kG) - k0[1] + "px"; this.numLoading += kI.length; for (var k8 = 0, k5 = kI.length; k8 < k5; k8++) { this.showTile([kI[k8][0], kI[k8][1], kQ.zoomLevel], k0, kD, k8, kQ.config.style) } } }, showTile: function (kF, kE, kI, kN) { this.centerPos = kE; var kG = ev[kI.mapType]; var kJ = this.map.config.style; var kC = this.getTileName(kF, kI, kJ); var kD = (kF[0] * kG.tileSize) + kE[0]; var T = (-1 - kF[1]) * kG.tileSize + kE[1]; var kM = [kD, T]; var kH = null; if (kI.mapType !== BMAP_SATELLITE_MAP) { kH = fc.calcLoopParam(kF[0], kF[2]); var kL = kH.offsetX; kM[0] += kL; kM._offsetX = kL } var kQ = this; var kP = this.mapTiles[kC]; if (kP) { kP.img.style.left = kM[0] + "px"; kP.img.style.top = kM[1] + "px"; if (kP.loaded) { this._checkTilesLoaded() } else { kP._addLoadCbk(function () { kQ._checkTilesLoaded() }) } return } kP = this.bufferTiles[kC]; if (kP) { this.imgNumber++; kI.tilesDiv.insertBefore(kP.img, kI.tilesDiv.lastChild); this.mapTiles[kC] = kP; kP.img.style.left = kM[0] + "px"; kP.img.style.top = kM[1] + "px"; if (kP.loaded) { this._checkTilesLoaded() } else { kP._addLoadCbk(function () { kQ._checkTilesLoaded() }) } var kO = new fW("onimagechange"); kO.action = "cache"; kO.tile = this.getTileName(kF, kI, kJ); this.map.dispatchEvent(kO) } else { var kK = new fv(kF[0], kF[1]); if (kH) { kK.x = kH.col } var i = kI.getTilesUrl(kK, kF[2]); kP = new h4(this, i, kM, kF, kI); kP._addLoadCbk(function () { kQ._checkTilesLoaded() }); kP._load(); this.mapTiles[kC] = kP; hA(this.map) } }, mouseWheel: function (kG) { var kF = this.map; if (!kF.config.enableWheelZoom) { return } var kH = kF.zoomLevel + (kG.trend === true ? 1 : -1); var kD = kF._getProperZoom(kH); if (kD.exceeded) { var T = new fW("onzoomexceeded"); T.targetZoom = kH; kF.dispatchEvent(T); return } kF.dispatchEvent(new fW("onzoomstart")); kF.lastLevel = kF.zoomLevel; kF.zoomLevel = kD.zoom; var i = kG.pixel; var kC = kF.pixelToPointIn(i, { zoom: kF.lastLevel }); var kE = kF.getZoomUnits(kF.zoomLevel); kF.centerPoint = new cG(kC.lng + kE * (kF.width / 2 - i.x), kC.lat - kE * (kF.height / 2 - i.y)); this.zoom(i) }, dblClick: function (T) { var i = this.map; if (!i.config.enableDblclickZoom) { return } if (i.mapType === "B_EARTH_MAP") { return } if (i.currentOperation === ep.dragging) { return } if (T.type == "onrightdblclick") { i.zoomOut(T.point) } else { i.zoomIn(T.point) } }, keypress: function (T) { var i = this.map; if (i.getMapType() === BMAP_EARTH_MAP) { return } T.type == "onpluspress" ? i.zoomIn() : i.zoomOut() } }); function hP(kC) { this.opts = kC || {}; this.copyright = this.opts.copyright || {}; this.transparentPng = this.opts.transparentPng || false; this.png8 = this.opts.png8 || false; this.height = this.opts.height || 0; this.opacity = this.opts.opacity || 1; this.pack = this.opts.pack || false; this.baseLayer = this.opts.baseLayer || false; this.dataType = this.opts.dataType || 1; this.transform = this.opts.transform || 0; this.spanLevel = this.opts.spanLevel || 0; this.isFlat = !this.opts.isFlat ? false : true; this.showLabel = this.opts.showLabel === false ? false : true; var e = this.opts.tileTypeName || "web"; this.tileType = il.getInstance(e); this.clipTile = this.opts.clipTile || false; this._type = "tilelayer"; this.isTop = this.opts.isTop || false; var i = b5() ? 128 : 256; this.cacheSize = this.opts.cacheSize || i; var T = this; this.tileCache = new aC(this.cacheSize, { clearCallback: function (kD) { if (kD.label) { if (kD.label.textImageBitmap) { kD.label.textImageBitmap.close() } if (kD.label.indoorTextImageBitmap) { kD.label.indoorTextImageBitmap.close() } } T._removeIndoorData(kD) } }); this.scaler = gu() >= 1.5 ? 2 : 1; this.normalUdt = kd("ditu", "normal").udt; this.numLoading = 0; this.numTileLoading = 0; this.firstTileLoad = false; this.retry = this.opts.retry || false; this.retryTime = this.opts.retryTime || 600; this.useThumbData = false; this.useThumbData = this.opts.useThumbData || false; if (this.baseLayer) { this.useThumbData = true } if (typeof this.opts.customLayer === "boolean") { this.customLayer = this.opts.customLayer } else { this.customLayer = true } } hP.inherits(dh, "TileLayer"); e9.extend(hP.prototype, { isTransparentPng: function () { return this.transparentPng }, getTilesUrl: function (kJ, e) { var T = ev[this.mapType]; if (typeof T !== "object") { return null } var kC = kJ.x; var kK = kJ.y; kC = fc.calcLoopParam(kC, e).col; var i = ""; if (this.opts.tileUrlTemplate) { i = this.opts.tileUrlTemplate; i = i.replace(/\{X\}/, kK); i = i.replace(/\{Y\}/, kC); i = i.replace(/\{Z\}/, e) } else { if (this.mapType === BMAPGL_NORMAL_MAP) { var kI = this.isCanvasMap ? 0 : 1; var kE = T.tileUrls[Math.abs(kK + kC) % T.tileUrls.length]; if (window.offLineIPAddress) { kE = window.offLineIPAddress + "tile5/" } var kD = this.map.config.style; i = kE + "?qt=vtile&x=" + kC + "&y=" + kK + "&z=" + e + (kD === "default" ? "" : ("&styleId=1")) + "&styles=pl&udt=" + this.normalUdt + "&scaler=" + this.scaler + "&showtext=" + kI; i = i.replace(/-(\d+)/gi, "M$1") } if (this.mapType === BMAP_SATELLITE_MAP) { var kF = kd("ditu", "satellite"); var kH = kF.ver; var kG = kF.udt; i = T.tileUrls[Math.abs(kK + kC) % T.tileUrls.length] + "u=x=" + kC + ";y=" + kK + ";z=" + e + ";v=" + kH + ";type=sate&fm=46&udt=" + kG; i = i.replace(/-(\d+)/gi, "M$1") } } return i }, initialize: function (kF) { this.map = kF; if (kF._renderType === "webgl") { var kE = null; if (this.customLayer !== false) { kE = this.getTilesUrl } e9.extend(this, fr); this.labelProcessor = new jA(this); this.callbackDataQueue = []; if (kE) { this.getTilesUrl = kE } var T = this; kF.on("indoor_data_refresh", function (kG) { if (!T.baseLayer) { return } T._refreshIndoorData(kG.uid, kG.floor) }); kF.on("custom_labels_ready", function (kG) { if (T.mapType !== BMAPGL_NORMAL_MAP && kG.model === "custom") { return } if ((kG.model === "custom") || kG.model === "mvt_" + T.drawIndex) { T._doWorkAfterLabelImageLoad(kG.virtualTile, kG.labelCanvas, null, kG.imgKey) } }); kF.on("glmoduleloaded", function () { if (!T.baseLayer) { return } T.updateAllIconsTextureCoords() }); kF.on("layer_update", function (kH) { if (T.dataType === 2 && kF.customLoaded && kF.areaCustomLoaded) { var kG = new fW("onlayer_clear"); kF.fire(kG) } }); kF.on("layer_clear", function (kG) { if (T.dataType === 2) { T.clearCache() } }); if (this.ontology && this.ontology._initEvent) { this.ontology._initEvent(kF) } } if (!kF.temp.layerZIndex) { kF.temp.layerZIndex = 0 } this.zIndex = this.zIndex || 1; if (kF.getRenderType() === "dom") { this.zIndex = kF.tileMgr.tileLayers.length } else { if (this.baseLayer) { this.zIndex = 0 } else { if (this.zIndex > 0) { this.adjustZIndex() } else { var e = kF._featureMgr.result.bkData; this.zIndex = e.length || 1 } } } if (!kF.temp.layid) { kF.temp.layid = 0 } if (!this.opts.mapType) { this.mapType = "BMAP_CUSTOM_LAYER_" + kF.temp.layid; kF.temp.layid++ } else { this.mapType = this.opts.mapType } var kC = ev[this.mapType]; if (!kC) { ev[this.mapType] = { tileUrls: [], tileSize: 256, baseUnits: 256, zoomLevelMin: 1, zoomLevelMax: 19, minZoom: 3, maxZoom: 19, minDataZoom: 3, maxDataZoom: 19, zoomLevelBase: 18, errorUrl: E.imgPath + "/blank.gif", bounds: new ik(new cG(-21364736, -10616832), new cG(23855104, 15859712)), imgExtend: "png" } } if (kF._renderType !== "webgl") { var kD = bS(kF.platform, '<div style="position:absolute;z-index:' + this.zIndex + '"></div>'); kD.style.display = ""; kD.style.left = Math.ceil(-kF.offsetX + kF.width / 2) + "px"; kD.style.top = Math.ceil(-kF.offsetY + kF.height / 2) + "px"; this.tilesDiv = kD } this.isCanvasMap = kF.isCanvasMap(); this.lastZoom = kF.getZoom(); var i = this; this.addEventListener("initDrawData", function (kG) { if (i.opts.boundary) { i.addBoundary(i.opts.boundary) } }); kF.on("destroy", function () { i.destroy() }) }, clearCache: function () { this.tileCache.clear(); this.map._featureMgr.clearData(this.drawIndex); this.map._featureMgr.setLabelData([], this.drawIndex); this.map._featureMgr.clearLabelOverlayData(this.drawIndex); this.labelProcessor.iconCache.clear() }, remove: function () { if (this.tilesDiv && this.tilesDiv.parentNode) { this.tilesDiv.innerHTML = ""; this.tilesDiv.parentNode.removeChild(this.tilesDiv) } delete this.tilesDiv }, getCopyright: function () { return this.copyright }, getMapType: function () { return this.mapType }, adjustZIndex: function () { if (this.map && this.map._featureMgr) { var e = this.map._featureMgr.result.bkData; while (e[this.zIndex]) { this.zIndex += 1 } } }, _getAdjoinZIndex: function (kD) { var T = this.zIndex; if (this.map && this.map._featureMgr) { var e = this.map._featureMgr.result.bkData; if (kD === "up") { for (var kC = this.zIndex + 1; kC < e.length; kC++) { if (e[kC]) { T = kC + 1; break } } } else { for (var kC = this.zIndex - 1; kC > 0; kC--) { if (e[kC]) { T = kC; break } } } } return T }, setZIndex: function (e) { this.setTargetZIndex(e) }, setTargetZIndex: function (e) { this.removeLabel && this.removeLabel(this.zIndex); this.zIndex = e; this.drawIndex = e; if (this.tilesDiv) { this.tilesDiv.style.zIndex = e } }, calcLoopParam: function (e, i) { return fc.calcLoopParam(e, i) }, addBoundary: function (kE) { if (!kE || !this.map) { return } if (typeof kE === "string") { kE = [kE] } for (var kC = 0; kC < kE.length; kC++) { var T = new BMapGL.Polygon(kE[kC]); if (T && b0(T._i)) { var kD = new fW("onbeforeaddoverlay", T); kD.overlay = T; kD.isLayerMask = true; this.map.dispatchEvent(kD); T._i(this.map); if (this.boundary) { this.boundary.push(T) } else { this.boundary = [T] } } } this.updateBoundary() }, clearBoundary: function () { this.boundary = false; this.updateBoundary() }, updateBoundary: function () { if (this.boundary === undefined || !this.map) { return } var i = this.map._featureMgr.result.bkData; if (i[this.zIndex]) { i[this.zIndex].showRegion = this.opts.showRegion; i[this.zIndex].boundary = this.boundary; this.map.dispatchEvent(new fW("onrefresh")); if (this.boundary === false) { var T = new fW("onremoveLayerMask"); T.hasLayerBoundary = this.map._featureMgr.hasLayerBoundary(); this.map.dispatchEvent(T) } } }, destroy: function () { this.copyright = null; this.clearCache() }, setTop: function (e) { this.isTop = !!e; if (this.map) { this.map._featureMgr.updateLayerMeta(this.zIndex, { isTop: this.isTop }); this.map.dispatchEvent(new fW("onupdate")) } }, setLowText: function (e) { this.isLowText = !!e; if (this.map) { this.map._featureMgr.updateLayerMeta(this.zIndex, { isLowText: this.isLowText }); this.map.dispatchEvent(new fW("onupdate")) } }, }); function o(i, e, T) { this.bounds = i; this.content = e; this.mapType = T } o.inherits(dh, "Copyright"); var eB = { get: function (e) { if (!eB.singleton) { eB.singleton = new gm(e) } return eB.singleton } }; function gm(i) { this._map = i; this._tileMgr = i.tileMgr; this._animationDiv = null; this._preAnimationDiv = null; this._animation = null; this._baseLayerDiv = null; this._transformStyleName = df.ifSupportCSS3("transform", true); this._transformOriginStyleName = df.ifSupportCSS3("transformOrigin", true); this._preZoomTimes = 1; this._preRenderTick = 1; this._enableCanvas2dMap = !!(i.getRenderType() === "canvas"); this._isIE9 = !!(e9.Browser.ie === 9); var e = this; i.addEventListener("maptypechange", function () { e.hide() }); i.addEventListener("load", function () { e.hide() }) } e9.extend(gm.prototype, { prepareLayer: function () { var kC = this._map; var e = this._tileMgr; this._canvas2dMapMgr = kC.canvas2dMapMgr; var T = this._baseLayerDiv = e.tilesDiv; if (!this._animationDiv) { var i = this._preAnimationDiv; if (i) { i.parentNode && i.parentNode.removeChild(i); this._preAnimationDiv = null } this._preAnimationDiv = this._animationDiv = T.cloneNode(true); kC.platform.insertBefore(this._animationDiv, kC.platform.firstChild) } this.show() }, prepareAniParam: function () { var kC = this._animationDiv; if (!kC) { return } var e = kC.children.length; var T; this._zoomAniInfo = []; for (var kD = e - 1; kD > -1; kD--) { var kE = {}; T = kC.children[kD].style; kE.top = parseInt(T.top, 10); kE.left = parseInt(T.left, 10); this._zoomAniInfo[kD] = kE } }, prepareLabelLayer: function () { var kD = this._map; if (this._enableCanvas2dMap && kD.canvas2dMapMgr) { if (this.touchZoomLabelCanvas) { this.touchZoomLabelCanvas.parentNode.removeChild(this.touchZoomLabelCanvas) } var i = kD.canvas2dMapMgr._labelCanvas; this.touchZoomLabelCanvas = i.cloneNode(false); var e = this.touchZoomLabelCanvas.getContext("2d"); e.drawImage(i, 0, 0); kD.platform.insertBefore(this.touchZoomLabelCanvas, kD.platform.firstChild); var kC = parseInt(i.style.left, 10); var T = parseInt(i.style.top, 10); this.touchZoomLabelCanvas.style.zIndex = 9; this.touchZoomLabelCanvas.style[this._transformOriginStyleName] = (this._fixPosition.x - (kD.offsetX + kC)) + "px " + (this._fixPosition.y - (kD.offsetY + T)) + "px"; i.style.visibility = "hidden" } }, show: function () { if (this._animationDiv) { this._animationDiv.style.visibility = "" } }, showLabel: function () { var i = this._map; if (this._enableCanvas2dMap && i.canvas2dMapMgr) { var e = i.canvas2dMapMgr._labelCanvas; if (e) { e.style.visibility = "" } if (this.touchZoomLabelCanvas) { this.touchZoomLabelCanvas.style.zIndex = -2; this.touchZoomLabelCanvas.style.visibility = "hidden" } } }, hide: function () { if (this._animationDiv) { this._animationDiv.style.visibility = "hidden" } if (this._preAnimationDiv) { this._preAnimationDiv.style.visibility = "hidden" } }, hideNonAnimationLayers: function () { var kC = this._map; if (kC.getRenderType() === "dom") { if (kC.overlayDiv) { kC.overlayDiv.style.visibility = "hidden" } if (kC.overlayDivEx) { kC.overlayDivEx.style.visibility = "hidden" } } var kE = kC.tileMgr.tileLayers; var kD; for (var T = 0, e = kE.length; T < e; T++) { kD = kE[T]; kD.tilesDiv.style.visibility = "hidden" } }, showNonAnimationLayers: function () { var kC = this._map; if (kC.getRenderType() === "dom") { if (kC.overlayDiv) { kC.overlayDiv.style.visibility = "" } if (kC.overlayDivEx) { kC.overlayDivEx.style.visibility = "" } } var kE = kC.tileMgr.tileLayers; var kD; for (var T = 0, e = kE.length; T < e; T++) { kD = kE[T]; kD.tilesDiv.style.visibility = "" } }, setFixPosition: function (e) { this._fixPosition = e }, setZoom: function (e, kI) { var kF = this._fixPosition; var kO = this._map; var kP = this._baseLayerDiv; var kG = { x: kF.x - parseInt(kP.style.left, 10) - kO.offsetX, y: kF.y - parseInt(kP.style.top, 10) - kO.offsetY }; var kC = this._animationDiv; if (!kC) { return } var kM = kC.children.length; var kK; var kN = this._transformStyleName; var kE = this._transformOriginStyleName; var kQ = this; var kS; var kH; for (var kL = kM - 1; kL > -1; kL--) { var kJ = this._zoomAniInfo[kL]; kK = kC.children[kL].style; var kD = kJ.left - kG.x; var T = kJ.top - kG.y; kJ.dx = kD * e - kD; kJ.dy = T * e - T; kJ.preDx = kD - kD; kJ.preDy = T - T; kS = kJ.preDx + (kJ.dx - kJ.preDx); kH = kJ.preDy + (kJ.dy - kJ.preDy) + kI; kK.left = kJ.left + kS + "px"; kK.top = kJ.top + kH + "px"; kK.width = kK.height = 256 * e + "px" } if (this._enableCanvas2dMap) { var kR = !kQ._isIE9 ? "translate3d(0px, " + kI + "px, 0) scale(" + e + ")" : "translate(0px, " + kI + "px) scale(" + e + ")"; this.touchZoomLabelCanvas.style[kN] = kR } }, setZoomFinish: function () { this._animationDiv = null }, startAnimation: function (kF) { this.prepareLayer(); this.hideNonAnimationLayers(); var kY = this._map; if (this.touchZoomLabelCanvas) { this.touchZoomLabelCanvas.style.display = "none" } kF = kF || {}; var kW = kF.zoomCount || 0; var kK = kF.fixPosition; var kU = kF.fixMCPosition; var kI = kF.pixOffset; this._zoomCount = kW; var kC = kY.getZoom(); var kX = kC + kW; var e = kY.config.enableContinuousZoom; var kO = 0.5; var kJ = 5; var T = Math.pow(2, kW); var k0 = this._baseLayerDiv; var kL = { x: kK.x - parseInt(k0.style.left, 10) - kY.offsetX, y: kK.y - parseInt(k0.style.top, 10) - kY.offsetY }; var kG = this._animationDiv; var kS = kG.children.length; var k2 = this._preZoomTimes; var kV = []; var kT = this._transformStyleName; var kH = this._transformOriginStyleName; for (var kR = kS - 1; kR > -1; kR--) { var kP = {}; var kQ = kG.children[kR].style; kP.top = parseInt(kQ.top, 10); kP.left = parseInt(kQ.left, 10); var kE = kP.left - kL.x; var kD = kP.top - kL.y; kP.dx = kE * T - kE; kP.dy = kD * T - kD; kP.preDx = kE * k2 - kE; kP.preDy = kD * k2 - kD; kV[kR] = kP } var kZ = this; var kN; var k1; var kM; this._zoomAni = new fL({ fps: 60, duration: e ? 500 : 1, transition: function (i) { i = i * kJ / (2 * kO); return kJ * i - kO * i * i }, render: function (lb) { lb = lb * (4 * kO) / (kJ * kJ); kN = k2 + lb * (T - k2); var k4 = kC + r(kN); var k9 = null; var k8 = 0; var lc = 0; if (kF.onAnimationBeforeLooping) { var ld = kF.onAnimationBeforeLooping(lb, k4); k9 = ld.loopingCenter; k8 = ld.yDiff; lc = ld.totalYDiff } for (var k5 = kV.length - 1; k5 > -1; k5--) { var k6 = kV[k5]; if (kG.children[k5]) { var la = kG.children[k5].style; k1 = k6.preDx + (k6.dx - k6.preDx) * lb - kI.width * lb; kM = k6.preDy + (k6.dy - k6.preDy) * lb - kI.height * lb + k8; la.left = k6.left + k1 + "px"; la.top = k6.top + kM + "px"; la.height = la.width = 256 * kN + "px" } } var k3 = kI.width * lb; var k7 = kI.height * lb; if (kY.isRestrict) { kZ._enableCanvas2dMap && kZ._canvas2dMapMgr.clearLabel() } else { kZ._enableCanvas2dMap && kZ._canvas2dMapMgr.drawLabel(kN, kK, kC, kX, kW, lb, k3, k7, lc, k8) } kZ._preZoomTimes = kN; kZ._preRenderTick = lb; kF.onAnimationLooping && kF.onAnimationLooping(lb, k4, k9) }, finish: function () { kZ._preZoomTimes = 1; kZ._zoomAni = null; kZ._animationDiv = null; kF.onAnimationFinish && kF.onAnimationFinish(); kZ.showNonAnimationLayers() } }); return this._zoomAni }, stopAnimation: function () { if (this._zoomAni) { this._zoomAni.stop(); this._zoomAni = null } } }); function kz(e) { this._initVars(e); this._initColorCanvas(); this._bindEvent(e) } e9.extend(kz.prototype, { _initVars: function (e) { this._map = e._map; this._canvas2dMapMgr = e; this._labelCtx = e._labelCtx; this.ratio = this._map.config.ratio; this.sizeRatio = this.ratio > 1 ? 2 : 1; this.RANK1 = 1000000; this.RANK2 = 2000000; this.RANK3 = 3000000; this.RANK4 = 4000000; this.RANK5 = 5000000 }, _initColorCanvas: function () { var i = 256, T = b6("canvas"), e = T.style; e.width = i + "px"; e.height = i + "px"; T.width = i; T.height = i; this._colorCvsSize = i; this._colorCvs = T; this._colorCtx = T.getContext("2d") }, getLabelImageData: function (kP) { var kO = kP.textImg; var T = kP.textPos; var kM = this.ratio; var kK = this.sizeRatio / kM; var kD = this._colorCtx; var kH = this._colorCvsSize; kD.clearRect(0, 0, kH, kH); var kJ = 0; var e = 0; var kG = 0; for (var kI = 0; kI < T.length; kI++) { if (T[kI].width > kJ) { kJ = T[kI].width; e = kI; kG = T[kI].drawX } } kJ /= kK; var kL = 0; for (var kI = 0, kF = T.length; kI < kF; kI++) { var kN = T[kI]; var kQ; if (kI === e) { kQ = 0 } else { kQ = kN.drawX - kG } kD.drawImage(kO, kN.srcX, kN.srcY, kN.width, kN.height, kQ, kL, kN.width / kK, kN.height / kK); if (kN.width / kK > kJ) { kJ = kN.width / kK } kL += kN.height / kK + 2 * kM } var kC = kD.getImageData(0, 0, kJ, kL); var kE = kD.getImageData(0, 0, kJ, kL); return [kC, kE] }, _bindEvent: function (i) { var e = this, T = i._map; T.addEventListener("onspotmouseover", function (kF) { if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) { return } if (kF.spots.length > 0) { var kE = kF.spots[0].userdata.uid; var kD = kF.spots[0].userdata.name; var kC = e.findLabelByUid(kE, kD); kC && e._toHighLightColor(kC) } }); T.addEventListener("onspotmouseout", function (kF) { if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) { return } if (kF.spots.length > 0) { var kE = kF.spots[0].userdata.uid; var kD = kF.spots[0].userdata.name; var kC = e.findLabelByUid(kE, kD); kC && e._toDefaultColor(kC) } }); T.addEventListener("onspotclick", function (kF) { if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) { return } if (kF.spots && kF.spots.length > 0) { var kE = kF.spots[0].userdata.uid; var kD = kF.spots[0].userdata.name; var kC = e.findLabelByUid(kE, kD); kC && e._changeBaseMapState(kC) } else { e._recoverNormalState() } }); T.on("spot_status_reset", function () { e._recoverNormalState() }); T.on("spot_highlight", function (kD) { var kC = e.findLabelByUid(kD.uid); kC && e._changeBaseMapState(kC) }) }, _getTextBound: function (kN) { if (!kN.textPos) { return null } var kL = this.ratio; var kJ = this.sizeRatio / kL; var T = kN.textPos; var kM = kN.baseDrawX; var kK = kN.baseDrawY; var kH = kM * kL + (T[0].drawX - kM) / kJ; var kF = kK * kL + (T[0].drawY - kK) / kJ; var kD = kH + T[0].width / kJ; var e = kF + T[0].height / kJ; for (var kI = 0, kG = T.length; kI < kG; kI++) { var kO = T[kI]; var kE = kM * kL + (kO.drawX - kM) / kJ; if (kE < kH) { kH = kE } var kC = kK * kL + (kO.drawY - kK) / kJ; if (kC < kF) { kF = kC } if (kE + kO.width > kD) { kD = kE + kO.width } if (kC + kO.height > e) { e = kC + kO.height } } return [kH, kF, kD, e] }, _toHighLightColor: function (T) { if (T._tempRank && T._tempRank == this.RANK5) { return } var kG = this._getTextBound(T); if (!kG) { return } var kC = Math.round(kG[0]); var i = Math.round(kG[1]); var e = this.getLabelImageData(T); var kE = e[0]; var kD = e[1]; var kF = this._canvas2dMapMgr.getFilterImageData(kE, this.RANK5); T._oldImgData = kD; this._labelCtx.putImageData(kF, kC, i) }, _toDefaultColor: function (e) { if (e._tempRank && e._tempRank == this.RANK5) { return } if (e._oldImgData) { var i = this.sizeRatio; var T = this._getTextBound(e); if (!T) { return } this._labelCtx.putImageData(e._oldImgData, Math.round(T[0]), Math.round(T[1])); e._oldImgData = null } }, _changeBaseMapState: function (kC) { var T = this._canvas2dMapMgr; var i = kC.guid; var e = kC.guidExt; var kD = { guid: i, name: kC.name, guidExt: e }; T._labelStrategy.setStrategyInfo(kD); T._loadData() }, _recoverNormalState: function () { var e = this._canvas2dMapMgr; e._labelStrategy.setStrategyInfo(null); e._loadData() }, findLabelByUid: function (kE, kC) { var kG = this._canvas2dMapMgr, e = kG._computedLabel; for (var kD = 0, T = e.length; kD < T; kD++) { var kF = e[kD]; if (!kG.isClickableLabel(kF)) { continue } if (kE && kF.guid === kE) { return kF } if (kC && kF.name === kC) { return kF } } return null } }); function H(e) { this._initVars(e) } e9.extend(H.prototype, { _initVars: function (e) { this._map = e._map; this._canvas2dMapMgr = e; this.ratio = this._map.config.ratio; this._strategyInfo = null; this.RANK1 = 1000000; this.RANK2 = 2000000; this.RANK3 = 3000000; this.RANK4 = 4000000; this.RANK5 = 5000000 }, setStrategyInfo: function (e) { this._strategyInfo = e }, preComputeLabel: function (kI, lA, li, kU, lu, lO) { var lc = [], kQ = kI._centerX, kO = kI._centerY, lP = kU * lu; var lp = this.ratio; var kH = this._map.getZoom(); var k7 = 0; if (kH === 5) { k7 = 4 } if (kH === 8) { k7 = -6 } kI.sort(function (ll, i) { if (ll.x * ll.y < i.x * i.y) { return -1 } else { return 1 } }); for (var k9 = 0, k5 = kI.length; k9 < k5; k9++) { var lF = kI[k9], k0 = lF.x, kX = lF.y, kV = lF.z; var k2 = fc.calcLoopParam(k0, kV).offsetX; var ln = k0 * lP, lm = (kX + 1) * lP, kC = (ln - kQ) / kU + lA / 2 + k2, T = (kO - lm) / kU + li / 2; for (var k6 = 0, lJ = lF.length; k6 < lJ; k6++) { var kK = lF[k6], kR = undefined, kP = undefined, lH = undefined, lG = undefined; var lw = kK.baseDrawX = kC + kK.baseX; var lv = kK.baseDrawY = T + kK.baseY; if (kK.type == "fixed") { var lg = kK.iconPos, kT = kK.textPos, lL = kK.textImg; if (lg) { lg.drawX = kC + lg.destX; lg.drawY = T + lg.destY; kR = lg.drawX; kP = lg.drawY; lH = lg.drawX + lg.width; lG = lg.drawY + lg.height } if (kT && lL) { for (var lx = 0; lx < kT.length; lx++) { var lK = kT[lx]; lK.drawX = kC + lK.destX; lK.drawY = T + lK.destY; if (!kR) { kR = lK.drawX; kP = lK.drawY; lH = lK.drawX + lK.width; lG = lK.drawY + lK.height } else { if (lK.drawX < kR) { kR = lK.drawX } if (lK.drawY < kP) { kP = lK.drawY } if (lK.drawX + lK.width > lH) { lH = lK.drawX + lK.width } if (lK.drawY + lK.height > lG) { lG = lK.drawY + lK.height } } } } } else { kK.tileX = kC; kK.tileY = T; kR = kC + kK.minXOriginal; kP = T + kK.minYOriginal; lH = kC + kK.maxXOriginal; lG = T + kK.maxYOriginal } if (kR != undefined) { var lz = lw + (kR - lw) / lp; var ly = lv + (kP - lv) / lp; var la = lw + (lH - lw) / lp; var k8 = lv + (lG - lv) / lp; kK.minX = lz; kK.minY = ly; kK.maxX = la; kK.maxY = k8; var lD = (lz + la) / 2, lC = (ly + k8) / 2, lj = kQ + (lD - lA / 2) * kU, lh = kO + (li / 2 - lC) * kU; kK.geoX = lj; kK.geoY = lh; lc.push(kK) } } } if (lO) { for (var k9 = 0, k5 = lO.length; k9 < k5; k9++) { var k4 = lO[k9]; var ls = k4[0]; var kL = k4[1]; var lg = ls.iconPos; var kF = lg.geoX; var kD = lg.geoY; var lw = (kF - kQ) / kU + lA / 2; var lv = (kO - kD) / kU + li / 2; var kR = lw + lg.destX; var kP = lv + lg.destY; var lH = kR + lg.width; var lG = kP + lg.height; ls.textPos = ls.textPos || ls._textPos; var kT = ls.textPos; var lB = kT[0]; var kZ = lw + lB.destX; var kN = lv + lB.destY; if (kN < kP) { kP = kN } if (kZ + lB.width > lH) { lH = kZ + lB.width } if (kN + lB.height > lG) { lG = kN + lB.height } if (kT.length === 2) { var kY = kT[1]; var kW = lw + kY.destX; var kM = lv + kY.destY; if (kM < kP) { kP = kM } if (kW + kY.width > lH) { lH = kW + kY.width } if (kM + kY.height > lG) { lG = kM + kY.height } } ls._tempBounds = [kR, kP, lH, lG]; var lg = kL.iconPos; var kF = lg.geoX; var kD = lg.geoY; var lw = (kF - kQ) / kU + lA / 2; var lv = (kO - kD) / kU + li / 2; var kR = lw + lg.destX; var kP = lv + lg.destY; var lH = kR + lg.width; var lG = kP + lg.height; kL.textPos = kL.textPos || kL._textPos; var kT = kL.textPos; var lB = kT[0]; var kZ = lw + lB.destX; var kN = lv + lB.destY; if (kZ < kR) { kR = kZ } if (kN < kP) { kP = kN } if (kN + lB.height > lG) { lG = kN + lB.height } if (kT.length === 2) { var kY = kT[1]; var kW = lw + kY.destX; var kM = lv + kY.destY; if (kW < kR) { kR = kW } if (kM < kP) { kP = kM } if (kM + kY.height > lG) { lG = kM + kY.height } } kL._tempBounds = [kR, kP, lH, lG] } for (var k9 = 0, k5 = lO.length; k9 < k5; k9++) { var k4 = lO[k9]; var ls = k4[0]; var kL = k4[1]; if (k9 === 0 && kL.textPos) { kL._textPos = kL.textPos; delete kL.textPos } var lE = ls; if (!ls.textPos && kL.textPos) { lE = kL } var lI = lE._tempBounds; for (k6 = k9 + 1; k6 < k5; k6++) { var k3 = lO[k6]; var ld = k3[0]; var lN = k3[1]; var kS = 0; var lM = ld._tempBounds; if (!(lI[2] < lM[0] || lI[0] > lM[2] || lI[3] < lM[1] || lI[1] > lM[3])) { kS++; if (ld.textPos) { ld._textPos = ld.textPos; delete ld.textPos } } var lM = lN._tempBounds; if (!(lI[2] < lM[0] || lI[0] > lM[2] || lI[3] < lM[1] || lI[1] > lM[3])) { kS++; if (lN.textPos) { lN._textPos = lN.textPos; delete lN.textPos } } if (kS >= 2) { if (lE.textPos) { lE._textPos = lE.textPos; delete lE.textPos } } } } for (var k9 = 0, k5 = lO.length; k9 < k5; k9++) { var k4 = lO[k9]; var ls = k4[0]; var kL = k4[1]; var le = ls; if (!ls.textPos && kL.textPos) { le = kL } var lg = le.iconPos; var kF = lg.geoX; var kD = lg.geoY; var lw = le.baseDrawX = (kF - kQ) / kU + lA / 2; var lv = le.baseDrawY = (kO - kD) / kU + li / 2; lg.drawX = lw + lg.destX; lg.drawY = lv + lg.destY; var kR = lg.drawX; var kP = lg.drawY; var lH = lg.drawX + lg.width; var lG = lg.drawY + lg.height; var kT = le.textPos; if (kT) { var lB = kT[0]; lB.drawX = lw + lB.destX; lB.drawY = lv + lB.destY; if (lB.drawX < kR) { kR = lB.drawX } if (lB.drawY < kP) { kP = lB.drawY } if (lB.drawX + lB.width > lH) { lH = lB.drawX + lB.width } if (lB.drawY + lB.height > lG) { lG = lB.drawY + lB.height } if (kT.length === 2) { var kY = kT[1]; kY.drawX = lw + kY.destX; kY.drawY = lv + kY.destY; if (kY.drawX < kR) { kR = kY.drawX } if (kY.drawY < kP) { kP = kY.drawY } if (kY.drawX + kY.width > lH) { lH = kY.drawX + kY.width } if (kY.drawY + kY.height > lG) { lG = kY.drawY + kY.height } } } var lz = lw + (kR - lw) / lp; var ly = lv + (kP - lv) / lp; var la = lw + (lH - lw) / lp; var k8 = lv + (lG - lv) / lp; le.minX = lz; le.minY = ly; le.maxX = la; le.maxY = k8; var lr = (lz + la) / 2; var lq = (ly + k8) / 2; var kG = kQ + (lr - lA / 2) * kU; var kE = kO + (li / 2 - lq) * kU; le.geoX = kG; le.geoY = kE; lc.push(le) } } var lt = this._strategyInfo; if (lt) { var lb = lt.guid; var lk = lt.name; var k1 = lt.guidExt; for (var k9 = 0, k5 = lc.length; k9 < k5; k9++) { var kJ = lc[k9]; delete kJ._tempRank; if (!this._canvas2dMapMgr.isClickableLabel(kJ) || (k1 === 1 && !kJ.guidExt)) { continue } if ((lb && lb === kJ.guid) || (lk && lk === kJ.name)) { kJ._tempRank = this.RANK5 } } } else { for (var k9 = 0, k5 = lc.length; k9 < k5; k9++) { var kJ = lc[k9]; if (kJ.type == "line" || !kJ.iconPos) { continue } delete kJ._tempRank } } lc.sort(function (lQ, ll) { var lR = lQ._tempRank ? lQ._tempRank : lQ.rank, i = ll._tempRank ? ll._tempRank : ll.rank; if (lR === i) { return lQ.baseX - ll.baseX } return i - lR }); for (var k9 = 0, k5 = lc.length; k9 < k5; k9++) { var lE = lc[k9]; lE.isDel = false; lE.isFadeout = false; lE._schedule = 0; lE._isIgnore = false; lE.arrIntersectIndex = []; for (k6 = k9 + 1; k6 < k5; k6++) { var lf = lc[k6]; if (!(lE.maxX - k7 < lf.minX || lE.minX > lf.maxX - k7 || lE.maxY - k7 < lf.minY || lE.minY > lf.maxY - k7)) { lE.arrIntersectIndex.push(k6) } } } for (var k9 = 0, k5 = lc.length; k9 < k5; k9++) { var kJ = lc[k9]; if (kJ.isDel == false) { var e = kJ.arrIntersectIndex; for (var k6 = 0, lJ = e.length; k6 < lJ; k6++) { var lo = lc[e[k6]]; lo.isDel = true; if (lo.guidExt === 1) { lo.isDel = false } } } } return lc } }); function ab(e) { this._map = e; this._initCanvas(); this._initVars(); this._bindEvent(); this._tileType = il.getInstance("na") } bG.register(function (i) { if (i.getRenderType() === "canvas") { var e = i.config.style; if (bG["FeatureStyle" + e]) { i.canvas2dMapMgr = new ab(i) } else { i.loadMapStyleFiles(function () { i.canvas2dMapMgr = new ab(i); i.canvas2dMapMgr._loadData() }) } } }); e9.extend(ab.prototype, { _initCanvas: function () { var kF = this._map, kD = kF.getSize(), kC = kD.width, i = kD.height, e = kF.platform, kG = b6("canvas"), kE = kG.style; var T = this.ratio = kF.config.ratio; this._width = kC; this._height = i; kE.cssText = "position: absolute;left:0;top:0;width:" + kC + "px;height:" + i + "px;z-index:100;"; kG.width = kC * T; kG.height = i * T; this._labelCanvas = kG; this._labelCtx = kG.getContext("2d"); e.appendChild(kG) }, _initVars: function () { var e = kd("ditu", "normal"); this._udt = e.udt; this._version = e.ver; this._labelDataUrls = ev.B_NORMAL_MAP.vectorTileUrls; this._style = bG["FeatureStyle" + this._map.config.style]; this._labelCount = 0; this._vectorDrawLib = new hl(this); this._cache = { maxNum: 500, delNum: 50, arrCache: [] }; this._computedLabel = null; this._spotData = null; this._labelStrategy = new H(this); this._labelClick = new kz(this); this._biz = new eD(this); this._map.temp.isPermitSpotOver = true; this.labelStyleParam = "pl"; if (this._map.getMapType() === BMAP_SATELLITE_MAP) { this.labelStyleParam = "sl" } this.statRequestCount = 0; this.statResponseCount = 0 }, _resizeHandler: function (kE) { var kG = this, i = kG._map, kD = i.getSize(), T = kD.width, kI = kD.height; var kF = this.ratio; var kJ = this._labelCanvas, kC = kJ.style; kC.width = T + "px"; kC.height = kI + "px"; kJ.width = T * kF; kJ.height = kI * kF; kG._width = T; kG._height = kI; var kH = true; kG._loadData(kH) }, _bindEvent: function () { var e = this, i = e._map; i.addEventListener("load", function (T) { e.clearLabel(); e._loadData() }); i.addEventListener("zoomend", function (T) { if (!T.notClearLabel) { e.clearLabel() } e._loadData() }); i.addEventListener("moveend", function (T) { e._loadData() }); i.addEventListener("resize", function (T) { e._resizeHandler(T) }); i.addEventListener("maptypechange", function (T) { if (T.mapType === BMAP_EARTH_MAP) { e.hideLabelCanvas() } else { e.showLabelCanvas(); if (T.mapType === BMAPGL_NORMAL_MAP) { e.labelStyleParam = "pl" } else { if (T.mapType === BMAP_SATELLITE_MAP) { e.labelStyleParam = "sl" } } e._loadData() } }); i.addEventListener("streetlayer_show", function (T) { if (this.isCanvasMap()) { e.showLabelCanvas() } }); i.addEventListener("streetlayer_hide", function (T) { if (this.isCanvasMap()) { e.hideLabelCanvas() } }); i.addEventListener("loadbizdata", function (kC) { var T = kC.data; e._biz.proecessBizData(T, function () { e.updateLabel() }) }); i.addEventListener("unloadbizdata", function (T) { e._biz.clearBizData(); e.updateLabel() }); e.isDrawText = false; setTimeout(function () { if (!e.isDrawText) { i.dispatchEvent(new fW("onmapwhitescreen")) } }, 10000) }, getStyle: function () { return this._style }, _getZoomUnits: function (e) { return Math.pow(2, 18 - e) }, _createCacheForm: function (T, kG, kF, i) { var kE = this; var e = kE._cache; var kC = e.arrCache; var kH = this._getLabelId(T, kG, kF, i); var kD = { id: kH, updateLabelCounter: 0 }; kC.push(kD); kC[kH] = kD; return kD }, _getLabelId: function (i, kC, T, e) { return "_" + i + "_" + kC + "_" + T + "_" + e + "_" + this.labelStyleParam }, _getCache: function (i, kC, T, e) { return this._cache.arrCache[this._getLabelId(i, kC, T, e)] }, _setCacheValue: function (kD, kQ, kO, kC, kJ) { var kL = this; var e = kL._cache; var kF = e.arrCache; var kH = e.maxNum; var kE = e.delNum; var kP = this._getLabelId(kD, kQ, kO, kC); var kK = kF[kP]; if (kJ) { kK.lb = kJ } if (kF.length > kH) { var T = kF.splice(0, kE); for (var kI = 0, kG = T.length; kI < kG; kI++) { var kM = T[kI], kN = kM.id; if (kF[kN].lb) { kF[kN].lb = null } kF[kN] = null; delete kF[kN] } T = null } }, _loadData: function (kO) { var k7 = this._map; if (!k7.isCanvasMap()) { return } var kH = k7.getCenterIn(); var k6 = fc.calcLoopCenterPoint(kH); var kG = this._tileType; var kJ = this._width / 2; var kV = this._height; var kW = k7.getZoom(); var kS = kG.getDataZoom(kW); var kL = k7.getZoomUnits(kW); var kR = kL * kJ; var k5 = k6.lng - kR; var k4 = k6.lng + kR; var kP = fc.isAddWidth(k5, k4); kJ = kP ? kJ * 1.5 : kJ; var kQ = kG.getTileSize(kW); var kD = kG.getMercatorSize(kW, kS); var kK = Math.floor(k6.lng / kD); var kM = Math.floor(k6.lat / kD); var kE = [kK, kM, (k6.lng - kK * kD) / kD * kQ, (k6.lat - kM * kD) / kD * kQ]; var kY = kE[0] - Math.ceil((kJ - kE[2]) / kQ); var k2 = kE[1] - Math.ceil((kV / 2 - kE[3]) / kQ); var kU = kE[0] + Math.ceil((kJ + kE[2]) / kQ); var kZ = kE[1] + Math.ceil((kV / 2 + kE[3]) / kQ); k7.temp.isPermitSpotOver = false; var e = []; for (var k1 = kY; k1 < kU; k1++) { for (var k0 = k2; k0 < kZ; k0++) { e.push([k1, k0, kS]); var kT = "id_" + k1 + "_" + k0 + "_" + kW; e[kT] = true } } e._zoom = kS; e = fc.calcLoopTiles(e, kW); e.sort((function (i) { return function (k9, la) { return ((0.4 * Math.abs(k9[0] - i[0]) + 0.6 * Math.abs(k9[1] - i[1])) - (0.4 * Math.abs(la[0] - i[0]) + 0.6 * Math.abs(la[1] - i[1]))) } })([kE[0], kE[1]])); var kN = this._cache.arrCache; this._curViewLabels = []; var kC = "viewKey_" + Math.floor(kH.lng) + "_" + Math.floor(kH.lat) + "_" + kW; this.statRequestCount = 0; this.statResponseCount = 0; this._labelCount += e.length; var kI = kW; for (var k1 = 0, kX = e.length; k1 < kX; k1++) { var kK = e[k1][0]; var kM = e[k1][1]; var T = e[k1][2]; var kF = this._getLabelId(kK, kM, T, kI); var k3 = kN[kF]; if (!k3) { k3 = this._createCacheForm(kK, kM, T, kI) } if (typeof k3.lb === "undefined") { k3.lb = null; this._loadLabelData(kK, kM, T, kI, kQ, kC); this.statRequestCount++ } else { if (k3.lb) { this._curViewLabels.push(k3.lb); this._labelCount-- } else { if (kO) { this._loadLabelData(kK, kM, T, kI, kQ, kC) } k3.updateLabelCounter++ } } } if (this._labelCount === 0) { this.updateLabel() } var k8 = this; if (k8.errorTimer) { clearTimeout(k8.errorTimer) } k8.errorTimer = setTimeout(function () { if (k8._labelCount !== 0) { k8._labelCount = 0; k8.updateLabel() } var la = new fW("onloaddatatimeout"); var lb = 0; var k9 = 0; var lc = 0; var i = 0; if (k8.statRequestCount === k8.statResponseCount) { lb = 1 } else { k9 = 1 } if (k9 === 1) { i = k8.statRequestCount - k8.statResponseCount; lc = k8.statResponseCount } la.noTimeoutCount = lb; la.timeoutCount = k9; la.timeoutNoLoaded = i; la.timeoutLoaded = lc; k8._map.dispatchEvent(la) }, 500) }, clearLabel: function () { var e = this._width; var T = this._height; var i = this.ratio; this._labelCtx.clearRect(0, 0, e * i, T * i) }, updateLabel: function () { var i = this._map; var e = i.getCenterIn(); var kC = this._width; var kF = this._height; var kI = i.getZoom(); var kH = this._tileType.getTileSize(kI); var kG = this._getZoomUnits(kI); var T = this._labelCtx; this._labelCanvas.style.left = -i.offsetX + "px"; this._labelCanvas.style.top = -i.offsetY + "px"; var kE = this._curViewLabels; kE._centerX = e.lng; kE._centerY = e.lat; var kD = this._biz.bizLabels; this._computedLabel = this._labelStrategy.preComputeLabel(kE, kC, kF, kG, kH, kD); this._computedLabel._zoom = kI; this.clearLabel(); this._vectorDrawLib.drawIconAndText(T, this._computedLabel, kI); this._addSpotData(); i.temp.isPermitSpotOver = true; if (kE.length > 0) { this.isDrawText = true } }, _loadLabelData: function (kL, kK, kJ, T, kM, e) { var kE = kL.toString(); var kC = kK.toString(); var kG = "cbk_" + kE.replace("-", "_") + "_" + kC.replace("-", "__") + "_" + Math.floor(kJ); var kQ = fF + "." + kG; var kP = this._labelDataUrls; var kI = Math.abs(kL + kK) % kP.length; var kV = kP[kI]; if (window.offLineIPAddress) { kV = window.offLineIPAddress + "pvd/" } var i = this.labelStyleParam; var kO = "?qt=vtile"; var kR = ""; if (this._map.config.style !== "default") { kR = "&styleId=1" } var kN = "x={x}&y={y}&z={z}&udt={udt}&v={v}&styles={styles}" + kR + "&textonly=1&textimg=1&scaler={scaler}&fn=" + encodeURIComponent(kQ); var kS = fc.calcLoopParam(kL, kJ).col; var kH = this.ratio > 1 ? 2 : 1; var kF = kN.replace(/{x}/, kS).replace(/{y}/, kK).replace(/{z}/, Math.floor(kJ)).replace(/{styles}/, i).replace(/{udt}/, this._udt).replace(/{v}/, this._version).replace(/{scaler}/, kH); var kD = kV + kO + "&param=" + window.encodeURIComponent(e5(kF)); var kU = this; var kT = kU._map; bG[kG] = function (kW) { kU._vectorDrawLib.parseLabelData(kW, kL, kK, kJ, T, kM, function (k1) { var kY = kT.getCenterIn(); var k2 = kT.getZoom(); var k4 = "viewKey_" + Math.floor(kY.lng) + "_" + Math.floor(kY.lat) + "_" + k2; kU._labelCount--; var k5 = kU._getCache(kL, kK, kJ, T).updateLabelCounter; kU._labelCount -= k5; var kZ = kU._curViewLabels; if (k4 === e || (kU._labelCount < 0 && k2 === kJ)) { kZ.push(k1) } if (k4 === e) { kU.statResponseCount++ } if (kU._labelCount <= 0) { var kX = (new Date()).getTime(); kU.updateLabel(); var k0 = (new Date()).getTime(); var k3 = new fW("oncanvasmaploaded"); k3.drawTime = k0 - kX; if (kU.statResponseCount === kU.statRequestCount) { k3.isAllLoadedDrawing = true } kT.dispatchEvent(k3) } kU._setCacheValue(kL, kK, kJ, T, k1); delete bG[kG] }) }; g4.load(kD) }, drawLabel: function (T, kC, kJ, i, kH, kD, e, kE, kI, kF) { var kG = this; if (!kG._computedLabel) { return } if (kG._computedLabel._zoom !== kJ) { kG.clearLabel(); return } kG._map.temp.isPermitSpotOver = false; kG.clearLabel(); kG._vectorDrawLib.zoomingIconAndText(this._labelCtx, kG._computedLabel, T, kC, i, kH, kD, e, kE, kI, kF) }, _addSpotData: function () { this._spotData = []; var kJ = this._map.getZoom(); for (var kE = 0, kD = this._computedLabel.length; kE < kD; kE++) { var kG = this._computedLabel[kE]; if (!this.isClickableLabel(kG) || (kG.guidExt === 1 && kG.startScale > kJ)) { continue } var kF = []; kF[0] = (kG.minX - kG.maxX) / 2; kF[1] = (kG.minY - kG.maxY) / 2; kF[2] = (kG.maxX - kG.minX) / 2; kF[3] = (kG.maxY - kG.minY) / 2; var kC = null; if (kG.iconPos) { kC = new cG(kG.iconPos.geoX, kG.iconPos.geoY) } var T = kG.name ? kG.name.replace("\\\\", "<br>") : ""; if (kG.iconPos && kG.iconPos.iconType.indexOf("ditie") > -1 && this._map.getZoom() > 14) { T = "" } var kI = { n: T, pt: new cG(kG.geoX, kG.geoY), userdata: { iconPoint: kC, uid: kG.guid, name: T, type: kG.iconPos ? kG.iconPos.iconType : "", iconImg: kG.iconImg, mapPoi: true, adver_log: kG.adver_log || "" }, bd: kF, tag: "MAP_SPOT_INFO" }; this._spotData.push(kI) } var kH = new fW("onspotsdataready"); kH.spots = this._spotData; this._map._spotDataOnCanvas = this._spotData; this._map.dispatchEvent(kH) }, isClickableLabel: function (e) { if (e.isDel || (!e.guid && !e.name)) { return false } return true }, getFilterImageData: function (T, kF) { var kG = T.data, kE = this._labelStrategy, kF = parseInt(kF); for (var kH = 0, kD = kG.length; kH < kD; kH += 4) { var e = kG[kH], kI = kG[kH + 1], kJ = kG[kH + 2], kK = kG[kH + 3]; if (kK === 0) { continue } var kC = Math.round((e + kI + kJ) / 3); var kL = kC - 90; kL = kL < 0 ? 0 : kL; if (kF === kE.RANK5) { kG[kH] = 51 + kL * 1.3; kG[kH + 1] = 133 + kL * 0.8; kG[kH + 2] = 255 } } return T }, showLabelCanvas: function () { this._labelCanvas.style.visibility = "" }, hideLabelCanvas: function () { this._labelCanvas.style.visibility = "hidden" } }); var aW = 5; var ju = 4; var gQ = 3; var P = 2; var eC = 1; var hO = 0; var kA = 3; var iL = 5; var fu = { 3: { start: 3, base: 3 }, 4: { start: 4, base: 5 }, 5: { start: 4, base: 5 }, 6: { start: 6, base: 7 }, 7: { start: 6, base: 7 }, 8: { start: 8, base: 9 }, 9: { start: 8, base: 9 }, 10: { start: 10, base: 10 }, 11: { start: 11, base: 12 }, 12: { start: 11, base: 12 }, 13: { start: 11, base: 12 }, 14: { start: 14, base: 15 }, 15: { start: 14, base: 15 }, 16: { start: 16, base: 17 }, 17: { start: 16, base: 17 }, 18: { start: 18, base: 19 }, 19: { start: 18, base: 19 }, 20: { start: 18, base: 19 }, 21: { start: 18, base: 19 } }; function hl(kC) { this._canvas2dMapMgr = kC; var i = this.ratio = kC._map.config.ratio; this._featureStyle = null; this._map = kC._map; var T = bH(); var e = "udt=" + T.udt + "&v=" + T.ver; this.sizeRatio = this.ratio > 1 ? 2 : 1; this._binaryCache = {}; this._iconCache = {}; this._initColorCanvas() } e9.extend(hl.prototype, { _initColorCanvas: function () { var i = 256, T = b6("canvas"), e = T.style; e.width = i + "px"; e.height = i + "px"; T.width = i; T.height = i; this._colorCvs = T; this._colorCtx = T.getContext("2d") }, parseLabelData: function (i, kE, kD, kC, e, kH, kG) { if (!this._featureStyle) { this._featureStyle = this._canvas2dMapMgr.getStyle() } if (!i || !i[0]) { kG([]); return } var kF = this._map.getZoomUnits(); var T = this; this.loadTextPng(i, kH, kE, kD, kC, e, kF, kG) }, loadTextPng: function (kT, kK, kI, kH, kF, i, kD, kC) { var kS = this; var e = kT[5]; var kR = this._map; var kO = kR.getZoom(); var T = kR.getSize(); var kP = T.width; var kN = T.height; var kQ = kR.getCenterIn(); var kG = kQ.lng; var kE = kQ.lat; var kM = kI * kK * kD; var kL = (kH + 1) * kK * kD; if (e) { var kJ = new Image(); kJ.onload = function () { kS.calcIconAndTextInfo(kT, kJ, kK, kI, kH, kF, i, kD, kM, kL, kC); delete this.onload }; kJ.src = e } else { setTimeout(function () { kS.calcIconAndTextInfo(kT, null, kK, kI, kH, kF, i, kD, kM, kL, kC) }, 1) } }, calcIconAndTextInfo: function (kV, kM, kN, kL, kI, kG, kC, kE, kP, kO, kD) { var kU = this; var kT = kU._featureStyle; var kJ = []; kJ.x = kL; kJ.y = kI; kJ.z = kG; var kK = kU._canvas2dMapMgr, T = kL * kE * kN, kS = (kI + 1) * kE * kN, kF = { tileLeft: T, tileTop: kS, zoomUnits: kE }; var e = []; if (kV[0]) { for (var kQ = 0; kQ < kV[0].length; kQ++) { if (kV[0][kQ][0] === kA) { e.push(kV[0][kQ]) } } } var kH = kV[2] || []; for (var kQ = 0; kQ < e.length; kQ++) { this._getFixedLabelInfo(e[kQ], kM, kC, kE, kN, kP, kO, kJ) } var kR = Math.pow(2, kC - kG); for (kQ = 0; kQ < kH.length; kQ++) { this._getLineLabelInfo(kH[kQ], kM, kG, kC, kE, kN, kP, kO, kR, kJ) } kD(kJ) }, _getFixedLabelInfo: function (kM, kQ, kD, kH, kR, kU, kT, kW) { var kL = kM[1]; if (!kL) { return } var kY = this._map.getZoom(); var k6 = this._map.config.style; var k7 = this._featureStyle; var kI = kD; if (kI === 9) { kI = 8 } for (var k3 = 0; k3 < kL.length; k3++) { var k8 = kL[k3]; var e = k8[0]; var kC = a3.getStyleFromCache(k6, e, "point", kI, k7); var k2 = a3.getStyleFromCache(k6, e, "pointText", kI, k7); if ((!k2 || k2.length === 0) && (!kC || kC.length === 0)) { if (kI === 5) { var kG = k8[1]; if (!kG) { continue } for (var kZ = 0; kZ < kG.length; kZ++) { var kX = kG[kZ][4]; if (kX && kX[7] === "北京") { kC = a3.getStyleFromCache(k6, e, "point", 6, k7); k2 = a3.getStyleFromCache(k6, e, "pointText", 6, k7); break } else { continue } } } else { continue } } var kG = k8[1]; if (!kG) { continue } var k4 = null; var kJ = 1; var T = 0; var kP = 0; if (kC && kC[0]) { kC = kC[0]; k4 = kC.icon; kJ = kC.zoom ? kC.zoom / 100 : 1 } else { kC = null } for (var kZ = 0; kZ < kG.length; kZ++) { var kX = kG[kZ][4]; if (!kX) { continue } var k1 = kX[2]; if (!this._isVisible(k1, kY)) { continue } var kK = kX[12]; if (k2 && k2.length > 0 && !kK) { continue } var kO = Math.round(kX[0] / 100); var kN = Math.round(kX[1] / 100); var k0 = { lng: kU + kO, lat: kT - (kR * kH - kN) }; var kF = kO / kH; var kE = kR - kN / kH; var kS = kX[7] || ""; var k5 = kX[5]; var kV = { type: "fixed", name: kS, textImg: kQ, rank: kX[4], baseX: kF, baseY: kE, iconPos: null, textPos: null, guid: kX[3] || "", tracer: k1, direction: k5, startScale: 3 }; if ((k5 !== ju && kK || !kK) && k4 !== null) { kV.iconPos = this._getIconPosition(k4, kJ, kF, kE, k0); if (kV.iconPos) { T = kV.iconPos.width; kP = kV.iconPos.height } } if (T === 0) { kV.direction = ju } if (kK) { kV.textPos = this._getTextDrawData(kX, kF, kE, T, kP) } if (kV.textPos || kV.iconPos) { kW.push(kV) } } } }, _isVisible: function (e, i) { var kC; if (!this._binaryCache[e]) { kC = e.toString(2); if (kC.length < 8) { kC = new Array(8 - kC.length + 1).join("0") + kC } this._binaryCache[e] = kC } kC = this._binaryCache[e]; var T = fu[i].start; return kC[i - T] === "1" }, _getIconPosition: function (kG, kE, T, i, e) { var kC = this._map.config.style; var kH = bG["iconSetInfo" + kC][kG]; if (!kH) { if (kG.charCodeAt(0) >= 48 && kG.charCodeAt(0) <= 57) { kH = bG["iconSetInfo" + kC]["_" + kG] } } if (!kH) { return null } var kD = kH[0]; var kF = kH[1]; kD = kD * kE; kF = kF * kE; return { srcX: 0, srcY: 0, destX: T - kD / 2, destY: i - kF / 2, width: kD, height: kF, geoX: e.lng, geoY: e.lat, mcPt: e, iconType: kG } }, _getTextDrawData: function (kN, kM, kL, kC, kJ) { var kS = kN[5]; if (typeof kS !== "number") { kS = 0 } var kH = this.ratio; var kG = kH / 2; kC *= kG; kJ *= kG; var kI = kN[12]; var kD = kI.length; var kV = 0; var kU = 0; var kR = []; var kQ = 0; var kT = 0; for (var kP = 0; kP < kD; kP++) { kT += Math.round(kI[kP][3]) } for (var kP = 0; kP < kD; kP++) { var kF = kI[kP]; var kE = kF[0]; var i = kF[1]; var T = kF[2]; var e = kF[3]; var kW = 2 * kH; var kO = 0; if (kC !== 0) { kO = 2 * kH } if (kC === 0) { kS = ju } switch (kS) { case gQ: var kK = kL - kT / 2 - kW * (kD - 1) / 2; kV = kM - T - kC / 2 - kO; kU = kK + kQ + kW * kP; break; case eC: var kK = kL - kT / 2 - kW * (kD - 1) / 2; kV = kM + kC / 2 + kO; kU = kK + kQ + kW * kP; break; case P: var kK = kL - kJ / 2 - kT - kW * (kD - 1) - kW; kV = kM - T / 2; kU = kK + kQ + kW * kP; break; case hO: var kK = kL + kJ / 2 + kW / 2; kV = kM - T / 2; kU = kK + kQ + kW * kP; break; case ju: var kK = kL - e / 2 - kW * (kD - 1) / 2; kV = kM - T / 2; kU = kK + kQ + kW * kP; break }kQ += e; if (T > 0 && e > 0) { kR.push({ srcX: kE, srcY: i, destX: kV, destY: kU, width: T, height: e }) } } if (kR.length > 0) { return kR } return null }, _getLineLabelInfo: function (kK, kC, kD, kZ, lc, kR, kX, kW, kY, kQ) { if (kK.length !== 10) { return } var k1 = this.ratio; var T = this.ratio; var k8 = kK[7].length; var kS = kK[1]; var la = kK[3]; var lg = kK[8]; var kG = kK[4]; var e = 2; var kE = kG.slice(0, e); for (var ld = e; ld < kG.length; ld += e) { kE[ld] = kE[ld - e] + kG[ld]; kE[ld + 1] = kE[ld - (e - 1)] + kG[ld + 1] } for (var ld = e; ld < kG.length; ld += e) { if (ld % (la * e) === 0 || ld % (la * e) === 1) { continue } kE[ld] = kE[ld - e] + kG[ld] / kY; kE[ld + 1] = kE[ld - (e - 1)] + kG[ld + 1] / kY } for (var lf = 0; lf < k8; lf++) { var lb = kK[7][lf]; if (!this._isVisible(lb, kZ)) { continue } var k3 = kK[6][lf]; var kP = lf * la * e; kG = kE.slice(kP, kP + la * e); var kT = []; var k2 = undefined; var k0 = undefined; var kO = undefined; var kN = undefined; var lg = kK[9].slice(0); if (k3) { lg.reverse() } var k6; var k4; for (var le = 0; le < la; le++) { var kM = kK[5][la * lf + le]; var k7 = kG[le * e] / 100; var k5 = kG[le * e + 1] / 100; var kL = lg[le]; var kH = kL[0]; var kJ = kL[1]; var kF = kL[2]; var kI = kL[3]; var kV; var kU; var li; var lh; if (le === 0) { k6 = li = k7 / lc; k4 = kR - k5 / lc; lh = k5 / lc } else { li = k7 / lc; lh = k5 / lc } var lk = k6 + (li - k6) * T - kF / 2; var lj = k4 + (kR - lh - k4) * T - kI / 2; if (k2 === undefined) { k2 = k6 - kF / 2; k0 = k4 - kI / 2; kO = k2 + kF; kN = k0 + kI } else { if (lk < k2) { k2 = lk } if (lj < k0) { k0 = lj } if (lk + kF > kO) { kO = lk + kF } if (lj + kI > kN) { kN = lj + kI } } kT.push({ angle: kM, srcX: kH, srcY: kJ, destX: lk, destY: lj, width: kF, height: kI }) } var k9 = { type: "line", textImg: kC, rank: kS, baseX: k6, baseY: k4, arrWordPos: kT, minXOriginal: k2, minYOriginal: k0, maxXOriginal: kO, maxYOriginal: kN, text: "" }; kQ.push(k9) } }, alterColor: function (kF, e, kE) { var T = this._colorCtx, i = this._canvas2dMapMgr; T.clearRect(0, 0, kF.width, kF.height); T.drawImage(e, kF.srcX, kF.srcY, kF.width, kF.height, 0, 0, kF.width, kF.height); var kD = T.getImageData(0, 0, kF.width, kF.height), kC = i.getFilterImageData(kD, kE); T.putImageData(kC, 0, 0) }, drawIconAndText: function (kR, kQ, e) { var kI = this.ratio; var kG = this.sizeRatio / kI; var kK = 2 / kI; var k2 = this; for (var kU = 0, kS = kQ.length; kU < kS; kU++) { var kJ = kQ[kU]; if (kJ.isDel == false) { var kD = kJ.baseDrawX; var kC = kJ.baseDrawY; if (kJ.type == "fixed") { var kF = kJ.iconPos, kV = kJ.textPos, kO = kJ.textImg, kY = kJ.startScale; if (kF && kY <= e) { var T = this._iconCache[kF.iconType]; if (T) { if (T.img) { kR.drawImage(T.img, 0, 0, T.img.width, T.img.height, Math.round(kD * kI + (kF.drawX - kD) / kK), Math.round(kC * kI + (kF.drawY - kC) / kK), kF.width / kK, kF.height / kK) } else { T.drawLabels.push(kJ) } } else { if (!T) { this._iconCache[kF.iconType] = { img: null, drawLabels: [kJ] }; var k4 = new Image(); k4._iconName = kF.iconType; k4.onload = function () { var la = k2._iconCache[this._iconName]; la.img = this; this.onload = null; for (var k6 = 0; k6 < la.drawLabels.length; k6++) { var k8 = la.drawLabels[k6]; var k7 = k8.baseDrawX; var k5 = k8.baseDrawY; var k9 = k8.iconPos; kR.drawImage(this, 0, 0, this.width, this.height, Math.round(k7 * kI + (k9.drawX - k7) / kK), Math.round(k5 * kI + (k9.drawY - k5) / kK), k9.width / kK, k9.height / kK) } la.drawPos = [] }; k4.src = E.getIconSetPath(k2._map.config.style) + kF.iconType + ".png" } } } if (kV && kO && kY <= e) { for (var kH = 0; kH < kV.length; kH++) { var kP = kV[kH]; if (!kJ._tempRank) { kR.drawImage(kO, kP.srcX, kP.srcY, kP.width, kP.height, Math.round(kD * kI + (kP.drawX - kD) / kG), Math.round(kC * kI + (kP.drawY - kC) / kG), kP.width / kG, kP.height / kG) } else { this.alterColor(kP, kO, kJ._tempRank); kR.drawImage(this._colorCvs, 0, 0, kP.width, kP.height, Math.round(kD * kI + (kP.drawX - kD) / kG), Math.round(kC * kI + (kP.drawY - kC) / kG), kP.width / kG, kP.height / kG) } } } } else { var kE = kJ.arrWordPos, kO = kJ.textImg, kN = kJ.tileX, kL = kJ.tileY; for (var kT = 0, kM = kE.length; kT < kM; kT++) { var kW = kE[kT]; var k3 = Math.round(kN + kW.destX); var k1 = Math.round(kL + kW.destY); var kX = kW.angle; k3 = kD * kI + k3 - kD; k1 = kC * kI + k1 - kC; if (kX > 10 && kX < 350) { kR.save(); var k0 = Math.round(k3 + kW.width / 2); var kZ = Math.round(k1 + kW.height / 2); kR.translate(k0, kZ); kR.rotate(-kX / 180 * Math.PI); kR.drawImage(kO, kW.srcX, kW.srcY, kW.width, kW.height, -Math.round(kW.width / 2), -Math.round(kW.height / 2), kW.width / kG, kW.height / kG); kR.restore() } else { kR.drawImage(kO, kW.srcX, kW.srcY, kW.width, kW.height, k3, k1, kW.width / kG, kW.height / kG) } } } } } }, isCollide: function (kE, kN, kM, e, kG, T, kI) { for (var kD = 0, kC = T.length; kD < kC; kD++) { var kH = T[kD], kF = 1 / Math.pow(2, kI + 1), kL = kF * kH[3] / 2, kK = kF * kH[4] / 2, kJ = kH[0]; if (kJ != kE) { if (!(kN + e < kH[1] - kL || kN > kH[1] + kH[3] + kL || kM + kG < kH[2] - kK || kM > kH[2] + kH[4] + kK)) { return true } } } return false }, zoomingIconAndText: function (k2, kW, kC, k0, k1, lu, k9, kK, lf, k8, kT) { var lv = this.ratio; var kL = this.sizeRatio / lv; var lw = 2 / lv; var lG = lv / 2; var lq = k0.x; var lp = k0.y; var k3 = 2 * lv; if (kT !== 0) { lp += k8 } var kO = undefined, kH = undefined, kE = undefined, kJ = undefined, kS = undefined; var le = lu > 0 ? true : false; if (!le) { kO = []; var li = 1 - k9 } for (var lC = 0, lA = kW.length; lC < lA; lC++) { var lx = kW[lC]; if (lx.isDel == false) { var lH = lx.baseDrawX; var lE = lx.baseDrawY; k2.save(); k2.translate(-kK * lv, -lf * lv); if (lx.isFadeout) { if (!le && lx._schedule <= k9 && !lx._isIgnore) { k2.globalAlpha = li; lx._schedule = k9 } else { lx._isIgnore = true; continue } } if (lx.type == "fixed") { var k4 = lx.iconPos, lb = lx.textPos, kF = lx.textImg, k5 = lx.startScale; var T; var ln = 0; if (k4) { ln = k3 } if (k4 && !lx.iconImg && this._iconCache[k4.iconType]) { T = this._iconCache[k4.iconType].img } if (k4 && k5 <= k1 && T) { kJ = k4.width; kS = k4.height; kH = (lq + (lH - lq) * kC) * lv - kJ / 2 / lw; kE = (lp + (lE - lp) * kC) * lv - kS / 2 / lw + kT; if (!le && this.isCollide(lC, kH, kE, kJ, kS, kO, lu)) { lx.isFadeout = true } k2.drawImage(T, k4.srcX, k4.srcY, T.width, T.height, Math.round(kH), Math.round(kE), kJ / lw, kS / lw); !le && kO.push([lC, kH, kE, kJ, kS]) } if (lb && kF && k5 <= k1) { var la; var lc; var kV = 0; var k7 = 0; if (k4) { kV = k4.width; k7 = k4.height } var lo = lb.length; var kN = 0; var ld = 0; for (var kX = 0; kX < lo; kX++) { var lz = lb[kX]; ld += lz.height; if (kN < lz.width) { kN = lz.width } } ld += (kX - 1) * k3; if (!le && this.isCollide(lC, kH, kE, kN, ld, kO, lu)) { lx.isFadeout = true } var ly = 0; for (var kX = 0; kX < lo; kX++) { var lz = lb[kX]; switch (lx.direction) { case gQ: la = -(kV / 2 / lw + lz.width + ln); lc = -ld / 2 + ly + k3 * kX; break; case eC: la = kV / 2 / lw + ln; lc = -ld / 2 + ly + k3 * kX; break; case P: la = -lz.width / 2; lc = -k7 / 2 / lw - ld + ly - k3 * (kX + 1); break; case hO: la = -lz.width / 2; lc = k7 / 2 / lw + ly + k3 * (kX + 1); break; case ju: la = -lz.width / 2; lc = -ld / 2 + ly + k3 * kX; break }ly += lz.height; kH = (lq + (lH - lq) * kC) * lv + la / kL; kE = (lp + (lE - lp) * kC) * lv + lc / kL; +kT; kJ = lz.width; kS = lz.height; if (!lx._tempRank) { k2.drawImage(kF, lz.srcX, lz.srcY, kJ, kS, Math.round(kH), Math.round(kE), kJ / kL, kS / kL) } else { this.alterColor(lz, kF, lx._tempRank); k2.drawImage(this._colorCvs, 0, 0, kJ, kS, Math.round(kH), Math.round(kE), kJ / kL, kS / kL) } !le && kO.push([lC, kH, kE, kJ, kS]) } } } else { var kU = lx.arrWordPos, kF = lx.textImg, lF = lx.tileX, lD = lx.tileY; var kM = kU[0]; var kI = Math.round(lF + kM.destX); var kG = Math.round(lD + kM.destY); for (var lB = 0, lm = kU.length; lB < lm; lB++) { var lt = kU[lB]; var lJ = Math.round(lF + lt.destX); var lI = Math.round(lD + lt.destY); var kZ = lt.angle; var lk = Math.round((lq + (lH - lq) * kC) * lv - kM.width / 2 + lJ - kI); var lj = Math.round((lp + (lE - lp) * kC) * lv - kM.height / 2 + lI - kG); kH = lk; kE = lj; kJ = lt.width; kS = lt.height; if (!le && this.isCollide(lC, kH, kE, kJ, kS, kO, lu)) { lx.isFadeout = true } if (kZ > 10 && kZ < 350) { var ls = lk + lt.width / 2; var lr = lj + lt.height / 2; var kD = kZ / 180 * Math.PI; var k6 = Math.cos(kD); var kP = Math.sin(kD); var lh = k6; var kQ = k6; var lg = kP; var kR = -kP; var kY = ls - ls * k6 - lr * kP; var e = lr + ls * kP - lr * k6; k2.save(); k2.transform(lh, kR, lg, kQ, kY, e); k2.drawImage(kF, lt.srcX, lt.srcY, kJ, kS, kH, kE, kJ / kL, kS / kL); k2.restore() } else { k2.drawImage(kF, lt.srcX, lt.srcY, kJ, kS, kH, kE, kJ / kL, kS / kL) } !le && kO.push([lC, kH, kE, kJ, kS]) } } k2.restore() } } } }); function eD(e) { this.initVars(e) } e9.extend(eD.prototype, { initVars: function (e) { this._map = e._map; this._canvas2dMapMgr = e; this.base64Prefix = "data:image/png;base64,"; this.bizData = null; this.objTextsPng = null; this.arrIconsPng = null; this.bizLabels = null }, proecessBizData: function (kE, kI) { var kG = this; this.bizData = kE; this.objTextsPng = null; this.arrIconsPng = null; var T = kE.textsPng; var kK = kE.iconsPng; if (!T || !kK) { return } var kH = new Image(); kH.onload = function () { kG.objTextsPng = this; kG.calcIconAndTextInfo(kI); this.onload = null }; kH.src = this.base64Prefix + T; var kJ = kK.length; var e = []; for (var kD = 0; kD < kJ; kD++) { var kF = kK[kD]; var kC = new Image(); (function (i) { kC.onload = function () { kJ--; e[i] = this; if (kJ === 0) { kG.arrIconsPng = e; kG.calcIconAndTextInfo(kI) } this.onload = null } })(kD); kC.src = this.base64Prefix + kF } }, calcIconAndTextInfo: function (kL) { if (this.objTextsPng && this.arrIconsPng) { var kH = this.bizData; var kF = kH.pois; var e = []; for (var kI = 0, kE = kF.length; kI < kE; kI++) { var kC = kF[kI]; var kG = this.arrIconsPng[kC.iconPng]; var kD = kG.height / 2; var kK = { type: "fixed", name: "", textImg: this.objTextsPng, iconImg: kG, rank: kC.rank, iconPos: { srcX: 0, srcY: 0, destX: -kG.width / 2, destY: -kD / 2, width: kG.width, height: kD, geoX: kC.x, geoY: kC.y, iconType: "vectorCustom" }, textPos: this.calcTextPos(kC.pos, kG), startScale: kC.from < 12 ? 12 : kC.from, guid: kC.guid, guidExt: 1, adver_log: kC.adver_log || "" }; var T = { type: "fixed", textDirLeft: "left", name: "", textImg: this.objTextsPng, iconImg: kG, rank: kC.rank, iconPos: { srcX: 0, srcY: 0, destX: -kG.width / 2, destY: -kD / 2, width: kG.width, height: kD, geoX: kC.x, geoY: kC.y, iconType: "vectorCustom" }, textPos: this.calcTextPosLeft(kC.pos, kG), startScale: kC.from < 12 ? 12 : kC.from, guid: kC.guid, guidExt: 1, adver_log: kC.adver_log || "" }; var kJ = [kK, T]; e.push(kJ) } this.bizLabels = e; kL && kL() } }, calcTextPos: function (kF, T) { var i = []; var kE = kF.length / 4; var kD = T.width / 2; if (kE === 1) { var kC = { srcX: kF[0], srcY: kF[1], destX: kD, destY: -kF[3] / 2, width: kF[2], height: kF[3] }; i.push(kC) } else { var kC = { srcX: kF[0], srcY: kF[1], destX: kD, destY: -kF[3], width: kF[2], height: kF[3] }; var e = { srcX: kF[4], srcY: kF[5], destX: kD, destY: 0, width: kF[6], height: kF[7] }; i.push(kC); i.push(e) } return i }, calcTextPosLeft: function (kF, T) { var i = []; var kE = kF.length / 4; var kD = T.width / 2; if (kE === 1) { var kC = { srcX: kF[0], srcY: kF[1], destX: -kD - kF[2], destY: -kF[3] / 2, width: kF[2], height: kF[3] }; i.push(kC) } else { var kC = { srcX: kF[0], srcY: kF[1], destX: -kD - kF[2], destY: -kF[3], width: kF[2], height: kF[3] }; var e = { srcX: kF[4], srcY: kF[5], destX: -kD - kF[2], destY: 0, width: kF[6], height: kF[7] }; i.push(kC); i.push(e) } return i }, clearBizData: function () { this.bizData = null; this.bizLabels = null } }); var jX = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }; var iq = { Int8: 1, Uint8: 1, Int16: 2, Uint16: 2, Uint32: 4, Float32: 4 }; function B(kC, kE, T, kD) { this.arrayBuffer = kC; this.attributes = kE.members; this.bytesPerElement = 0; if (this.attributes) { for (var e = 0; e < this.attributes.length; e++) { this.bytesPerElement += iq[this.attributes[e].type] * this.attributes[e].components } } else { this.bytesPerElement = kC.BYTES_PER_ELEMENT * kE.components } this.length = kD || kC.byteLength / this.bytesPerElement; this.type = T; this.arrayType = kE } B.prototype.bind = function (i) { var e = i[this.type]; if (!this.buffer) { this.buffer = i.createBuffer(); i.bindBuffer(e, this.buffer); i.bufferData(e, this.arrayBuffer, i.STATIC_DRAW); this.arrayBuffer = null } else { i.bindBuffer(e, this.buffer) } }; B.prototype.setVertexAttribPointers = function (kC, e) { for (var i = 0; i < this.attributes.length; i++) { var kD = this.attributes[i]; var T = e.attributes[kD.name]; kC.vertexAttribPointer(T, kD.components, kC[jX[kD.type]], kD.normalize, this.bytesPerElement, kD.offset) } }; B.prototype.updateVertexData = function (kC, i, T) { this.arrayBuffer = i; if (!this.buffer) { return this.bind(kC) } if (T <= this.length) { var e = kC[this.type]; kC.bindBuffer(e, this.buffer); kC.bufferData(e, this.arrayBuffer, kC.STATIC_DRAW) } else { this.destroy(kC); this.bind(kC) } this.length = T }; B.prototype.destroy = function (e) { if (this.buffer) { e.deleteBuffer(this.buffer); this.buffer = null } }; B.BufferType = { VERTEX: "ARRAY_BUFFER", ELEMENT: "ELEMENT_ARRAY_BUFFER" }; B.ELEMENT_ATTRIBUTE_TYPE = "Uint16"; B.VERTEX_ATTRIBUTE_ALIGNMENT = 4; function dY() { this.boundProgram = null; this.boundVertexBuffer = null; this.boundElementBuffer = null; this.vao = null } dY.prototype.bind = function (kG, e, kC, kF) { var kD = kG.extVertexArrayObject; if (kD === undefined) { kD = kG.extVertexArrayObject = kG.getExtension("OES_vertex_array_object") } if (kD) { if (!this.vao) { this.vao = kD.createVertexArrayOES() } kD.bindVertexArrayOES(this.vao) } else { } if (!this.boundProgram) { var kH = kD ? 0 : (kG.currentNumAttributes || 0); var kE = e.numAttributes; var T; for (T = kH; T < kE; T++) { kG.enableVertexAttribArray(T) } if (!kD) { for (T = kE; T < kH; T++) { kG.disableVertexAttribArray(T) } kG.currentNumAttributes = kE } kC.bind(kG); kC.setVertexAttribPointers(kG, e); if (kF) { kF.bind(kG) } if (kD) { this.boundProgram = e; this.boundVertexBuffer = kC; this.boundElementBuffer = kF } } }; dY.prototype.update = function (kG, kC, T, kF, e, i, kE) { var kD = kG.extVertexArrayObject; if (kD === undefined) { kD = kG.extVertexArrayObject = kG.getExtension("OES_vertex_array_object") } if (kD) { kD.bindVertexArrayOES(this.vao); if (this.boundVertexBuffer) { this.boundVertexBuffer.updateVertexData(kG, T, kF); this.boundVertexBuffer.setVertexAttribPointers(kG, this.boundProgram) } if (e && this.boundElementBuffer) { this.boundElementBuffer.updateVertexData(kG, i, kE) } } else { kC.updateVertexData(kG, T, kF); if (e) { e.updateVertexData(kG, i, kE) } } }; dY.prototype.unbind = function (i) { var e = i.extVertexArrayObject; if (e) { e.bindVertexArrayOES(null); this.boundProgram = null; this.boundVertexBuffer = null; this.boundElementBuffer = null } }; dY.prototype.destroy = function (i) { var e = i.extVertexArrayObject; if (e && this.vao) { e.deleteVertexArrayOES(this.vao); this.vao = null; this.boundProgram = null; this.boundVertexBuffer = null; this.boundElementBuffer = null } }; function F() { } e9.extend(F.prototype, { centerAndZoomIn: function (T, kI, kJ) { kJ = kJ || {}; if (!this.loaded) { this.firstTileLoad = false } kI = this._getProperZoom(kI).zoom; if (kJ.noAnimation !== true && this.loaded) { var kE = this._ifUseAnimation(T, kI); if (kE) { this.flyToIn(T, kI, kJ); return } } var kG = this; if (!T && !kI) { return } this._stopAllAnimations(); if (T && !T.equals(this.centerPoint)) { this.fire(new fW("oncenter_changed")) } if (kI && kI !== this.zoomLevel) { this.fire(new fW("onzoom_changed")) } T = T || this.centerPoint; kI = kI || this.zoomLevel; kI = this._getProperZoom(kI).zoom; if (this.mapType === BMAP_EARTH_MAP) { if (!this._earth) { this.mapType = BMAPGL_NORMAL_MAP; this.temp.originMapType = BMAP_EARTH_MAP; function kH() { kG._earth = new bG.Earth(kG, { showRealSunlight: kG.config.showRealSunlight, showMilkyway: kG.config.showMilkyway, earthBackground: kG.config.earthBackground }); kG._proxyEarthEvents(); kG._changeEarthMapType(BMAP_EARTH_MAP); e9.extend(kG, bG.EarthView.prototype); delete kG.temp.originMapType } hm.load("earth", function () { if (bG["FeatureStyle" + kG.config.style]) { kH() } else { kG.loadMapStyleFiles(function () { kH() }) } }) } } this.lastLevel = this.zoomLevel || kI; this.zoomLevel = kI; var kF = new fW("onload"); kF.point = T; kF.zoom = kI; this.centerPoint = new cG(T.lng, T.lat); this.defaultZoomLevel = this.defaultZoomLevel || this.zoomLevel; this.defaultCenter = this.defaultCenter || this.centerPoint; if (this.mapType !== BMAP_EARTH_MAP) { this.centerPoint = this.restrictCenter(this.centerPoint) } if (!this.loaded && !(this.temp.originMapType === BMAP_EARTH_MAP)) { var i = this.config.defaultMaxBounds; var kD = new o(i, "baidu", this.mapType); if (this.mapType !== BMAP_NONE_MAP) { var kC = new hP({ mapType: this.mapType, copyright: kD, dataType: this.mapType === BMAP_SATELLITE_MAP ? gX : h3, customLayer: this.mapType === BMAP_SATELLITE_MAP, baseLayer: true, transparentPng: false, tileTypeName: this.mapType === BMAP_SATELLITE_MAP ? "web" : "na" }); kC._isInnerLayer = true; this.addTileLayer(kC); this.baseLayerAdded = true } if (this.mapType === BMAP_NONE_MAP) { hQ.sendMessage(a1(4, 3, 15), ["layer", "blank"]) } else { if (this.mapType === BMAP_SATELLITE_MAP) { hQ.sendMessage(a1(4, 3, 2), ["layer", "raster"]) } else { hQ.sendMessage(a1(4, 3, 1, 1), ["layer", "vector", "normal"]) } } if (this.mapType === BMAP_SATELLITE_MAP && this.config.showVectorStreetLayer) { this._addHybirdVectorMap() } else { if (this.mapType === BMAP_SATELLITE_MAP && this._isHybridShow === true) { this._addHybirdMap() } } this.on("zoom_changed", function () { if (this._heading === 0) { return } if (this.getZoom() < 7 && this.config.restrictCenter === true) { kG.resetHeading() } }) } this.loaded = true; this.dispatchEvent(kF); kJ.callback && kJ.callback() }, _ifUseAnimation: function (kC, kH) { var kG = this.getSize(); var T = { zoom: this.zoomLevel }; var kJ = { zoom: kH }; var kI = this.pointToPixelIn(this.centerPoint); var kD = this.pointToPixelIn(kC, T); var kF = this.pointToPixelIn(this.centerPoint, kJ); var kL = this.pointToPixelIn(kC, kJ); var kE = Math.abs(kI.x - kD.x); var i = Math.abs(kI.y - kD.y); var e = Math.abs(kF.x - kL.x); var kK = Math.abs(kF.y - kL.y); if ((kE > kG.width || i > kG.height) && (e > kG.width || kK > kG.height)) { return false } return true }, _setPlatformPosition: function (kJ, kI, kL) { kL = kL || {}; if (kJ === 0 && kI === 0 && !kL.point) { return } if (isNaN(kL.initMapOffsetX)) { kL.initMapOffsetX = this.offsetX } if (isNaN(kL.initMapOffsetY)) { kL.initMapOffsetY = this.offsetY } var kF = iX(this._heading); if (this._tilt > 0) { kI = kI / Math.cos(iX(this._tilt)) } var kK = kJ * Math.cos(kF) + kI * Math.sin(kF); var kH = -kJ * Math.sin(kF) + kI * Math.cos(kF); kK = kK + kL.initMapOffsetX; kH = kH + kL.initMapOffsetY; if (kL.point) { var i = this.restrictCenter(kL.point); if (!i.equals(this.centerPoint)) { this.centerPoint = i.clone(); this.fire(new fW("oncenter_changed")) } } else { var kC = this.offsetX - kK; var e = this.offsetY - kH; var kG = this.centerPoint.lng; var kE = this.centerPoint.lat; var kD = new cG(kG, kE); var T = this.getZoomUnits(); this.centerPoint = this.restrictCenter(new cG(kD.lng + kC * T, kD.lat - e * T), T); this.fire(new fW("oncenter_changed")) } this.offsetX = kK; this.offsetY = kH; this.dispatchEvent(new fW("onmoving")) }, restrictCenter: function (kK, e) { if (this.config.restrictCenter === false) { return kK } e = e || this.getZoomUnits(); var kI = this.pixelToPointIn(new fv(this.width, 0), { center: kK }); var kF = this.pixelToPointIn(new fv(0, this.height), { center: kK }); var kL = kK.lng; var kQ = kK.lat; if (!!this.config.restrictBounds && !this.config.restrictBounds.isEmpty()) { var kP = this.config.restrictBounds; var T = kP.getSouthWest(); var kN = kP.getNorthEast(); var kJ = jy.convertLL2MC(T); var kD = jy.convertLL2MC(kN); var kG = this.calcNewZoomByRestriction(kL, kQ, kF, kI, kJ.lng, kD.lng, kJ.lat, kD.lat); if (kG > this.zoomLevel) { this.zoomLevel = kG; return kK } kK.lng = this.calcNewLngByBounds(kL, kF, kI, kJ.lng, kD.lng, e); kK.lat = this.calcNewLatByBounds(kQ, kF, kI, kJ.lat, kD.lat, e); return kK } var kH = this.pixelToPointIn(new fv(0, 0), { center: kK }); var kC = this.pixelToPointIn(new fv(0, this.height), { center: kK }); if (this.zoomLevel < 5) { if (kH.lat > h5.MAX_LAT && kC.lat < h5.MIN_LAT) { var i = h5.MAX_LAT - kK.lat; var kE = kK.lat - h5.MIN_LAT; var kO; if (i < kE) { kO = i / (this.height / 2) } else { kO = kE / (this.height / 2) } var kM = 18 - r(kO); this.zoomLevel = kM; return kK } } if (kH.lat > h5.MAX_LAT) { kK.lat = h5.MAX_LAT - this.height / 2 * e } else { if (kC.lat < h5.MIN_LAT) { kK.lat = h5.MIN_LAT + this.height / 2 * e } } return kK }, calcNewZoomByRestriction: function (kJ, kI, e, kH, kD, kF, kC, kE) { var kM = 0; var kN = 0; if (typeof kC === "number" && typeof kE === "number" && kH.lat > kE && e.lat < kC) { var T = kE - kI; var i = kI - kC; var kG; if (T < i) { kG = T / (this.height / 2) } else { kG = i / (this.height / 2) } kM = 18 - r(kG) } if (typeof kD === "number" && typeof kF === "number" && kH.lng > kF && e.lng < kD) { var kL = kF - kJ; var kK = kJ - kD; var kG; if (kL < kK) { kG = kL / (this.width / 2) } else { kG = kK / (this.width / 2) } kN = 18 - r(kG) } return Math.max(kM, kN) || this.zoomLevel }, calcNewLatByBounds: function (i, kC, T, kF, kE, e) { var kD = i; if (T.lat > kE) { kD = kE - this.height / 2 * e } else { if (kC.lat < kF) { kD = kF + this.height / 2 * e } } return kD }, calcNewLngByBounds: function (kF, kE, kC, kD, T, e) { var i = kF; if (kC.lng > T) { i = T - this.width / 2 * e } else { if (kE.lng < kD) { i = kD + this.width / 2 * e } } return i }, zoomTo: function (T, kN, kE) { var kH = ev[this.mapType]; if (!kH) { return } var kF = this._getProperZoom(T); T = kF.zoom; if (this.zoomLevel === T) { kE && kE.callback && kE.callback(); return } var kM = T; this.lastLevel = this.zoomLevel; kE = kE || {}; if (this.zoomEventStatus === "idle") { var kO = new fW("onzoomstart"); kO.isGesture = !!kE.isGesture; this.fire(kO); this.zoomEventStatus = "zooming" } if (!kN && (this.getInfoWindow() && this.temp.infoWin && this.temp.infoWin.isOpen())) { kN = jy.convertLL2MC(this.getInfoWindow().getPoint()) } var kG = null; if (kE.fixPixel) { kG = kE.fixPixel } else { if (kN) { kG = this.pointToPixelIn(kN, { useRound: false }) } } var kL = this.pixelToPointIn(kG); var kC = this.centerPoint.clone(); this.fixPoint = kN; this.fixPixel = kG; this.fixCenter = kC; this.mousePosMCPoint = kL; if (kE.noAnimation) { T = kF.zoom; this.zoomLevel = T; this.fire(new fW("onzoom_changed")); var kJ = this.getCurrentMaxTilt(); if (this._tilt > kJ) { this._tilt = kJ } if (kN) { if (this._heading % 360 !== 0 || this._tilt > 0) { var kK = this._webglMapCamera.fromScreenPixelToMC(kG.x, kG.y, { center: kC, zoom: this.zoomLevel }); if (kK) { var kQ = kK.sub(kL); var e = kC.sub(kQ); this.centerPoint = this.restrictCenter(e) } } else { var i = this.getZoomUnits(); var e = new cG(kN.lng - i * (kG.x - this.width / 2), kN.lat + i * (kG.y - this.height / 2)); this.centerPoint = this.restrictCenter(e, i) } this.fire(new fW("oncenter_changed")) } this._checkFireZoomend(); kE.callback && kE.callback(); return } this._animationInfo.zoom = { current: this.zoomLevel, diff: T - this.zoomLevel, target: T }; var kP = this; var kD = this._tilt; if (this.fixPoint || kD > h5.MAX_DRAG_TILT_L2) { kE.renderCallback = function () { var kU = kP.getCurrentMaxTilt(); if (kP._tilt > kU) { kP._tilt = kU } var kV = kP.fixPixel; if (!kP.fixPixel || !kP.fixPoint) { return } var kR = kP.fixPixel; var k1 = kP.fixPoint; var kY = kP.fixCenter; var kW = kP.mousePosMCPoint; if (kP._heading % 360 !== 0 || kP._tilt > 0) { var kS = kP._webglMapCamera.fromScreenPixelToMC(kR.x, kR.y, { center: kY, zoom: kP.zoomLevel, tilt: kP._tilt }); if (kS) { var k0 = kS.sub(kW); var kT = kY.sub(k0); kP.centerPoint = kP.restrictCenter(kT) } } else { var kX = kR; var kZ = kP.getZoomUnits(); var kT = new cG(k1.lng - kZ * (kX.x - kP.width / 2), k1.lat + kZ * (kX.y - kP.height / 2)); kP.centerPoint = kP.restrictCenter(kT, kZ) } kP.fire(new fW("oncenter_changed")) } } if (kE.fromMouseWheel === true) { this._startInfiniteZoomAnimation(kE); kE.callback && kE.callback(); kP._checkFireZoomend(); return } if (!kE.callback) { kE.callback = function () { kP._checkFireZoomend() } } else { var kI = kE.callback; kE.callback = function (kR, kS) { kI(kR, kS); kP._checkFireZoomend() } } this._startAnimation(kE) }, _checkFireZoomend: function () { var e = this; if (e.fireZoomendTimer) { clearTimeout(e.fireZoomendTimer) } e.fireZoomendTimer = setTimeout(function () { if (e.zoomEventStatus === "zooming") { e.fire(new fW("onzoomend")); e.zoomEventStatus = "idle" } e.fireZoomendTimer = null }, 150) }, deepZoomMedia: function (e) { var i = this; if (!i.temp.isStdCtrlBusy) { i.temp.isStdCtrlBusy = true; i.deepZoomTo(i.zoomLevel + e); setTimeout(function () { i.temp.isStdCtrlBusy = false }, 400) } }, deepZoomTo: function (e) { this.zoomTo(e) }, flyToIn: function (T, k6, kR) { kR = kR || {}; var kD = this._getProperZoom(k6); k6 = kD.zoom; if (this.centerPoint.equals(T) && this.zoomLevel === k6 && typeof kR.heading !== "number" && typeof kR.tilt !== "number") { return } var e = this.getHeading() % 360; var kJ = this.getTilt(); var kP = 0; var kT = 0; var kM = this.getBounds().containsPoint(T); if (typeof kR.heading === "number") { kP = kR.heading } else { if (kM) { kP = e } } if (typeof kR.tilt === "number") { kT = kR.tilt } else { if (kM) { kT = kJ } } this._heading = e; var k3 = kP - e; var kZ = kT - kJ; var kN = this; var kF = this.zoomLevel; var kG = 1.42; var kV = this.zoomScale(k6 - kF); var k8 = this.getZoomUnits(); var kL = this.centerPoint.div(k8); var k9 = T.div(k8); var k2 = this.worldSize(); var kY = kG; var kX = Math.max(this.width, this.height); var kW = kX / kV; var kK = k9.sub(kL).mag(); var i = kY * kY; function k5(lb) { var la = (kW * kW - kX * kX + (lb ? -1 : 1) * i * i * kK * kK) / (2 * (lb ? kW : kX) * i * kK); return Math.log(Math.sqrt(la * la + 1) - la) } function kC(la) { return (Math.exp(la) - Math.exp(-la)) / 2 } function kH(la) { return (Math.exp(la) + Math.exp(-la)) / 2 } function kQ(la) { return kC(la) / kH(la) } var kI = k5(0); var k0 = function (la) { return (kH(kI) / kH(kI + kY * la)) }; var k1 = function (la) { return kX * ((kH(kI) * kQ(kI + kY * la) - kC(kI)) / i) / kK }; var kE = (k5(1) - kI) / kY; if (Math.abs(kK) < 0.000001 || kE === Infinity || isNaN(kE)) { if (Math.abs(kX - kW) < 0.000001) { this._animationInfo.zoom = { current: this.zoomLevel, diff: k6 - this.zoomLevel }; this._animationInfo.center = { current: this.centerPoint, diff: T.sub(this.centerPoint) }; this._animationInfo.heading = { current: e, diff: kP - e }; this._animationInfo.tilt = { current: kJ, diff: kT - kJ }; this.setLock(true); this._startAnimation({ callback: function (la) { kN.setLock(false); if (kR.callback) { kR.callback(la) } }, duration: kR.duration }); return } var k7 = kW < kX ? -1 : 1; kE = Math.abs(Math.log(kW / kX)) / kY; k1 = function () { return 0 }; k0 = function (la) { return Math.exp(k7 * kY * la) } } var k4 = 1.7; if (kE < 0.3) { k4 = 0.8 } else { if (kE > 5) { k4 = (kE - 5) / 2 + k4 } } var kS = kR.duration || 1000 * kE / k4; if (isNaN(kS)) { var kU = {}; for (var kO in kR) { kU[kO] = kR[kO]; kU.noAnimation = true } this.centerAndZoomIn(T, k6, kU); return } this.fire(new fW("onmovestart")); this.fire(new fW("onzoomstart")); this.setLock(true); this._startAnimation({ duration: kS, renderCallback: function (la, lb) { var lc = la * kE; var lf = k1(lc); var le = kF + kN.scaleZoom(1 / k0(lc)); if (le < kN.getMinZoom()) { le = kN.getMinZoom() } if (le > kN.getMaxZoom()) { le = kN.getMaxZoom() } if (le !== kN.zoomLevel) { kN.zoomLevel = le; kN.fire(new fW("onzoom_changed")) } kN.centerPoint = kL.add(k9.sub(kL).mult(lf)).mult(k8); kN.fire(new fW("oncenter_changed")); if (typeof kP === "number") { var ld = la / 0.7; if (ld > 1) { ld = 1 } kN.setHeading(e + k3 * la, { noAnimation: true }) } if (typeof kT === "number") { kN.setTilt(kJ + kZ * la, { noAnimation: true }) } }, callback: function (la, lb) { kN.setLock(false); if (lb && lb.stop === true) { kN.fire(new fW("onmoveend")); kN.fire(new fW("onzoomend")); kR.callback && kR.callback(la); return } if (k6 !== kN.zoomLevel) { kN.zoomLevel = k6; kN.fire(new fW("onzoom_changed")) } kN.fire(new fW("onmoveend")); kN.fire(new fW("onzoomend")); kR.callback && kR.callback(la) } }) }, zoomScale: function (e) { return Math.pow(2, e) }, scaleZoom: function (e) { return Math.log(e) / Math.LN2 }, panToIn: function (i, T) { T = T || {}; if (!i || i.equals(this.centerPoint)) { T.callback && T.callback(); return } var kC = this.pointToPixelIn(i); var e = Math.round(this.width / 2); var kE = Math.round(this.height / 2); var kD = this._ifUseAnimation(i, this.zoomLevel); if (T.noAnimation === true || kD === false) { this._stopAllAnimations(); this._panToIn(e - kC.x, kE - kC.y, i); T.callback && T.callback(); return } this.flyToIn(i, this.zoomLevel, T) }, _panToIn: function (i, e, kC) { var T = this.temp; if (T.operating === true) { return } if (T.dragAni) { T.dragAni.stop(false, { readyToMove: true }); T.dragAni = null } this.dispatchEvent(new fW("onmovestart")); this._setPlatformPosition(i, e, { point: kC }); this.dispatchEvent(new fW("onmoveend")) }, _stopAllAnimations: function (e) { e = e || {}; if (this._ani) { this._ani.stop(!!e.goToEnd, { stopCurrentAnimation: e.stopCurrentAnimation }); this._ani = null } if (this._infiniteAni) { this._infiniteAni.stop(); this._infiniteAni = null } }, panBy: function (i, e, T) { i = Math.round(i) || 0; e = Math.round(e) || 0; T = T || {}; if (Math.abs(i) <= this.width && Math.abs(e) <= this.height && T.noAnimation !== true) { this._panBy(i, e, T) } else { this._panToIn(i, e, T.point); T.callback && T.callback() } }, _panBy: function (i, e, kD) { if (this.temp.operating === true) { return } kD = kD || {}; this.dispatchEvent(new fW("onmovestart")); var kC = this; var T = kC.temp; T.pl = kC.offsetX; T.pt = kC.offsetY; if (T.tlPan) { T.tlPan.cancel() } if (T.dragAni) { T.dragAni.stop(false, { readyToMove: true }); T.dragAni = null } T.tlPan = new fL({ fps: kD.fps || kC.config.fps, duration: kD.duration || kC.config.actionDuration, transition: kD.transition || gS.easeInOutQuad, render: function (kE) { this.terminative = kC.temp.operating; if (kC.temp.operating) { return } kC._setPlatformPosition(i * kE, e * kE, { initMapOffsetX: T.pl, initMapOffsetY: T.pt }) }, finish: function (kE) { kC.dispatchEvent(new fW("onmoveend")); kC.temp.tlPan = false; if (kC.temp.stopArrow === true) { kC.temp.stopArrow = false; if (kC.temp.arrow !== 0) { kC._arrow() } } } }) }, _startAnimation: function (i) { var kD = this._animationInfo; var T = this; i = i || {}; if (T._ani) { T._ani.stop(!!i.goToEnd, { stopCurrentAnimation: i.stopCurrentAnimation }) } if (T._infiniteAni) { T._infiniteAni.stop(); T._infiniteAni = null } var kE = i.duration || 500; var kF = i.transition || gS.ease; var e = new fW("onanimation_start"); this.fire(e); if (i.unstopable) { kD = this._animationInfoUnstopable } var kC = new fL({ duration: kE, transition: kF, render: function (kI, kH) { for (var kG in kD) { if (!kD.hasOwnProperty(kG)) { continue } var kK = kD[kG].current; var kJ = kD[kG].diff; T._setValueTick(kG, kK, kJ, kI) } if (i.renderCallback) { i.renderCallback(kI, kH) } }, finish: function (kG) { T.fire(new fW("onanimation_end")); if (i.unstopable) { T._animationInfoUnstopable = {}; T._unstopableAni = null } else { T._ani = null; T._animationInfo = {} } if (i.mapNeedCbk) { i.mapNeedCbk() } if (i.callback) { i.callback(kG) } }, onStop: function (kG) { kG = kG || {}; T.fire(new fW("onanimation_end")); if (kG.stopCurrentAnimation) { T._animationInfo = {} } T._ani = null; if (i.mapNeedCbk) { i.mapNeedCbk() } if (i.callback) { i.callback(null, { stop: true }) } } }); if (i.unstopable) { T._unstopableAni = kC } else { T._ani = kC } }, _startInfiniteZoomAnimation: function (e) { var i = this; if (i._ani) { i._ani.stop(!!e.goToEnd, { stopCurrentAnimation: e.stopCurrentAnimation }) } if (i._infiniteAni) { return } this.fire(new fW("onanimation_start")); i._infiniteAni = new fL({ duration: 10000, transition: gS.linear, render: function () { var T = i._animationInfo.zoom; if (Math.abs(T.current - T.target) < 0.001) { i._setValue("zoom", T.target); i._infiniteAni && i._infiniteAni.stop(); return } T.current += (T.target - T.current) * 0.35; i._setValue("zoom", T.current); if (e.renderCallback) { e.renderCallback() } }, finish: function () { i._infiniteAni = null; i._animationInfo = {}; i.fire(new fW("onanimation_end")); if (e.callback) { e.callback() } }, onStop: function () { i._infiniteAni = null; i._animationInfo = {}; i.fire(new fW("onanimation_end")); if (e.callback) { e.callback() } } }) }, _setValue: function (e, T) { if (e === "zoom") { this._preZoomLevel = this.zoomLevel; var i = this._getProperZoom(T); T = i.zoom; if (T !== this.zoomLevel) { this.zoomLevel = T; if (T < 5) { this.restrictCenter(this.centerPoint) } this.fire(new fW("on" + e + "_changed")) } return } else { if (e === "center") { this.centerPoint = T } } this["_" + e] = T; this.fire(new fW("on" + e + "_changed")) }, _setValueTick: function (e, kD, kC, i) { if (e === "center") { var T = new cG(kD.lng + kC.lng * i, kD.lat + kC.lat * i); this._setValue(e, T); return } if (e === "zoom") { this._setValue(e, Math.pow(kD, 1 - i) * Math.pow(kD + kC, i)); return } this._setValue(e, kD + kC * i) }, setHeading: function (kC, i) { i = i || {}; if (kC === this._heading) { i.callback && i.callback(); return } var T = eq(this._heading, 360); var e = eq(kC, 360); if (e === T) { this._heading = e; i.callback && i.callback(); return } if (e === 0 && T > 180) { e = 360 } if (i.noAnimation) { this._setValue("heading", e); i.callback && i.callback(); return } if (i.unstopable) { this._animationInfoUnstopable.heading = { current: T, diff: e - T } } else { var kD = e - T; if (Math.abs(e - T) > 180) { if (kD > 0) { kD = kD - 360 } else { kD = kD + 360 } } this._animationInfo.heading = { current: T, diff: kD } } this._startAnimation(i) }, resetHeading: function (e) { var i = this._heading; while (i < 0) { i += 360 } i = i % 360; if (i > 180) { i -= 360 } this._heading = i; e = e || {}; e.unstopable = true; this.setHeading(0, e) }, getHeading: function () { while (this._heading > 360) { this._heading -= 360 } if (this._heading > 180) { this._heading -= 360 } return this._heading }, setTilt: function (e, i) { i = i || {}; if (e === this._tilt) { i.callback && i.callback(); return } if (e > h5.MAX_TILT) { e = h5.MAX_TILT } if (e < h5.MIN_TILT) { e = h5.MIN_TILT } if (i && i.noAnimation) { this._setValue("tilt", e); i.callback && i.callback(); return } this._animationInfo.tilt = { current: this._tilt, diff: e - this._tilt }; this._startAnimation(i) }, getTilt: function () { return this._tilt }, getCenterIn: function () { return this.centerPoint }, getZoom: function () { return this.zoomLevel }, getCameraPosition: function (T) { T = T || {}; var e = T.center || this.centerPoint; var kC = T.zoom || this.zoomLevel; var kF = typeof T.heading === "number" ? T.heading : this._heading; var i = typeof T.tilt === "number" ? T.tilt : this._tilt; var kE = this._webglMapCamera.generateMVMatrix(e, kC, kF, i); var kD = mat4.create(Float32Array); mat4.invert(kD, kE); return this._webglMapCamera.getPosition(kD) } }); function bs(i) { this._jobQueue = []; this._idleOnlyJobQueue = []; var e = this; this.isIdle = true; i.on("updateframe", function (kC) { var T = 12 - kC.frameTime; T = T < 1 ? 1 : T; e.isIdle = false; if (e.idleWorkTimer) { clearInterval(e.idleWorkTimer); e.idleWorkTimer = null } e.runJobs(T) }); this._idleWorkerTicker = (function (T) { return function () { if (T.isIdle) { T.runJobs(); T.runIdleOnlyJobs() } } })(this); i.on("mapglidle", function () { e.isIdle = true; e.runJobs(); e.runIdleOnlyJobs(); e.idleWorkTimer = setInterval(e._idleWorkerTicker, bs.MAX_IDLE_TIME) }); i.on("destroy", function () { if (e.idleWorkTimer) { clearInterval(e.idleWorkTimer); e.idleWorkTimer = null } }) } bs.MAX_IDLE_TIME = 50; bs.MAX_FRAME_TIME = 6; bs.prototype.runJobs = function (i) { if (this._jobQueue.length === 0) { return } var kC = iy(); var e = 0; i = i || bs.MAX_FRAME_TIME; while (this._jobQueue.length && e < i) { var T = this._jobQueue.shift(); if (T.state !== "invalid") { T.call() } e = iy() - kC } }; bs.prototype.runIdleOnlyJobs = function () { if (this._idleOnlyJobQueue.length === 0) { return } var T = iy(); var e = 0; while (this._idleOnlyJobQueue.length && e < bs.MAX_IDLE_TIME) { var i = this._idleOnlyJobQueue.shift(); if (i.state !== "invalid") { i.call() } e = iy() - T } }; bs.prototype.checkIdleRunning = function () { if (this.isIdle && !this.idleWorkTimer) { this.runJobs(); this.runIdleOnlyJobs(); this.idleWorkTimer = setInterval(this._idleWorkerTicker, 50) } }; bs.prototype.addJob = function (e) { this._jobQueue.push(e); this.checkIdleRunning() }; bs.prototype.clearJobs = function () { this._jobQueue.length = 0; this._idleOnlyJobQueue.length = 0 }; bs.prototype.addIdleOnlyJob = function (e) { this._idleOnlyJobQueue.push(e); this.checkIdleRunning() }; var d5 = {}; (function (kF) { if (!kJ) { var kJ = 0.000001 } if (!i) { var i = (typeof Float32Array !== "undefined") ? Float32Array : Array } if (!kD) { var kD = Math.random } var T = {}; var kE = Math.PI / 180; T.toRadian = function (kK) { return kK * kE }; var kI = {}; kI.create = function (kL) { kL = kL || i; var kK = new kL(2); kK[0] = 0; kK[1] = 0; return kK }; kI.clone = function (kK, kM) { kM = kM || i; var kL = new kM(2); kL[0] = kK[0]; kL[1] = kK[1]; return kL }; kI.fromValues = function (kK, kN, kM) { kM = kM || i; var kL = new kM(2); kL[0] = kK; kL[1] = kN; return kL }; kI.copy = function (kL, kK) { kL[0] = kK[0]; kL[1] = kK[1]; return kL }; kI.set = function (kL, kK, kM) { kL[0] = kK; kL[1] = kM; return kL }; kI.add = function (kM, kL, kK) { kM[0] = kL[0] + kK[0]; kM[1] = kL[1] + kK[1]; return kM }; kI.subtract = function (kM, kL, kK) { kM[0] = kL[0] - kK[0]; kM[1] = kL[1] - kK[1]; return kM }; kI.sub = kI.subtract; kI.multiply = function (kM, kL, kK) { kM[0] = kL[0] * kK[0]; kM[1] = kL[1] * kK[1]; return kM }; kI.mul = kI.multiply; kI.divide = function (kM, kL, kK) { kM[0] = kL[0] / kK[0]; kM[1] = kL[1] / kK[1]; return kM }; kI.div = kI.divide; kI.min = function (kM, kL, kK) { kM[0] = Math.min(kL[0], kK[0]); kM[1] = Math.min(kL[1], kK[1]); return kM }; kI.max = function (kM, kL, kK) { kM[0] = Math.max(kL[0], kK[0]); kM[1] = Math.max(kL[1], kK[1]); return kM }; kI.scale = function (kM, kL, kK) { kM[0] = kL[0] * kK; kM[1] = kL[1] * kK; return kM }; kI.scaleAndAdd = function (kM, kL, kK, kN) { kM[0] = kL[0] + (kK[0] * kN); kM[1] = kL[1] + (kK[1] * kN); return kM }; kI.distance = function (kM, kL) { var kK = kL[0] - kM[0], kN = kL[1] - kM[1]; return Math.sqrt(kK * kK + kN * kN) }; kI.dist = kI.distance; kI.squaredDistance = function (kM, kL) { var kK = kL[0] - kM[0], kN = kL[1] - kM[1]; return kK * kK + kN * kN }; kI.sqrDist = kI.squaredDistance; kI.length = function (kL) { var kK = kL[0], kM = kL[1]; return Math.sqrt(kK * kK + kM * kM) }; kI.len = kI.length; kI.squaredLength = function (kL) { var kK = kL[0], kM = kL[1]; return kK * kK + kM * kM }; kI.sqrLen = kI.squaredLength; kI.negate = function (kL, kK) { kL[0] = -kK[0]; kL[1] = -kK[1]; return kL }; kI.normalize = function (kN, kM) { var kL = kM[0], kO = kM[1]; var kK = kL * kL + kO * kO; if (kK > 0) { kK = 1 / Math.sqrt(kK); kN[0] = kM[0] * kK; kN[1] = kM[1] * kK } return kN }; kI.dot = function (kL, kK) { return kL[0] * kK[0] + kL[1] * kK[1] }; kI.cross = function (kM, kL, kK) { var kN = kL[0] * kK[1] - kL[1] * kK[0]; kM[0] = kM[1] = 0; kM[2] = kN; return kM }; kI.lerp = function (kM, kL, kK, kN) { var kP = kL[0], kO = kL[1]; kM[0] = kP + kN * (kK[0] - kP); kM[1] = kO + kN * (kK[1] - kO); return kM }; kI.random = function (kK, kM) { kM = kM || 1; var kL = kD() * 2 * Math.PI; kK[0] = Math.cos(kL) * kM; kK[1] = Math.sin(kL) * kM; return kK }; kI.transformMat2 = function (kN, kM, kL) { var kK = kM[0], kO = kM[1]; kN[0] = kL[0] * kK + kL[2] * kO; kN[1] = kL[1] * kK + kL[3] * kO; return kN }; kI.transformMat2d = function (kN, kM, kL) { var kK = kM[0], kO = kM[1]; kN[0] = kL[0] * kK + kL[2] * kO + kL[4]; kN[1] = kL[1] * kK + kL[3] * kO + kL[5]; return kN }; kI.transformMat3 = function (kN, kM, kL) { var kK = kM[0], kO = kM[1]; kN[0] = kL[0] * kK + kL[3] * kO + kL[6]; kN[1] = kL[1] * kK + kL[4] * kO + kL[7]; return kN }; kI.transformMat4 = function (kN, kM, kL) { var kK = kM[0], kO = kM[1]; kN[0] = kL[0] * kK + kL[4] * kO + kL[12]; kN[1] = kL[1] * kK + kL[5] * kO + kL[13]; return kN }; kI.rotate = function (kN, kL, kK, kR) { var kQ = kL[0] - kK[0]; var kP = kL[1] - kK[1]; var kM = Math.sin(kR); var kO = Math.cos(kR); kN[0] = kQ * kO - kP * kM + kK[0]; kN[1] = kQ * kM + kP * kO + kK[1]; return kN }; kI.forEach = (function () { var kK = kI.create(); return function (kN, kR, kS, kQ, kP, kL) { var kO, kM; if (!kR) { kR = 2 } if (!kS) { kS = 0 } if (kQ) { kM = Math.min((kQ * kR) + kS, kN.length) } else { kM = kN.length } for (kO = kS; kO < kM; kO += kR) { kK[0] = kN[kO]; kK[1] = kN[kO + 1]; kP(kK, kK, kL); kN[kO] = kK[0]; kN[kO + 1] = kK[1] } return kN } })(); kI.str = function (kK) { return "vec2(" + kK[0] + ", " + kK[1] + ")" }; kF.vec2 = kI; var kH = {}; kH.create = function (kL) { kL = kL || i; var kK = new kL(3); kK[0] = 0; kK[1] = 0; kK[2] = 0; return kK }; kH.clone = function (kK, kM) { kM = kM || i; var kL = new kM(3); kL[0] = kK[0]; kL[1] = kK[1]; kL[2] = kK[2]; return kL }; kH.fromValues = function (kK, kO, kM, kN) { kN = kN || i; var kL = new kN(3); kL[0] = kK; kL[1] = kO; kL[2] = kM; return kL }; kH.copy = function (kL, kK) { kL[0] = kK[0]; kL[1] = kK[1]; kL[2] = kK[2]; return kL }; kH.set = function (kL, kK, kN, kM) { kL[0] = kK; kL[1] = kN; kL[2] = kM; return kL }; kH.add = function (kM, kL, kK) { kM[0] = kL[0] + kK[0]; kM[1] = kL[1] + kK[1]; kM[2] = kL[2] + kK[2]; return kM }; kH.subtract = function (kM, kL, kK) { kM[0] = kL[0] - kK[0]; kM[1] = kL[1] - kK[1]; kM[2] = kL[2] - kK[2]; return kM }; kH.sub = kH.subtract; kH.multiply = function (kM, kL, kK) { kM[0] = kL[0] * kK[0]; kM[1] = kL[1] * kK[1]; kM[2] = kL[2] * kK[2]; return kM }; kH.mul = kH.multiply; kH.divide = function (kM, kL, kK) { kM[0] = kL[0] / kK[0]; kM[1] = kL[1] / kK[1]; kM[2] = kL[2] / kK[2]; return kM }; kH.div = kH.divide; kH.min = function (kM, kL, kK) { kM[0] = Math.min(kL[0], kK[0]); kM[1] = Math.min(kL[1], kK[1]); kM[2] = Math.min(kL[2], kK[2]); return kM }; kH.max = function (kM, kL, kK) { kM[0] = Math.max(kL[0], kK[0]); kM[1] = Math.max(kL[1], kK[1]); kM[2] = Math.max(kL[2], kK[2]); return kM }; kH.scale = function (kM, kL, kK) { kM[0] = kL[0] * kK; kM[1] = kL[1] * kK; kM[2] = kL[2] * kK; return kM }; kH.scaleAndAdd = function (kM, kL, kK, kN) { kM[0] = kL[0] + (kK[0] * kN); kM[1] = kL[1] + (kK[1] * kN); kM[2] = kL[2] + (kK[2] * kN); return kM }; kH.distance = function (kM, kL) { var kK = kL[0] - kM[0], kO = kL[1] - kM[1], kN = kL[2] - kM[2]; return Math.sqrt(kK * kK + kO * kO + kN * kN) }; kH.dist = kH.distance; kH.squaredDistance = function (kM, kL) { var kK = kL[0] - kM[0], kO = kL[1] - kM[1], kN = kL[2] - kM[2]; return kK * kK + kO * kO + kN * kN }; kH.sqrDist = kH.squaredDistance; kH.length = function (kL) { var kK = kL[0], kN = kL[1], kM = kL[2]; return Math.sqrt(kK * kK + kN * kN + kM * kM) }; kH.len = kH.length; kH.squaredLength = function (kL) { var kK = kL[0], kN = kL[1], kM = kL[2]; return kK * kK + kN * kN + kM * kM }; kH.sqrLen = kH.squaredLength; kH.negate = function (kL, kK) { kL[0] = -kK[0]; kL[1] = -kK[1]; kL[2] = -kK[2]; return kL }; kH.normalize = function (kN, kM) { var kL = kM[0], kP = kM[1], kO = kM[2]; var kK = kL * kL + kP * kP + kO * kO; if (kK > 0) { kK = 1 / Math.sqrt(kK); kN[0] = kM[0] * kK; kN[1] = kM[1] * kK; kN[2] = kM[2] * kK } return kN }; kH.dot = function (kL, kK) { return kL[0] * kK[0] + kL[1] * kK[1] + kL[2] * kK[2] }; kH.cross = function (kL, kQ, kP) { var kK = kQ[0], kS = kQ[1], kR = kQ[2], kO = kP[0], kN = kP[1], kM = kP[2]; kL[0] = kS * kM - kR * kN; kL[1] = kR * kO - kK * kM; kL[2] = kK * kN - kS * kO; return kL }; kH.lerp = function (kM, kL, kK, kN) { var kQ = kL[0], kP = kL[1], kO = kL[2]; kM[0] = kQ + kN * (kK[0] - kQ); kM[1] = kP + kN * (kK[1] - kP); kM[2] = kO + kN * (kK[2] - kO); return kM }; kH.random = function (kK, kO) { kO = kO || 1; var kM = kD() * 2 * Math.PI; var kN = (kD() * 2) - 1; var kL = Math.sqrt(1 - kN * kN) * kO; kK[0] = Math.cos(kM) * kL; kK[1] = Math.sin(kM) * kL; kK[2] = kN * kO; return kK }; kH.transformMat4 = function (kN, kM, kL) { var kK = kM[0], kP = kM[1], kO = kM[2]; kN[0] = kL[0] * kK + kL[4] * kP + kL[8] * kO + kL[12]; kN[1] = kL[1] * kK + kL[5] * kP + kL[9] * kO + kL[13]; kN[2] = kL[2] * kK + kL[6] * kP + kL[10] * kO + kL[14]; return kN }; kH.transformMat3 = function (kN, kM, kL) { var kK = kM[0], kP = kM[1], kO = kM[2]; kN[0] = kK * kL[0] + kP * kL[3] + kO * kL[6]; kN[1] = kK * kL[1] + kP * kL[4] + kO * kL[7]; kN[2] = kK * kL[2] + kP * kL[5] + kO * kL[8]; return kN }; kH.transformQuat = function (kQ, kW, kK) { var kX = kW[0], kV = kW[1], kU = kW[2], kS = kK[0], kR = kK[1], kP = kK[2], kT = kK[3], kN = kT * kX + kR * kU - kP * kV, kM = kT * kV + kP * kX - kS * kU, kL = kT * kU + kS * kV - kR * kX, kO = -kS * kX - kR * kV - kP * kU; kQ[0] = kN * kT + kO * -kS + kM * -kP - kL * -kR; kQ[1] = kM * kT + kO * -kR + kL * -kS - kN * -kP; kQ[2] = kL * kT + kO * -kP + kN * -kR - kM * -kS; return kQ }; kH.rotateX = function (kM, kL, kK, kP) { var kO = [], kN = []; kO[0] = kL[0] - kK[0]; kO[1] = kL[1] - kK[1]; kO[2] = kL[2] - kK[2]; kN[0] = kO[0]; kN[1] = kO[1] * Math.cos(kP) - kO[2] * Math.sin(kP); kN[2] = kO[1] * Math.sin(kP) + kO[2] * Math.cos(kP); kM[0] = kN[0] + kK[0]; kM[1] = kN[1] + kK[1]; kM[2] = kN[2] + kK[2]; return kM }; kH.rotateY = function (kM, kL, kK, kP) { var kO = [], kN = []; kO[0] = kL[0] - kK[0]; kO[1] = kL[1] - kK[1]; kO[2] = kL[2] - kK[2]; kN[0] = kO[2] * Math.sin(kP) + kO[0] * Math.cos(kP); kN[1] = kO[1]; kN[2] = kO[2] * Math.cos(kP) - kO[0] * Math.sin(kP); kM[0] = kN[0] + kK[0]; kM[1] = kN[1] + kK[1]; kM[2] = kN[2] + kK[2]; return kM }; kH.rotateZ = function (kM, kL, kK, kP) { var kO = [], kN = []; kO[0] = kL[0] - kK[0]; kO[1] = kL[1] - kK[1]; kO[2] = kL[2] - kK[2]; kN[0] = kO[0] * Math.cos(kP) - kO[1] * Math.sin(kP); kN[1] = kO[0] * Math.sin(kP) + kO[1] * Math.cos(kP); kN[2] = kO[2]; kM[0] = kN[0] + kK[0]; kM[1] = kN[1] + kK[1]; kM[2] = kN[2] + kK[2]; return kM }; kH.forEach = (function () { var kK = kH.create(); return function (kN, kR, kS, kQ, kP, kL) { var kO, kM; if (!kR) { kR = 3 } if (!kS) { kS = 0 } if (kQ) { kM = Math.min((kQ * kR) + kS, kN.length) } else { kM = kN.length } for (kO = kS; kO < kM; kO += kR) { kK[0] = kN[kO]; kK[1] = kN[kO + 1]; kK[2] = kN[kO + 2]; kP(kK, kK, kL); kN[kO] = kK[0]; kN[kO + 1] = kK[1]; kN[kO + 2] = kK[2] } return kN } })(); kH.str = function (kK) { return "vec3(" + kK[0] + ", " + kK[1] + ", " + kK[2] + ")" }; kF.vec3 = kH; var kG = {}; kG.create = function (kL) { kL = kL || i; var kK = new kL(4); kK[0] = 0; kK[1] = 0; kK[2] = 0; kK[3] = 0; return kK }; kG.clone = function (kK, kM) { kM = kM || i; var kL = new kM(4); kL[0] = kK[0]; kL[1] = kK[1]; kL[2] = kK[2]; kL[3] = kK[3]; return kL }; kG.fromValues = function (kK, kP, kN, kL, kO) { kO = kO || i; var kM = new kO(4); kM[0] = kK; kM[1] = kP; kM[2] = kN; kM[3] = kL; return kM }; kG.copy = function (kL, kK) { kL[0] = kK[0]; kL[1] = kK[1]; kL[2] = kK[2]; kL[3] = kK[3]; return kL }; kG.set = function (kM, kK, kO, kN, kL) { kM[0] = kK; kM[1] = kO; kM[2] = kN; kM[3] = kL; return kM }; kG.add = function (kM, kL, kK) { kM[0] = kL[0] + kK[0]; kM[1] = kL[1] + kK[1]; kM[2] = kL[2] + kK[2]; kM[3] = kL[3] + kK[3]; return kM }; kG.subtract = function (kM, kL, kK) { kM[0] = kL[0] - kK[0]; kM[1] = kL[1] - kK[1]; kM[2] = kL[2] - kK[2]; kM[3] = kL[3] - kK[3]; return kM }; kG.sub = kG.subtract; kG.multiply = function (kM, kL, kK) { kM[0] = kL[0] * kK[0]; kM[1] = kL[1] * kK[1]; kM[2] = kL[2] * kK[2]; kM[3] = kL[3] * kK[3]; return kM }; kG.mul = kG.multiply; kG.divide = function (kM, kL, kK) { kM[0] = kL[0] / kK[0]; kM[1] = kL[1] / kK[1]; kM[2] = kL[2] / kK[2]; kM[3] = kL[3] / kK[3]; return kM }; kG.div = kG.divide; kG.min = function (kM, kL, kK) { kM[0] = Math.min(kL[0], kK[0]); kM[1] = Math.min(kL[1], kK[1]); kM[2] = Math.min(kL[2], kK[2]); kM[3] = Math.min(kL[3], kK[3]); return kM }; kG.max = function (kM, kL, kK) { kM[0] = Math.max(kL[0], kK[0]); kM[1] = Math.max(kL[1], kK[1]); kM[2] = Math.max(kL[2], kK[2]); kM[3] = Math.max(kL[3], kK[3]); return kM }; kG.scale = function (kM, kL, kK) { kM[0] = kL[0] * kK; kM[1] = kL[1] * kK; kM[2] = kL[2] * kK; kM[3] = kL[3] * kK; return kM }; kG.scaleAndAdd = function (kM, kL, kK, kN) { kM[0] = kL[0] + (kK[0] * kN); kM[1] = kL[1] + (kK[1] * kN); kM[2] = kL[2] + (kK[2] * kN); kM[3] = kL[3] + (kK[3] * kN); return kM }; kG.distance = function (kN, kL) { var kK = kL[0] - kN[0], kP = kL[1] - kN[1], kO = kL[2] - kN[2], kM = kL[3] - kN[3]; return Math.sqrt(kK * kK + kP * kP + kO * kO + kM * kM) }; kG.dist = kG.distance; kG.squaredDistance = function (kN, kL) { var kK = kL[0] - kN[0], kP = kL[1] - kN[1], kO = kL[2] - kN[2], kM = kL[3] - kN[3]; return kK * kK + kP * kP + kO * kO + kM * kM }; kG.sqrDist = kG.squaredDistance; kG.length = function (kM) { var kK = kM[0], kO = kM[1], kN = kM[2], kL = kM[3]; return Math.sqrt(kK * kK + kO * kO + kN * kN + kL * kL) }; kG.len = kG.length; kG.squaredLength = function (kM) { var kK = kM[0], kO = kM[1], kN = kM[2], kL = kM[3]; return kK * kK + kO * kO + kN * kN + kL * kL }; kG.sqrLen = kG.squaredLength; kG.negate = function (kL, kK) { kL[0] = -kK[0]; kL[1] = -kK[1]; kL[2] = -kK[2]; kL[3] = -kK[3]; return kL }; kG.normalize = function (kO, kN) { var kL = kN[0], kQ = kN[1], kP = kN[2], kM = kN[3]; var kK = kL * kL + kQ * kQ + kP * kP + kM * kM; if (kK > 0) { kK = 1 / Math.sqrt(kK); kO[0] = kN[0] * kK; kO[1] = kN[1] * kK; kO[2] = kN[2] * kK; kO[3] = kN[3] * kK } return kO }; kG.dot = function (kL, kK) { return kL[0] * kK[0] + kL[1] * kK[1] + kL[2] * kK[2] + kL[3] * kK[3] }; kG.lerp = function (kM, kL, kK, kN) { var kQ = kL[0], kP = kL[1], kO = kL[2], kR = kL[3]; kM[0] = kQ + kN * (kK[0] - kQ); kM[1] = kP + kN * (kK[1] - kP); kM[2] = kO + kN * (kK[2] - kO); kM[3] = kR + kN * (kK[3] - kR); return kM }; kG.random = function (kK, kL) { kL = kL || 1; kK[0] = kD(); kK[1] = kD(); kK[2] = kD(); kK[3] = kD(); kG.normalize(kK, kK); kG.scale(kK, kK, kL); return kK }; kG.transformMat4 = function (kO, kN, kL) { var kK = kN[0], kQ = kN[1], kP = kN[2], kM = kN[3]; kO[0] = kL[0] * kK + kL[4] * kQ + kL[8] * kP + kL[12] * kM; kO[1] = kL[1] * kK + kL[5] * kQ + kL[9] * kP + kL[13] * kM; kO[2] = kL[2] * kK + kL[6] * kQ + kL[10] * kP + kL[14] * kM; kO[3] = kL[3] * kK + kL[7] * kQ + kL[11] * kP + kL[15] * kM; return kO }; kG.transformQuat = function (kQ, kW, kK) { var kX = kW[0], kV = kW[1], kU = kW[2], kS = kK[0], kR = kK[1], kP = kK[2], kT = kK[3], kN = kT * kX + kR * kU - kP * kV, kM = kT * kV + kP * kX - kS * kU, kL = kT * kU + kS * kV - kR * kX, kO = -kS * kX - kR * kV - kP * kU; kQ[0] = kN * kT + kO * -kS + kM * -kP - kL * -kR; kQ[1] = kM * kT + kO * -kR + kL * -kS - kN * -kP; kQ[2] = kL * kT + kO * -kP + kN * -kR - kM * -kS; return kQ }; kG.forEach = (function () { var kK = kG.create(); return function (kN, kR, kS, kQ, kP, kL) { var kO, kM; if (!kR) { kR = 4 } if (!kS) { kS = 0 } if (kQ) { kM = Math.min((kQ * kR) + kS, kN.length) } else { kM = kN.length } for (kO = kS; kO < kM; kO += kR) { kK[0] = kN[kO]; kK[1] = kN[kO + 1]; kK[2] = kN[kO + 2]; kK[3] = kN[kO + 3]; kP(kK, kK, kL); kN[kO] = kK[0]; kN[kO + 1] = kK[1]; kN[kO + 2] = kK[2]; kN[kO + 3] = kK[3] } return kN } })(); kG.str = function (kK) { return "vec4(" + kK[0] + ", " + kK[1] + ", " + kK[2] + ", " + kK[3] + ")" }; kF.vec4 = kG; var kC = {}; kC.create = function (kL) { kL = kL || i; var kK = new kL(4); kK[0] = 1; kK[1] = 0; kK[2] = 0; kK[3] = 1; return kK }; kC.clone = function (kK, kM) { kM = kM || i; var kL = new kM(4); kL[0] = kK[0]; kL[1] = kK[1]; kL[2] = kK[2]; kL[3] = kK[3]; return kL }; kC.copy = function (kL, kK) { kL[0] = kK[0]; kL[1] = kK[1]; kL[2] = kK[2]; kL[3] = kK[3]; return kL }; kC.identity = function (kK) { kK[0] = 1; kK[1] = 0; kK[2] = 0; kK[3] = 1; return kK }; kC.transpose = function (kM, kL) { if (kM === kL) { var kK = kL[1]; kM[1] = kL[2]; kM[2] = kK } else { kM[0] = kL[0]; kM[1] = kL[2]; kM[2] = kL[1]; kM[3] = kL[3] } return kM }; kC.invert = function (kO, kM) { var kN = kM[0], kL = kM[1], kK = kM[2], kQ = kM[3], kP = kN * kQ - kK * kL; if (!kP) { return null } kP = 1 / kP; kO[0] = kQ * kP; kO[1] = -kL * kP; kO[2] = -kK * kP; kO[3] = kN * kP; return kO }; kC.adjoint = function (kM, kK) { var kL = kK[0]; kM[0] = kK[3]; kM[1] = -kK[1]; kM[2] = -kK[2]; kM[3] = kL; return kM }; kC.determinant = function (kK) { return kK[0] * kK[3] - kK[2] * kK[1] }; kC.multiply = function (kO, kT, kR) { var kN = kT[0], kM = kT[1], kL = kT[2], kK = kT[3]; var kU = kR[0], kS = kR[1], kQ = kR[2], kP = kR[3]; kO[0] = kN * kU + kL * kS; kO[1] = kM * kU + kK * kS; kO[2] = kN * kQ + kL * kP; kO[3] = kM * kQ + kK * kP; return kO }; kC.mul = kC.multiply; kC.rotate = function (kO, kR, kQ) { var kN = kR[0], kM = kR[1], kL = kR[2], kK = kR[3], kS = Math.sin(kQ), kP = Math.cos(kQ); kO[0] = kN * kP + kL * kS; kO[1] = kM * kP + kK * kS; kO[2] = kN * -kS + kL * kP; kO[3] = kM * -kS + kK * kP; return kO }; kC.scale = function (kO, kP, kR) { var kN = kP[0], kM = kP[1], kL = kP[2], kK = kP[3], kS = kR[0], kQ = kR[1]; kO[0] = kN * kS; kO[1] = kM * kS; kO[2] = kL * kQ; kO[3] = kK * kQ; return kO }; kC.str = function (kK) { return "mat2(" + kK[0] + ", " + kK[1] + ", " + kK[2] + ", " + kK[3] + ")" }; kC.frob = function (kK) { return (Math.sqrt(Math.pow(kK[0], 2) + Math.pow(kK[1], 2) + Math.pow(kK[2], 2) + Math.pow(kK[3], 2))) }; kC.LDU = function (kK, kN, kM, kL) { kK[2] = kL[2] / kL[0]; kM[0] = kL[0]; kM[1] = kL[1]; kM[3] = kL[3] - kK[2] * kM[1]; return [kK, kN, kM] }; kF.mat2 = kC; var e = {}; e.create = function (kL) { kL = kL || i; var kK = new kL(16); kK[0] = 1; kK[1] = 0; kK[2] = 0; kK[3] = 0; kK[4] = 0; kK[5] = 1; kK[6] = 0; kK[7] = 0; kK[8] = 0; kK[9] = 0; kK[10] = 1; kK[11] = 0; kK[12] = 0; kK[13] = 0; kK[14] = 0; kK[15] = 1; return kK }; e.clone = function (kK) { var kL = new i(16); kL[0] = kK[0]; kL[1] = kK[1]; kL[2] = kK[2]; kL[3] = kK[3]; kL[4] = kK[4]; kL[5] = kK[5]; kL[6] = kK[6]; kL[7] = kK[7]; kL[8] = kK[8]; kL[9] = kK[9]; kL[10] = kK[10]; kL[11] = kK[11]; kL[12] = kK[12]; kL[13] = kK[13]; kL[14] = kK[14]; kL[15] = kK[15]; return kL }; e.copy = function (kL, kK) { kL[0] = kK[0]; kL[1] = kK[1]; kL[2] = kK[2]; kL[3] = kK[3]; kL[4] = kK[4]; kL[5] = kK[5]; kL[6] = kK[6]; kL[7] = kK[7]; kL[8] = kK[8]; kL[9] = kK[9]; kL[10] = kK[10]; kL[11] = kK[11]; kL[12] = kK[12]; kL[13] = kK[13]; kL[14] = kK[14]; kL[15] = kK[15]; return kL }; e.identity = function (kK) { kK[0] = 1; kK[1] = 0; kK[2] = 0; kK[3] = 0; kK[4] = 0; kK[5] = 1; kK[6] = 0; kK[7] = 0; kK[8] = 0; kK[9] = 0; kK[10] = 1; kK[11] = 0; kK[12] = 0; kK[13] = 0; kK[14] = 0; kK[15] = 1; return kK }; e.transpose = function (kN, kM) { if (kN === kM) { var kR = kM[1], kP = kM[2], kO = kM[3], kK = kM[6], kQ = kM[7], kL = kM[11]; kN[1] = kM[4]; kN[2] = kM[8]; kN[3] = kM[12]; kN[4] = kR; kN[6] = kM[9]; kN[7] = kM[13]; kN[8] = kP; kN[9] = kK; kN[11] = kM[14]; kN[12] = kO; kN[13] = kQ; kN[14] = kL } else { kN[0] = kM[0]; kN[1] = kM[4]; kN[2] = kM[8]; kN[3] = kM[12]; kN[4] = kM[1]; kN[5] = kM[5]; kN[6] = kM[9]; kN[7] = kM[13]; kN[8] = kM[2]; kN[9] = kM[6]; kN[10] = kM[10]; kN[11] = kM[14]; kN[12] = kM[3]; kN[13] = kM[7]; kN[14] = kM[11]; kN[15] = kM[15] } return kN }; e.invert = function (k3, k8) { var lc = k8[0], la = k8[1], k9 = k8[2], k6 = k8[3], kO = k8[4], kN = k8[5], kM = k8[6], kL = k8[7], k2 = k8[8], k1 = k8[9], k0 = k8[10], kZ = k8[11], le = k8[12], ld = k8[13], lb = k8[14], k7 = k8[15], kY = lc * kN - la * kO, kX = lc * kM - k9 * kO, kW = lc * kL - k6 * kO, kV = la * kM - k9 * kN, kU = la * kL - k6 * kN, kT = k9 * kL - k6 * kM, kS = k2 * ld - k1 * le, kR = k2 * lb - k0 * le, kQ = k2 * k7 - kZ * le, kP = k1 * lb - k0 * ld, k5 = k1 * k7 - kZ * ld, k4 = k0 * k7 - kZ * lb, kK = kY * k4 - kX * k5 + kW * kP + kV * kQ - kU * kR + kT * kS; if (!kK) { return null } kK = 1 / kK; k3[0] = (kN * k4 - kM * k5 + kL * kP) * kK; k3[1] = (k9 * k5 - la * k4 - k6 * kP) * kK; k3[2] = (ld * kT - lb * kU + k7 * kV) * kK; k3[3] = (k0 * kU - k1 * kT - kZ * kV) * kK; k3[4] = (kM * kQ - kO * k4 - kL * kR) * kK; k3[5] = (lc * k4 - k9 * kQ + k6 * kR) * kK; k3[6] = (lb * kW - le * kT - k7 * kX) * kK; k3[7] = (k2 * kT - k0 * kW + kZ * kX) * kK; k3[8] = (kO * k5 - kN * kQ + kL * kS) * kK; k3[9] = (la * kQ - lc * k5 - k6 * kS) * kK; k3[10] = (le * kU - ld * kW + k7 * kY) * kK; k3[11] = (k1 * kW - k2 * kU - kZ * kY) * kK; k3[12] = (kN * kR - kO * kP - kM * kS) * kK; k3[13] = (lc * kP - la * kR + k9 * kS) * kK; k3[14] = (ld * kX - le * kV - lb * kY) * kK; k3[15] = (k2 * kV - k1 * kX + k0 * kY) * kK; return k3 }; e.adjoint = function (kS, kV) { var kZ = kV[0], kX = kV[1], kW = kV[2], kT = kV[3], kN = kV[4], kM = kV[5], kL = kV[6], kK = kV[7], kR = kV[8], kQ = kV[9], kP = kV[10], kO = kV[11], k1 = kV[12], k0 = kV[13], kY = kV[14], kU = kV[15]; kS[0] = (kM * (kP * kU - kO * kY) - kQ * (kL * kU - kK * kY) + k0 * (kL * kO - kK * kP)); kS[1] = -(kX * (kP * kU - kO * kY) - kQ * (kW * kU - kT * kY) + k0 * (kW * kO - kT * kP)); kS[2] = (kX * (kL * kU - kK * kY) - kM * (kW * kU - kT * kY) + k0 * (kW * kK - kT * kL)); kS[3] = -(kX * (kL * kO - kK * kP) - kM * (kW * kO - kT * kP) + kQ * (kW * kK - kT * kL)); kS[4] = -(kN * (kP * kU - kO * kY) - kR * (kL * kU - kK * kY) + k1 * (kL * kO - kK * kP)); kS[5] = (kZ * (kP * kU - kO * kY) - kR * (kW * kU - kT * kY) + k1 * (kW * kO - kT * kP)); kS[6] = -(kZ * (kL * kU - kK * kY) - kN * (kW * kU - kT * kY) + k1 * (kW * kK - kT * kL)); kS[7] = (kZ * (kL * kO - kK * kP) - kN * (kW * kO - kT * kP) + kR * (kW * kK - kT * kL)); kS[8] = (kN * (kQ * kU - kO * k0) - kR * (kM * kU - kK * k0) + k1 * (kM * kO - kK * kQ)); kS[9] = -(kZ * (kQ * kU - kO * k0) - kR * (kX * kU - kT * k0) + k1 * (kX * kO - kT * kQ)); kS[10] = (kZ * (kM * kU - kK * k0) - kN * (kX * kU - kT * k0) + k1 * (kX * kK - kT * kM)); kS[11] = -(kZ * (kM * kO - kK * kQ) - kN * (kX * kO - kT * kQ) + kR * (kX * kK - kT * kM)); kS[12] = -(kN * (kQ * kY - kP * k0) - kR * (kM * kY - kL * k0) + k1 * (kM * kP - kL * kQ)); kS[13] = (kZ * (kQ * kY - kP * k0) - kR * (kX * kY - kW * k0) + k1 * (kX * kP - kW * kQ)); kS[14] = -(kZ * (kM * kY - kL * k0) - kN * (kX * kY - kW * k0) + k1 * (kX * kL - kW * kM)); kS[15] = (kZ * (kM * kP - kL * kQ) - kN * (kX * kP - kW * kQ) + kR * (kX * kL - kW * kM)); return kS }; e.determinant = function (k5) { var la = k5[0], k8 = k5[1], k6 = k5[2], k4 = k5[3], kN = k5[4], kM = k5[5], kL = k5[6], kK = k5[7], k1 = k5[8], k0 = k5[9], kZ = k5[10], kY = k5[11], lc = k5[12], lb = k5[13], k9 = k5[14], k7 = k5[15], kX = la * kM - k8 * kN, kW = la * kL - k6 * kN, kV = la * kK - k4 * kN, kU = k8 * kL - k6 * kM, kT = k8 * kK - k4 * kM, kS = k6 * kK - k4 * kL, kR = k1 * lb - k0 * lc, kQ = k1 * k9 - kZ * lc, kP = k1 * k7 - kY * lc, kO = k0 * k9 - kZ * lb, k3 = k0 * k7 - kY * lb, k2 = kZ * k7 - kY * k9; return kX * k2 - kW * k3 + kV * kO + kU * kP - kT * kQ + kS * kR }; e.multiply = function (kW, k0, kX) { var k4 = k0[0], k3 = k0[1], k1 = k0[2], kY = k0[3], kQ = k0[4], kO = k0[5], kM = k0[6], kK = k0[7], kV = k0[8], kU = k0[9], kT = k0[10], kS = k0[11], k6 = k0[12], k5 = k0[13], k2 = k0[14], kZ = k0[15]; var kR = kX[0], kP = kX[1], kN = kX[2], kL = kX[3]; kW[0] = kR * k4 + kP * kQ + kN * kV + kL * k6; kW[1] = kR * k3 + kP * kO + kN * kU + kL * k5; kW[2] = kR * k1 + kP * kM + kN * kT + kL * k2; kW[3] = kR * kY + kP * kK + kN * kS + kL * kZ; kR = kX[4]; kP = kX[5]; kN = kX[6]; kL = kX[7]; kW[4] = kR * k4 + kP * kQ + kN * kV + kL * k6; kW[5] = kR * k3 + kP * kO + kN * kU + kL * k5; kW[6] = kR * k1 + kP * kM + kN * kT + kL * k2; kW[7] = kR * kY + kP * kK + kN * kS + kL * kZ; kR = kX[8]; kP = kX[9]; kN = kX[10]; kL = kX[11]; kW[8] = kR * k4 + kP * kQ + kN * kV + kL * k6; kW[9] = kR * k3 + kP * kO + kN * kU + kL * k5; kW[10] = kR * k1 + kP * kM + kN * kT + kL * k2; kW[11] = kR * kY + kP * kK + kN * kS + kL * kZ; kR = kX[12]; kP = kX[13]; kN = kX[14]; kL = kX[15]; kW[12] = kR * k4 + kP * kQ + kN * kV + kL * k6; kW[13] = kR * k3 + kP * kO + kN * kU + kL * k5; kW[14] = kR * k1 + kP * kM + kN * kT + kL * k2; kW[15] = kR * kY + kP * kK + kN * kS + kL * kZ; return kW }; e.mul = e.multiply; e.translate = function (kW, kY, kR) { var kQ = kR[0], kP = kR[1], kO = kR[2], k1, k0, kZ, kX, kN, kM, kL, kK, kV, kU, kT, kS; if (kY === kW) { kW[12] = kY[0] * kQ + kY[4] * kP + kY[8] * kO + kY[12]; kW[13] = kY[1] * kQ + kY[5] * kP + kY[9] * kO + kY[13]; kW[14] = kY[2] * kQ + kY[6] * kP + kY[10] * kO + kY[14]; kW[15] = kY[3] * kQ + kY[7] * kP + kY[11] * kO + kY[15] } else { k1 = kY[0]; k0 = kY[1]; kZ = kY[2]; kX = kY[3]; kN = kY[4]; kM = kY[5]; kL = kY[6]; kK = kY[7]; kV = kY[8]; kU = kY[9]; kT = kY[10]; kS = kY[11]; kW[0] = k1; kW[1] = k0; kW[2] = kZ; kW[3] = kX; kW[4] = kN; kW[5] = kM; kW[6] = kL; kW[7] = kK; kW[8] = kV; kW[9] = kU; kW[10] = kT; kW[11] = kS; kW[12] = k1 * kQ + kN * kP + kV * kO + kY[12]; kW[13] = k0 * kQ + kM * kP + kU * kO + kY[13]; kW[14] = kZ * kQ + kL * kP + kT * kO + kY[14]; kW[15] = kX * kQ + kK * kP + kS * kO + kY[15] } return kW }; e.scale = function (kN, kL, kM) { var kK = kM[0], kP = kM[1], kO = kM[2]; kN[0] = kL[0] * kK; kN[1] = kL[1] * kK; kN[2] = kL[2] * kK; kN[3] = kL[3] * kK; kN[4] = kL[4] * kP; kN[5] = kL[5] * kP; kN[6] = kL[6] * kP; kN[7] = kL[7] * kP; kN[8] = kL[8] * kO; kN[9] = kL[9] * kO; kN[10] = kL[10] * kO; kN[11] = kL[11] * kO; kN[12] = kL[12]; kN[13] = kL[13]; kN[14] = kL[14]; kN[15] = kL[15]; return kN }; e.rotate = function (k4, lb, ld, kK) { var kU = kK[0], kT = kK[1], kS = kK[2], k5 = Math.sqrt(kU * kU + kT * kT + kS * kS), kZ, k9, kY, lf, le, lc, la, kR, kQ, kP, kO, k3, k2, k1, k0, kX, kW, kV, k8, k7, k6, kN, kM, kL; if (Math.abs(k5) < kJ) { return null } k5 = 1 / k5; kU *= k5; kT *= k5; kS *= k5; kZ = Math.sin(ld); k9 = Math.cos(ld); kY = 1 - k9; lf = lb[0]; le = lb[1]; lc = lb[2]; la = lb[3]; kR = lb[4]; kQ = lb[5]; kP = lb[6]; kO = lb[7]; k3 = lb[8]; k2 = lb[9]; k1 = lb[10]; k0 = lb[11]; kX = kU * kU * kY + k9; kW = kT * kU * kY + kS * kZ; kV = kS * kU * kY - kT * kZ; k8 = kU * kT * kY - kS * kZ; k7 = kT * kT * kY + k9; k6 = kS * kT * kY + kU * kZ; kN = kU * kS * kY + kT * kZ; kM = kT * kS * kY - kU * kZ; kL = kS * kS * kY + k9; k4[0] = lf * kX + kR * kW + k3 * kV; k4[1] = le * kX + kQ * kW + k2 * kV; k4[2] = lc * kX + kP * kW + k1 * kV; k4[3] = la * kX + kO * kW + k0 * kV; k4[4] = lf * k8 + kR * k7 + k3 * k6; k4[5] = le * k8 + kQ * k7 + k2 * k6; k4[6] = lc * k8 + kP * k7 + k1 * k6; k4[7] = la * k8 + kO * k7 + k0 * k6; k4[8] = lf * kN + kR * kM + k3 * kL; k4[9] = le * kN + kQ * kM + k2 * kL; k4[10] = lc * kN + kP * kM + k1 * kL; k4[11] = la * kN + kO * kM + k0 * kL; if (lb !== k4) { k4[12] = lb[12]; k4[13] = lb[13]; k4[14] = lb[14]; k4[15] = lb[15] } return k4 }; e.rotateX = function (kK, kR, kQ) { var kW = Math.sin(kQ), kP = Math.cos(kQ), kV = kR[4], kU = kR[5], kT = kR[6], kS = kR[7], kO = kR[8], kN = kR[9], kM = kR[10], kL = kR[11]; if (kR !== kK) { kK[0] = kR[0]; kK[1] = kR[1]; kK[2] = kR[2]; kK[3] = kR[3]; kK[12] = kR[12]; kK[13] = kR[13]; kK[14] = kR[14]; kK[15] = kR[15] } kK[4] = kV * kP + kO * kW; kK[5] = kU * kP + kN * kW; kK[6] = kT * kP + kM * kW; kK[7] = kS * kP + kL * kW; kK[8] = kO * kP - kV * kW; kK[9] = kN * kP - kU * kW; kK[10] = kM * kP - kT * kW; kK[11] = kL * kP - kS * kW; return kK }; e.rotateY = function (kO, kV, kU) { var kW = Math.sin(kU), kT = Math.cos(kU), kN = kV[0], kM = kV[1], kL = kV[2], kK = kV[3], kS = kV[8], kR = kV[9], kQ = kV[10], kP = kV[11]; if (kV !== kO) { kO[4] = kV[4]; kO[5] = kV[5]; kO[6] = kV[6]; kO[7] = kV[7]; kO[12] = kV[12]; kO[13] = kV[13]; kO[14] = kV[14]; kO[15] = kV[15] } kO[0] = kN * kT - kS * kW; kO[1] = kM * kT - kR * kW; kO[2] = kL * kT - kQ * kW; kO[3] = kK * kT - kP * kW; kO[8] = kN * kW + kS * kT; kO[9] = kM * kW + kR * kT; kO[10] = kL * kW + kQ * kT; kO[11] = kK * kW + kP * kT; return kO }; e.rotateZ = function (kO, kR, kQ) { var kW = Math.sin(kQ), kP = Math.cos(kQ), kN = kR[0], kM = kR[1], kL = kR[2], kK = kR[3], kV = kR[4], kU = kR[5], kT = kR[6], kS = kR[7]; if (kR !== kO) { kO[8] = kR[8]; kO[9] = kR[9]; kO[10] = kR[10]; kO[11] = kR[11]; kO[12] = kR[12]; kO[13] = kR[13]; kO[14] = kR[14]; kO[15] = kR[15] } kO[0] = kN * kP + kV * kW; kO[1] = kM * kP + kU * kW; kO[2] = kL * kP + kT * kW; kO[3] = kK * kP + kS * kW; kO[4] = kV * kP - kN * kW; kO[5] = kU * kP - kM * kW; kO[6] = kT * kP - kL * kW; kO[7] = kS * kP - kK * kW; return kO }; e.fromRotationTranslation = function (kX, kV, kT) { var kQ = kV[0], kP = kV[1], kO = kV[2], kR = kV[3], kY = kQ + kQ, kK = kP + kP, kS = kO + kO, kN = kQ * kY, kM = kQ * kK, kL = kQ * kS, kW = kP * kK, kU = kP * kS, k1 = kO * kS, k2 = kR * kY, k0 = kR * kK, kZ = kR * kS; kX[0] = 1 - (kW + k1); kX[1] = kM + kZ; kX[2] = kL - k0; kX[3] = 0; kX[4] = kM - kZ; kX[5] = 1 - (kN + k1); kX[6] = kU + k2; kX[7] = 0; kX[8] = kL + k0; kX[9] = kU - k2; kX[10] = 1 - (kN + kW); kX[11] = 0; kX[12] = kT[0]; kX[13] = kT[1]; kX[14] = kT[2]; kX[15] = 1; return kX }; e.fromQuat = function (kU, kR) { var kO = kR[0], kN = kR[1], kM = kR[2], kP = kR[3], kV = kO + kO, kK = kN + kN, kQ = kM + kM, kL = kO * kV, kT = kN * kV, kS = kN * kK, k1 = kM * kV, k0 = kM * kK, kY = kM * kQ, kZ = kP * kV, kX = kP * kK, kW = kP * kQ; kU[0] = 1 - kS - kY; kU[1] = kT + kW; kU[2] = k1 - kX; kU[3] = 0; kU[4] = kT - kW; kU[5] = 1 - kL - kY; kU[6] = k0 + kZ; kU[7] = 0; kU[8] = k1 + kX; kU[9] = k0 - kZ; kU[10] = 1 - kL - kS; kU[11] = 0; kU[12] = 0; kU[13] = 0; kU[14] = 0; kU[15] = 1; return kU }; e.frustum = function (kO, kL, kT, kK, kS, kQ, kP) { var kR = 1 / (kT - kL), kN = 1 / (kS - kK), kM = 1 / (kQ - kP); kO[0] = (kQ * 2) * kR; kO[1] = 0; kO[2] = 0; kO[3] = 0; kO[4] = 0; kO[5] = (kQ * 2) * kN; kO[6] = 0; kO[7] = 0; kO[8] = (kT + kL) * kR; kO[9] = (kS + kK) * kN; kO[10] = (kP + kQ) * kM; kO[11] = -1; kO[12] = 0; kO[13] = 0; kO[14] = (kP * kQ * 2) * kM; kO[15] = 0; return kO }; e.perspective = function (kN, kM, kL, kO, kK) { var kQ = 1 / Math.tan(kM / 2), kP = 1 / (kO - kK); kN[0] = kQ / kL; kN[1] = 0; kN[2] = 0; kN[3] = 0; kN[4] = 0; kN[5] = kQ; kN[6] = 0; kN[7] = 0; kN[8] = 0; kN[9] = 0; kN[10] = (kK + kO) * kP; kN[11] = -1; kN[12] = 0; kN[13] = 0; kN[14] = (2 * kK * kO) * kP; kN[15] = 0; return kN }; e.ortho = function (kN, kL, kT, kK, kR, kQ, kP) { var kO = 1 / (kL - kT), kS = 1 / (kK - kR), kM = 1 / (kQ - kP); kN[0] = -2 * kO; kN[1] = 0; kN[2] = 0; kN[3] = 0; kN[4] = 0; kN[5] = -2 * kS; kN[6] = 0; kN[7] = 0; kN[8] = 0; kN[9] = 0; kN[10] = 2 * kM; kN[11] = 0; kN[12] = (kL + kT) * kO; kN[13] = (kR + kK) * kS; kN[14] = (kP + kQ) * kM; kN[15] = 1; return kN }; e.lookAt = function (kY, k5, k6, kQ) { var k4, k3, k1, kM, kL, kK, kT, kS, kR, kZ, k2 = k5[0], k0 = k5[1], kX = k5[2], kP = kQ[0], kO = kQ[1], kN = kQ[2], kW = k6[0], kV = k6[1], kU = k6[2]; if (Math.abs(k2 - kW) < kJ && Math.abs(k0 - kV) < kJ && Math.abs(kX - kU) < kJ) { return e.identity(kY) } kT = k2 - kW; kS = k0 - kV; kR = kX - kU; kZ = 1 / Math.sqrt(kT * kT + kS * kS + kR * kR); kT *= kZ; kS *= kZ; kR *= kZ; k4 = kO * kR - kN * kS; k3 = kN * kT - kP * kR; k1 = kP * kS - kO * kT; kZ = Math.sqrt(k4 * k4 + k3 * k3 + k1 * k1); if (!kZ) { k4 = 0; k3 = 0; k1 = 0 } else { kZ = 1 / kZ; k4 *= kZ; k3 *= kZ; k1 *= kZ } kM = kS * k1 - kR * k3; kL = kR * k4 - kT * k1; kK = kT * k3 - kS * k4; kZ = Math.sqrt(kM * kM + kL * kL + kK * kK); if (!kZ) { kM = 0; kL = 0; kK = 0 } else { kZ = 1 / kZ; kM *= kZ; kL *= kZ; kK *= kZ } kY[0] = k4; kY[1] = kM; kY[2] = kT; kY[3] = 0; kY[4] = k3; kY[5] = kL; kY[6] = kS; kY[7] = 0; kY[8] = k1; kY[9] = kK; kY[10] = kR; kY[11] = 0; kY[12] = -(k4 * k2 + k3 * k0 + k1 * kX); kY[13] = -(kM * k2 + kL * k0 + kK * kX); kY[14] = -(kT * k2 + kS * k0 + kR * kX); kY[15] = 1; return kY }; e.str = function (kK) { return "mat4(" + kK[0] + ", " + kK[1] + ", " + kK[2] + ", " + kK[3] + ", " + kK[4] + ", " + kK[5] + ", " + kK[6] + ", " + kK[7] + ", " + kK[8] + ", " + kK[9] + ", " + kK[10] + ", " + kK[11] + ", " + kK[12] + ", " + kK[13] + ", " + kK[14] + ", " + kK[15] + ")" }; e.frob = function (kK) { return (Math.sqrt(Math.pow(kK[0], 2) + Math.pow(kK[1], 2) + Math.pow(kK[2], 2) + Math.pow(kK[3], 2) + Math.pow(kK[4], 2) + Math.pow(kK[5], 2) + Math.pow(kK[6], 2) + Math.pow(kK[6], 2) + Math.pow(kK[7], 2) + Math.pow(kK[8], 2) + Math.pow(kK[9], 2) + Math.pow(kK[10], 2) + Math.pow(kK[11], 2) + Math.pow(kK[12], 2) + Math.pow(kK[13], 2) + Math.pow(kK[14], 2) + Math.pow(kK[15], 2))) }; kF.mat4 = e })(window); function cm() { this.result = { bkData: [], eleData: [[], [], [], [], [], [], [], [], [], []], tileLabels: [] } } e9.extend(cm.prototype, { createLayer: function (T, i) { var e = this.result.bkData; if (!e[T]) { e[T] = [[], [], []] } this.updateLayer(T, i) }, removeLayer: function (i) { var e = this.result.bkData; e[i] = null }, updateLayer: function (T, i) { var e = this.result.bkData; if (!e[T]) { return } i = i || {}; e[T].tileTypeName = i.tileTypeName || "na"; e[T].dataType = i.dataType || 2; e[T].png8 = i.png8 || false; e[T].pack = i.pack || false; e[T].isTop = i.isTop || false; e[T].opacity = i.opacity || 1; e[T].isLowText = i.isLowText || false; e[T].clipTile = i.clipTile || false; e[T].boundary = i.boundary || false; if (i.ontology) { e[T].ontology = i.ontology } }, updateLayerMeta: function (kD, T) { var e = this.result.bkData; if (!e[kD]) { return } T = T || {}; var kE = Object.keys(T); for (var kC = 0; kC < kE.length; kC++) { if (T.hasOwnProperty(kE[kC])) { e[kD][kE[kC]] = T[kE[kC]] } } }, hasLayerBoundary: function () { var e = this.result.bkData; var T = false; for (var kC = 0; kC < e.length; kC++) { if (e[kC] && e[kC].boundary) { T = true; break } } return T }, getResult: function () { return this.result }, setData: function (kE, kD, kF) { var e = this.result.bkData; var T = e[kD] ? e[kD][kF] : null; if (!T) { return } for (var kC = 0; kC < T.length; kC++) { if (T[kC].key && T[kC].key === kE.key) { T[kC] = kE; return } } T.push(kE) }, setLabelData: function (T, i) { var e = this.result.tileLabels; e[i || 0] = T }, getLabelData: function (i) { var e = this.result.tileLabels; if (i === undefined) { return e } return e[i] || [] }, clearLabelData: function (i) { var e = this.result.tileLabels; if (i === undefined) { e = []; return } e[i] = [] }, setOverlayData: function (T, e, i) { if (!this.result.eleData[e]) { return } if (e >= 2 && e <= 4) { this.result.eleData[e][i || 0] = T; return } else { if (e === 0 || e === 5 || e === 6) { T.sort(function (kD, kC) { return kD.overlay.zIndex - kC.overlay.zIndex }) } } this.result.eleData[e] = T }, clearLabelOverlayData: function (e) { if (e === undefined) { this.result.eleData[2] = []; this.result.eleData[3] = []; this.result.eleData[4] = [] } this.result.eleData[2][e] = []; this.result.eleData[3][e] = []; this.result.eleData[4][e] = [] }, clearData: function (kC) { var e = this.result.bkData; if (typeof kC === "number") { if (e[kC]) { e[kC][0] = []; e[kC][1] = []; e[kC][2] = [] } return } for (var T = 0; T < e.length; T++) { if (!e[T]) { continue } e[T][0] = []; e[T][1] = []; e[T][2] = [] } }, sortThumbData: function (i) { var e = this.result.bkData; var T = e[i]; if (!T) { return } if (T[0] && T[0].length > 0) { T[0].sort(function (kD, kC) { return kD.tileInfo.useZoom - kC.tileInfo.useZoom }) } } }); var gE = (function () { var kM = new Int8Array(4); var T = new Int32Array(kM.buffer, 0, 1); var kH = new Float32Array(kM.buffer, 0, 1); function kO(kV) { T[0] = kV; return kH[0] } function i(kV) { kH[0] = kV; return T[0] } function kI(kV) { var kX = (kV[3] << 24 | kV[2] << 16 | kV[1] << 8 | kV[0]); var kW = kO(kX & 4278190079); return kW } var kD = 0; var kG = 1; var kK = 2; var kS = 0; var kP = 1; var kN = 2; var kE = 9; function kL(kV, kW) { var kX; if (kW % 2 === 0) { kX = [-kV[1], kV[0]] } else { kX = [kV[1], -kV[0]] } return kX } function e(kV, kW, kX) { var kY = kL(kV, kW); var kZ; if (kX === kG) { return kY } else { if (kW === 4 || kW === 5) { kZ = [kY[0] - kV[0], kY[1] - kV[1]] } else { kZ = [kY[0] + kV[0], kY[1] + kV[1]] } if (kX === kD) { vec2.normalize(kZ, kZ) } return kZ } } function kR(kW, kV) { return Math.sqrt(Math.pow(kW[0] - kV[0], 2) + Math.pow(kW[1] - kV[1], 2)) } function kC(kZ, kY, kX, kV) { var kW = vec2.dot(kZ, kY); if (kX === kN || kX === kP) { if ((kV === 0 || kV === 1) && kW > 0) { return true } else { if ((kV === 2 || kV === 3) && kW < 0) { return true } } } if ((kV === 0 || kV === 1) && kW < 0) { return true } else { if ((kV === 2 || kV === 3) && kW > 0) { return true } } return false } function kJ(kW, k1, k3) { var k2 = kL(kW, k1); var kY; var k0 = kW; var kZ = k3; var k5 = []; vec2.normalize(k5, [k0[0] + kZ[0], k0[1] + kZ[1]]); var k4 = vec2.dot(k2, [-k5[1], k5[0]]); if (Math.abs(k4) < 0.1) { k4 = 1 } var kX = 1 / k4; kY = [-k5[1] * kX, k5[0] * kX]; var kV = vec2.dot(kW, kY); if (kV < 0) { vec2.negate(kY, kY) } return { cos2: kV, offset: kY } } function kU(kW, k1, k3, kV) { var k2 = kL(kW, k1); var k0; var kZ; var kY; if (k1 === 0 || k1 === 1) { k0 = k3; kZ = kW } else { k0 = kW; kZ = k3 } if (!k0 || !kZ) { return k2 } var k5 = [k0[0] + kZ[0], k0[1] + kZ[1]]; if (k5[0] === 0 && k5[1] === 0) { vec2.normalize(k5, kZ) } else { vec2.normalize(k5, k5) } var k6 = kC(k5, k2, kV, k1); if (k6) { return k2 } var k4 = vec2.dot(k2, [-k5[1], k5[0]]); if (Math.abs(k4) < 0.1) { k4 = 1 } var kX = 1 / k4; kY = [-k5[1] * kX, k5[0] * kX]; return kY } function kT(k6, k7, k0, kZ, k9, k5, kY, k1, kX, k4) { var k3; var kW = 0; var kV = false; k3 = k5.length / kE - 1; function k8(la) { if (k1 instanceof Array) { la = Math.max(0, Math.min(la, k1.length - 1)); return k1[la] } else { return k1 } } kF(k7[0], k6[0], k0[0], k9, kZ, 4, k8(0), kX, undefined, k5, k4); k3++; kW++; kF(k7[0], k6[0], k0[0], k9, kZ, 5, k8(0), kX, undefined, k5, k4); k3++; kW++; for (var k2 = 0; k2 < k6.length; k2++) { kF(k7[k2], k6[k2], k0[k2], k9, kZ, 0, k8(k2), kX, k6[k2 - 1], k5, k4); kQ(kY, ++k3, ++kW, kV); kF(k7[k2], k6[k2], k0[k2], k9, kZ, 1, k8(k2), kX, k6[k2 - 1], k5, k4); kQ(kY, ++k3, ++kW, kV); kF(k7[k2 + 1], k6[k2], k0[k2 + 1], k9, kZ, 2, k8(k2 + 1), kX, k6[k2 + 1], k5, k4); kQ(kY, ++k3, ++kW, kV); kF(k7[k2 + 1], k6[k2], k0[k2 + 1], k9, kZ, 3, k8(k2 + 1), kX, k6[k2 + 1], k5, k4); kQ(kY, ++k3, ++kW, kV); if (kZ === kP && k2 !== k6.length - 1) { kF(k7[k2 + 1], k6[k2], k0[k2 + 1], k9, kZ, 8, k8(k2 + 1), kX, k6[k2 + 1], k5, k4); kQ(kY, ++k3, ++kW, kV); kV = kV ? false : true } } kF(k7[k7.length - 1], k6[k6.length - 1], k0[k7.length - 1], k9, kZ, 6, k8(k7.length - 1), kX, undefined, k5, k4); kQ(kY, ++k3, ++kW, kV); kF(k7[k7.length - 1], k6[k6.length - 1], k0[k7.length - 1], k9, kZ, 7, k8(k7.length - 1), kX, undefined, k5, k4); kQ(kY, ++k3, ++kW, kV) } function kF(k8, kY, k2, k9, kX, k3, k0, kW, k6, k5, k4) { var k7 = k3 % 2 === 0 ? 1 : -1; var k1; if (k3 === 4 || k3 === 5 || k3 === 6 || k3 === 7) { k1 = e(kY, k3, k9) } else { if (k3 === 0 || k3 === 1 || k3 === 2 || k3 === 3) { k1 = kU(kY, k3, k6, kX) } else { if (k3 === 8) { var kZ = kJ(kY, k3, k6); k1 = kZ.offset; vec2.normalize(k1, k1); var kV = kZ.cos2; if (kV < 0) { k7 = -k7 } } } } k5[k5.length] = k8[0] * 10; k5[k5.length] = k8[1] * 10; k5[k5.length] = k1[0] * kW * 10; k5[k5.length] = k1[1] * kW * 10; k5[k5.length] = k0; k5[k5.length] = k7; k5[k5.length] = 0; k5[k5.length] = k4 || 0; k5[k5.length] = k2 } function kQ(kZ, kX, kV, kY) { var kW; if (kV % 2 === 0) { if (kY) { kZ[kZ.length] = kX - 2; kZ[kZ.length] = kX - 1; kZ[kZ.length] = kX } else { kZ[kZ.length] = kX - 1; kZ[kZ.length] = kX - 2; kZ[kZ.length] = kX } } else { if (kY) { kZ[kZ.length] = kX - 1; kZ[kZ.length] = kX - 2; kZ[kZ.length] = kX } else { kZ[kZ.length] = kX - 2; kZ[kZ.length] = kX - 1; kZ[kZ.length] = kX } } } return { getVertexCount: function (kW, kV) { if (kV === kP) { return kW * 5 - 2 } else { return kW * 4 } }, buildData: function (k8, kX, k9, k3, kV, k0, kW, k4, k6) { var k5 = []; var k2 = k6 ? k6 : 0; var kZ = [k2 * 10]; for (var k1 = 0; k1 < k8.length; k1++) { if (k1 > 0) { k2 += kR(k8[k1], k8[k1 - 1]); kZ.push(k2 * 10) } if (k1 !== k8.length - 1) { var kY = [k8[k1 + 1][0] - k8[k1][0], k8[k1 + 1][1] - k8[k1][1]]; var lb = []; if (kY[0] === 0 && kY[1] === 0) { lb = [0, 0] } else { vec2.normalize(lb, kY) } k5[k5.length] = [lb[0], lb[1]] } } var la; if (k0[0] instanceof Array) { for (var k1 = 0; k1 < k0.length; k1++) { var k7 = kI(k0[k1]); if (!la) { la = [k7] } else { la.push(k7) } } } else { la = kI(k0) } return kT(k5, k8, kZ, kX, k9, k3, kV, la, kW, k4) }, toTileSolidLineVertices: function (kZ, kW) { var kX = new Float32Array(kZ.length / kE * 5); var kV = new Int16Array(kX.buffer); var k1 = 0; var kY = 0; for (var k0 = 0; k0 < kZ.length; k0 += kE) { kV[k1] = ~~kZ[k0]; kV[k1 + 1] = ~~kZ[k0 + 1]; kV[k1 + 2] = ~~kZ[k0 + 2]; kV[k1 + 3] = ~~kZ[k0 + 3]; kX[kY + 2] = kZ[k0 + 4]; kV[k1 + 6] = kZ[k0 + 5]; kV[k1 + 7] = kW ? kW : 0; kV[k1 + 8] = kZ[k0 + 7]; kV[k1 + 9] = 0; k1 += 10; kY += 5 } return kX } } })(); var gX = 1; var h3 = 2; var fr = { drawIndex: 0, devicePixelRatio: gu(), zoomState: 1, curViewTilesInfo: null, iconSetImg: null, LAST_CALC_ZOOM: -1, LAST_LOAD_VECTOR_ZOOM_CHANGE: false, lastCollisionTestTime: 0, remove: function () { this.tileCache.clear(); this.removeLabel(this.drawIndex); if (this.tileLabels) { this.tileLabels = [] } }, removeLabel: function (i) { if (this.dataType === 2 && ((this.tileType && this.tileType.getName() === "na") || (this.ontology && this.ontology instanceof ek))) { this.map._featureMgr.clearData(i); this.map._featureMgr.clearLabelOverlayData(i); this.map._featureMgr.clearLabelData(i); var T = new fW("onspotsdataremove"); T.index = i; this.map.dispatchEvent(T); if (this.ontology && this.ontology instanceof ek) { this.clearCache(); return } var e = new fW("onlayer_update"); e.name = "na"; this.map.fire(e) } }, initDrawData: function () { this.drawIndex = this.zIndex; var e = { tileTypeName: this.tileType.getName(), dataType: this.dataType, png8: this.png8, pack: this.pack, isTop: this.isTop || false, opacity: this.opacity, isLowText: this.isLowText || false, clipTile: this.clipTile, boundary: this.boundary }; if (this.ontology) { e.ontology = this.ontology } this.map._featureMgr.createLayer(this.drawIndex, e); this.dispatchEvent(new fW("oninitDrawData")) }, destroyDrawData: function () { this.map._featureMgr.removeLayer(this.drawIndex); var i = new fW("onremoveLayerMask"); i.hasLayerBoundary = this.map._featureMgr.hasLayerBoundary(); this.map.dispatchEvent(i) }, setZIndex: function (kG) { kG = Math.abs(Math.floor(kG)) || 1; if (!kG || kG === this.zIndex) { return } var kD = this.map._featureMgr.result.bkData; var kC = this.map.tileMgr.tileLayers; var kI = this.map._normalLayerMgr.layers; function kJ(kO) { var kM = null; var kN = [kC, kI]; for (var kK = 0; kK < kN.length; kK++) { for (var kL = 0; kL < kN[kK].length; kL++) { if (kN[kK][kL].zIndex === kO) { kM = kN[kK][kL]; break } } if (kM) { break } } return kM } var T = []; var kF = []; var kH = this.zIndex; var i = kJ(kG); if (kD[kG] && i) { T.push(i); kF.push(kD[kG]); this.setTargetZIndex(kG); kD[kG] = kD[kH]; kD[kH] = null } else { this.setTargetZIndex(kG); kD[kG] = kD[kH]; kD[kH] = null; this.map.dispatchEvent(new fW("onupdate")); return } var kE = kG + 1; while (kE) { var e = kJ(kE); if (kD[kE] && e) { T.push(e); kF.push(kD[kE]); T.shift().setTargetZIndex(kE); kD[kE] = kF.shift(); kE += 1 } else { T.shift().setTargetZIndex(kE); kD[kE] = kF.shift(); kE = 0 } } this.map.dispatchEvent(new fW("onupdate")) }, setZIndexTop: function () { var e = this.map._featureMgr.result.bkData; e[e.length] = e[this.zIndex]; e[this.zIndex] = null; this.setTargetZIndex(e.length - 1); this.map.dispatchEvent(new fW("onrefresh")) }, setUpLevel: function () { var e = this._getAdjoinZIndex("up"); if (this.zIndex !== e) { this.setZIndex(e) } }, setDownLevel: function () { var e = this._getAdjoinZIndex("down"); if (this.zIndex !== e) { this.setZIndex(e) } }, getTileKey: function (e, kC) { kC = kC || {}; var i = typeof kC.useZoom === "number" ? kC.useZoom : e.useZoom; var T = e.style || this.mapStyleId || "default"; return this.mapType + "_" + T + "_" + e.col + "_" + e.row + "_" + e.zoom + "_" + i }, getTileRenderDataKey: function (i) { var T = i.col; var kC = i.zoom; var e = i.baseTileSize; T = fc.calcLoopParam(T, kC, e).col; return this.mapType + "_" + T + "_" + i.row + "_" + kC + "_" + i.useZoom }, getTileUnits: function (e) { var kC = this.map; var T = ev[kC.getMapType()]; var i = T.baseUnits * Math.pow(2, T.zoomLevelBase - e); return i }, getTilesUrl: function (kD, kM, kN) { var i = kD.x; var kO = kD.y; var kJ = kd("ditu", "normal"); var kF = kJ.ver; var kG = kJ.udt; i = fc.calcLoopParam(i, kM, kN).col; var kL = ev.B_NORMAL_MAP.vectorTileUrls; var kE = Math.abs(i + kO) % kL.length; var kK = kL[kE]; if (window.offLineIPAddress) { kL = [window.offLineIPAddress + "pvd/"]; kK = kL[0] } var T = "x=" + i + "&y=" + kO + "&z=" + Math.floor(kM); var kI = this.devicePixelRatio > 1 ? "&scaler=2" : ""; var kH = "&textimg=1"; if (this.map.config.textRenderType === "canvas") { kH = "&textimg=0" } var kC = this.map.config.style; if (typeof kC === "string" && kC !== "default") { T += "&styleId=" + E.mapStyleNameIdPair[kC] } T += "&styles=pl" + kH + kI + "&v=" + kF + "&udt=" + kG + "&json=0"; var e = kK + "?qt=vtile&param=" + window.encodeURIComponent(e5(T)); return e }, getRasterTilesUrl: function (T, kE, kC) { var kD = ev[this.map.mapType]; var i = this.map.config.style; var e = kD.tileUrls[Math.abs(kE + T) % kD.tileUrls.length] + "?qt=tile&x=" + T + "&y=" + kE + "&z=" + kC + ((i === "default" || typeof i !== "string") ? "" : ("&styleId=" + E.mapStyleNameIdPair[i])) + "&styles=pl&udt=" + this.normalUdt + "&scaler=" + this.scaler + "&p=1"; e = e.replace(/-(\d+)/gi, "M$1"); return e }, getZoomState: function () { var T = this.map; var i = T.getZoom(); var e = i - this.lastZoom; if (e > 0) { this.zoomState = 1 } else { if (e < 0) { this.zoomState = -1 } } this.lastZoom = i; return this.zoomState }, releaseOutViewTileData: function (e) { var kD = this.map._workerMgr.releasePendingData(e); for (var kC = 0, T = kD.length; kC < T; kC++) { var kE = this.getTileKey(kD[kC]); this.tileCache.removeData(kE); this._checkTilesLoaded() } }, loadLayerData: function (e, kC, i) { this.hasZoomChange = i; this.curViewTilesInfo = e; if (this.ontology instanceof ek) { this.loadTileData && this.loadTileData(e, kC); return } this.mapStyleId = this.map.getMapStyleId(); this.releaseOutViewTileData(e); var T = this.getZoomState(); if (this.dataType === h3) { if (kC) { this.getVectorLayerDataFromCache(e, T) } else { this.loadVectorLayerData(e) } } else { this.loadRasterLayerData(e, kC) } }, getVectorLayerDataFromCache: function (kI, kU) { this.map.temp.isPermitSpotOver = false; this.tileLabels = []; var kX = this.map._displayOptions; if (this.mapType === BMAP_NORMAL_MAP) { var kM = this.map._customLabelMgr.virtualTiles.custom; if (kM && kM instanceof Array) { for (var kS = 0; kS < kM.length; kS++) { this.tileLabels.push(kM[kS].label); if (!kM[kS].label.iconReady) { var kO = false; var kW = kM[kS].label.fixedLabel; for (var kQ = 0; kQ < kW.length; kQ++) { var kH = kW[kQ]; if (!kH.iconPos) { continue } else { if (!kH.iconPos.texcoord) { kO = true; break } } } if (!kO) { kM[kS].label.iconReady = true } else { kM[kS].label.iconReady = false; this.updateAllIconsTextureCoords(kM[kS]) } } } } } this.thumbCache = {}; var kV = -1; for (var kS = 0, kN = kI.length; kS < kN; kS++) { var kT = kI[kS]; var kD = kT.col; var kE = kT.row; var T = kT.zoom; var kP = this._getTileTexImgKey(kT); var kC = kT.useZoom; kV = T; var kF = this.getTileKey(kT); var kZ = this.tileCache.getData(kF); if (kZ && kZ.status === "ready") { var k0 = kZ; this.map._featureMgr.setData(kZ, this.drawIndex, 2); if (kX.poi && kZ.label) { if (kZ.label.status === "ready") { kZ.label.tileInfo = kZ.tileInfo; this.tileLabels.push(kZ.label); if (kZ.label.textureSources && kZ.label.textureSources[kC] && this.map._webglMapScene) { var kY = this.map._webglMapScene._painter; if (!kY._labelTextureAtlasOffset[kP]) { kY._addToAsyncJob(kZ.label.textureSources[kC]) } } } else { if (kZ.label.status !== "processing") { this.processLabelData(kZ) } } } } else { var kR = { tileInfo: kT, dataType: h3, key: kF }; this.map._featureMgr.setData(kR, this.drawIndex, 2); if (this.useThumbData) { this.setThumbData(kD, kE, T, kC, kU) } } } this.tileLabels.labelZoom = kV; this.updateLabels(kU); var kJ = this.map.getZoom(); var kG = Math.floor(kJ); var kL = kJ - kG; var kK = Math.floor(this.LAST_CALC_ZOOM); var e = this.LAST_CALC_ZOOM - kK; var k1 = false; if (this.hasZoomChange) { if (Math.abs(kJ - this.LAST_CALC_ZOOM) >= 0.5) { k1 = true } else { if (kL < 0.5 && e >= 0.5) { k1 = true } else { if (kL >= 0.5 && e < 0.5) { k1 = true } } } if (k1) { this.cacheDataCollideLabels(0) } this.LAST_CALC_ZOOM = kJ } else { if (this.tileLabels.length > 0) { this.cacheDataCollideLabels(e9.Browser.ie ? 50 : 30) } } }, loadVectorLayerData: function (kI) { this.map.temp.isPermitSpotOver = false; var kH = this; function kG(i, kJ) { var kL = kH.tileCache.getData(kJ); if (!kL) { return } if (!i || i.error) { i.event && bG.fetchDebug && bG.fetchDebug.sendError({ title: i.event.title, msg: i.event.msg, category: bG.fetchDebug.category.AJAX, level: bG.fetchDebug.levels.ERROR, url: i.event.title }); var kK = new fW("ontileloaderror"); i = i || {}; kK.error = i.error || ""; kK.message = i.message || ""; kH.map.fire(kK); kL.status = "init"; kL.reloadTimer = setTimeout(function () { if (kL.retry < 3) { kL.retry++; kL.status = "loading"; kH.loadVectorTileData(i.tileInfo, kG) } else { kH.tileCache.removeData(kJ); kH._checkTilesLoaded() } }, 4000); if (kH.map._featureMgr) { kH.map._featureMgr.clearData(kH.drawIndex) } kH.getVectorLayerDataFromCache(kH.curViewTilesInfo, kH.getZoomState()); return } if (kL.reloadTimer) { clearTimeout(kL.reloadTimer); kL.reloadTimer = null } kH.callbackDataQueue.push([i, kJ]); if (kH.processDataTimer) { return } kH.processDataTimer = setTimeout(function () { while (kH.callbackDataQueue.length > 0) { var kN = kH.callbackDataQueue.shift(); kH.vectorTileDataCbk(kN[0], kN[1]); kH._checkTilesLoaded() } if (kH.map._featureMgr) { kH.map._featureMgr.clearData(kH.drawIndex) } kH.getVectorLayerDataFromCache(kH.curViewTilesInfo, kH.getZoomState()); var kM = new fW("onrefresh"); kM.source = "webgllayer"; kH.map.dispatchEvent(kM); kH.processDataTimer = null }, 200) } for (var kF = 0, kD = kI.length; kF < kD; kF++) { var T = kI[kF]; var kE = this.getTileKey(T); var e = this.tileCache.getData(kE); if (!e) { e = { status: "init", tileInfo: T, dataType: h3, key: kE, retry: 0 } } if (e.status !== "ready" && e.status !== "loading") { this.numLoading++; this.numTileLoading++; e.status = "loading"; this.tileCache.setData(kE, e); var kC = this.getProcessedLabelZoom(T); if (kC) { T.processedLabelZooms = kC } this.loadVectorTileData(T, kG) } } }, setThumbData: function (i, kD, kC, e, T) { if (T === 1) { if (this._findParentZoomTile(i, kD, kC, e, 8) === false) { this._findChildZoomTile(i, kD, kC, e, 3) } } else { if (T === -1) { if (this._findChildZoomTile(i, kD, kC, e, 3) === false) { this._findParentZoomTile(i, kD, kC, e, 8) } } } this.map._featureMgr.sortThumbData(this.drawIndex) }, _findParentZoomTile: function (kF, kO, kN, kD, kI) { var kE = ev[this.getMapType()]; var T = kE.minDataZoom; var e = kF; var kL = kO; var kJ = kN; var kK = kD; for (var kH = 1; kH <= kI; kH++) { var kC = this.tileType.getParentTile(e, kL, kJ, kK, T); if (kC === null) { continue } var kM = this.getTileKey(kC); var kG = this.tileCache.getData(kM); if (kG && kG.status === "ready") { if (this.thumbCache[kM]) { continue } this.map._featureMgr.setData(kG, this.drawIndex, 0); this.thumbCache[kM] = true; return true } e = kC.col; kL = kC.row; kJ = kC.zoom; kK = kC.useZoom } return false }, _findChildZoomTile: function (kG, kI, e, kD, kR) { var kP = ev[this.getMapType()]; var kL = kP.maxDataZoom; var kF = kG; var kH = kI; var kJ = e; var kC = kD; var kE = true; for (var kO = 1; kO <= kR; kO++) { var kM = false; var T = this.tileType.getChildTiles(kF, kH, kJ, kC, kL, kO); if (!T) { continue } for (var kN = 0; kN < T.length; kN++) { var kK = this.getTileKey(T[kN]); var kQ = this.tileCache.getData(kK); if (kQ && kQ.status === "ready") { if (!this.thumbCache[kK]) { this.map._featureMgr.setData(kQ, this.drawIndex, 1); this.thumbCache[kK] = true } kM = true } else { kE = false } } if (kM) { break } } return kE }, loadVectorTileData: function (kP, kQ) { var kD = kP.col; var kE = kP.row; var e = kP.zoom; var kN = kP.baseTileSize; var kC = this.getTilesUrl(new fv(kD, kE), e, kN); var kF = this.map.getPrivateRegions(); if (!this.processData && this.map.getPrivateStatus() && kF) { var kL = kP.useZoom; var kK = this.tileType.getMercatorSize(kL); var kJ = kD * kK; var kI = kE * kK; var kM = new cG(kJ + kK / 2, kI + kK / 2); var kH = new ik(new cG(kJ, kI), new cG(kJ + kK, kI + kK)); var kG = gu() >= 1.5 ? 2 : 1; for (var kO = 0; kO < kF.length; kO++) { if (kF[kO] instanceof cV) { if (kF[kO].crossPoint(kM, kH, kL)) { var kR = { x: kD, y: kE, z: e, mapZoom: kL, scalerRadio: kG, textimg: this.map.config.textRenderType === "canvas" ? 0 : 1 }; var T = kF[kO].tileUrlFunction(kC, kR); if (T && T.url) { kC = T.url; T.header && (kP.header = T.header) } break } } } } if (!kC) { return } var kT = this.getTileKey(kP); hA(this.map); if (!this.processData) { if (!this.map || !this.map._workerMgr) { return } this.map._workerMgr.loadTileData(kC, kP, kT, kQ); return } var kQ = "cbk" + kT.replace(/-/g, "_"); var kS = this; bG[kQ] = function (i) { var kU = (function (kV) { return function () { kV.tileInfo = kP; var k1 = kS.processData(kV); if (!k1.road) { return } var kY = { tileInfo: kP, renderData: { base: [] }, status: "ready", key: kT, mapType: kS.mapType }; var k4 = []; var k7 = []; for (var k0 = 0; k0 < k1.road.length; k0++) { var k3 = k1.road[k0]; var k2 = -1; for (var kZ = 0; kZ < k3.length; kZ++) { var k5 = k3[kZ]; var k6 = []; if (k4.length / 7 + k5[0].length / 2 > 65536) { kY.renderData.base.push({ type: "line", data: [gE.toTileSolidLineVertices(k4, 4000), new Uint16Array(k7)] }); k4 = []; k7 = [] } for (var kX = 0; kX < k5[0].length; kX += 2) { k6[k6.length] = [k5[0][kX], k5[0][kX + 1]] } var kW = k5[3]; gE.buildData(k6, k5[1], k5[2], k4, k7, kW, k5[4], k0 + 20) } kY.renderData.base.push({ type: "line", data: [gE.toTileSolidLineVertices(k4, 4000), new Uint16Array(k7)] }) } kS.tileCache.setData(kT, kY); if (kS.map._featureMgr) { kS.map._featureMgr.clearData(kS.drawIndex) } kS.getVectorLayerDataFromCache(kS.curViewTilesInfo, kS.getZoomState()); kS.map.dispatchEvent(new fW("onrefresh")) } })(i); kS.map.jobScheduler.addJob(kU); delete bG[kQ] }; kC += "&fn=" + encodeURIComponent(fF + "." + kQ); g4.load(kC) }, vectorTileDataCbk: function (kC, kD) { var kH = new fW("ontileloaded"); kH.perfStat = kC.perfStat || []; var e = this.map; e.fire(kH); var i = kC.tileInfo; var T = i.col; var kM = i.row; var kL = i.zoom; var kK = i.baseTileSize; var kF = this.tileCache.getData(kD); if (!kF) { return } if (!this.showLabel) { kC.label = null } kF.renderData = kC; kF.tileInfo = i; var kE = fc.calcLoopParam(T, kL, kK); var kI = kE.geoOffsetX; kF.tileInfo.loopOffsetX = kI; kF.status = "ready"; kF.mapType = this.mapType; this.tileCache.setData(kD, kF); kF.label = kC.label; kC.label = null; if (kC.indoorData && e._indoorMgr) { e._indoorMgr.setData(kC.indoorData) } var kG = "id_" + T + "_" + kM + "_" + kL; if (!this.curViewTilesInfo[kG]) { e.fire(new fW("ontilenotinview")); return } var kJ = e._displayOptions; if (kJ.poi) { this.processLabelData(kF) } if (kC.indoorData && e._indoorMgr && e._indoorMgr.currentUid) { this._refreshIndoorData(e._indoorMgr.currentUid, e._indoorMgr.currentFloor) } }, _refreshIndoorData: function (kK, kJ) { var kM = this.map._indoorMgr.getIndoorData(kK); if (this.map && this.map.parking) { this.map.parking.currentUid = kK; this.map.parking.currentFloor = kJ } var kP = kM.tileKeys; var kN = Math.floor(this.map.getZoom()); for (var kH = 0; kH < kP.length; kH++) { var kE = kP[kH]; var kG = this.tileCache.getData(kE); if (!kG || !kG.renderData) { continue } var kO = kG.renderData; if (!kO) { continue } kO.indoorBase = []; kO.indoorBaseContour = []; kO.indoorBorder3D = []; kO.indoorArea3D = []; kG.label.indoorLabel = []; this.labelProcessor.clearCollisionCache(kG.label); for (var kI in kO.indoorData) { if (kI === "tileInfo") { continue } var e = kO.indoorData[kI]; var kD = e.defaultFloor; if (kI === kK) { kD = kJ; e.currentFloor = kJ } if (e.floors[kD]) { if (e.floors[kD].base) { for (var kF = 0; kF < e.floors[kD].base.length; kF++) { kO.indoorBase.push(e.floors[kD].base[kF]) } } if (e.floors[kD].contour) { for (var kF = 0; kF < e.floors[kD].contour.length; kF++) { kO.indoorBaseContour.push(e.floors[kD].contour[kF]) } } if (e.floors[kD].indoorBorder3D) { kO.indoorBorder3D.push(e.floors[kD].indoorBorder3D) } if (e.floors[kD].area3D) { kO.indoorArea3D.push(e.floors[kD].area3D) } if (e.floors[kD].pois) { kG.label.indoorLabel = kG.label.indoorLabel.concat(e.floors[kD].pois) } } } this.updateAllIconsTextureCoords(kG); var kL = this; this.labelProcessor.loadIconImages(kG, function (i) { kL.updateAllIconsTextureCoords(i) }, "indoor"); var kC = kE.split("_"); var T = parseInt(kC[kC.length - 1], 10); if (T !== kN) { continue } kL.map._featureMgr.setData(kG, this.drawIndex, 2) } this.dataBackCollideLabels(); this.map.dispatchEvent(new fW("onrefresh")) }, _removeIndoorData: function (i) { if (!i.indoorData) { return } for (var e in i.indoorData) { if (e === "tileInfo") { continue } this.map._indoorMgr.removeData(e, i.key) } }, getProcessedLabelZoom: function (kC) { var kD = kx.baseZoomInfo[kC.zoom]; if (!kD) { return false } var T = []; for (var kE = 0; kE < kD.length; kE++) { var kF = this.getTileKey(kC, { useZoom: kD[kE] }); var e = this.tileCache.getData(kF); if (e && e.status === "ready" && e.label && e.label.status === "ready") { T.push(kD[kE]) } } if (T.length) { return T } else { return false } }, getSameZoomDataFromCache: function (T) { var kC = kx.baseZoomInfo[T.zoom]; for (var kD = 0; kD < kC.length; kD++) { var kE = this.getTileKey(T, { useZoom: kC[kD] }); if (T.useZoom === kC[kD]) { continue } var e = this.tileCache.getData(kE); if (e && e.status === "ready" && e.label && e.label.status === "ready") { return e } } return false }, hasSameLabelData: function (kC, T) { for (var e = 0; e < T.length; e++) { if (T[e].key === kC) { return true } } return false }, getDataByFloorName: function (T, kC) { for (var e = 0; e < T.length; e++) { if (T[e].floorName === kC) { return T[e] } } return null }, mergeIndoorLabelData: function (kH, e) { for (var kF in kH) { if (kF === "tileInfo") { continue } if (e[kF]) { var T = kH[kF].floors; var kI = e[kF].floors; for (var kD = 0; kD < T.length; kD++) { var kC = T[kD]; var kG = kC.floorName; var kE = this.getDataByFloorName(kI, kG); if (kE) { if (kE.pois) { kE.pois = kE.pois.concat(kC.pois); kC.pois = kE.pois } else { kE.pois = kC.pois } } } } } }, mergeSameZoomLabelData: function (kF) { var kD = kF.label; if (!kD) { return } var e = kF.tileInfo; var kE = this.getSameZoomDataFromCache(e); if (!kE) { return } var kC = kE.label; if (!kC) { return } for (var T = 0; T < kD.fixedLabel.length; T++) { if (!this.hasSameLabelData(kD.fixedLabel[T].key, kC.fixedLabel)) { kC.hasNewData = true; kC.fixedLabel.push(kD.fixedLabel[T]) } } for (var T = 0; T < kD.lineLabel.length; T++) { if (!this.hasSameLabelData(kD.lineLabel[T].key, kC.lineLabel)) { kC.hasNewData = true; kC.lineLabel.push(kD.lineLabel[T]) } } for (var T = 0; T < kD.indoorLabel.length; T++) { if (!this.hasSameLabelData(kD.indoorLabel[T].key, kC.indoorLabel)) { kC.hasNewData = true; kC.indoorLabel.push(kD.indoorLabel[T]) } } kF.label = kC; if (kE.renderData.indoorData && kF.renderData.indoorData) { this.mergeIndoorLabelData(kF.renderData.indoorData, kE.renderData.indoorData) } }, processLabelData: function (kE) { if (!kE.label) { return } if (kE.label.status === "processing") { return } kE.label.status = "processing"; var kC = this; kC.updateAllIconsTextureCoords(kE); this.labelProcessor.loadIconImages(kE, function (kF) { kC.updateAllIconsTextureCoords(kF) }); if (this.map.config.textRenderType === "canvas") { var e = this.labelProcessor.drawLabelsOnCanvas(kE, function (kH, kJ) { var kG = kE.tileInfo; var kI = kC.map.config.mapStyleId; if (!bG["customStyleInfo_" + kI]) { kC.mergeSameZoomLabelData(kE) } if (kH) { if (!kE.label.textureHeights) { kE.label.textureHeights = [] } kE.label.textureHeights[kG.useZoom] = kH.height } if (kJ) { if (!kE.label.indoorTextureHeights) { kE.label.indoorTextureHeights = [] } kE.label.indoorTextureHeights[kG.useZoom] = kJ.height } var kF = kC._getTileTexImgKey(kG); kC._doWorkAfterLabelImageLoad(kE, kH, kJ, kF) }); return } var T = kE.label.textImageBitmap || kE.label.textImgStr; var kD = kE.label.indoorTextImageBitmap || kE.label.indoorTextImgStr; this.labelProcessor.loadImgByStr(T, kD, function i(kK, kI) { var kH = kE.label.textureHeight; var kL = kE.label.indoorTextureHeight; kE.label.textureHeight = undefined; kE.label.indoorTextureHeight = undefined; var kG = kE.tileInfo; kC.mergeSameZoomLabelData(kE); var kJ = kE.label; kJ.textImgStr = ""; kJ.indoorTextImgStr && (kJ.indoorTextImgStr = ""); if (!kJ.textureHeights) { kJ.textureHeights = [] } kJ.textureHeights[kG.useZoom] = kH; if (!kJ.indoorTextureHeights) { kJ.indoorTextureHeights = [] } kJ.indoorTextureHeights[kG.useZoom] = kL; var kF = kC._getTileTexImgKey(kG); kC._doWorkAfterLabelImageLoad(kE, kK, kI, kF) }) }, _getTileTexImgKey: function (i) { var T = i.style || this.mapStyleId || "default"; var e = T + "_" + i.col + "_" + i.row + "_" + i.zoom; if (this.map.config.textRenderType === "canvas") { e += "_" + i.useZoom } return e }, _doWorkAfterLabelImageLoad: function (kC, kF, e, kJ) { var kE = this; var kH = kC.label; kH.tileInfo = kC.tileInfo; kH.status = "ready"; if (kF || e) { var T = kH.tileInfo; if (kF) { kF.id = kJ; if (!kH.textureSources) { kH.textureSources = [] } kH.textureSources[T.useZoom] = kF } if (e) { e.id = kJ + "_indoor"; if (!kH.indoorTextureSources) { kH.indoorTextureSources = [] } kH.indoorTextureSources[T.useZoom] = e } if (kE.map._webglMapScene) { var kI = kE.map._webglMapScene._painter; if (kF) { kI._addToAsyncJob(kH.textureSources[T.useZoom]) } } } if (kC.custom !== true) { kE.tileLabels.push(kH) } else { if (!kF && kE.tileLabels) { for (var kD = 0; kD < kE.tileLabels.length; kD++) { var kG = kE.tileLabels[kD]; this.labelProcessor.clearCollisionCache(kG) } } setTimeout(function () { kE.updateAllIconsTextureCoords(kC); kE.labelProcessor.loadIconImages(kC, function (i) { kE.updateAllIconsTextureCoords(kC) }, true); kE.map.dispatchEvent(new fW("onupdate")) }, 200) } if (kE.collisionTimer) { return } kE.collisionTimer = setTimeout(function () { kE.dataBackCollideLabels(); kE.collisionTimer = null }, 300) }, _updateIconTextureCoords: function (kG, T) { if (!kG) { return } var kF = this.map; for (var kC = 0; kC < kG.length; kC++) { var kE = kG[kC]; if (!kE.iconPos) { continue } if (kF._webglMapScene) { var e = kF._webglMapScene._painter; var kD = T + "_" + kE.iconPos.iconType; kE.iconPos.texcoord = e._iconTextureAtlasCoords[kD] || null } } }, updateAllIconsTextureCoords: function (kD) { if (this.map.viewAnimationTime) { return } if (kD) { if (kD.label) { var i = kD.tileInfo.style; this._updateIconTextureCoords(kD.label.fixedLabel, i); this._updateIconTextureCoords(kD.label.indoorLabel, i) } } else { var kC = this.tileCache.getAllData(); for (var T in kC) { var e = kC[T].data; if (e.status === "ready" && e.label) { var i = e.tileInfo.style; this._updateIconTextureCoords(e.label.fixedLabel, i); this._updateIconTextureCoords(e.label.indoorLabel, i) } } } this.updateLabels(); this.map.dispatchEvent(new fW("onrefresh")) }, cacheDataCollideLabels: function (T) { var kD = this; var i = this.map._featureMgr; function kC() { if (kD && !kD.map.tileMgr && !kD.map.tileMgr.isExitTileLayer(kD)) { return } kD.cacheLabelTimer = null; var kE; var kF = kD.map.getTilt(); var kH = kD.map.getHeading() % 360; if (kD.tileLabels.length === 0 || (kD.tileLabels.length === 1 && kD.tileLabels[0].tileInfo.zoom === 0)) { kE = i.getLabelData(kD.drawIndex); if (kE.length > 0) { kE = kD.labelProcessor.collisionTest(kE, -1) } } else { if (kF || kH) { if (this._collisionTimer) { if (!kF) { clearTimeout(this._collisionTimer) } else { if (Date.now() - kD.lastCollisionTestTime > 500) { kD.lastCollisionTestTime = Date.now() } else { clearTimeout(this._collisionTimer) } } } this._collisionTimer = setTimeout(function () { if (kD && !kD.map.tileMgr && !kD.map.tileMgr.isExitTileLayer(kD)) { kD._collisionTimer = null; return } kE = kD.labelProcessor.collisionTest(kD.tileLabels); if (kE) { if (kD._isInnerLayer && kD.map.stencil && kD.map.stencil.isPoiMask) { var kI = kD.isPoiInPolygon(kE); i.setLabelData(kI, kD.drawIndex) } else { i.setLabelData(kE, kD.drawIndex) } } kD.updateLabels(); kD.map.dispatchEvent(new fW("onrefresh")); kD._collisionTimer = null }, 60); return } else { kE = kD.labelProcessor.getCachedLabels(kD.tileLabels) } } if (kE) { if (kD._isInnerLayer && kD.map.stencil && kD.map.stencil.isPoiMask) { var kG = kD.isPoiInPolygon(kE); i.setLabelData(kG, kD.drawIndex) } else { i.setLabelData(kE, kD.drawIndex) } } kD.updateLabels(); kD.map.dispatchEvent(new fW("onrefresh")) } if (!T) { clearTimeout(kD.cacheLabelTimer); kC() } else { if (kD.cacheLabelTimer) { return } kD.cacheLabelTimer = setTimeout(function e() { kC() }, T) } }, isPoiInPolygon: function (T) { var kV = this; var kL = kV.map.stencil; var kD = kV.map._featureMgr.result.eleData[9]; var kC = []; for (var kQ = 0; kQ < kD.length; kQ++) { var kM = kD[kQ].overlay.points; kC = kC.concat(kM) } for (var kT = 0; kT < T.length; kT++) { var kF = []; var kE = []; for (var kR = 0; kR < T[kT].fixedLabel.length; kR++) { var kK = T[kT].fixedLabel[kR]; var kO = kK.pt; if (kK.pt && aw(kO, kC)) { kF.push(kK) } else { kE.push(kK) } } if (kL.showRegion === "inside") { T[kT].fixedLabel = kF } else { if (kL.showRegion === "outside") { T[kT].fixedLabel = kE } } var kP = []; var kH = []; for (var kQ = 0; kQ < T[kT].lineLabel.length; kQ++) { var kS = T[kT].lineLabel[kQ]; var e = kS.pt; if (e && aw(e, kC)) { kP.push(kS) } else { kH.push(kS) } } if (kL.showRegion === "inside") { T[kT].lineLabel = kP } else { if (kL.showRegion === "outside") { T[kT].lineLabel = kH } } var kN = []; var kJ = []; for (var kI = 0; kI < T[kT].indoorLabel.length; kI++) { var kU = T[kT].indoorLabel[kI]; var kG = kU.pt; if (kG && aw(kG, kC)) { kN.push(kU) } else { kJ.push(kU) } } if (kL.showRegion === "inside") { T[kT].indoorLabel = kN } else { if (kL.showRegion === "outside") { T[kT].indoorLabel = kJ } } } return T }, dataBackCollideLabels: function () { var T = this; if (T && !T.map.tileMgr && !T.map.tileMgr.isExitTileLayer(T)) { return } if (!T.tileLabels || (T.tileLabels && T.tileLabels.length === 0)) { return } var e; T.labelProcessor.calcLabelsCollision(T.tileLabels); e = T.labelProcessor.getCachedLabels(T.tileLabels); if (e) { if (T._isInnerLayer && T.map.stencil && T.map.stencil.isPoiMask) { var i = T.isPoiInPolygon(e); T.map._featureMgr.setLabelData(i, T.drawIndex) } else { T.map._featureMgr.setLabelData(e, T.drawIndex) } } T.updateLabels(); T.map.dispatchEvent(new fW("onupdate")); if (b5()) { this.labelProcessor._refreshSpotData() } }, updateLabels: function (kD) { var kE = this.map; if (!kE._featureMgr) { return } var i = kE._featureMgr; var T = i.getLabelData(this.drawIndex); if (T.length > 0) { var kC = kE.getZoom(); if (T.labelZoom - kC < 3) { this.labelProcessor.updateLabels(T); var e = this.labelProcessor.fixDataFormat(T); i.setOverlayData(e[0], 2, this.drawIndex); i.setOverlayData(e[1], 3, this.drawIndex); i.setOverlayData(e[2], 4, this.drawIndex) } else { i.clearLabelOverlayData(this.drawIndex) } kE.temp.isPermitSpotOver = false; this.labelProcessor.curSpotAdded = false } }, loadRasterLayerData: function (kH, kC) { this.thumbCache = {}; var kI = this.getZoomState(); if (kC) { for (var kF = 0, kD = kH.length; kF < kD; kF++) { var T = kH[kF]; var kE = this.getTileKey(T); var e = this.tileCache.getData(kE); if (e && e.status === "ready") { if (T.tileTypeName === "xyz") { e.tileInfo = T } this.map._featureMgr.setData(e, this.drawIndex, 2) } else { if (this.useThumbData) { this.setThumbData(T.col, T.row, T.zoom, T.useZoom, kI) } } } return } for (var kF = 0, kD = kH.length; kF < kD; kF++) { var T = kH[kF]; var kE = this.getTileKey(T); var e = this.tileCache.getData(kE); if (!e) { this.numTileLoading++; this.tileCache.setData(kE, {}); var kG = this; this.loadRasterTileData(T, function (i, kJ) { kG._checkLayerTilesLoaded(); kG.rasterTileDataCbk(i, kJ) }) } } }, loadRasterTileData: function (i, e) { var kC = i.col; var kF = i.row; var kD = i.zoom; var T = this.getTilesUrl(new fv(kC, kF), kD, i); if (!T) { return } var kE = this.getTileKey(i); this.loadTileImage(T, kE, e, i) }, loadTileImage: function (kG, T, kE, e) { var kC = new Image(); kC.crossOrigin = "anonymous"; kC.tileInfo = e; var kD; var kF = this; function kH() { if (kF.retry) { kD && clearInterval(kD); kD = null } } if (this.retry) { var i = 1; kD = setInterval(function () { if (i > 3) { kH(); return } kC.src = kG; i++ }, this.retryTime) } kC.onload = function () { kH(); kE && kE(this, T) }; kC.onerror = function () { kH(); bG.fetchDebug && bG.fetchDebug.sendError({ title: kG, msg: kG, category: bG.fetchDebug.category.RESOURCE, level: bG.fetchDebug.levels.ERROR, url: kG }); kE && kE(null, T) }; kC.src = kG; return kC }, rasterTileDataCbk: function (kG, kE) { if (!kG || typeof kG === "string") { this.tileCache.removeData(kE); return } var T = kG.tileInfo; var kC = T.col; var kN = T.row; var kM = T.zoom; var i = this.tileCache.getData(kE); if (!i) { return } var kH = "id_" + kC + "_" + kN + "_" + kM; var kL = this; i.dataType = gX; i.tileInfo = T; if (T.tileTypeName === "xyz") { var kK = T.tileSize; i.textureSource = kG; i.renderData = { vertexAll: [0, 0, this.height, 0, 0, kK, 0, this.height, 1, 0, kK, kK, this.height, 1, 1, 0, 0, this.height, 0, 0, kK, kK, this.height, 1, 1, 0, kK, this.height, 0, 1] }; kL.setRasterTileData(kE, i, kH) } else { i.textureSource = kG; var kF = fc.calcLoopParam(kC, kM); var kJ = kF.geoOffsetX; kG.tileInfo.loopOffsetX = kJ; if (T.combine) { var kD = 0.0035; if (T.dataIndex > 0) { var kI = T.dataIndex / 256; i.renderData = { vertexAll: [0, 0, this.height, 0, 0, T.dataIndex, 0, this.height, kI - kD, 0, T.dataIndex, 256, this.height, kI - kD, 1, 0, 0, this.height, 0, 0, T.dataIndex, 256, this.height, kI - kD, 1, 0, 256, this.height, 0, 1] } } else { var e = -T.dataIndex; var kI = e / 256; i.renderData = { vertexAll: [e, 0, this.height, kI + kD, 0, 256, 0, this.height, 1, 0, 256, 256, this.height, 1, 1, e, 0, this.height, kI + kD, 0, 256, 256, this.height, 1, 1, e, 256, this.height, kI + kD, 1] } } } else { i.renderData = { vertexAll: [0, 0, this.height, 0, 0, 256, 0, this.height, 1, 0, 256, 256, this.height, 1, 1, 0, 0, this.height, 0, 0, 256, 256, this.height, 1, 1, 0, 256, this.height, 0, 1] } } this.setRasterTileData(kE, i, kH) } }, setRasterTileData: function (kD, e, kC) { e.status = "ready"; this.tileCache.setData(kD, e); var T = false; if (this.curViewTilesInfo[kC]) { e.dataType = gX; e.png8 = this.png8 || false; this.map._featureMgr.setData(e, this.drawIndex, 2); T = true } if (T) { var i = new fW("onrefresh"); i.source = "webgllayer"; this.map.dispatchEvent(i) } }, _checkLayerTilesLoaded: function () { this.numTileLoading--; if (this.firstTileLoad === false) { this.dispatchEvent(new fW("ontilesloadstart")); this.firstTileLoad = true } var e = this; if (this.numTileLoading === 0) { if (this._checkTileLoadedTimer) { clearTimeout(this._checkTileLoadedTimer); this._checkTileLoadedTimer = null } this._checkTileLoadedTimer = setTimeout(function () { if (e.numTileLoading === 0) { e.dispatchEvent(new fW("ontilesloadend")); e.firstTileLoad = false } e._checkTileLoadedTimer = null }, 60) } }, _checkTilesLoaded: function () { this._checkLayerTilesLoaded(); this.numLoading--; if (this.map.firstTileLoad === false) { this.map.dispatchEvent(new fW("onfirsttilesloaded")); this.map.firstTileLoad = true } var e = this; if (this.numLoading === 0) { if (this._checkLoadedTimer) { clearTimeout(this._checkLoadedTimer); this._checkLoadedTimer = null } this._checkLoadedTimer = setTimeout(function () { if (e.numLoading === 0) { e.map.dispatchEvent(new fW("ontilesloaded")); e.map.firstTileLoad = false } e._checkLoadedTimer = null }, 60) } }, isClickableLabel: function (e) { if (e.isDel) { return false } if (e.zoom > 9 && !e.guid) { return false } if (e.zoom <= 9 && !e.name && !e.guid) { return false } return true } }; var aW = 5; var ju = 4; var gQ = 3; var P = 2; var eC = 1; var hO = 0; function az(e) { this._ratio = gu(); this._iconCache = {}; this._map = e; this._drawingCanvasPool = []; this._drawingCanvasHeight = 4096; this._bufferSpan = [5, 5] } e9.extend(az.prototype, { _loadIcons: function (T, kI, kE) { var kC = 0; var kF = this; var kD = this._map.config.style; for (var kG in T) { kC++; var kH = new Image(); kH.id = kG; kH.crossOrigin = "anonymous"; kH.onload = function () { kF._iconCache[this.id].loaded = true; kC--; if (kC === 0) { kI() } this.onload = null }; kH.onerror = function () { kF._iconCache[this.id] = null; kC--; if (kC === 0) { kI() } this.onerror = null }; if (!kE) { var e = E.getIconSetPath(kD) + kG + ".png"; var i = bH(); if (i && i.udt) { e += "?udt=" + i.udt } } else { var e = kG } kH.src = e; this._iconCache[kG] = { loaded: false, image: kH } } }, _getEmptyDrawingCanvas: function () { for (var T = 0; T < this._drawingCanvasPool.length; T++) { if (this._drawingCanvasPool[T]._free === true) { this._drawingCanvasPool[T]._free = false; return this._drawingCanvasPool[T] } } var e = this._createNewDrawingCanvas(); this._drawingCanvasPool.push(e); e._free = false; return e }, _createNewDrawingCanvas: function () { var e = b6("canvas"); e.width = 512; e.height = this._drawingCanvasHeight; e._free = true; e._id = bG.getGUID(); var i = e.getContext("2d", { colorSpace: "display-p3" }); i.textBaseline = "bottom"; i.lineJoin = "round"; return e }, drawLabelsOnCanvas: function (kU, kC) { var kK = kU.label.fixedLabel.slice(0); var kQ = kU.label.lineLabel.slice(0); var T = kU.label.indoorLabel.slice(0); if (kK.length === 0 && kQ.length === 0 && T.length === 0) { kC(); return } var kF = function (kZ, i) { return kZ.styleId - i.styleId }; kK.sort(kF); kQ.sort(kF); T.sort(kF); var kT = {}; var e = this._getEmptyDrawingCanvas(); var kP = e.getContext("2d", { colorSpace: "display-p3" }); kP.clearRect(0, 0, e.width, e.height); var kX = 0; var kL = null; var kE = 0; if (kK.length > 0) { while (kE < kK.length && !kK[kE].styleText[0]) { kE++ } if (kK[kE] && kK[kE].styleText[0]) { kL = kK[kE].styleText[0].fontSize + kK[kE].styleText[0].haloSize * 2 } } if (kL === null && T.length > 0) { kE = 0; while (kE < T.length && !T[kE].styleText[0]) { kE++ } if (T[kE] && T[kE].styleText[0]) { kL = T[kE].styleText[0].fontSize + T[kE].styleText[0].haloSize * 2 } } if (kL === null && kQ.length > 0) { kE = 0; while (kE < kQ.length && !kQ[kE].styleText[0]) { kE++ } if (kQ[kE] && kQ[kE].styleText[0]) { kL = kQ[kE].styleText[0].fontSize + kQ[kE].styleText[0].haloSize * 2 } } if (kL === null || isNaN(kL)) { kC(); return } var kH = 0; var kG = kL; kG += this._bufferSpan[1]; var kN = {}; var kY = 0; var kO = []; for (var kS = 0; kS < kK.length; kS++) { var kJ = kK[kS]; var kM = kJ.name; var kR = kJ.styleText; if (!kM || kR.length === 0) { continue } var kD = kJ.icon; if (kJ.textOnIcon && (!this._iconCache[kD] || this._iconCache[kD].loaded === false)) { kO.push(kJ); kY++; if (!kN[kD]) { kN[kD] = true } continue } var kV = this._drawEachText(kP, kJ, kX, kH, kG, kL, kT); if (!kV) { continue } kH = kV.curX; kG = kV.curY; kL = kV.curLineHeight; kX = kV.styleId } var kV = this._drawEachTypeOfLabels(kP, T, kX, kH, kG, kL, kT); kX = kV.curStyleId; kH = kV.curX; kG = kV.curY; kL = kV.curLineHeight; var kV = this._drawEachTypeOfLabels(kP, kQ, kX, kH, kG, kL, kT); kX = kV.curStyleId; kH = kV.curX; kG = kV.curY; kL = kV.curLineHeight; if (kY > 0) { var kW = this; this._loadIcons(kN, function () { kV = kW._drawEachTypeOfLabels(kP, kO, kX, kH, kG, kL, kT); kX = kV.curStyleId; kH = kV.curX; kG = kV.curY; kL = kV.curLineHeight; var i = kW._generateEachLabelCanvas(e, kG, kK, kQ, T, kU); kC(i[0], i[1]) }); return } var kI = this._generateEachLabelCanvas(e, kG, kK, kQ, T, kU); kC(kI[0], kI[1]) }, drawCustomLabelsOnCanvas: function (kH, kG, T) { if (kH.length === 0) { kG(); return } var kE = {}; var kD = false; for (var kC = 0; kC < kH.length; kC++) { var kF = null; if (kH[kC].textOnIcon && kH[kC].icon) { kF = kH[kC].icon } if (kF && !kE[kF] && (!this._iconCache[kF] || this._iconCache[kF].loaded === false)) { kE[kF] = true; kD = true } } var e = this; if (kD) { this._loadIcons(kE, function () { e._drawCustomLabel(kH, kG, T) }, true) } else { e._drawCustomLabel(kH, kG, T) } }, _drawCustomLabel: function (kP, kD, T) { var kF; var kE; var kG; var kO; var kR; var e; var kK; var kC = 0; var kN = kP.length; var kI = T ? [] : null; var kJ = this; for (var kL = 0; kL < kP.length; kL++) { if (!kP[kL].name) { continue } var kQ = kM(kP[kL]); if (!kQ) { continue } if (kQ.overHeight) { if (T) { kN = (kL - kC); kI.push(kH(kC, kN)); kK = null; kC = kL; kN = kP.length; kL = kL - 1 } else { break } } kF = kQ.curX + this._bufferSpan[0]; kE = kQ.curY; kG = kQ.curLineHeight; kR = kQ.styleId } if (!kK) { kS({ style: {} }) } if (T) { kN = kN - kC; kI.push(kH(kC, kN)) } else { kI = kH(kC, kN) } kK = null; kD(kI); function kS(i) { kF = 0 + kJ._bufferSpan[0]; kE = ((i.style.fontSize || 0) + (i.style.haloSize || 0) * 2) + kJ._bufferSpan[1] || 0; kG = kE - kJ._bufferSpan[1]; kO = {}; kR = -1; e = kJ._getEmptyDrawingCanvas(); kK = e.getContext("2d", { colorSpace: "display-p3" }); kK.clearRect(0, 0, e.width, e.height) } function kM(i) { if (!kK) { kS(i) } if (T) { i.cachedIsDel = {} } var kT = kJ._drawEachText(kK, i, kR, kF, kE, kG, kO); return kT } function kH(kX, kW) { var kU = kE; var kT = kJ._copyToNewCanvas(e, kU + kJ._bufferSpan[0]); for (var kV = kX; kV < kP.length && kV < kX + kW; kV++) { if (!kP[kV].name && kP[kV].style.iconSize) { kJ._addFixedLabelBounds(kP[kV]); continue } if (!kP[kV].textSize) { continue } kJ._updateFixedLabelCoords(kP[kV], kU + kJ._bufferSpan[0]); kJ._addFixedLabelBounds(kP[kV]) } kT.range = [kX, kW]; return kT } }, _drawEachTypeOfLabels: function (kL, kF, kJ, kC, T, kD, kH) { for (var kE = 0; kE < kF.length; kE++) { var kG = kF[kE]; var kK = kG.name; var e = kG.styleText; if (!kK || e.length === 0) { continue } var kI = this._drawEachText(kL, kG, kJ, kC, T, kD, kH); if (!kI) { continue } kC = kI.curX + this._bufferSpan[0]; T = kI.curY; kD = kI.curLineHeight; kJ = kI.styleId; if (kI.curY > this._drawingCanvasHeight) { return { curX: kC, curY: T, curLineHeight: kD, curStyleId: kJ } } } return { curX: kC, curY: T, curLineHeight: kD, curStyleId: kJ } }, _drawIndoorTextLabelOnCanvas: function (kD) { var e = this._getEmptyDrawingCanvas(); var kK = e.getContext("2d", { colorSpace: "display-p3" }); kK.clearRect(0, 0, e.width, e.height); var kS = 0; var kJ = null; var kI = 0; var kG; var kP = {}; var kO = []; for (var kE in kD) { if (kE === "tileInfo") { continue } var kC = kD[kE]; var kN = kC.defaultFloor; var kH = kC.floors; for (var kM = 0; kM < kH.length; kM++) { if (kM === kN) { continue } var kQ = kH[kM]; if (!kQ.pois) { continue } var kF = kQ.pois; for (var kL = 0; kL < kF.length; kL++) { if (kJ === null && kF[kL].styleText[0]) { kJ = kF[kL].styleText[0].fontSize + kF[kL].styleText[0].haloSize * 2; kG = kJ } kO.push(kF[kL]) } } } if (kJ === null) { return null } kO.sort(function (kT, i) { return i.rank - kT.rank || kT.styleId - i.styleId }); var kR = this._drawEachTypeOfLabels(kK, kO, kS, kI, kG, kJ, kP); kS = kR.curStyleId; kI = kR.curX; kG = kR.curY; kJ = kR.curLineHeight; var T = this._copyToNewCanvas(e, kG); return T }, _updateIndoorLabelsCoords: function (kJ, kK) { for (var kI in kJ) { if (kI === "tileInfo") { continue } var e = kJ[kI]; var kE = e.defaultFloor; var kF = e.floors; for (var kG = 0; kG < kF.length; kG++) { if (kG === kE) { continue } var T = kF[kG]; if (!T.pois) { continue } var kD = T.pois; for (var kC = 0; kC < kD.length; kC++) { var kH = kD[kC]; if (kH.name && (!kH.textSize || kH.textSize.length === 0)) { kD.splice(kC, 1); kC--; continue } this._updateFixedLabelCoords(kH, kK); this._addFixedLabelBounds(kH) } } } }, _generateEachLabelCanvas: function (kF, kE, kG, e, kI, T) { kE = Math.min(kE, this._drawingCanvasHeight); var kH = this._copyToNewCanvas(kF, kE); var kC = null; if (T.renderData.indoorData) { kC = this._drawIndoorTextLabelOnCanvas(T.renderData.indoorData); if (kC) { this._updateIndoorLabelsCoords(T.renderData.indoorData, kC.height) } } for (var kD = 0; kD < kG.length; kD++) { if (!kG[kD].textSize) { continue } this._updateFixedLabelCoords(kG[kD], kE); this._addFixedLabelBounds(kG[kD]) } for (var kD = 0; kD < kI.length; kD++) { if (!kI[kD].textSize) { continue } this._updateFixedLabelCoords(kI[kD], kE); this._addFixedLabelBounds(kI[kD]) } for (var kD = 0; kD < e.length; kD++) { this._updateLineLabelCoords(e[kD], kE) } return [kH, kC] }, _copyToNewCanvas: function (T, i) { if (i === 0) { return null } var kC = b6("canvas"); kC.width = T.width; kC.height = i; var e = kC.getContext("2d", { colorSpace: "display-p3" }); e.drawImage(T, 0, 0, 512, i, 0, 0, 512, i); kC._id = T._id; T._free = true; return kC }, _drawEachText: function (kV, kG, T, kX, kW, k4, kD) { var k3 = kG.name; var kL = kG.styleText ? kG.styleText[0] : kG.style; if (!kL) { return null } var kO = kL.fontSize || 0; var k8 = kL.fontWeight; var ll = kL.haloSize || 0; var lp = kL.padding || [0, 0]; if (!kQ) { } if (kL.fontRgba) { var ls = kL.fontRgba[3] / 255; var kK = []; kK[3] = ls; for (var lr = 0; lr < 3; lr++) { kK[lr] = kL.fontRgba[lr] } } if (kL.haloRgba) { var ls = kL.haloRgba[3] / 255; var kR = []; kR[3] = ls; for (var lr = 0; lr < 3; lr++) { kR[lr] = kL.haloRgba[lr] } } var lf = kK ? "rgba(" + kK.join(",") + ")" : kL.color; var kF = kR ? "rgba(" + kR.join(",") + ")" : kL.strokeColor; var ln = kG.styleId || 0; if (ll > 4) { ll = 4 } var k5 = []; var kT = []; var k1 = 0; if (kD && !kD[ln]) { kD[ln] = {} } var kN = kO + ll * 2 + lp[0] * 2; var k6 = kN; if (kG.containDescendings) { k6 += 4 } if (ll === 0) { k6 += 2 } if (kG.textOnIcon) { k6 = Math.max(k6, kG.iconSize[1]) } if (ln !== T || k6 > k4) { T = ln; if (k8 >= 10 && k8 % 10 === 0) { kV.font = k8 * 10 + " " + kO + "px sans-serif" } else { kV.font = kO + "px sans-serif" } if (k6 > k4) { var k2 = k6 - k4; k4 += k2; kW += k2 } if (ll > 0) { kV.lineWidth = ll * 2; kV.strokeStyle = kF } kV.fillStyle = lf } if (kG.type === "line") { var kI = k3.split(""); for (var lo = 0; lo < kI.length; lo++) { var lh = kI[lo]; var kY; var k9; if (kD[ln][lh]) { var kQ = kD[ln][lh]; kY = kQ.displaySize; k9 = kQ.curWordPosition } else { var kC = Math.ceil(kV.measureText(lh).width); if (kX + kC > 512) { kX = 0 + this._bufferSpan[0]; kW += k6; kW += this._bufferSpan[1]; k4 = k6 } if (kW + this._bufferSpan[1] > this._drawingCanvasHeight) { return { curX: kX, curY: kW, curLineHeight: k4, styleId: ln } } var li = kX; if (ll > 0) { kC += ll; li -= Math.round(ll / 2); kV.strokeText(lh, kX, kW) } kV.fillText(lh, kX, kW); var le = [kC, k6]; kY = [Math.round(le[0] / 2), Math.round(le[1] / 2)]; k9 = [li, kW - k6]; kD[ln][lh] = { displaySize: kY, curWordPosition: k9, totalHeight: k1 }; kX += kC + 2 } k5.push(kY); kT.push(k9) } k1 = Math.round(k5[0][1]) } else { if (kD[ln][k3]) { var kQ = kD[ln][k3]; k5 = kQ.textSize; kT = kQ.labelImagePosition; k1 = kQ.totalHeight } else { var kP = k3.split("\\"); if (kP.length > 1 && kG.textOnIcon) { var lq = 0; var lm = 0; var lt = []; var kZ = 8; for (var lo = 0; lo < kP.length; lo++) { var k3 = kP[lo]; var kM = Math.ceil(kV.measureText(k3).width); if (kM > lq) { lq = kM } lt.push(Math.round(kM / 2)); lm += k6 } var kJ = lq + 2 * kZ; var lk = lm + 2 * kZ; if (kX + kJ > 512) { kX = 0 + this._bufferSpan[0]; kW += k4; kW += this._bufferSpan[1] } kW += lm - k6 + 2 * kZ; var ld = kX; var k0 = kW - lk; var e = Math.round(kJ / 2); var kS = this._iconCache[kG.icon].image; this.drawStretchedIcon(kV, kS, [ld, k0], kZ, lq, lm); for (var lo = 0; lo < kP.length; lo++) { var k3 = kP[lo]; var lj = ld + (e - lt[lo]); var lg = k0 + 4 + (lo + 1) * k6; kV.fillText(k3, lj, lg) } k5.push([Math.round(kJ / 2), Math.round(lk / 2)]); kT.push([ld, k0]); kX += kJ; k4 = lk; k1 = Math.round(lk / 2) } else { for (var lo = 0; lo < kP.length; lo++) { var k3 = kP[lo]; var kM = Math.ceil(kV.measureText(k3).width); if (kM > 512 && kP.length == 1) { kP[lo] = k3.substring(0, Math.floor(k3.length / 2)); kP[lo + 1] = k3.substring(Math.floor(k3.length / 2)); lo--; continue } var kJ = kM; var kE = 0; if (kG.textOnIcon) { kE = 10; kJ += kE * 2; if (kG.styleId === 519) { kJ = kG.iconSize[0]; kE = Math.round((kJ - kM) / 2) } } if (kX + kJ > 512) { kW += k6; kW += this._bufferSpan[1]; if (kW + this._bufferSpan[1] > this._drawingCanvasHeight) { kW -= k6; kW -= this._bufferSpan[1]; return { overHeight: true, curX: kX, curY: kW, curLineHeight: k4, styleId: ln } } kX = 0 + this._bufferSpan[0]; k4 = k6 } else { if (kW + this._bufferSpan[1] > this._drawingCanvasHeight) { return { overHeight: true, curX: kX, curY: kW, curLineHeight: k4, styleId: ln } } } var ld = kX; var k0 = kW - k6; var lc = kX; var lb = kW; if (kG.containDescendings) { lb -= 4 } if (kG.textOnIcon) { var k7 = false; var kS = this._iconCache[kG.icon].image; var la = kG.iconSize.concat([]); if (kN >= la[1]) { la[1] = kN; k7 = true; k6 += kE * 2; var k2 = k6 - k4; if (k2 > 0) { kW += k2; k4 = k6; lb += (k2 - kE); k0 += (k2 - kE * 2) } else { lb -= kE; k0 -= kE * 2 } } if (kM >= la[0]) { la[0] = kM } if (kG.styleId === 519) { kV.drawImage(kS, 0, 0, la[0], la[1], ld, k0, la[0], la[1]) } else { if (kG.noStretch) { lb -= kN / 2; var kU = kM + kE * 2; kV.drawImage(kS, 0, 0, kS.width, kS.height, ld, k0, kU, kN) } else { if (k7) { this.drawStretchedIcon(kV, kS, [ld, k0], kE, kM, la[1]) } else { this.draw3StretchedIcon(kV, kS, [ld, k0], kE, kM, la[1]) } } } lc += kE; if (kG.iconSize[1] > kN) { lb -= (kG.iconSize[1] - kN) / 2 - 1 } } if (ll > 0) { if (ln === 71028) { k6 -= 2 } if (ln === 32) { k6 -= 2 } kV.strokeText(k3, lc, lb) } kV.fillText(k3, lc, lb); var kH = [kJ, k6]; var kY = [Math.round(kH[0] / 2), Math.round(kH[1] / 2)]; k5.push(kY); kT.push([ld, k0]); k1 += Math.round(kY[1]); kX += kJ } } kD[ln][k3] = { textSize: k5, labelImagePosition: kT, totalHeight: k1 } } } kG.textSize = k5; kG.labelImagePosition = kT; kG.totalHeight = k1; return { curX: kX, curY: kW, curLineHeight: k4, styleId: ln } }, drawStretchedIcon: function (e, T, kC, kF, kG, i) { var kE = kC[0]; var kD = kC[1]; e.drawImage(T, 0, 0, kF, kF, kE, kD, kF, kF); e.drawImage(T, kF, 0, 1, kF, kE + kF, kD, kG, kF); e.drawImage(T, T.width - kF, 0, kF, kF, kE + kG + kF, kD, kF, kF); e.drawImage(T, 0, kF, kF, 1, kE, kD + kF, kF, i); e.drawImage(T, kF, kF, 1, 1, kE + kF, kD + kF, kG, i); e.drawImage(T, T.width - kF, kF, kF, 1, kE + kG + kF, kD + kF, kF, i); e.drawImage(T, 0, T.height - kF, kF, kF, kE, kD + i + kF, kF, kF); e.drawImage(T, kF, T.height - kF, 1, kF, kE + kF, kD + i + kF, kG, kF); e.drawImage(T, T.width - kF, T.height - kF, kF, kF, kE + kG + kF, kD + i + kF, kF, kF) }, draw3StretchedIcon: function (e, i, T, kE, kG, kF) { var kD = T[0]; var kC = T[1]; e.drawImage(i, 0, 0, kE, i.height, kD, kC, kE, i.height); e.drawImage(i, kE, 0, 1, i.height, kD + kE, kC, kG, i.height); e.drawImage(i, i.width - kE, 0, kE, i.height, kD + kE + kG, kC, kE, i.height) }, _updateFixedLabelCoords: function (kD, kS) { if (kS === 0) { return } var kN = []; var kZ = []; var k0 = 0; var kQ = kD.totalHeight; var k8 = kD.textSize.length; var kE = kD.direction; if (typeof kE !== "number") { kE = 0 } for (var k1 = 0; k1 < k8; k1++) { var kT = kD.labelImagePosition[k1]; var kR = kD.textSize[k1]; var kP = kT[0]; var kC = kT[1]; var kF = kR[0]; var kK = kR[1]; var kM = 0; var kY = 0; if (typeof kD.textMargin === "number") { kY = kD.textMargin } var kL; var e; var kH = 0; var kO = 0; if (!kD.iconPos) { if (!kD.custom) { kE = ju } } else { kH = kD.iconPos.width; kO = kD.iconPos.height } switch (kE) { case gQ: var T = kQ / 2 - kK + kM * (k8 - 1) / 2; kL = Math.round(-kH / 2 - kF - kY); e = Math.round(T - k0 - kM * k1); break; case eC: var T = kQ / 2 - kK + kM * (k8 - 1) / 2; kL = Math.round(kH / 2 + kY); e = Math.round(T - k0 - kM * k1); break; case P: var T = kO / 2 + kQ - kK + kM * k8; kL = Math.round(-kF / 2); e = Math.round(T - k0 - kM * k1); break; case hO: var T = -kO / 2 - kM - kK; kL = Math.round(-kF / 2); e = Math.round(T - k0 - kM * k1); break; case ju: var T = -kQ / 2 - kM * (k8 - 1) / 2; kL = Math.round(-kF / 2); e = Math.round(T - k0 - kM * k1); break }k0 += kK; var kJ = kL + kF; var k9 = e; var kI = kJ; var k7 = k9 + kK; var kG = kL; var k6 = k7; kN.push(kL, e, kJ, k9, kI, k7, kL, e, kI, k7, kG, k6); var k5 = kP / 512; var kX = (kS - kC - kK * 2) / kS; var k4 = (kP + kF * 2) / 512; var kW = kX; var k3 = k4; var kV = (kS - kC) / kS; var k2 = k5; var kU = kV; kZ.push(k5, kX, k4, kW, k3, kV, k5, kX, k3, kV, k2, kU) } if (!kD.textPos) { kD.textPos = {} } kD.textPos.vertex = kN; kD.textPos.texcoord = kZ }, _addFixedLabelBounds: function (kI) { var kE = 1000; var kC = 1000; var T = -1000; var e = -1000; if (kI.iconPos) { var kG = kI.iconPos["vertex"]; for (var kH = 0, kD = kG.length; kH < kD; kH += 2) { var kM = kG[kH]; var kK = kG[kH + 1]; if (kM < kE) { kE = kM } if (kM > T) { T = kM } if (kK < kC) { kC = kK } if (kK > e) { e = kK } } } if (kI.custom && kI.style.iconSize && !kI.name) { var kJ = kI.style.iconSize; var kL = kI.direction; switch (kL) { case ju: kE = -Math.round(kJ[0] / 2); kC = -Math.round(kJ[1] / 2); T = Math.round(kJ[0] / 2); e = Math.round(kJ[1] / 2); break; case P: kE = -Math.round(kJ[0] / 2); kC = 0; T = Math.round(kJ[0] / 2); e = kJ[1]; break } } if (kI.textPos) { var kF = kI.textPos["vertex"]; for (var kH = 0, kD = kF.length; kH < kD; kH += 2) { var kM = kF[kH]; var kK = kF[kH + 1]; if (kM < kE) { kE = kM } if (kM > T) { T = kM } if (kK < kC) { kC = kK } if (kK > e) { e = kK } } } kI.bds = [kE, kC, T, e] }, _updateLineLabelCoords: function (kT, kJ) { if (kJ === 0) { return } var kC = kT.wordsInfo; var kQ = kT.wordCount; if (!kT.labelImagePosition) { return } var kL = kT.labelImagePosition.slice(0); if (kT.reverse) { kL.reverse() } var k2 = 1000; var kZ = 1000; var k0 = -1000; var kY = -1000; for (var kU = 0; kU < kQ; kU++) { var k3 = kL[kU]; var k1 = k3[0]; var kR = k3[1]; var kP = kT.textSize[kU]; var kI = kP[0]; var e = kP[1]; var kH = k1 / 512; var kO = (kJ - kR - e * 2) / kJ; var kF = (k1 + kI * 2) / 512; var kN = kO; var kD = kF; var kM = (kJ - kR) / kJ; var T = kH; var kK = kM; kC[kU].size = [kI, e]; kC[kU].texcoord = [kH, kO, kF, kN, kD, kM, kH, kO, kD, kM, T, kK]; var kX = kC[kU].offset[0]; var kW = kC[kU].offset[1]; var kV = kX - kI / 2; var kG = kW + e / 2; var kE = kW - e / 2; var kS = kX + kI / 2; if (kV < k2) { k2 = kV } if (kS > k0) { k0 = kS } if (kE < kZ) { kZ = kE } if (kG > kY) { kY = kG } } kT.bds = [k2, kZ, k0, kY] } }); var gi = { 0: "00000000", 16: "00010000", 32: "00100000", 48: "00110000", 64: "01000000", 96: "01100000" }; function et(kE, kG, kC) { var kD = kE.bds; if (!kD) { return false } var kF = kE.tracer; var T; if (kF) { if (!gi[kF]) { T = kF.toString(2); if (T.length < 8) { T = new Array(8 - T.length + 1).join("0") + T } gi[kF] = T } T = gi[kF]; var e = kx.mapZoomStartZoomMapping[kG]; var kH = kG > 20 ? 21 : kG; return T[kH - e] === "1" } var i = kE.displayRange; if (kC >= i[0] && kC <= i[1]) { return true } return false } function jA(i, e) { this.map = i.map; this.layer = i; e = e || []; this.allLabels = []; this._spotData = []; this._strategyInfo = null; this.RANK1 = 1000000; this.RANK2 = 2000000; this.RANK3 = 3000000; this.RANK4 = 4000000; this.RANK5 = 5000000; this._ratio = gu(); this._useRound = true; this._sharpenRender = false; if (this._ratio > h5.HIGH_RES_MIN_RATIO) { this._useRound = false; this._sharpenRender = true } this._mapIsMoving = false; this._onMapIdleCallback = e.onMapIdleCallback; this.map.temp.isPermitSpotOver = true; this.currentSelectedLabel = null; this.map._labelProcessor = this; this.iconCache = new aC((b5() || e9.Browser.ie) ? 64 : 128, { clearCallback: function (T) { } }); this.fixedLabelData = []; this.lineLabelData = []; this.highlightLabelData = []; this._iconLoadTimer = null; this._labelTextCanvas = null; if (this.map.config.textRenderType === "canvas") { this._labelTextCanvas = this.map.tileMgr.getLabelTextCanvas() } this.bind() } e9.extend(jA.prototype, { bind: function () { var T = this.map; var i = this; T.addEventListener("mapstatusbusy_inner", function (kC) { i._mapIsMoving = true; if (i._ratio > h5.HIGH_RES_MIN_RATIO) { i._sharpenRender = false } else { i._useRound = false } }); T.addEventListener("mapstatusidle_inner", function (kC) { if (i._ratio > h5.HIGH_RES_MIN_RATIO) { i._sharpenRender = true } else { i._useRound = true } i._mapIsMoving = false }); T.addEventListener("onspotmouseover", function (kE) { if (!this.temp.isPermitSpotOver) { return } if (kE.spots.length > 0) { var kD = kE.spots[0].userdata.uid; var kF = kE.spots[0].userdata.tilePosStr; var kC = i.getLabelByUid(kD, kF); kC && kC.formatedData && i._toHighlightColor(kC.formatedData) } }); T.addEventListener("onspotmouseout", function (kE) { if (!this.temp.isPermitSpotOver) { return } if (kE.spots.length > 0) { var kD = kE.spots[0].userdata.uid; var kF = kE.spots[0].userdata.tilePosStr; var kC = i.getLabelByUid(kD, kF); kC && kC.formatedData && i._toDefaultColor(kC.formatedData) } }); T.addEventListener("spotclick", function (kE) { if (kE.spots && kE.spots.length > 0) { if (kE.spots[0].userdata.zoom < 10) { return } var kD = kE.spots[0].userdata.uid; var kF = kE.spots[0].userdata.tilePosStr; if (i.currentSelectedLabel && (i.currentSelectedLabel.uid !== kD || i.currentSelectedLabel.tilePosStr !== kF)) { i._recoverNormalState() } var kC = i.getLabelByUid(kD, kF); kC && i._changeBaseMapState(kC) } else { i._recoverNormalState() } }); T.on("spot_status_reset", function () { i._recoverNormalState() }); T.on("spot_highlight", function (kD) { var kC = i.getLabelByUid(kD.uid, kD.tilePosStr); kC && kC.formatedData && i._toHighlightColor(kC.formatedData) }); T.addEventListener("mousemove", function (kC) { if (i.curSpotAdded) { return } if (this.currentOperation !== ep.idle || i._mapIsMoving === true) { return } i._refreshSpotData(); this.temp.isPermitSpotOver = true; i.curSpotAdded = true }); if (b5()) { function e() { i._refreshSpotData() } T.addEventListener("mapstatusidle_inner", e) } T.on("style_loaded", function () { if (i.map.config.textRenderType === "canvas" && !i._labelTextCanvas) { i._labelTextCanvas = i.map.tileMgr.getLabelTextCanvas() } }); T.on("destroy", function () { i.iconCache.clear(); for (var kC = 0; kC < i.fixedLabelData.length; kC++) { i.fixedLabelData[kC] = null } i.fixedLabelData = []; i.lineLabelData = []; i.highlightLabelData = []; for (var kC = 0; kC < i.allLabels.length; kC++) { i.allLabels[kC]._mcBds = null; i.allLabels[kC] = null } i.allLabels = []; for (var kC = 0; kC < i._spotData.length; kC++) { i._spotData[kC].pt = null; i._spotData[kC].userdata.iconPoint = null; i._spotData[kC] = null } i._spotData = [] }) }, getLabelByUid: function (kG, kH) { var e = this.map._featureMgr.getResult().tileLabels[this.layer.drawIndex] || []; for (var kF = 0; kF < e.length; kF++) { var kC = e[kF].fixedLabel; for (var kE = 0; kE < kC.length; kE++) { if (e[kF].fixedLabel[kE].guid === kG && e[kF].fixedLabel[kE].tilePosStr === kH) { return e[kF].fixedLabel[kE] } } var kD = e[kF].indoorLabel; for (var T = 0; T < kD.length; T++) { if (e[kF].indoorLabel[T].guid === kG && e[kF].indoorLabel[T].tilePosStr === kH) { return e[kF].indoorLabel[T] } } } return null }, getTileByLabelUid: function (kG) { var e = this.map._featureMgr.getResult().tileLabels[this.layer.drawIndex] || []; for (var kF = 0; kF < e.length; kF++) { var kC = e[kF].fixedLabel; for (var kE = 0; kE < kC.length; kE++) { if (e[kF].fixedLabel[kE].guid === kG) { return e[kF] } } var kD = e[kF].indoorLabel; for (var T = 0; T < kD.length; T++) { if (e[kF].indoorLabel[T].guid === kG) { return e[kF] } } } return null }, _toHighlightColor: function (T) { if (T.tempRank && T.tempRank === this.RANK5) { return } var e = this.map._featureMgr.getResult().eleData[4][this.layer.drawIndex] || []; var kD = false; for (var kC = 0; kC < e.length; kC++) { if (e[kC] === T || (e[kC].guid === T.guid && e[kC].tilePosStr === T.tilePosStr && e[kC].zoom === T.zoom)) { kD = true; break } } if (kD) { return } e.push(T); this.map._featureMgr.setOverlayData(e, 4, this.layer.drawIndex); this.map.dispatchEvent(new fW("onrefresh")) }, _toDefaultColor: function (T) { if (T.tempRank && T.tempRank === this.RANK5) { return } var e = this.map._featureMgr.getResult().eleData[4][this.layer.drawIndex] || []; for (var kC = 0; kC < e.length; kC++) { if (T === e[kC] || (T.guid === e[kC].guid && T.tilePosStr === e[kC].tilePosStr && T.zoom === e[kC].zoom)) { e.splice(kC, 1); break } } this.map._featureMgr.setOverlayData(e, 4, this.layer.drawIndex); this.map.dispatchEvent(new fW("onrefresh")) }, _changeBaseMapState: function (i) { var kD = i.guid; var kH = i.formatedData.guidExt; var kI = { guid: kD, tilePosStr: i.tilePosStr, guidExt: kH }; this._strategyInfo = kI; this.currentSelectedLabel = i; var kC = this.map._featureMgr; var e = kC.getLabelData(this.layer.drawIndex); e = this.collisionTest(e); this.updateLabels(e); var kJ = this.fixDataFormat(e); kC.setOverlayData(kJ[0], 2, this.layer.drawIndex); kC.setOverlayData(kJ[1], 3, this.layer.drawIndex); kC.setOverlayData(kJ[2], 4, this.layer.drawIndex); var T = this.getTileByLabelUid(kD); this.currentSelectedLabel.tileInfo = T.tileInfo; var kG = this.layer.tileCache.getAllData(); for (var kF in kG) { var kE = kG[kF].data; if (!kE.label) { continue } this.clearCollisionCache(kE.label) } this.map.dispatchEvent(new fW("onrefresh")) }, _recoverNormalState: function () { this._strategyInfo = null; var kG = false; var kE = this.map._featureMgr.getLabelData(this.layer.drawIndex); if (this.currentSelectedLabel) { var T = this.currentSelectedLabel.guid; this.clearCollisionCache(this.getTileByLabelUid(T)); var kD = this.layer.tileCache.getAllData(); for (var kC in kD) { if (Object.prototype.hasOwnProperty.call(kD, kC)) { var kF = kD[kC].data; if (!kF.label) { continue } this.clearCollisionCache(kF.label) } } this.currentSelectedLabel.tempRank = null; this.currentSelectedLabel = null; kG = true } kE = this.collisionTest(kE); this.updateLabels(kE); var e = this.fixDataFormat(kE); var i = this.map._featureMgr; i.setOverlayData(e[0], 2, this.layer.drawIndex); i.setOverlayData(e[1], 3, this.layer.drawIndex); i.setOverlayData([], 4, this.layer.drawIndex); this.map.dispatchEvent(new fW("onrefresh")); if (kG) { this.curSpotAdded = false; this._refreshSpotData() } }, loadIconImages: function (kP, kF, T) { var kO = kP.label; var kR = kP.tileInfo.style; var kD = kO.fixedLabel; if (T === "indoor") { kD = [] } var kN = kO.indoorLabel; var kM = kD.length + kN.length; var kS = this; var kQ = 0; var kK = 200; for (var kL = 0; kL < kM; kL++) { var kI; if (kL < kD.length) { kI = kD[kL] } else { kI = kN[kL - kD.length] } if (!kI.iconPos) { var kH = this.loadSVGSymbol(kI, kR); if (!kH) { continue } else { if (kH !== true) { var kG = kI.iconPos.iconType; var e = kR + "_" + kG; this.iconCache.setData(e, { loaded: false, image: kH }); kI.iconPos.img = kH } } } var kG = kI.iconPos.iconType; var e = kR + "_" + kG; kQ++; if (this.iconCache.getData(e)) { if (this.iconCache.getData(e).loaded) { kF(kP) } else { if (kI.iconPos.img) { kI.iconPos.img.id = e; kI.iconPos.img.iconUrl = kG; this.iconCache.setData(e, { loaded: true, image: kI.iconPos.img }); this._addToIconTexture(kI.iconPos.img); kF(kP) } else { } } continue } if (!T || T === "indoor") { var kE = E.getIconSetPath(this.map.config.style) + kG + ".png"; var kJ = bH(); if (kJ && kJ.udt) { kE += "?udt=" + kJ.udt } } else { var kE = kG } var kC = new Image(); kC.id = e; kC.iconUrl = kE; kC.crossOrigin = "anonymous"; kC.onload = function () { if (kS.iconCache.getData(this.id)) { kS.iconCache.getData(this.id).loaded = true; kS._addToIconTexture(this) } if (!kS._iconLoadTimer) { kS._iconLoadTimer = setTimeout(function () { kF(); kS._iconLoadTimer = null }, kK) } this.onload = null }; kC.onerror = function () { if (!kS._iconLoadTimer) { kS._iconLoadTimer = setTimeout(function () { kF(); kS._iconLoadTimer = null }, kK) } kS.iconCache.removeData(this.id); this.onerror = null; bG.fetchDebug && bG.fetchDebug.sendError({ title: this.iconUrl, msg: this.iconUrl, category: bG.fetchDebug.category.RESOURCE, level: bG.fetchDebug.levels.ERROR, url: this.iconUrl }) }; kC.src = kE; this.iconCache.setData(e, { loaded: false, image: kC }) } return kQ }, _addToIconTexture: function (kE) { if (!this.map._webglMapScene) { return } var kG = this.map._webglMapScene._painter; var e = kG._iconTextureAtlas.addTexture(kE); if (e === false) { this.map.fire(new fW("onlayer_clear")) } if (!e) { return } kG._iconTextureAtlasOffset[kE.id] = e; var kJ = 0 * kE.width / 1024 + e.width; var kD = 0 * kE.height / 1024 + e.height; var kI = kE.width / 1024 + e.width; var kC = kD; var kH = kI; var T = kE.height / 1024 + e.height; var kF = kJ; var i = T; kG._iconTextureAtlasCoords[kE.id] = [kJ, kD, kI, kC, kH, T, kJ, kD, kH, T, kF, i] }, loadSVGSymbol: function (kC, T) { var i = kC.symbol || {}; var kF = dU.generateKey(i.path, i); if (!kF) { return null } var kE = this.iconCache.getData(T + "_" + kF); if (kE && kE.loaded) { kC.iconPos = this.createVertex(kE.image.width / 2, kE.image.height / 2, kF); return true } var kD = new dU(i.path, i); kD.add(); var e = kD.render(); if (!e) { return null } kC.iconPos = this.createVertex(kD.size.width, kD.size.height, kF); return kD.data }, createVertex: function (kE, kI, T) { var kD = Math.round(-kE / 2); var kK = Math.round(-kI / 2); var kC = kD + kE; var kJ = kK; var i = kC; var kH = kJ + kI; var e = kD; var kG = kH; var kF = { vertex: [kD, kK, kC, kJ, i, kH, kD, kK, i, kH, e, kG], texcoord: null, width: kE, height: kI, iconType: T }; return kF }, loadImgByStr: function (kC, kD, kE) { if (!kC && !kD) { kE && kE(null, null); return } if (typeof kC === "object" && typeof kD === "object") { kE(kC, kD); return } var i = 0; var T = null; var e = null; if (kC) { i++; T = new Image(); T.onload = function () { i--; if (i === 0) { kE && kE(this, e) } this.onload = null }; T.src = kC } if (kD) { i++; e = new Image(); e.onload = function () { i--; if (i === 0) { kE && kE(T, this) } this.onload = null }; e.src = kD } }, collisionTest: function (lu, kN, kU) { if (this.map.viewAnimationTime) { return [] } if (!lu) { return [] } if (this.layer.ontology && this.layer.ontology.noCollision) { for (var k5 = 0; k5 < lu.length; k5++) { var lI = lu[k5].fixedLabel; for (var k3 = 0; k3 < lI.length; k3++) { var kF = lI[k3]; var lK = this.layer.ontology.getLayerVisible(kF.layerName); kF.isDel = !lK } } return lu } var kQ = this.map; var ly = kQ.getHeading(); ly = this.calcLoopHeading(ly); var lg = kQ.height; var k8 = this.allLabels; for (var k5 = 0; k5 < k8.length; k5++) { k8[k5]._mcBds = null } k8.length = 0; lu.sort(function (ll, i) { var lM = ll.tileInfo; var lL = i.tileInfo; if (lM.col * lM.row < lL.col * lL.row) { return -1 } else { return 1 } }); var kR = kQ.getTilt(); var lz = kQ.getZoom(); if (this.layer.ontology) { lz += (this.layer.spanLevel || 0) } var k1; if (kU) { k1 = kU } else { k1 = this.getZoomStep() } for (var k5 = 0, kZ = lu.length; k5 < kZ; k5++) { var T = lu[k5]; var k9 = T.tileInfo; var k2 = k9.zoom; var lh = k9.loopOffsetX / Math.pow(2, 18 - k2); if (!ly && !kR) { if (T.unnecessaryCollisionTest && T.unnecessaryCollisionTest[kU]) { continue } } var lI = T.fixedLabel || []; for (var k3 = 0, lF = lI.length; k3 < lF; k3++) { var kF = lI[k3]; kF.zoom = k2; if (kN === -1 && kF.isDel) { continue } if (this.layer.ontology) { var lK = this.layer.ontology.getLayerVisible(kF.layerName); if (!lK) { continue } } if (!et(kF, k9.useZoom, lz)) { kF.isDel = true; continue } this.calcCollisionBounds(kF, k1, lh, lg); k8.push(kF) } var k4 = T.indoorLabel || []; for (var k0 = 0, lc = k4.length; k0 < lc; k0++) { var lb = k4[k0]; lb.zoom = k2; if (kN === -1 && lb.isDel) { continue } if (!et(lb, k9.useZoom)) { lb.isDel = true; continue } this.calcCollisionBounds(lb, k1, lh, lg); k8.push(lb) } var lE = T.lineLabel || []; for (var k7 = 0, kS = lE.length; k7 < kS; k7++) { var lq = lE[k7]; if (kN === -1 && lq.isDel) { continue } if (!et(lq, k9.useZoom)) { lq.isDel = true; continue } var kG = lq.pt; var lp = kQ.pointToPixelIn(kG, { zoom: k1, useRound: this._useRound }); var lH = lp.x + lh; var lG = lg - lp.y; var kD = lq.bds; var ls = kD[0]; var lr = kD[1]; var kW = kD[2]; var kV = kD[3]; var kP = ls; var kO = lr; var lD = kW; var lC = kV; if ((ly >= 0 && ly < 45) || (ly >= 315 && ly < 360)) { kP = ls; kO = lr; lD = kW; lC = kV } else { if (ly >= 45 && ly < 135) { kP = lr; kO = -kW; lD = kV; lC = -ls } else { if (ly >= 135 && ly < 225) { kP = -kW; kO = -kV; lD = -ls; lC = -lr } else { if (ly >= 225 && ly < 315) { kP = -kV; kO = ls; lD = -lr; lC = kW } } } } lq._tempBds = [lH + kP, lG + kO, lH + lD, lG + lC]; var lw = kQ.pixelToPointIn(new fv(lq._tempBds[0], lp.y + kO), { zoom: k1 }); var lo = kQ.pixelToPointIn(new fv(lq._tempBds[2], lp.y + lC), { zoom: k1 }); lq._mcBds = [lw, lo]; k8.push(lq) } } var ln = this._strategyInfo; if (ln) { var k6 = ln.guid; var kX = ln.guidExt; var lk = false; for (var kY = 0, kM = k8.length; kY < kM; kY++) { var kE = k8[kY]; delete kE.tempRank; if (!this.layer.isClickableLabel(kE) || (kX === 1 && !kE.guidExt)) { continue } if (k6 === kE.guid && ln.tilePosStr === kE.tilePosStr) { kE.tempRank = this.RANK5; lk = true } } if (!lk && this.currentSelectedLabel) { this.currentSelectedLabel.tempRank = this.RANK5; var la = this.currentSelectedLabel.tileInfo; if (la) { var kT = la.zoom; var lx = la.loopOffsetX / Math.pow(2, 18 - kT); this.calcCollisionBounds(this.currentSelectedLabel, k1, lx, lg); k8.push(this.currentSelectedLabel) } } } else { for (var kC = 0, kL = k8.length; kC < kL; kC++) { var kI = k8[kC]; if (kI.type === "line" || !kI.iconPos) { continue } delete kI.tempRank } } k8.sort(function (lL, ll) { var lM = lL.tempRank ? lL.tempRank : lL.rank; var i = ll.tempRank ? ll.tempRank : ll.rank; return i - lM || lL.startZoom - ll.startZoom || ll.pt.lng - lL.pt.lng || ll.pt.lat - lL.pt.lat }); var lB = 0; if (kR > 0) { lB = 6 } lz = kQ.getZoom(); if (lz >= 8 && lz < 9) { lz < 8.5 ? (lB = 6) : (lB = 3) } if (kQ._displayOptions.labelMargin > 0) { lB = kQ._displayOptions.labelMargin } var li = 2; if (lz < 6 && lz >= 5) { li = -1 } for (var lm = 0, kK = k8.length; lm < kK; lm++) { var lA = k8[lm]; var lt = lA._tempBds; lA.isDel = false; lA._intersectIdx = []; for (var le = lm + 1; le < kK; le++) { var lf = k8[le]; var lJ = lf._tempBds; if (!(lt[2] + lB + li < lJ[0] - lB || lt[0] - lB > lJ[2] + lB + li || lt[3] + lB + li < lJ[1] - lB || lt[1] - lB > lJ[3] + lB + li)) { lA._intersectIdx.push(le) } } } for (var lj = 0, kJ = k8.length; lj < kJ; lj++) { var kH = k8[lj]; if (kH.isDel === false) { var e = kH._intersectIdx; for (var ld = 0, lv = e.length; ld < lv; ld++) { k8[e[ld]].isDel = true; if (k8[e[ld]].cachedIsDel) { k8[e[ld]].cachedIsDel[kU] = true } } } } return lu }, calcCollisionBounds: function (kI, kG, i, kH) { var kE = kI.ptFix || kI.pt; var kC = this.map; var kD = kC.pointToPixelIn(kE, { zoom: kG, useRound: this._useRound }); var T = kD.x + i; var kK = kH - kD.y; var e = kI.bds; kI._tempBds = [T + e[0], kK + e[1], T + e[2], kK + e[3]]; var kF = kC.pixelToPointIn(new fv(kI._tempBds[0], kD.y + e[1]), { zoom: kG }); var kJ = kC.pixelToPointIn(new fv(kI._tempBds[2], kD.y + e[3]), { zoom: kG }); kI._mcBds = [kF, kJ] }, getZoomStep: function () { var T = this.map.getZoom(); var e = Math.floor(T); var i = T - e >= 0.5 ? e + 0.5 : e; return i }, clearCollisionCache: function (e) { if (!e) { return } e.cacheState = null; e.unnecessaryCollisionTest = null }, getCachedLabels: function (e) { e = e || []; var T = this.getZoomStep(); var kE = false; for (var kC = 0; kC < e.length; kC++) { var kD = e[kC]; if (!kD.cacheState || !kD.cacheState[T]) { kE = true; break } if (kD.hasNewData) { kE = true; break } } if (kE) { this.calcLabelsCollision(e) } return e }, calcLabelsCollision: function (T) { var kD = this.getZoomStep(); var kE = {}; var kL; var kC; var kN; var kP; var kO; var kM; T = this.collisionTest(T, undefined, kD); a2.addLabelIntoAreaSpots(T); for (var kI = 0; kI < T.length; kI++) { kL = T[kI]; kC = kL.tileInfo; kP = kC.col + "," + kC.row; kE[kP] = 1 } var e = {}; for (var kG = 0; kG < T.length; kG++) { kL = T[kG]; if (!kL.cacheState) { kL.cacheState = {} } kC = kL.tileInfo; kO = kC.col; kM = kC.row; kP = kO + "," + kM; if (kL.cacheState[kD] === "stable") { e[kP] = 1; if (!kL.hasNewData) { continue } } for (var kH = 0; kH < kL.fixedLabel.length; kH++) { kN = kL.fixedLabel[kH]; if (!kN.cachedIsDel) { kN.cachedIsDel = {} } kN.cachedIsDel[kD] = kN.isDel } for (var kK = 0; kK < kL.indoorLabel.length; kK++) { kN = kL.indoorLabel[kK]; if (!kN.cachedIsDel) { kN.cachedIsDel = {} } kN.cachedIsDel[kD] = kN.isDel } for (var kJ = 0; kJ < kL.lineLabel.length; kJ++) { kN = kL.lineLabel[kJ]; if (!kN.cachedIsDel) { kN.cachedIsDel = {} } kN.cachedIsDel[kD] = kN.isDel } if (kE[(kO - 1) + "," + (kM - 1)] && kE[(kO - 1) + "," + kM] && kE[(kO - 1) + "," + (kM + 1)] && kE[kO + "," + (kM - 1)] && kE[kO + "," + (kM + 1)] && kE[(kO + 1) + "," + (kM - 1)] && kE[(kO + 1) + "," + kM] && kE[(kO + 1) + "," + (kM + 1)]) { kL.cacheState[kD] = "stable"; e[kP] = 1 } else { if (!kL.cacheState[kD]) { kL.cacheState[kD] = "unstable" } } } for (var kF = 0; kF < T.length; kF++) { kL = T[kF]; kC = kL.tileInfo; kP = kC.col + "," + kC.row; kO = +kC.col; kM = +kC.row; if (e[(kO - 1) + "," + (kM - 1)] && e[(kO - 1) + "," + kM] && e[(kO - 1) + "," + (kM + 1)] && e[kO + "," + (kM - 1)] && e[kO + "," + (kM + 1)] && e[(kO + 1) + "," + (kM - 1)] && e[(kO + 1) + "," + kM] && e[(kO + 1) + "," + (kM + 1)]) { if (!kL.unnecessaryCollisionTest) { kL.unnecessaryCollisionTest = {} } kL.unnecessaryCollisionTest[kD] = 1 } } T.hasNewData = false }, updateLabels: function (kD) { var T = this.map; var kJ = T.getZoom(); var kL = T.getHeading(); kL = this.calcLoopHeading(kL); var kK = T.getTilt(); var kE = this.getZoomStep(); for (var kI = 0, kF = kD.length; kI < kF; kI++) { var kH = kD[kI]; var kC = kH.tileInfo; var kG = kC.loopOffsetX || 0; var e = { zoom: kJ, mcOffsetX: kG }; this.updateFixedLabel(kH.fixedLabel, kK, kL, kH, kE, e); e = { zoom: kJ, mcOffsetX: 0 }; this.updateFixedLabel(kH.indoorLabel, kK, kL, kH, kE, e); this.updateLineLabel(kH.lineLabel, kK, kL, kH, kE) } }, updateFixedLabel: function (kI, kL, i, kO, kE, kJ) { if (kI.length === 1) { } var e = kJ.zoom; var kD = kJ.mcOffsetX; var kT; for (var kP = 0, kG = kI.length; kP < kG; kP++) { var kK = kI[kP]; if (!kK.cachedIsDel) { continue } if (!kL && !i && kO.cacheState && kO.cacheState[kE]) { kK.isDel = kK.cachedIsDel[kE]; if (typeof kK.isDel === "undefined") { kK.isDel = kK.cachedIsDel[kE] = true } } if (kK.startScale > e) { kK.isDel = true } if (kK.isDel) { continue } var kS = kK.pt; var T = (kK.hue || 0) ? gH(kK.hue) : 0; var kC = kK.iconPos; if (kC && kC.texcoord) { if (!kC.rtVertex) { kC.rtVertex = []; kT = kC.vertex; var kH = i5(kS.lng); var kR = i5(kS.lat); kC.rtVertex = [kH[0], kR[0], kH[1], kR[1], 0, kT[0], kT[1], 0, 0, kC.texcoord[0], kC.texcoord[1], T, kH[0], kR[0], kH[1], kR[1], 0, kT[2], kT[3], 0, 0, kC.texcoord[2], kC.texcoord[3], T, kH[0], kR[0], kH[1], kR[1], 0, kT[4], kT[5], 0, 0, kC.texcoord[4], kC.texcoord[5], T, kH[0], kR[0], kH[1], kR[1], 0, kT[6], kT[7], 0, 0, kC.texcoord[6], kC.texcoord[7], T, kH[0], kR[0], kH[1], kR[1], 0, kT[8], kT[9], 0, 0, kC.texcoord[8], kC.texcoord[9], T, kH[0], kR[0], kH[1], kR[1], 0, kT[10], kT[11], 0, 0, kC.texcoord[10], kC.texcoord[11], T] } } if (!kK.textOnIcon) { T = 0 } var kQ = kK.textPos; if (kQ) { if (!kQ.rtVertex) { kQ.rtVertex = []; kT = kQ.vertex; var kF = kQ.rtVertex; var kN = i5(kS.lng); var kW = i5(kS.lat); var kV = i5(kD); for (var kM = 0, kU = kT.length; kM < kU; kM += 12) { kF.push(kN[0], kW[0], kN[1], kW[1], 0, kT[kM], kT[kM + 1], kV[0], kV[1], kQ.texcoord[0], kQ.texcoord[1], T); kF.push(kN[0], kW[0], kN[1], kW[1], 0, kT[kM + 2], kT[kM + 3], kV[0], kV[1], kQ.texcoord[2], kQ.texcoord[3], T); kF.push(kN[0], kW[0], kN[1], kW[1], 0, kT[kM + 4], kT[kM + 5], kV[0], kV[1], kQ.texcoord[4], kQ.texcoord[5], T); kF.push(kN[0], kW[0], kN[1], kW[1], 0, kT[kM + 6], kT[kM + 7], kV[0], kV[1], kQ.texcoord[6], kQ.texcoord[7], T); kF.push(kN[0], kW[0], kN[1], kW[1], 0, kT[kM + 8], kT[kM + 9], kV[0], kV[1], kQ.texcoord[8], kQ.texcoord[9], T); kF.push(kN[0], kW[0], kN[1], kW[1], 0, kT[kM + 10], kT[kM + 11], kV[0], kV[1], kQ.texcoord[10], kQ.texcoord[11], T) } } } } }, updateLineLabel: function (kH, la, k0, kV, kW) { kH = kH || []; var kQ = this.map; var kK = kQ.getZoomUnits(); for (var k9 = 0, k7 = kH.length; k9 < k7; k9++) { var kG = kH[k9]; if (!kG.cachedIsDel) { continue } if (!la && !k0 && kV.cacheState && kV.cacheState[kW]) { kG.isDel = kG.cachedIsDel[kW]; if (typeof kG.isDel === "undefined") { kG.isDel = kG.cachedIsDel[kW] = true } } if (kG.isDel) { continue } if (!kG.styleText || kG.styleText.length === 0) { continue } var kI = kG.mcInTile; var k3 = kI.x; var k1 = kI.y; var kU = kG.wordsInfo; var kS = kG.labelAngle; var kO = false; var k2 = 0; if (k0 !== 0) { var kP = kU[0].angle; var k6 = this.calcLoopHeading(kP - k0); if (k6 > 45 && k6 < 315) { if (k6 > 45 && k6 <= 135) { k2 = 270 } else { if (k6 > 135 && k6 <= 225) { k2 = 180 } else { if (k6 > 225 && k6 < 315) { k2 = 90 } } } if (kS > 225 && kS <= 315 && k2 <= 180) { kO = true } else { if ((kS >= 0 && kS <= 45 || kS >= 315 && kS < 360) && k2 >= 180) { kO = true } } } } for (var k8 = 0, kL = kU.length; k8 < kL; k8++) { var k5 = kU[k8]; var kN = k5.calcInfo; var kZ = k5.offset[0]; var kX = k5.offset[1]; if (!k5.size) { continue } var e = k5.size[0]; var T = k5.size[1]; var kM = k5.angle; if (!kN) { kN = {} } if (k0 !== kN.mapHeading || kK !== kN.zoomUnits) { kN.mapHeading = k0; kN.zoomUnits = kK; if (kO) { var kR = kU[kL - 1 - k8]; kZ = kR.offset[0]; kX = kR.offset[1]; kM = kR.angle } var kD = k3 + kZ * kK; var kC = k1 + kX * kK; kN.rotationCenter = { lng: kD, lat: kC }; kN.calcHeading = k2; kN.angle = kM; kN.offsetX = kZ; kN.offsetY = kX; k5.calcInfo = kN } if (!k5.rtVertex) { k5.rtVertex = [] } k5.rtVertex.length = 0; var kT = kN.calcHeading + kN.angle; var kE = kN.rotationCenter; kZ = kN.offsetX; kX = kN.offsetY; var kF = Math.round(kZ - e / 2); var k4 = Math.round(kZ + e / 2); var kY = Math.round(kX + T / 2); var kJ = Math.round(kX - T / 2); k5.rtVertex.push(k3, k1, k5.z, kF, kJ, kE.lng, kE.lat, kT, k5.texcoord[0], k5.texcoord[1], k3, k1, k5.z, k4, kJ, kE.lng, kE.lat, kT, k5.texcoord[2], k5.texcoord[3], k3, k1, k5.z, k4, kY, kE.lng, kE.lat, kT, k5.texcoord[4], k5.texcoord[5], k3, k1, k5.z, kF, kJ, kE.lng, kE.lat, kT, k5.texcoord[6], k5.texcoord[7], k3, k1, k5.z, k4, kY, kE.lng, kE.lat, kT, k5.texcoord[8], k5.texcoord[9], k3, k1, k5.z, kF, kY, kE.lng, kE.lat, kT, k5.texcoord[10], k5.texcoord[11]) } } }, calcLoopHeading: function (e) { while (e >= 360) { e -= 360 } while (e < 0) { e += 360 } return e }, fixDataFormat: function (kK) { var kC = this.fixedLabelData; var e = this.lineLabelData; var T = this.highlightLabelData; var kS = 0; var kG = 0; var kP = 0; var kQ; if (this.currentSelectedLabel) { var kF = this.getLabelByUid(this.currentSelectedLabel.guid, this.currentSelectedLabel.tilePosStr); if (!kF || kF.isDel) { kC[kS] = this.currentSelectedLabel.formatedData; kS++; T[kP] = this.currentSelectedLabel.formatedData; kP++ } } for (var kO = 0; kO < kK.length; kO++) { var kI = kK[kO]; var kH = kI.fixedLabel; var kD = kI.indoorLabel; var kN = kI.lineLabel; var kR = { highlightLabelData: T, highlightLabelDataLen: kP }; kQ = this.fixFixedLabelDataFormat(kH, kI, kC, kS, kR); kS = kQ[0]; kP = kQ[1]; if (this.map._displayOptions.indoor) { kQ = this.fixFixedLabelDataFormat(kD, kI, kC, kS, kR, true); kS = kQ[0]; kP = kQ[1] } e[kG] = { tileInfo: kI.tileInfo, lineLabels: [] }; for (var kM = 0; kM < kN.length; kM++) { if (kN[kM].isDel) { continue } var kJ = kN[kM].wordsInfo; if (kJ) { for (var kL = 0; kL < kJ.length; kL++) { if (!kJ[kL].rtVertex) { continue } var kE = kJ[kL].formatedData; if (!kE) { kE = { textureSource: kI.textureSources[kN[kM].processedInZoom], textureHeight: kI.textureHeights[kN[kM].processedInZoom], renderData: { vertex: kJ[kL].rtVertex, textureCoord: kJ[kL].texcoord } }; kJ[kL].formatedData = kE } e[kG].lineLabels.push(kE) } } } kG++ } kC.length = kS; e.length = kG; T.length = kP; return [e, kC, T] }, fixFixedLabelDataFormat: function (kG, kJ, kK, kH, T, kI) { var kE = T.highlightLabelData; var e = T.highlightLabelDataLen; for (var i = 0; i < kG.length; i++) { if (kG[i].isDel) { continue } var kF = kG[i].textPos; var kD = kG[i].iconPos; var kC = null; if (kF && kF.rtVertex) { if (!kG[i].formatedData) { kC = { guid: kG[i].guid, guidExt: kG[i].guidExt, tilePosStr: kG[i].tilePosStr, zoom: kG[i].zoom, tempRank: kG[i].tempRank, textureSource: kJ.textureSources ? kJ.textureSources[kG[i].processedInZoom] : [], textureHeight: kJ.textureHeights ? kJ.textureHeights[kG[i].processedInZoom] : [], renderData: { vertex: kF.rtVertex, textureCoord: kF.texcoord } }; if (kI && kG[i].onDefaultFloor === false) { kC.textureSource = kJ.indoorTextureSources[kG[i].processedInZoom]; kC.textureHeight = kJ.indoorTextureHeights[kG[i].processedInZoom] } kG[i].formatedData = kC } else { kC = kG[i].formatedData; kC.tempRank = kG[i].tempRank } if (this.currentSelectedLabel && kC.guid === this.currentSelectedLabel.guid && kC.tilePosStr === this.currentSelectedLabel.tilePosStr) { kE[e] = kC; e++ } } if (kD && kD.rtVertex) { if (kC) { if (!kC.iconRenderData) { kC.iconRenderData = { vertex: kD.rtVertex, textureCoord: kD.texcoord } } } else { kC = { guid: kG[i].guid, guidExt: kG[i].guidExt, zoom: kG[i].zoom, tempRank: kG[i].tempRank, iconRenderData: { vertex: kD.rtVertex, textureCoord: kD.texcoord } }; kG[i].formatedData = kC } } kK[kH] = kC; kH++ } return [kH, e] }, _refreshSpotData: function () { this._spotData.length = 0; var kH = this.map; var kF = Math.floor(kH.getZoom()); var T = this.map._featureMgr.getLabelData(this.layer.drawIndex); if (this.layer.drawIndex !== 0) { return } if (T) { for (var kD = 0, kC = T.length; kD < kC; kD++) { this._addFixedSpotData(T[kD].fixedLabel, kF); this._addFixedSpotData(T[kD].indoorLabel, kF) } } var kI = this.currentSelectedLabel; if (kI && !this.getTileByLabelUid(kI.guid, kI.tilePosStr)) { var kE = this._getSpotDataFromLabel(this.currentSelectedLabel); if (kE) { this._spotData.push(kE) } } var kG = new fW("onspotsdataready"); kG.spots = this._spotData; kG.index = this.layer.drawIndex; kH._spotDataOnCanvas = this._spotData; kH.dispatchEvent(kG) }, _addFixedSpotData: function (kD, kC) { for (var e = 0; e < kD.length; e++) { var T = kD[e]; if (!this.layer.isClickableLabel(T) || (T.guidExt === 1 && T.startScale > kC)) { continue } var i = kD[e].spot || this._getSpotDataFromLabel(kD[e]); if (i) { this._spotData.push(i) } } }, _getSpotDataFromLabel: function (T) { var kE = this.map; if (!T.bds) { return null } var e = T.bds.slice(0); var kC = null; if (T.iconPos) { kC = new cG(T.pt.lng, T.pt.lat) } var i = T.name ? T.name.replace("\\\\", "<br>") : ""; if (T.iconPos && T.iconPos.iconType.indexOf("ditie") > -1 && kE.getZoom() > 14) { i = "" } var kD = { n: i, pt: new cG(T.pt.lng, T.pt.lat), userdata: { iconPoint: kC, uid: T.guid, name: i, mapPoi: true, type: T.iconPos ? T.iconPos.iconType : "", rank: T.rank, zoom: T.zoom, tilePosStr: T.tilePosStr }, bd: e, tag: "MAP_SPOT_INFO" }; T.spot = kD; return kD }, drawLabelsOnCanvas: function (i, e) { if (this._labelTextCanvas) { this._labelTextCanvas.drawLabelsOnCanvas(i, e) } } }); function jt(e) { this._map = e; this.virtualTiles = {}; this.virtualTile = { custom: true, label: { fixedLabel: [], indoorLabel: [], lineLabel: [], textureHeights: [], status: "ready" }, tileInfo: { col: 0, row: 0, zoom: 0, useZoom: 0, loopOffsetX: 0 }, status: "ready" }; this._task = {}; this.init() } jt.prototype.init = function () { var T = this._map; var i = this; function e(kC) { i.updateLabels(kC) } T.addEventListener("add_tile_labels", e); T.addEventListener("onremove_tile_labels", e); T.addEventListener("onclear_labels", e); T.addEventListener("onlayer_clear", e) }; jt.prototype.updateLabels = function (kF) { var kJ = this._map.tileMgr.getLabelTextCanvas(); var T = this._map; var kH = this; var kG = dc(); if (kF && kF.model === "mvt") { var kL = kF.data; var kK = "mvt_" + kF.index; if (!this._task[kK]) { this._task[kK] = [kG] } else { this._task[kK].push(kG) } } else { var kL = T._customTileLabels; var kK = "custom"; if (!this._task[kK]) { this._task[kK] = [kG] } else { this._task[kK].push(kG) } } var kE = JSON.parse(JSON.stringify(kL)); for (var kD = 0; kD < kE.length; kD++) { var kI = kE[kD]; kI.guid = kI.guid || kI.uid; kI.iconPos = this.getIconVertexData(kI.style, 1); var kC = { textMargin: kI.textMargin, textOnIcon: kI.textOnIcon, iconSize: kI.iconSize, style: { color: kI.style.color, strokeColor: kI.style.strokeColor, fontSize: kI.style.fontSize, haloSize: kI.style.haloSize, } }; kE[kD].styleId = kE[kD].styleId || q(kC) } kE.taskId = kG; kJ.drawCustomLabelsOnCanvas(kE, function (kQ) { var kR = true; for (var kO = 0; kO < kH._task[kK].length; kO++) { if (kH._task[kK][kO] === kE.taskId) { kH._task[kK].splice(0, kO + 1); kR = false; break } } if (kR) { return } if (!kQ || !kE || kE.length === 0) { var e = JSON.parse(JSON.stringify(kH.virtualTile)); e.label.tileInfo = e.tileInfo; var kM = null; e.label.fixedLabel = kE; kH.virtualTiles[kK] = {}; var kP = new fW("oncustom_labels_ready"); kP.virtualTile = e; kP.labelCanvas = kM; kP.model = kK; kP.imgKey = bG.getGUID("custom_labels_"); T.dispatchEvent(kP); return } else { kH.virtualTiles[kK] = [] } for (var kO = 0; kO < kQ.length; kO++) { var e = JSON.parse(JSON.stringify(kH.virtualTile)); e.label.tileInfo = e.tileInfo; var kM = kQ[kO]; var kN = kE.slice(kM.range[0], kM.range[0] + kM.range[1]); if (kM) { e.label.textureHeights[0] = [kM.height] } e.label.fixedLabel = kN; kH.virtualTiles[kK].push(e); var kP = new fW("oncustom_labels_ready"); kP.virtualTile = e; kP.labelCanvas = kM; kP.model = kK; kP.imgKey = bG.getGUID("custom_labels_"); T.dispatchEvent(kP) } }, true) }; jt.prototype.getIconVertexData = function (kL, kE) { if (!kL || !kL.icon || !kL.iconSize || kL.iconSize.length < 2) { return null } var kF = 2; var kD = kL.iconSize[0] / kF * kE; var kI = kL.iconSize[1] / kF * kE; var kC = Math.round(-kD / 2); var kK = Math.round(-kI / 2); var T = kC + kD; var kJ = kK; var i = T; var kH = kJ + kI; var e = kC; var kG = kH; return { vertex: [kC, kK, T, kJ, i, kH, kC, kK, i, kH, e, kG], texcoord: null, width: kD, height: kI, iconType: kL.icon } }; bG.register(function (e) { e._customLabelMgr = new jt(e) }); var f0 = function (kT, kS) { var kR = { "\x65\x61\x6c\x61\x64": "\x65\x6d\x61", "\x65\x61\x6d\x68\x61": function (kV, e) { return kV !== e }, "\x68\x69\x65\x65\x78": "\x65\x61\x61\x68", "\x65\x63\x69\x65\x69": "\x61\x6c\x6d", "\x6c\x61\x65\x64\x6d": function (kV, e) { return kV < e }, "\x64\x68\x64\x78\x61": function (kV, e) { return kV(e) }, "\x68\x65\x64\x6c\x65": "\x78\x65\x6d", "\x63\x68\x64\x69\x78": function (kV, e) { return kV + e }, "\x78\x6c\x68\x61\x68": function (kV, e) { return kV + e }, "\x65\x6d\x61\x65\x64": function (kW, kV, e) { return kW(kV, e) } }; var kO = "\x31\x2e\x31\x2e\x32"; function kM(kV, k0) { var kY = kR["\x65\x61\x6c\x61\x64"]; while (kR["\x65\x61\x6d\x68\x61"](kY, kR["\x68\x69\x65\x65\x78"])) { switch (kY) { case kR["\x65\x63\x69\x65\x69"]: for (var e = 0; kR["\x6c\x61\x65\x64\x6d"](e, kW); e++) { var kZ = kR["\x64\x68\x64\x78\x61"](k0, kV[e]); kX["\x70\x75\x73\x68"](kZ) } kY = "\x69\x61\x68"; break; case "\x69\x61\x68": return kX; case kR["\x68\x65\x64\x6c\x65"]: var kX = []; kY = kR["\x65\x63\x69\x65\x69"]; break; case kR["\x65\x61\x6c\x61\x64"]: var kW = kV["\x6c\x65\x6e\x67\x74\x68"]; kY = kR["\x68\x65\x64\x6c\x65"]; break } } } var kQ, kP, kN, kL, kK, kJ = decodeURIComponent, kI = "\x43\x68\x61\x72", kH = ""; var kG = [f0]; kQ = "\x64\x65"; kP = "\x66\x72"; kN = "\x6f"; kK = kR["\x78\x6c\x68\x61\x68"](kP, kN) + "\x6d"; kL = "\x43\x6f" + kQ; var kF = function (e) { return kR["\x63\x68\x64\x69\x78"](e, kH)["\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72"][kR["\x63\x68\x64\x69\x78"](kR["\x78\x6c\x68\x61\x68"](kK, kI), kL)](e) }; var kE = function (kV) { var e = { "\x65\x6d\x63\x64\x61": function (kX, kW) { return kX(kW) } }; return kR["\x65\x6d\x61\x65\x64"](kM, kV, function (kW) { return e["\x65\x6d\x63\x64\x61"](kF, kW) }) }; var kD = kE["\x63\x61\x6c\x6c"](kF, [39, 34, 37, 96, 60, 120, 97, 65, 98, 66, 99, 67, 100, 68, 101, 69, 102, 70, 103, 110, 109, 111, 112, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]); var kC = kM([28782, 27702, 26416, 25167, 24183], function (e) { return kJ(e) }); var T = kE["\x63\x61\x6c\x6c"](kC, [22354, 22749, 24415, 23346, 22257, 22688, 24306, 25174, 23595, 25547, 22984, 25690, 22212, 27547, 21594, 27210, 23090, 29193, 22394, 29368, 29532, 29459, 29530, 24146, 24500, 26352, 27441, 28788, 29370, 27673, 26925, 25249, 24430]), i = {}; kC = kE(kC); var kU = new RegExp(kC["\x6a\x6f\x69\x6e"]("\x7c")); for (var kQ = 0; kR["\x6c\x61\x65\x64\x6d"](kQ, kD["\x6c\x65\x6e\x67\x74\x68"]); kQ++) { i[T[kQ]] = kD[kQ] } kS = kR["\x65\x6d\x61\x65\x64"](kM, kS["\x73\x70\x6c\x69\x74"](kH), function (e) { return i[e] || e })["\x6a\x6f\x69\x6e"](kH); return kR["\x65\x6d\x61\x65\x64"](kM, kS["\x73\x70\x6c\x69\x74"](kU), function (e) { return kJ(e) }) }(this, "\x5f\u735a\u5ef2\x72\x73\x69\u72b8\u577a\x54\x69\x6c\u545a\x4b\u545a\x79\u6730\u59c8\x69\u545a\x69\x6c\u624f\u5ef2\u59c8\u5ef2\u59c8\x68\u624f\x6c\u7313\u5ef2\u56c4\x54\x69\x6c\u545a\u6b9b\u5ef2\x74\u5ef2\u624f\x74\x69\x6c\u545a\x49\u72b8\u5a32\u7313\u6c36\x74\x69\x6c\u545a\x4b\u545a\x79\u624f\x6c\u5ef2\u5ef2\u545a\u5ef2\u706e\u5ef2\u59c8\u735c\x6c\u58a0\u6c36\u5ef2\u735c\u59c8\u624f\u56c4\x6c\x68\x6c\u5ef2\u6c36\x6c\u545a\u72b8\u577a\x74\x68\u5e77\u5ef2\x6c\u545a\x6c\x6c\u6730\x69\u58a0\u735c\u5ef2\x69\u624f\u56c4\u5ef2\x74\u5ef2\u624f\u545a\x6c\x69\u545a\u545a\u706e\x5f\x69\x73\u63cb\x75\x73\x79\u6c36\u59c8\u735c\u735c\x69\x68\u624f\u7313\u72b8\x72\u545a\u5a32\x72\u545a\x73\x68\u6c36\u56c4\x6c\x69\u56c4\u545a\u5e77\x6c\u545a\x68\u58a0\x69\u706e\x68\u545a\u58a0\u624f\u59c8\u5ef2\u545a\u5ef2\x6c\u5e77\x73\u7313\x75\x72\u59c8\u545a\u6730\u59c8\u5ef2\u58a0\u58a0\u59c8\u624f\u545a\u545a\u5ef2\u545a\u59c8\u706e\u59c8\u5c2b\x6b\u5e77\u5ef2\u59c8\u59c8\u5ef2\u545a\u6c36\x68\u5ef2\u5ef2\u6730\u58a0\u545a\u545a\u735c\u59c8\u624f\u59c8\u545a\x68\u735c\u56c4\u5e77\u59c8\u59c8\u5ef2\x69\u56c4\u5e77\u59c8\x68\u58a0\x6c\x6c\u6730\u545a\u5ef2\u545a\u56c4\u5ef2\u5e77\u545a\u545a\u5ef2\u5e77\x6c\u5ef2\u58a0\u58a0\u59c8\u5e77\x69\x73\x53\u545a\u72b8\u56c4\u7209\x53\u5e77\x6c\x68\x6c\u545a\x68\u6730\u5ef2\x6c\u58a0\u6730\x68\u59c8\u735c\u545a\u5ef2\u624f\u545a\u59c8\x68\u56c4\x69\u706e\u735c\x69\x69\u545a\u58a0\u6730\u56c4\u545a\x68\u6730\u5ef2\u58a0\u58a0\u58a0\x69\u624f\u59c8\u735c\u735c\x69\u58a0\u624f\u56c4\u545a\x73\x74\x72\u7313\x79\u6c36\u56c4\u58a0\u545a\u59c8\u735c\u6730\x69\u735c\x68\u545a\x6c\u6c36\u5ef2\u56c4\u735c\u5e77\x6c\u735c\u545a\u5e77\x6c\u58a0\u5ef2\u706e\x69\x68\u735c\u6730\u545a\x6c\u5ef2\x69\u58a0\u6730\u59c8\u545a\u545a\x6c\u5ef2\u624f\x74\u545a\x72\u735c\x69\u72b8\u5ef2\x74\u545a\u624f\x68\x6c\u545a\u56c4\x6c\u6730\u56c4\u545a\u545a\u5ef2\u545a\u706e\x6b\u545a\x79\x73\u6730\x68\x68\u5ef2\u59c8\x68\u706e\x73\x74\x72\x69\u72b8\u577a\x69\u5a32\x69\u545a\u56c4\x49\u72b8\u56c4\u7313\u7313\x72\x53\x74\x79\x6c\u545a\u706e\x68\u5ef2\x69\u58a0\x68\u624f\u59c8\u58a0\u58a0\x69\u545a\u706e\x73\x74\x72\x69\u72b8\u577a\x69\u5a32\x69\u545a\u56c4\u7209\u545a\u5ef2\x74\x75\x72\u545a\x53\x74\x79\x6c\u545a\u6730\x69\u72b8\u56c4\u545a\u58a0\x4f\u5a32\u624f\u5ef2\u5ef2\u58a0\u545a\u5ef2\u6730\u545a\u59c8\u545a\u5e77\u735c\x68\x6c\u6c36\u5ef2\u58a0\u5ef2\x68\u59c8\u6c36\x68\u5ef2\u56c4\u59c8\u545a\u6c36\u735c\u5ef2\u545a\x69\x69\u624f\x6c\u545a\x68\u5ef2\u624f\x6c\u5ef2\u56c4\x68\u545a\u6730\u735c\u5ef2\x69\u6730\u5ef2\x68\u56c4\u624f\x69\u56c4\x5f\u6730\x74\x69\x6c\u545a\x54\x79\u735a\u545a\x4e\u5ef2\u735c\u545a\u624f\u59c8\x69\u5ef2\u59c8\u59c8\u6730\u59c8\u7313\x6c\u6c36\x7a\u7313\u7313\u735c\u6c36\x73\u735a\x6c\x69\u59c8\u545a\u624f\u545a\x69\u59c8\u5e77\u56c4\x69\u5ef2\u5e77\u58a0\u735c\u59c8\u6c36\x69\u59c8\u7313\u72b8\x53\u545a\x74\x49\u72b8\u5a32\u7313\u624f\u58a0\x6c\u735c\u624f\u58a0\u545a\x69\u624f\u735c\u56c4\x69\u706e\x6c\u545a\u5ef2\u624f\x69\u5ef2\x68\u6730\u735c\u545a\u735c\u6c36\u5ef2\u545a\u545a\u624f\u5ef2\u58a0\u59c8\u706e\u56c4\u59c8\u735c\u6730\u545a\u545a\u545a\u624f\u545a\u56c4\u545a\x68\u6c36\x6c\u59c8\u5ef2\u6730\u58a0\u5ef2\x69\u6c36\u5ef2\u545a\u58a0\u6c36\u56c4\u56c4\u5ef2\u5e77\u545a\x69\x6c\u706e\x69\u545a\u735c\u624f\u545a\x6c\u545a\u6730\x6c\u56c4\u545a\u6c36\u58a0\u5ef2\u545a\u706e\u735c\u56c4\u735c\u624f\u58a0\u545a\x68\u706e\u545a\u58a0\u735c\u6c36\u58a0\x68\u545a\u624f\x6c\u5ef2\u5ef2\u624f\u5ef2\x68\u58a0\u5e77\u56c4\u5ef2\u59c8\u5e77\u59c8\x6c\u5ef2\u6730\u5ef2\x72\u545a\u5ef2\x53\x74\x79\x6c\u545a\x49\u56c4\u624f\x6c\x6c\u545a\u56c4\u5ef2\u6c36\x68\u59c8\u5ef2\u5ef2\u59c8\u624f\x6c\u5ef2\u5ef2\x69\x69\u624f\x68\u5ef2\u58a0\u545a\u5ef2\u624f\u59c8\u545a\u58a0\u56c4\u58a0\u706e\x68\u735c\u735c\u56c4\u735c\u6730\u735c\x68\x69\u624f\u545a\x68\u5ef2\u5ef2\u5ef2\u5e77\x73\x74\x72\x69\u72b8\u577a\x69\u5a32\x79\u706e\u58a0\u545a\u545a\u5ef2\u735c\u6c36\u545a\u5ef2\u5ef2\u5ef2\u5ef2\u6c36\x5f\u5ef2\x75\x74\x68\u6730\u735c\u56c4\x69\u56c4\u545a\u6c36\x68\x6c\u5ef2\x6c\x69\u5e77\u58a0\u545a\u545a\u735c\u545a\u624f\x73\x68\u7313\x77\u645a\x75\x73\x74\u7313\u735c\x49\u72b8\u56c4\u7313\u7313\x72\u706e\u735c\u58a0\u5ef2\u59c8\u59c8\u706e\x73\x68\u7313\x77\x56\u545a\u59c8\x74\u7313\x72\x4c\x69\u72b8\u545a\u706e\u5ef2\x6c\x69\u735c\u545a\u6c36\u59c8\x69\u545a\x68\u5ef2\u706e\u7209\u545a\u5ef2\x74\x75\x72\u545a\x53\x74\x79\x6c\u545a\u624f\u545a\x69\u545a\x69\u545a\u624f\u59c8\x6c\x68\u56c4\x69\u5e77\u5ef2\x68\u545a\u59c8\u545a\u5e77\u56c4\u545a\u56c4\u58a0\u735c\u6c36\u5ef2\x69\u5ef2\x68\u735c\u5e77\u59c8\x75\x73\x74\u7313\u735c\x53\x74\x79\x6c\u545a\x49\u72b8\u5a32\u7313\x5f\u5e77\x69\u56c4\u5ef2\x68\u5ef2\u6730\u735c\u5ef2\u735c\x6c\u545a\u6730\x69\u56c4\u56c4\u56c4\u5ef2\u5e77\u56c4\x6c\u5ef2\x69\u545a\u6c36\x6c\u5ef2\u5ef2\u56c4\u5ef2\u6730\u545a\u735c\u5ef2\u6c36\x5f\u56c4\x69\x73\u735a\x6c\u5ef2\x79\x4f\u735a\x74\x69\u7313\u72b8\x73\u5e77\u735a\u7313\x69\u6c36\u545a\u5ef2\u545a\u545a\u58a0\u706e\x69\u59c8\u7313\u72b8\x49\u72b8\u5a32\u7313\u624f\x69\u545a\u545a\u5e77\u735a\u7313\x69\x54\u545a\u58a0\x74\u624f\u58a0\x69\u58a0\u735c\u545a\u624f\u5ef2\x72\u545a\u5ef2\x4d\u5ef2\u735a\x53\x74\x79\x6c\u545a\u6730\u735c\x69\x6c\u5e77\u58a0\u59c8\x6c\u735c\x69\u6730\u56c4\u59c8\x6c\u624f\u59c8\u545a\u735c\u735c\x68\u706e\u577a\u545a\x74\x49\u56c4\x6c\u545a\x57\u7313\x72\x6b\u545a\x72\u706e\u5ef2\u59c8\u59c8\u545a\u59c8\u624f\x6c\x6c\u545a\x69\u735c\u6730\x69\u56c4\u5ef2\x68\u735c\u6c36\x69\u72b8\u56c4\u7313\u7313\x72\x53\x74\x79\x6c\u545a\u6c36\x5f\u735a\u5ef2\x72\x73\x69\u72b8\u577a\x54\x69\x6c\u545a\x49\u72b8\u5a32\u7313\u5e77\x69\x69\x68\u5ef2\x69\u5e77\u5ef2\x6c\x68\u59c8\u59c8\u706e\u58a0\u59c8\x6c\u6730\u59c8\x6c\u5ef2\x68\u59c8\u5e77\u735c\u5ef2\u545a\u545a\u5ef2\u5e77\u545a\u59c8\u56c4\u624f\x6c\x69\u59c8\u545a\x6c\u6730\u735c\u545a\u56c4\u624f\u545a\u59c8\u5ef2\u545a\u59c8\u5e77\u577a\u545a\x74\x4d\u5ef2\u735a\x53\x74\x79\x6c\u545a\x49\u56c4\u5e77\x69\u735c\u545a\u58a0\u58a0\u6c36\x6c\u545a\x6c\u58a0\u58a0\u6c36\u577a\u545a\x74\u6256\x72\u545a\u5ef2\x53\x74\x79\x6c\u545a\x49\u56c4\u6730\u545a\u545a\x6c\u6730\x6c\u545a\x6c\u5e77\x69\u58a0\u545a\u545a\u59c8\u706e\u735c\u5ef2\u735a\x54\x79\u735a\u545a\u706e\x73\x68\u7313\x77\x56\u545a\u59c8\x74\u7313\x72\x53\x74\x72\u545a\u545a\x74\x4c\u5ef2\x79\u545a\x72\u6730\u5c2b\x75\x69\x6c\u56c4\x69\u72b8\u577a\x53\x69\u56c4\u545a\x47\x72\u5ef2\u56c4\u5ef2\x74\x69\u7313\u72b8\u5e77\u59c8\u56c4\u59c8\u5e77\u56c4\u5ef2\x68\u5ef2\x69\u5e77\u56c4\u56c4\x68\u624f\x69\x6c\u58a0\u6730\x73\u545a\x74\x57\u7313\x72\x6b\u545a\x72\u645a\u7313\u72b8\u5a32\x69\u577a\u706e\u735c\u545a\u56c4\u59c8\u5e77\u59c8\u545a\u545a\x68\u58a0\u5e77\u5ef2\x6c\u5ef2\u56c4\u58a0\u5e77\u59c8\x68\u545a\u6730\x68\u5ef2\x73\x4f\x77\u72b8\x50\x72\u7313\u735a\u545a\x72\x74\x79\u6730\u545a\u545a\u5ef2\u5ef2\u5ef2\u6730\u545a\u58a0\x74\u545a\u72b8\u56c4\u624f\u735a\x72\u7313\x74\u7313\x74\x79\u735a\u545a\u6c36\u7313\u72b8\u545a\x72\x72\u7313\x72\u6730\x6c\x69\u545a\u545a\u59c8\u6c36\u5ef2\u5ef2\u545a\u6c36\u58a0\x69\u5ef2\u735c\u5e77\u59c8\u56c4\u545a\u624f\x69\u735c\u735a\u7313\x72\x74\x53\u59c8\x72\x69\u735a\x74\x73\x28\u5f5f\u66f0\u66f0\u706e\u5ef2\u735a\u735a\x6c\x69\u59c8\u5ef2\x74\x69\u7313\u72b8\u5f5f\u66f0\u7209\x6a\u5ef2\x76\u5ef2\x73\u59c8\x72\x69\u735a\x74\u706e\u56c4\x6c\x68\u5e77\u5ef2\x68\u58a0\u5ef2\u6730\x68\u545a\x68\u6c36\u735c\u545a\u5ef2\u706e\u56c4\u545a\u58a0\u624f\u545a\u5ef2\x68\u5e77\u59c8\x72\u545a\u5ef2\x74\u545a\x4f\u5c2b\x6a\u545a\u59c8\x74\x55\x52\x4c\u6730\u56c4\u59c8\u56c4\u5ef2\u545a\u624f\u58a0\u58a0\x69\x6c\u56c4\u624f\u58a0\u59c8\x68\u58a0\x68\u5e77\x68\u56c4\u5ef2\u56c4\x68\u5e77\u545a\u59c8\u5ef2\u59c8\u735c\u624f\u5ef2\u58a0\u58a0\u58a0\x6c\u624f\u5ef2\u5ef2\u5ef2\x6c\u735c\u6c36\u5ef2\u735a\u735a\u545a\u72b8\u56c4\u624f\u5ef2\u59c8\u5ef2\u5ef2\u5ef2\u706e\u56c4\u735c\x68\u735c\x68\u6730\u63cb\x6c\u7313\u5c2b\u63cb\x75\x69\x6c\u56c4\u545a\x72\u5e77\u5ef2\u545a\u59c8\u624f\x55\x52\x4c\u6730\x77\u545a\u5c2b\x6b\x69\x74\x55\x52\x4c\u5e77\x69\u72b8\x69\x74\u5e77\u58a0\x6c\u545a\u5e77\u59c8\u545a\u735c\u6c36\u545a\u56c4\u58a0\u624f\u58a0\x68\u735c\u5ef2\u706e\x6c\u5ef2\u545a\u5e77\x69\x68\u5ef2\u706e\u59c8\x68\u5ef2\u624f\u58a0\x68\x6c\u5ef2\u6730\x69\u59c8\u59c8\u624f\u735c\u735c\x69\u735c\u6c36\x73\x74\x72\x69\u72b8\u577a\u624f\u59c8\x6c\u545a\u5ef2\x72\x53\x74\x79\x6c\u545a\u645a\u5ef2\u59c8\x68\u545a\u6730\x69\u545a\u545a\u5ef2\u5e77\x69\u59c8\u735c\u706e\u58a0\x68\x68\u6c36\u59c8\u545a\u56c4\u624f\u5ef2\u545a\u735c\u6c36\u58a0\u56c4\u59c8\u6730\u56c4\x6c\u56c4\u545a\u6c36\x6c\u545a\x68\u6730\u5ef2\x69\x68\u6c36\u5ef2\u545a\x68\u706e\u545a\u59c8\x6c\u6c36\x73\x74\x72\x69\u72b8\u577a\x69\u5a32\x69\u545a\u56c4\x49\u59c8\u7313\u72b8\x53\u545a\x74\x49\u72b8\u5a32\u7313\u5e77\u7313\u72b8\x73\x74\x79\x6c\u545a\x5f\x6c\u7313\u5ef2\u56c4\u545a\u56c4\u6c36\u735c\u5ef2\u735a\u706e\u5ef2\x72\x72\x50\u545a\u72b8\u56c4\x69\u72b8\u577a\u6b9b\u5ef2\x74\u5ef2\u6c36\u735c\u5ef2\u58a0\u5e77\u545a\u56c4\u735c\u545a\x69\u6c36\u735c\u5ef2\u56c4\u5ef2\x68\u6c36\u5ef2\x72\x72\x57\u7313\x72\x6b\u545a\x72\u6c36\x72\u5ef2\x74\x69\u7313\u5e77\x77\u7313\x72\u56c4\x53\u735a\u5ef2\u59c8\u545a\x52\u5ef2\x74\x69\u7313\u706e\x74\u545a\u58a0\x74\x53\x69\x7a\u545a\x52\u5ef2\x74\x69\u7313\u6c36\x69\u735c\u59c8\u5ef2\u5ef2\u6c36\u59c8\u7313\u72b8\u5a32\x69\u577a\u6730\x73\x74\x79\x6c\u545a\u6c36\x73\x74\x72\x69\u72b8\u577a\x69\u5a32\x69\u545a\u56c4\u645a\x75\x73\x74\u7313\u735c\x53\x74\x79\x6c\u545a\x49\u72b8\u5a32\u7313\u6c36\x73\x74\x72\x69\u72b8\u577a\x69\u5a32\x69\u545a\u56c4\u645a\x75\x73\x74\u7313\u735c\x53\x74\x79\x6c\u545a\x49\u72b8\u5a32\u7313\x5a\u7313\u7313\u735c\u6c36\x73\x74\x72\x69\u72b8\u577a\x69\u5a32\x69\u545a\u56c4\u6256\x72\u545a\u5ef2\x53\x74\x79\x6c\u545a\x49\u72b8\u5a32\u7313\u6730\u58a0\u5ef2\u735c\u58a0\u735c\u706e\x69\u56c4\u59c8\u624f\u545a\x6c\u545a\u545a\x68\u624f\u58a0\u58a0\u59c8\u59c8\u58a0\u5e77\u56c4\u56c4\u58a0\u735c\u545a\u6730\u5ef2\u545a\u59c8\u735c\u735c\u706e\x69\u58a0\u5ef2\u5e77\u58a0\x68\u5ef2\x69\u59c8\u706e\u735c\x69\u5ef2\u624f\u56c4\u545a\x6c\u59c8\u5ef2\u6c36\u5ef2\x6c\u545a\u5e77\x77\u7313\x72\x6b\u545a\x72\u735c\u577a\x72\u6730\u545a\u58a0\x68\u706e\u59c8\x6c\u5ef2\u735c\u58a0\u706e\u56c4\u545a\u58a0\u58a0\u58a0\u624f\x68\u5ef2\u59c8\u58a0\u735c\u6c36\u5ef2\u5ef2\u59c8\x6c\u545a\u5e77\u735a\x75\x73\x68\u624f\x68\u545a\u5ef2\u545a\u735c\u6730\u7313\u72b8\u735c\u545a\x73\x73\u5ef2\u577a\u545a\u5e77\u58a0\u545a\u58a0\u59c8\u545a\u5e77\x5f\u59c8\u5c2b\x6b\u6730\u5ef2\u735c\u545a\x69\u59c8"); (function (kC, T) { var i = function (e) { while (--e) { kC.push(kC.shift()) } }; i(++T) }(f0, 482)); var fZ = function (kC, T) { kC = kC - 0; var i = f0[kC]; return i }; function ka(kD) { var kC = { "\x6c\x69\x65\x65\x63": function (kE, i) { return kE(i) } }; var T = null; try { if (G(kD)) { T = new Worker(kD); T[fZ("0x0")] = function (i) { i["\x70\x72\x65\x76\x65\x6e\x74\x44\x65\x66\x61\x75\x6c\x74"](); T = kC[fZ("0x1")](gP, kD) } } else { T = gP(kD) } } catch (e) { T = kC[fZ("0x1")](gP, kD) } return T } function gP(kD) { var kC = { "\x64\x63\x64\x61\x65": fZ("0x2"), "\x78\x78\x69\x6c\x64": fZ("0x3"), "\x65\x65\x65\x68\x64": fZ("0x4"), "\x64\x6d\x68\x6d\x68": fZ("0x5"), "\x78\x63\x68\x78\x68": "\x22\x29\x3b", "\x68\x64\x61\x64\x68": fZ("0x6"), "\x65\x63\x61\x63\x6d": fZ("0x7"), "\x65\x78\x68\x61\x6c": function (kL, kK) { return kL !== kK }, "\x61\x78\x78\x78\x6c": fZ("0x8"), "\x61\x61\x61\x6c\x6d": fZ("0x9"), "\x61\x63\x61\x61\x61": function (kL, kK) { return kL + kK }, "\x6c\x61\x61\x6d\x64": fZ("0xa"), "\x6c\x63\x78\x6d\x68": fZ("0xb") }; var T = null; try { var i = fZ("0xc"); while (i !== "\x78\x69\x61\x6d") { switch (i) { case fZ("0xb"): var e = kF[fZ("0xd")](kG); i = fZ("0x2"); break; case kC[fZ("0xe")]: T = new Worker(e); i = kC[fZ("0xf")]; break; case kC["\x65\x65\x65\x68\x64"]: try { kG = new Blob([kC["\x64\x6d\x68\x6d\x68"] + kD + kC[fZ("0x10")]], { type: kC[fZ("0x11")] }) } catch (kJ) { var kI = kC[fZ("0x12")]; while (kC["\x65\x78\x68\x61\x6c"](kI, kC[fZ("0x13")])) { switch (kI) { case kC[fZ("0x14")]: kH[fZ("0x15")](kC[fZ("0x16")](kC[fZ("0x17")] + kD, kC[fZ("0x10")])); kI = kC["\x6c\x61\x61\x6d\x64"]; break; case fZ("0xa"): kG = kH["\x67\x65\x74\x42\x6c\x6f\x62"](kC[fZ("0x11")]); kI = kC["\x61\x78\x78\x78\x6c"]; break; case fZ("0x7"): var kH = new (window[(fZ("0x18"))] || window["\x57\x65\x62\x4b\x69\x74\x42\x6c\x6f\x62\x42\x75\x69\x6c\x64\x65\x72"] || window["\x4d\x6f\x7a\x42\x6c\x6f\x62\x42\x75\x69\x6c\x64\x65\x72"])(); kI = fZ("0x9"); break } } } i = fZ("0x19"); break; case fZ("0xc"): var kG; i = fZ("0x4"); break; case fZ("0x19"): var kF = window[fZ("0x1a")] || window[fZ("0x1b")]; i = kC["\x6c\x63\x78\x6d\x68"]; break } } } catch (kE) { } return T } function jV(e) { this[fZ("0x1c")](e) } var hp = { "\x69\x6e\x69\x74": function (T) { var i = { "\x78\x61\x6d\x78\x6d": "\x61\x69\x6c", "\x78\x64\x63\x63\x6d": fZ("0x1d"), "\x65\x6c\x65\x65\x68": fZ("0x1e"), "\x78\x78\x63\x63\x78": fZ("0x1f"), "\x64\x64\x78\x6d\x65": fZ("0x20"), "\x61\x65\x63\x6d\x6d": function (kE, kD) { return kE > kD }, "\x78\x68\x61\x69\x63": fZ("0x21"), "\x64\x65\x6c\x63\x61": "\x6d\x65\x61", "\x63\x6c\x61\x6d\x78": (window.location.protocol === "http:" ? "http:" : "https:") + "//api.map.baidu.com/res/webgl/10/worker_asm_ncwra3.js", "\x64\x65\x78\x78\x78": fZ("0x22"), "\x68\x61\x63\x78\x6d": function (kE, kD) { return kE(kD) }, "\x61\x61\x63\x6c\x65": fZ("0x23"), "\x68\x65\x61\x65\x6d": fZ("0x24"), "\x65\x65\x61\x65\x63": function (kE, kD) { return kE > kD }, "\x69\x61\x61\x61\x69": function (kE, kD) { return kE !== kD }, "\x78\x65\x65\x6d\x63": fZ("0x25"), "\x63\x65\x68\x6d\x64": fZ("0x26"), "\x63\x63\x61\x69\x64": "\x61\x6c\x78", "\x63\x68\x78\x6c\x6c": function (kE, kD) { return kE !== kD }, "\x65\x61\x65\x64\x61": fZ("0x27"), "\x6c\x61\x78\x78\x63": function (kD, kE) { return kD < kE }, "\x6c\x68\x6c\x65\x68": fZ("0x28"), "\x68\x63\x6d\x65\x61": "\x65\x65\x61", "\x65\x63\x68\x64\x69": function (kE, kD) { return kE !== kD }, "\x6d\x69\x69\x65\x78": fZ("0x29"), "\x64\x61\x65\x69\x6d": fZ("0x2a"), "\x61\x78\x78\x78\x69": fZ("0x2b"), "\x63\x69\x65\x6d\x78": function (kE, kD) { return kE < kD }, "\x6d\x61\x63\x65\x6c": fZ("0x2c"), "\x63\x6d\x6d\x69\x78": fZ("0x2d"), "\x68\x65\x61\x65\x68": fZ("0x2e"), "\x64\x78\x65\x63\x6d": function (kE, kD) { return kE !== kD }, "\x69\x6d\x68\x65\x6c": fZ("0x2f"), "\x68\x61\x69\x78\x68": fZ("0x30"), "\x65\x6c\x61\x69\x78": function (kE, kD) { return kE >= kD }, "\x63\x65\x65\x6c\x61": fZ("0x31"), "\x68\x6c\x65\x64\x6c": fZ("0x32"), "\x64\x65\x65\x61\x65": "\x61\x6c\x65", "\x68\x68\x61\x63\x68": fZ("0x33"), "\x63\x78\x78\x69\x65": function (kE, kD) { return kE < kD }, "\x6d\x61\x64\x61\x68": function (kE, kD) { return kE > kD }, "\x61\x61\x78\x65\x61": fZ("0x34"), "\x65\x64\x6d\x65\x69": function (kD) { return kD() }, "\x69\x6d\x63\x61\x61": function (kE, kD) { return kE === kD }, "\x61\x63\x63\x61\x65": fZ("0x35"), "\x65\x68\x78\x78\x63": "\x6f\x6e\x73\x74\x79\x6c\x65\x7a\x6f\x6f\x6d\x75\x70\x64\x61\x74\x65" }; var e = this; this[fZ("0x36")] = T; this[fZ("0x37")] = []; var kC = Math[fZ("0x38")](navigator["\x68\x61\x72\x64\x77\x61\x72\x65\x43\x6f\x6e\x63\x75\x72\x72\x65\x6e\x63\x79"] - 2, 0) || 4; if ((i[fZ("0x39")](b5) || e9["\x42\x72\x6f\x77\x73\x65\x72"]["\x69\x65"]) && i[fZ("0x3a")](kC, 2)) { kC = 2 } this[fZ("0x3b")] = []; this[fZ("0x3c")] = i[fZ("0x39")](gu); this[fZ("0x3d")] = this["\x72\x61\x74\x69\x6f"]; if (this[fZ("0x3c")] > 1) { this[fZ("0x3e")] = 2 } else { this[fZ("0x3e")] = 1 } if (i[fZ("0x3f")](typeof this["\x6d\x61\x70"][fZ("0x40")][fZ("0x41")], "\x73\x74\x72\x69\x6e\x67")) { this[fZ("0x42")] = null; this[fZ("0x43")] = []; this[fZ("0x44")] = null } fG["\x63\x61\x6e\x55\x73\x65\x57\x65\x62\x41\x73\x73\x65\x6d\x62\x6c\x79"](function (kK) { var kI = { "\x78\x65\x78\x63\x65": function (kN, kM) { return kN !== kM }, "\x63\x6d\x6d\x69\x68": i[fZ("0x45")], "\x61\x6d\x65\x69\x63": i["\x78\x64\x63\x63\x6d"], "\x63\x69\x65\x69\x6c": fZ("0x46"), "\x61\x63\x61\x63\x68": i[fZ("0x47")], "\x6c\x61\x61\x65\x61": i[fZ("0x48")], "\x61\x63\x6d\x6c\x78": i[fZ("0x49")], "\x64\x6c\x68\x6c\x61": function (kN, kM) { return i[fZ("0x4a")](kN, kM) }, "\x61\x6c\x65\x6c\x6c": "\x68\x65\x78", "\x6d\x64\x61\x63\x69": fZ("0x4b"), "\x64\x6c\x69\x64\x65": i[fZ("0x4c")], "\x69\x78\x6d\x61\x69": fZ("0x4d"), "\x65\x6c\x69\x65\x65": i[fZ("0x4e")], "\x63\x61\x65\x61\x6c": fZ("0x4f"), "\x6c\x65\x68\x78\x69": "\x61\x63\x64", "\x63\x61\x78\x78\x63": fZ("0x50"), "\x61\x78\x61\x6d\x61": fZ("0x51") }; var kD; if (kK) { kD = (window.location.protocol === "http:" ? "http:" : "https:") + "//api.map.baidu.com/res/webgl/10/worker_wasm_cimp12.js" } else { kD = i[fZ("0x52")] } for (var kL = 0; kL < kC; kL++) { var kJ = i[fZ("0x53")]; while (kJ !== "\x78\x68\x6c\x61") { switch (kJ) { case i[fZ("0x53")]: var kH = i[fZ("0x54")](ka, kD); kJ = fZ("0x2"); break; case i[fZ("0x55")]: e["\x61\x72\x72\x57\x6f\x72\x6b\x65\x72"][fZ("0x56")](kH); kJ = i[fZ("0x57")]; break; case "\x61\x61\x65": kH[fZ("0x58")] = function kE(kQ) { var kP = fZ("0x4d"); while (kI[fZ("0x59")](kP, fZ("0x20"))) { switch (kP) { case kI["\x63\x6d\x6d\x69\x68"]: this[fZ("0x5a")] = null; kP = "\x69\x78\x61"; break; case kI[fZ("0x5b")]: this[fZ("0x5a")] && this[fZ("0x5a")](null, this[fZ("0x5c")]); kP = kI[fZ("0x5d")]; break; case kI[fZ("0x5e")]: e[fZ("0x5f")](kM["\x75\x72\x6c"], kM[fZ("0x60")], kM[fZ("0x61")], kN); kP = kI[fZ("0x62")]; break; case fZ("0x51"): T["\x66\x69\x72\x65"](kO); kP = kI[fZ("0x63")]; break; case fZ("0x64"): if (kI[fZ("0x65")](e[fZ("0x37")][fZ("0x66")], 0)) { kP = kI[fZ("0x67")]; break } kP = fZ("0x1f"); break; case kI["\x6d\x64\x61\x63\x69"]: this["\x5f\x70\x61\x72\x73\x69\x6e\x67\x54\x69\x6c\x65\x49\x6e\x66\x6f"] = null; kP = kI["\x64\x6c\x69\x64\x65"]; break; case kI[fZ("0x68")]: kP = kQ[fZ("0x69")] ? kI[fZ("0x6a")] : kI[fZ("0x5b")]; break; case kI[fZ("0x5d")]: this[fZ("0x6b")] = ![]; kP = kI[fZ("0x6c")]; break; case fZ("0x1f"): var kO = new fW(fZ("0x6d")); kP = kI["\x63\x61\x65\x61\x6c"]; break; case kI[fZ("0x6e")]: this[fZ("0x5c")] = null; kP = "\x61\x6d\x63"; break; case fZ("0xa"): this[fZ("0x5a")] && this[fZ("0x5a")](kQ[fZ("0x69")], this[fZ("0x5c")]); kP = fZ("0x46"); break; case kI[fZ("0x6f")]: var kN = kM["\x63\x62\x6b"]; kP = kI[fZ("0x5e")]; break; case fZ("0x70"): var kM = e["\x61\x72\x72\x50\x65\x6e\x64\x69\x6e\x67\x44\x61\x74\x61"]["\x73\x68\x69\x66\x74"](); kP = kI[fZ("0x6f")]; break; case kI[fZ("0x71")]: kO[fZ("0x72")] = kI[fZ("0x73")]; kP = kI["\x61\x78\x61\x6d\x61"]; break } } }; kJ = i[fZ("0x55")]; break } } } if (i[fZ("0x74")](e[fZ("0x37")][fZ("0x66")], 0)) { for (var kG = 0; kG < Math["\x6d\x69\x6e"](e["\x61\x72\x72\x50\x65\x6e\x64\x69\x6e\x67\x44\x61\x74\x61"][fZ("0x66")], kC); kG++) { var kF = e[fZ("0x37")]["\x73\x68\x69\x66\x74"](); e[fZ("0x5f")](kF["\x75\x72\x6c"], kF[fZ("0x60")], kF[fZ("0x61")], kF[fZ("0x75")]) } } }); T["\x6f\x6e"](i[fZ("0x76")], function () { var kF = fZ("0x77"); while (i["\x69\x61\x61\x61\x69"](kF, fZ("0x26"))) { switch (kF) { case i[fZ("0x78")]: e[fZ("0x44")] = null; kF = i[fZ("0x79")]; break; case i[fZ("0x7a")]: if (i[fZ("0x7b")](typeof this[fZ("0x40")][fZ("0x41")], i[fZ("0x7c")])) { kF = fZ("0x7d"); break } kF = i[fZ("0x79")]; break; case fZ("0x77"): for (var kE = 0, kD = e[fZ("0x3b")][fZ("0x66")]; i[fZ("0x7e")](kE, kD); kE++) { e[fZ("0x3b")][kE][fZ("0x7f")] = ![]; e[fZ("0x3b")][kE]["\x70\x6f\x73\x74\x4d\x65\x73\x73\x61\x67\x65"]({ "\x61\x63\x74\x69\x6f\x6e": i[fZ("0x80")] }) } kF = fZ("0x81"); break; case i["\x64\x65\x6c\x63\x61"]: e[fZ("0x43")] = []; kF = i[fZ("0x78")]; break; case i[fZ("0x82")]: e[fZ("0x42")] = null; kF = fZ("0xa"); break } } }); T["\x6f\x6e"](i["\x65\x68\x78\x78\x63"], function () { var kF = fZ("0x2b"); while (i[fZ("0x83")](kF, i[fZ("0x84")])) { switch (kF) { case fZ("0x2d"): e["\x73\x74\x72\x69\x6e\x67\x69\x66\x69\x65\x64\x43\x75\x73\x74\x6f\x6d\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f\x5a\x6f\x6f\x6d"] = []; kF = "\x69\x63\x6d"; break; case i["\x64\x61\x65\x69\x6d"]: e["\x73\x74\x72\x69\x6e\x67\x69\x66\x69\x65\x64\x41\x72\x65\x61\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f"] = null; kF = i[fZ("0x84")]; break; case "\x63\x65\x64": if (typeof this["\x63\x6f\x6e\x66\x69\x67"][fZ("0x41")] !== i[fZ("0x7c")]) { kF = fZ("0x85"); break } kF = i[fZ("0x84")]; break; case i[fZ("0x86")]: for (var kE = 0, kD = e[fZ("0x3b")][fZ("0x66")]; i["\x63\x69\x65\x6d\x78"](kE, kD); kE++) { e["\x61\x72\x72\x57\x6f\x72\x6b\x65\x72"][kE]["\x69\x73\x53\x65\x6e\x64\x46\x53"] = ![] } kF = i["\x6d\x61\x63\x65\x6c"]; break; case fZ("0x85"): e[fZ("0x42")] = null; kF = i[fZ("0x87")]; break } } }); T["\x6f\x6e"](fZ("0x88"), function () { var kE = i["\x68\x65\x61\x65\x68"]; while (i[fZ("0x89")](kE, i[fZ("0x8a")])) { switch (kE) { case fZ("0x8b"): e[fZ("0x43")] = []; kE = fZ("0x8c"); break; case fZ("0x8c"): e["\x73\x74\x72\x69\x6e\x67\x69\x66\x69\x65\x64\x41\x72\x65\x61\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f"] = null; kE = fZ("0x8d"); break; case fZ("0x32"): e[fZ("0x3b")][fZ("0x66")] = 0; kE = fZ("0x8e"); break; case i["\x68\x61\x69\x78\x68"]: for (var kD = kF[fZ("0x66")] - 1; i[fZ("0x8f")](kD, 0); kD--) { kF[kD] = null } kE = i[fZ("0x90")]; break; case fZ("0x2e"): for (var kD = 0; kD < e[fZ("0x3b")][fZ("0x66")]; kD++) { if (e[fZ("0x3b")][kD]) { e[fZ("0x3b")][kD][fZ("0x91")]() } } kE = i[fZ("0x92")]; break; case i[fZ("0x93")]: e["\x73\x74\x72\x69\x6e\x67\x69\x66\x69\x65\x64\x43\x75\x73\x74\x6f\x6d\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f"] = null; kE = fZ("0x8b"); break; case fZ("0x8d"): var kG = Object[fZ("0x94")](e); kE = i[fZ("0x95")]; break; case fZ("0x31"): e[fZ("0x96")] = null; kE = i[fZ("0x93")]; break; case fZ("0x8e"): var kF = e[fZ("0x37")]; kE = i[fZ("0x97")]; break; case fZ("0x33"): for (var kD = 0; i[fZ("0x98")](kD, kG[fZ("0x66")]); kD++) { if (i[fZ("0x74")](kG[kD]["\x69\x6e\x64\x65\x78\x4f\x66"](fZ("0x99")), -1) || i[fZ("0x3a")](kG[kD][fZ("0x9a")](i[fZ("0x9b")]), -1)) { delete e[kG[kD]] } } kE = i[fZ("0x8a")]; break } } }) }, "\x67\x65\x74\x49\x64\x6c\x65\x57\x6f\x72\x6b\x65\x72": function () { var kD = { "\x61\x78\x61\x68\x63": function (kF, kE) { return kF < kE }, "\x68\x61\x64\x63\x65": fZ("0x9c"), "\x6d\x61\x65\x69\x69": function (kF, kE) { return kF !== kE }, "\x6c\x61\x64\x68\x65": fZ("0x9d") }; for (var kC = 0, T = this[fZ("0x3b")][fZ("0x66")]; kD[fZ("0x9e")](kC, T); kC++) { var i = kD[fZ("0x9f")]; while (kD[fZ("0xa0")](i, fZ("0xa1"))) { switch (i) { case kD[fZ("0xa2")]: e["\x5f\x69\x73\x42\x75\x73\x79"] = !![]; i = "\x61\x68\x64"; break; case fZ("0x9c"): var e = this["\x61\x72\x72\x57\x6f\x72\x6b\x65\x72"][kC]; i = fZ("0xa3"); break; case fZ("0xa3"): if (!e[fZ("0x6b")]) { i = fZ("0x9d"); break } i = fZ("0xa1"); break; case fZ("0xa4"): return e } } } return null }, "\x72\x65\x6c\x65\x61\x73\x65\x50\x65\x6e\x64\x69\x6e\x67\x44\x61\x74\x61": function (T) { var e = { "\x64\x6d\x61\x61\x68": function (kI, kH) { return kI !== kH }, "\x65\x65\x78\x6c\x69": function (kI, kH) { return kI + kH }, "\x63\x69\x61\x63\x63": fZ("0xa5") }; var kG = []; var kF = this[fZ("0x37")]; for (var kE = kF["\x6c\x65\x6e\x67\x74\x68"] - 1; kE >= 0; kE--) { var kD = kF[kE]; var kC = kD[fZ("0x60")]; if (e["\x64\x6d\x61\x61\x68"](T[fZ("0xa6")], kC["\x74\x69\x6c\x65\x54\x79\x70\x65\x4e\x61\x6d\x65"])) { continue } var i = e["\x65\x65\x78\x6c\x69"](e["\x65\x65\x78\x6c\x69"](e[fZ("0xa7")] + kC[fZ("0xa8")] + "\x5f" + kC["\x72\x6f\x77"], "\x5f"), kC[fZ("0xa9")]); if (!T[i]) { kF[fZ("0xaa")](kE, 1); kG["\x70\x75\x73\x68"](kC) } } return kG }, "\x6c\x6f\x61\x64\x54\x69\x6c\x65\x44\x61\x74\x61": function (kN, kL, kJ, kG) { var kD = { "\x6c\x6c\x65\x64\x61": fZ("0xab"), "\x68\x63\x61\x61\x63": "\x64\x64\x68", "\x6c\x61\x61\x69\x69": "\x65\x61\x61", "\x68\x61\x78\x65\x61": fZ("0xac"), "\x63\x65\x78\x64\x78": "\x69\x61\x6d", "\x68\x6d\x6d\x64\x6d": fZ("0xad"), "\x65\x68\x61\x61\x61": fZ("0x34"), "\x78\x65\x65\x61\x6d": function (kS, kR) { return kS + kR }, "\x65\x61\x61\x61\x61": fZ("0xae"), "\x6d\x64\x69\x64\x65": fZ("0xaf"), "\x68\x6c\x61\x6c\x69": fZ("0xb0"), "\x78\x65\x65\x6d\x65": fZ("0xb1"), "\x6d\x65\x6d\x68\x65": fZ("0xa"), "\x63\x6c\x61\x68\x63": fZ("0xb2"), "\x6d\x78\x61\x63\x63": fZ("0x5f"), "\x61\x6c\x69\x6d\x65": fZ("0xb3"), "\x78\x6c\x68\x61\x78": fZ("0xb4"), "\x63\x69\x65\x68\x61": fZ("0x99"), "\x65\x69\x65\x69\x65": fZ("0xb5"), "\x63\x6c\x68\x64\x69": function (kS, kR) { return kS + kR }, "\x61\x68\x65\x63\x65": fZ("0xb6"), "\x64\x65\x64\x78\x6d": function (kS, kR) { return kS + kR }, "\x61\x69\x61\x68\x6d": "\x61\x65\x68", "\x69\x64\x61\x68\x61": fZ("0xb7"), "\x6d\x61\x6d\x6c\x65": fZ("0xb8"), "\x69\x64\x64\x64\x61": "\x65\x6d\x78", "\x64\x6c\x61\x69\x65": fZ("0xb9"), "\x6c\x61\x61\x64\x61": function (kR) { return kR() }, "\x65\x61\x65\x65\x78": fZ("0xba"), "\x78\x69\x78\x6d\x65": fZ("0x7d"), "\x61\x6c\x63\x64\x68": fZ("0xbb"), "\x78\x63\x6c\x6d\x69": fZ("0xbc"), "\x63\x65\x6d\x6d\x68": fZ("0xbd"), "\x61\x63\x63\x65\x63": "\x65\x6d\x61", "\x78\x65\x69\x63\x78": fZ("0xbe"), "\x6c\x6c\x65\x69\x6d": function (kR, kS) { return kR + kS }, "\x69\x64\x61\x68\x6d": "\x78\x63\x6c", "\x6d\x69\x6c\x6d\x6d": fZ("0xbf"), "\x6d\x6c\x65\x64\x6c": "\x6c\x65\x6c", "\x65\x64\x64\x68\x65": fZ("0xc0"), "\x69\x65\x65\x63\x61": fZ("0xc1"), "\x69\x69\x68\x61\x69": fZ("0xc2"), "\x61\x6c\x68\x63\x63": "\x63\x75\x73\x74\x6f\x6d\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f\x5f", "\x6d\x61\x65\x65\x61": fZ("0xc3"), "\x6c\x69\x63\x65\x6c": fZ("0xc4"), "\x65\x63\x61\x65\x63": "\x6d\x69\x6c", "\x61\x61\x6c\x65\x65": "\x43\x75\x73\x74\x6f\x6d", "\x69\x6d\x65\x78\x78": fZ("0xc5"), "\x6c\x65\x6c\x78\x78": fZ("0xc6"), "\x69\x78\x65\x65\x63": fZ("0xc7"), "\x64\x61\x68\x61\x69": fZ("0xc8"), "\x61\x65\x68\x6d\x6d": "\x63\x64\x63", "\x78\x64\x65\x65\x69": fZ("0xc9") }; var kI = fZ("0xca"); while (kI !== fZ("0xb9")) { switch (kI) { case fZ("0xc1"): kC[fZ("0xcb")] = kH; kI = kD[fZ("0xcc")]; break; case kD[fZ("0xcd")]: if (!kO[fZ("0x7f")]) { kI = fZ("0xb4"); break } kI = kD[fZ("0xce")]; break; case kD[fZ("0xcf")]: if (kP && this[fZ("0x44")]) { kI = kD[fZ("0xd0")]; break } kI = kD[fZ("0xd1")]; break; case fZ("0xd2"): this[kD[fZ("0xd3")] + kE] = JSON[fZ("0xd4")](bG[kD[fZ("0xd5")](kD[fZ("0xd6")], kE)]); kI = "\x61\x65\x68"; break; case "\x69\x6d\x65": var kF = this[fZ("0x36")]["\x70\x61\x72\x6b\x69\x6e\x67"][fZ("0xd7")]; kI = kD[fZ("0xd8")]; break; case kD[fZ("0xd9")]: kC["\x63\x75\x73\x74\x6f\x6d\x4d\x61\x70\x53\x74\x79\x6c\x65"] = this["\x73\x74\x72\x69\x6e\x67\x69\x66\x69\x65\x64\x43\x75\x73\x74\x6f\x6d\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f"]; kI = "\x64\x69\x61"; break; case kD[fZ("0xda")]: if (!(kP && !this["\x6d\x61\x70"][fZ("0x40")][fZ("0xdb")])) { kI = kD["\x6d\x65\x6d\x68\x65"]; break } kI = kD["\x63\x6c\x61\x68\x63"]; break; case kD[fZ("0xd8")]: var kC = { "\x61\x63\x74\x69\x6f\x6e": kD[fZ("0xdc")], "\x75\x72\x6c": kN, "\x74\x69\x6c\x65\x49\x6e\x66\x6f": kL, "\x74\x69\x6c\x65\x4b\x65\x79": kJ, "\x69\x73\x54\x65\x78\x74": kQ, "\x69\x73\x50\x6f\x69": i, "\x62\x75\x69\x6c\x64\x69\x6e\x67\x53\x69\x64\x65\x47\x72\x61\x64\x61\x74\x69\x6f\x6e": e, "\x68\x61\x73\x50\x6f\x6c\x79": T ? ![] : !![], "\x68\x61\x73\x4c\x69\x6e\x65": T ? this[fZ("0x36")]["\x63\x6f\x6e\x66\x69\x67"][fZ("0xdd")] : !![], "\x63\x61\x72\x70\x6f\x72\x74": kF }; kI = kD[fZ("0xde")]; break; case kD["\x78\x6c\x68\x61\x78"]: if (!this[kD[fZ("0xd5")](kD[fZ("0xdf")], kK)] && bG[fZ("0xe0") + kK]) { kI = kD[fZ("0xe1")]; break } kI = "\x61\x78\x63"; break; case fZ("0xb5"): this[kD[fZ("0xe2")](kD[fZ("0xdf")], kK)] = JSON["\x73\x74\x72\x69\x6e\x67\x69\x66\x79"](bG[kD[fZ("0xe2")]("\x46\x65\x61\x74\x75\x72\x65\x53\x74\x79\x6c\x65", kK)]); kI = kD[fZ("0xe3")]; break; case fZ("0xb6"): if (!this[kD[fZ("0xe4")](fZ("0x34"), kE)]) { kI = fZ("0xd2"); break } kI = kD[fZ("0xe5")]; break; case fZ("0xbf"): if (kP && bG[kD[fZ("0xe4")](fZ("0xe6"), kK)]) { kI = fZ("0xbd"); break } kI = fZ("0xc4"); break; case kD[fZ("0xe7")]: if (kP) { kI = kD[fZ("0xe8")]; break } kI = "\x65\x78\x6d"; break; case kD[fZ("0xe9")]: this[fZ("0x37")][fZ("0x56")](kM); kI = kD[fZ("0xea")]; break; case fZ("0xc9"): kD[fZ("0xeb")](kG); kI = kD[fZ("0xcd")]; break; case fZ("0xec"): var i = this[fZ("0x36")][fZ("0xed")][fZ("0xee")]; kI = kD[fZ("0xef")]; break; case "\x78\x6d\x63": kC[fZ("0xf0")] = { "\x77\x6f\x72\x64\x53\x70\x61\x63\x65\x52\x61\x74\x69\x6f": this[fZ("0x3d")], "\x74\x65\x78\x74\x53\x69\x7a\x65\x52\x61\x74\x69\x6f": this[fZ("0x3e")] }; kI = fZ("0xf1"); break; case kD["\x65\x61\x65\x65\x78"]: var kQ = i ? this[fZ("0x36")][fZ("0xed")][fZ("0xf2")] : ![]; kI = kD[fZ("0xf3")]; break; case kD[fZ("0xd0")]: kC[fZ("0xf4")] = this["\x73\x74\x72\x69\x6e\x67\x69\x66\x69\x65\x64\x41\x72\x65\x61\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f"]; kI = fZ("0xad"); break; case fZ("0xf5"): if (this[fZ("0x99") + kK]) { kI = fZ("0xbe"); break } kI = kD["\x61\x6c\x63\x64\x68"]; break; case kD[fZ("0xf6")]: var kP = !!(kK[fZ("0x9a")]("\x63\x75\x73\x74\x6f\x6d") === 0); kI = fZ("0xf7"); break; case fZ("0xb2"): if (kP && this[fZ("0x42")]) { kI = kD[fZ("0xd9")]; break } kI = fZ("0xac"); break; case kD[fZ("0xf8")]: if (!this[fZ("0x42")]) { kI = "\x78\x61\x65"; break } kI = fZ("0xc4"); break; case fZ("0xca"): var kO = this[fZ("0xf9")](); kI = kD[fZ("0xfa")]; break; case kD["\x78\x65\x69\x63\x78"]: kC["\x66\x65\x61\x74\x75\x72\x65\x53\x74\x79\x6c\x65"] = this[kD[fZ("0xfb")](fZ("0x99"), kK)]; kI = fZ("0xbb"); break; case "\x78\x61\x69": kC["\x69\x63\x6f\x6e\x53\x65\x74\x49\x6e\x66\x6f"] = this[kD["\x65\x68\x61\x61\x61"] + kE]; kI = fZ("0xb1"); break; case kD[fZ("0xfc")]: this[fZ("0x96")] = JSON[fZ("0xd4")](bG[fZ("0xfd")]); kI = kD["\x6d\x69\x6c\x6d\x6d"]; break; case kD["\x6d\x6c\x65\x64\x6c"]: kO[fZ("0xfe")] = kL; kI = kD["\x65\x64\x64\x68\x65"]; break; case "\x69\x65\x65": kC["\x6d\x61\x70\x53\x74\x79\x6c\x65\x49\x64"] = kK; kI = kD["\x69\x65\x65\x63\x61"]; break; case kD[fZ("0xff")]: this[fZ("0x42")] = JSON[fZ("0xd4")](bG[kD[fZ("0xfb")](kD[fZ("0x100")], kK)]); kI = fZ("0xc4"); break; case fZ("0x32"): if (!this["\x73\x74\x72\x69\x6e\x67\x69\x66\x69\x65\x64\x49\x6e\x64\x6f\x6f\x72\x53\x74\x79\x6c\x65"]) { kI = fZ("0x101"); break } kI = "\x69\x65\x6d"; break; case fZ("0xa"): kC[fZ("0xfd")] = this[fZ("0x96")]; kI = kD[fZ("0x102")]; break; case kD[fZ("0x103")]: if (this[fZ("0x36")]["\x70\x61\x72\x6b\x69\x6e\x67"]) { kI = "\x69\x6d\x65"; break } kI = fZ("0xaf"); break; case fZ("0x104"): var kM = { "\x75\x72\x6c": kN, "\x74\x69\x6c\x65\x49\x6e\x66\x6f": kL, "\x74\x69\x6c\x65\x4b\x65\x79": kJ, "\x63\x62\x6b": kG }; kI = kD[fZ("0xe9")]; break; case kD[fZ("0xcc")]: kO[fZ("0x7f")] = !![]; kI = kD[fZ("0xce")]; break; case kD[fZ("0xce")]: kO["\x70\x6f\x73\x74\x4d\x65\x73\x73\x61\x67\x65"](kC); kI = kD[fZ("0xea")]; break; case kD[fZ("0x105")]: if (kP && bG["\x63\x75\x73\x74\x6f\x6d\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f\x5f" + kH]) { kI = fZ("0x106"); break } kI = kD[fZ("0x107")]; break; case kD[fZ("0xde")]: var kK = this[fZ("0x36")][fZ("0x108")](); kI = fZ("0xc6"); break; case kD[fZ("0xe8")]: kE = kD["\x61\x61\x6c\x65\x65"]; kI = kD[fZ("0x109")]; break; case kD[fZ("0x10a")]: var kH = this[fZ("0x36")][fZ("0x10b")](); kI = kD["\x78\x63\x6c\x6d\x69"]; break; case fZ("0x10c"): kO[fZ("0x5a")] = kG; kI = fZ("0x10d"); break; case fZ("0xf7"): var kE = kK; kI = kD[fZ("0xe7")]; break; case kD[fZ("0x10e")]: var T = this[fZ("0x36")][fZ("0x10f")] !== BMAPGL_NORMAL_MAP && this[fZ("0x36")]["\x63\x6f\x6e\x66\x69\x67"][fZ("0x110")]; kI = fZ("0xc3"); break; case kD["\x64\x61\x68\x61\x69"]: this[fZ("0x44")] = JSON[fZ("0xd4")](bG[fZ("0xe6") + kH]); kI = fZ("0xf5"); break; case kD[fZ("0xf3")]: var e = this[fZ("0x36")][fZ("0xed")][fZ("0x111")]; kI = fZ("0x112"); break; case kD["\x61\x65\x68\x6d\x6d"]: kI = kO ? "\x65\x65\x6c" : fZ("0x104"); break; case fZ("0xc0"): kO[fZ("0x5c")] = kJ; kI = kD[fZ("0x10e")]; break; case fZ("0x106"): if (!this["\x73\x74\x72\x69\x6e\x67\x69\x66\x69\x65\x64\x41\x72\x65\x61\x53\x74\x79\x6c\x65\x49\x6e\x66\x6f"]) { kI = kD[fZ("0x113")]; break } kI = kD[fZ("0x107")]; break; case kD[fZ("0x109")]: if (kP && bG[kD[fZ("0xfb")](fZ("0xe6"), kK)] && !bG[kD[fZ("0x100")] + kK]["\x62\x61\x73\x65\x46\x73"]) { kI = kD["\x78\x64\x65\x65\x69"]; break } kI = fZ("0x114"); break } } }, "\x73\x65\x74\x57\x6f\x72\x6b\x65\x72\x43\x6f\x6e\x66\x69\x67": function (i) { var e = { "\x61\x61\x65\x61\x6c": fZ("0x115"), "\x64\x69\x6d\x64\x63": fZ("0x116"), "\x61\x6c\x63\x65\x65": "\x63\x68\x65", "\x65\x65\x61\x61\x61": "\x65\x61\x64", "\x63\x65\x65\x68\x78": function (kG, kF) { return kG < kF }, "\x61\x6c\x61\x64\x78": fZ("0x117") }; var kE = e["\x61\x61\x65\x61\x6c"]; while (kE !== fZ("0x117")) { switch (kE) { case "\x69\x6c\x78": var kD = { "\x61\x63\x74\x69\x6f\x6e": e["\x64\x69\x6d\x64\x63"] }; kE = e["\x61\x6c\x63\x65\x65"]; break; case e["\x65\x65\x61\x61\x61"]: for (var kC = 0; e[fZ("0x118")](kC, this[fZ("0x3b")]["\x6c\x65\x6e\x67\x74\x68"]); kC++) { this[fZ("0x3b")][kC]["\x70\x6f\x73\x74\x4d\x65\x73\x73\x61\x67\x65"](kD) } kE = e[fZ("0x119")]; break; case fZ("0x11a"): for (var T in i) { if (i[fZ("0x11b")](T)) { kD[T] = i[T] } } kE = e[fZ("0x11c")]; break } } } }; e9[fZ("0x11d")](jV[fZ("0x11e")], hp); function jd(i) { this.tileLayers = []; this.map = i; var e = this.config = ev[this.map.mapType]; this.errorUrl = e.errorUrl; this.tileSize = e.tileSize; this.baseUnits = e.baseUnits; this.baseZoomLevel = e.zoomLevelBase; this.tileURLs = e.tileUrls; this.tilesInfoCache = {}; this.loadDelay = 10; this._labelTextCanvas = null } bG.register(function (i) { if (i._renderType !== "webgl") { return } var e = i.tileMgr = new jd(i); i.addEventListener("addtilelayer", function (kC) { e.addWebGLLayer(kC.target) }); i.addEventListener("removetilelayer", function (kC) { e.removeWebGLLayer(kC.target) }); i.on("update", function T(kD) { if (i.getFeatureStyleTags().length === 0 || !(i.customLoaded && i.areaCustomLoaded)) { return } var kC = false; if (kD.changedStatus && kD.changedStatus.onzoom_changed) { kC = true } e.loadLayersData({ zoomChanged: kC }) }); i.on("style_changed", function () { e.loadLayersData() }); i.on("destroy", function () { for (var kC = 0; kC < e.tileLayers.length; kC++) { e.tileLayers[kC].remove(); e.tileLayers[kC].destroyDrawData(); e.tileLayers[kC] = null } e.tilesInfoCache = {}; e.tileLayers = []; e._labelTextCanvas = null; e.map = null; e.requestTime = null }) }); e9.extend(jd.prototype, { addWebGLLayer: function (T) { this.tileLayers.push(T); T.initDrawData(); if (this.tileLayers.length > 1) { for (var e = 1; e < this.tileLayers.length; e++) { if (this.tileLayers[e].isFlat) { this.map.setDisplayOptions({ isFlat: true }); break } } } if (this.map.getFeatureStyleTags().length > 0 && this.map.customLoaded && this.map.areaCustomLoaded) { this.loadLayersData() } else { var kC = this; this.map.loadMapStyleFiles(function () { var i = new fW("onlayer_update"); i.name = "na"; kC.map.fire(i); kC.loadLayersData() }) } }, removeWebGLLayer: function (kE) { var kF = false; for (var kD = 0, kC = this.tileLayers.length; kD < kC; kD++) { if (kE === this.tileLayers[kD]) { kF = true; this.tileLayers.splice(kD, 1); break } } if (kF === false) { return } kE.destroyDrawData(); if (this.map.getFeatureStyleTags().length > 0) { this.loadLayersData() } if (this.tileLayers.length === 1) { this.map.setDisplayOptions({ isFlat: false }) } else { var e = false; for (var kD = 1; kD < this.tileLayers.length; kD++) { if (this.tileLayers[kD].isFlat) { e = true; break } } this.map.setDisplayOptions({ isFlat: e }) } var T = new fW("onrefresh"); T.source = "removewebgllayer"; this.map.fire(T) }, getLabelTextCanvas: function () { if (!this._labelTextCanvas) { this._labelTextCanvas = new az(this.map) } return this._labelTextCanvas }, loadLayersData: function (i) { if (!this.map || this.map.suspendLoad) { return } var kD = this; i = i || {}; var kC = !!i.zoomChanged; var e = (kC === true || this.map.getTilt() > 50); if (!e) { if (!this.syncLoadTimer) { this.syncLoadTimer = setTimeout(function () { kD._loadLayersFromCache(kC); kD.syncLoadTimer = null }, 40) } } else { this._loadLayersFromCache(kC) } if (!kD.map.viewAnimationTime) { this.timer && window.clearTimeout(this.timer) } if (!this.requestTime) { this.requestTime = new Date().getTime() } else { if (new Date().getTime() - this.requestTime >= 1000) { T() } } function T() { if (!kD.map) { return } if (kD.map.viewAnimationTime) { if (new Date().getTime() - kD.map.viewAnimationTime < 1000) { return } kD.map.viewAnimationTime = new Date().getTime() } var kF = kD.tileLayers.length; kD.tilesInfoCache = {}; for (var kH = 0; kH < kF; kH++) { var kJ = kD.tileLayers[kH]; var kI = kJ.tileType; var kE = null; var kG = kD._getTilesInfoKey(kI, kJ); if (kD.tilesInfoCache[kG]) { kE = kD.tilesInfoCache[kG] } else { kE = kD.calcTilesInfo(kI, kJ); kD.tilesInfoCache[kG] = kE } kE && kJ.loadLayerData(kE, false, kC) } kD.timer = null; kD.requestTime = null } this.timer = window.setTimeout(T, this.loadDelay); if ((b5() || e9.Browser.ie) && kC) { this.loadDelay = 200 } else { this.loadDelay = 80 } }, _getTilesInfoKey: function (i, T) { var e = i.getName(); e += ("_" + (T.transform ? T.transform.source : "default")); e += ("_" + T.spanLevel || 0); return e }, _loadLayersFromCache: function (kE) { if (!this.map) { return } this.map._featureMgr.clearData(); this.map.tileLabels = []; var kH = this.tileLayers; kH.sort(function (kI, i) { return kI.zIndex - i.zIndex > 0 }); var T = kH.length; this.tilesInfoCache = {}; for (var kD = 0; kD < T; kD++) { var kG = kH[kD]; var kF = kG.tileType; var e = null; var kC = this._getTilesInfoKey(kF, kG); if (this.tilesInfoCache[kC]) { e = this.tilesInfoCache[kC] } else { e = this.calcTilesInfo(kF, kG); this.tilesInfoCache[kC] = e } e && kG.loadLayerData(e, true, kE) } }, calcTilesInfo: function (kP, lg) { var k2 = this.map; var k8 = k2.getMapType(); var k3 = ev[k8]; var kX = k2.getZoom(); var e = Math.floor(kX); var kF = kP.getDataZoom(kX); var lk = kP.getName(); kF = ck(kF, k3.minDataZoom, k3.maxDataZoom); var lb = e; if (kP._name === "web" || kP._name === "xyz") { lb = kF } else { if (lb < 3) { lb = 3 } } var k1 = kP.getTileSize(kX); var kE = kP.getBaseTileSize(kX); var kZ = k2.getBoundsIn(); if (!kZ) { return } var kT = kP.getMercatorSize(kX, kF); var kS; var la; var k0; var ld; var k4 = k2.getCenterIn(); k4 = fc.calcLoopCenterPoint(k4); if (lk === "xyz") { return this.calcXYZTilesInfo(k4, kZ, kF, lk, lg, k2) } var kY = Math.floor(k4.lng / kT); var kH = Math.floor(k4.lat / kT); var k6 = 0; var kC = 0; kZ = fc.calcLoopMapBounds(kZ, k4); if (kZ.ne.lng > fc._mc180X) { var kN = fc.getSpaceDistanceInPixel(kF); k6 = Math.ceil(kN / kE) } if (kZ.sw.lng < fc._mcM180X) { var kN = fc.getSpaceDistanceInPixel(kF); kC = Math.ceil(kN / kE) } if (kZ.ne.lat > 19505879.362428114 || kZ.sw.lat < -15949096.637571886) { kZ.ne.lat = 19505879.362428114; kZ.sw.lat = -15949096.637571886 } var kJ = [Math.floor(kZ.sw.lng / kT) - kC, Math.floor(kZ.sw.lat / kT)]; var li = [Math.floor(kZ.ne.lng / kT) + k6, Math.floor(kZ.ne.lat / kT)]; kS = kJ[0] - k2.config.extendTiles; la = li[0] + 1 + k2.config.extendTiles; k0 = kJ[1] - k2.config.extendTiles; ld = li[1] + 1 + k2.config.extendTiles; var kO = []; for (var kL = kS; kL < la; kL++) { if (fc.isTileBlank(kL, kF, kE) === true) { continue } for (var kQ = k0; kQ < ld; kQ++) { var lf = false; var kK = 256; if (lk === "web") { var kV = this._webTileRaste180(kL, kQ, kF); lf = kV.combine; kK = kV.dataIndex } var kM = { col: kL, row: kQ, zoom: kF, useZoom: lb, tileTypeName: lk, loopOffsetX: 0, tileSize: k1, baseTileSize: kE, mercatorSize: kT, combine: lf, dataIndex: kK }; kO.push(kM); var k7 = "id_" + kL + "_" + kQ + "_" + kF; kO[k7] = true } } if (kF <= 5) { for (var lh = 0, le = kO.length; lh < le; lh++) { var kL = kO[lh].col; var kQ = kO[lh].row; var k9 = fc.calcLoopParam(kL, kF); var kG = k9.T; var kU = kL >= 0 ? kL - kG : kL + kG; var kW = "id_" + kU + "_" + kQ + "_" + kF; if (fc.isTileBlank(kU, kF, kE) === true) { continue } if (!kO[kW]) { var lf = false; var kK = 256; if (lk === "web") { var kV = this._webTileRaste180(kU, kQ, kF); lf = kV.combine; kK = kV.dataIndex } var kM = { col: kU, row: kQ, zoom: kF, useZoom: lb, loopOffsetX: 0, tileSize: k1, baseTileSize: kE, mercatorSize: kT, combine: lf, dataIndex: kK }; kO.push(kM); kO[kW] = true } } } if (this.map._tilt > 0 && (lk !== "web" || kX >= 8)) { for (var lh = 0; lh < kO.length; lh++) { var kI = kO[lh]; var lc = kI.col; var lj = kI.row; var k5 = []; k5.minX = lc * kT; k5.maxX = (lc + 1) * kT; k5.minY = lj * kT; k5.maxY = (lj + 1) * kT; var kD = new cG(0, 0); kD.lng = (k5.minX + k5.maxX) / 2; kD.lat = (k5.minY + k5.maxY) / 2; var kR = k2.pointToPixelIn(kD); if (kR.x > 0 && kR.x < this.map.width && kR.y > 0 && kR.y < this.map.height) { continue } if (k5.minX < k4.lng && k5.maxX > k4.lng && k5.minY < k4.lat && k5.maxY > k4.lat) { continue } if (!this.ifTileInMapBounds(k5, kZ, lc, lj)) { kO.splice(lh, 1); lh-- } } } kO.sort((function (i) { return function (T, ll) { return ((0.4 * Math.abs(T.col - i[0]) + 0.6 * Math.abs(T.row - i[1])) - (0.4 * Math.abs(ll.col - i[0]) + 0.6 * Math.abs(ll.row - i[1]))) } })([kY, kH])); kO.zoom = kF; kO.tileTypeName = lk; return kO }, _webTileRaste180: function (T, kH, e) { var i = this.map; var kE = false; var kF = 256; var kD = fc.calcLoopParam(T, e); var kG = { col: kD.col, row: kH, baseTileSize: 256, zoom: e }; var kC = jy.prototype.tileToBound(kG, i.getCenter()); if (Math.ceil(kC.LL.sw.lng) * Math.floor(kC.LL.ne.lng) < 0) { kE = true; kF = fc.pixelWidth(kC.MC.sw.lng, e); if (kG.col < 0) { kF = -kF } } return { combine: kE, dataIndex: kF } }, calcXYZTilesInfo: function (kN, kG, kM, kR, kF, kU) { var kI = kU.width; var kS = kU.height; var kH = Math.floor(kM); var kJ = null; if (kF.transform.target === "EPSG3857") { var kC = dL.transformBDmcPoint(kN, kF.transform); var kD = dL.getRangeExtent(kC, kI, kS, kH, kF.transform); kJ = [kD.minX, kD.minY, kD.maxX, kD.maxY] } else { if (kF.transform.source === "BD09MC") { var kC = [kN.lng, kN.lat]; kJ = [kG.sw.lng, kG.sw.lat, kG.ne.lng, kG.ne.lat] } else { var kC = dL.transformBDmcPoint(kN, kF.transform); var kE = dL.transformBDmcPoint(kG.ne, kF.transform); var kL = dL.transformBDmcPoint(kG.sw, kF.transform); kJ = dL.getLoopBox(kC, [kL[0], kL[1], kE[0], kE[1]]) } } if (!kC || !kJ) { return [] } kH = kH + kF.spanLevel; var T = dL.getTileRangeForExtentFactory(kJ, kH, kF.transform); var e = []; var kV = dL.getResolutionScale(kH, kF.transform); for (var kQ = T.minX; kQ <= T.maxX; kQ++) { for (var kO = T.minY; kO <= T.maxY; kO++) { var kP = { col: kQ, row: kO, zoom: kH, useZoom: kH, tileTypeName: kR, loopOffsetX: 0, tileSize: 256 * kV, transform: kF.transform, combine: false, dataIndex: 0 }; e.push(kP); var kK = "id_" + kQ + "_" + kO + "_" + kH; e[kK] = true } } var kT = dL.getTileCoordForCoordAndZ(kC, kH); e.sort((function (i) { return function (kW, kX) { return ((0.4 * Math.abs(kW.col - i[0]) + 0.6 * Math.abs(kW.row - i[1])) - (0.4 * Math.abs(kX.col - i[0]) + 0.6 * Math.abs(kX.row - i[1]))) } })([kT[1], kT[2]])); e.zoom = kH; e.tileTypeName = kR; return e }, getCurrentViewTilesInfo: function (T, kC) { var i = this._getTilesInfoKey(T, kC); var e = this.tilesInfoCache[i]; if (!e) { return this.calcTilesInfo(T, kC) } return e }, ifTileInMapBounds: function (e, kE, T, kD) { var i = kE.normalizedBottomLeft; var kP = kE.normalizedTopRight; var kH = kE.normalizedTopLeft; var kF = kE.normalizedBottomRight; var kC = false; var kO = new cG(e.minX, e.minY); var kL = new cG(e.maxX, e.maxY); var kG = new cG(kL.lng, kO.lat); var kM = new cG(kO.lng, kL.lat); var kJ = [kM, kL, kG, kO]; for (var kN = 0, kI = kJ.length; kN < kI; kN++) { var kK = kN + 1; if (kK === kI) { kK = 0 } var kQ = kN; var kR = jx(kJ[kK], kJ[kQ], kH, i); if (kR) { kC = true; break } kR = jx(kJ[kK], kJ[kQ], kF, kP); if (kR) { kC = true; break } kR = jx(kJ[kK], kJ[kQ], kP, kH); if (kR) { kC = true; break } kR = jx(kJ[kK], kJ[kQ], i, kF); if (kR) { kC = true; break } } return kC }, getTileLayer: function (kD) { for (var kC = 0, e = this.tileLayers.length; kC < e; kC++) { var T = this.tileLayers[kC]; if (T.mapType === kD) { return T } } return null }, isExitTileLayer: function (kD) { for (var kC = 0, e = this.tileLayers.length; kC < e; kC++) { var T = this.tileLayers[kC]; if (T === kD) { return true } } return false }, getZoomState: function (i) { var e = i - this.lastZoom; if (e > 0) { this.zoomState = 1 } else { if (e < 0) { this.zoomState = -1 } } this.lastZoom = i; return this.zoomState } }); function iW(e) { this.map = e; this.gl = null; this.layers = []; this.mouseEventThrottle = this.throttle(this.pick, 100).bind(this); this.mousePointerThrottle = this.throttle(this.mouseStatus, 300).bind(this); this.base = new cG(12069475.280738307, 3929271.1724863998); this.iconCache = new aC((b5() || e9.Browser.ie) ? 64 : 128, { clearCallback: function (i) { } }) } bG.register(function (i) { if (i._renderType !== "webgl") { return } var e = i._normalLayerMgr = new iW(i); i.toFormatCoords = function (kE, kH) { var kG = []; var kF = e.base; if (kH && kH.center) { kF = jy.convertLL2MC(kH.center) } for (var kD = 0; kD < kE.length; kD++) { var T = jy.convertLL2MC(new cG(kE[kD][0], kE[kD][1])); var kC = [T.lng - kF.lng, T.lat - kF.lat]; kG.push(kC) } return kG }; i.indexToRgb = function (kC) { kC++; var T = Math.floor(kC / 65536); kC -= T * 65536; var kE = Math.floor(kC / 256); kC -= kE * 256; var kD = kC; return [kD, kE, T] }; i.addEventListener("addnormallayer", function (T) { e.addWebGLLayer(T.target) }); i.addEventListener("removenormallayer", function (T) { e.removeWebGLLayer(T.target) }); i.addEventListener("update", function (kF) { if (kF.changedStatus && kF.changedStatus.onsize_changed) { if (e.gl) { e.clearFramebuffer(); var kE = i.getSize(); var kD = kE.width; var T = kE.height; var kC = i.config.ratio; kD = Math.round(kD * kC); T = Math.round(T * kC); e.pickFBO = e.createFramebuffer(kD, T) } } }); i.addEventListener("onmousemove", e._layerMouseEvent.bind(e)); i.addEventListener("onclick", e._layerClickEvent.bind(e)); i.addEventListener("ondblclick", e._layerDBLClickEvent.bind(e)); i.addEventListener("onrightclick", e._layerRightClickEvent.bind(e)); i.on("destroy", function () { e.removeAllLayers(true); i.indexToRgb = null; i.toFormatCoords = null; e.pickFBO = null; e.preFramebuffer = null; e.gl = null; e.iconCache.clear() }); i.on("glmoduleloaded", function () { e.gl = i._webglPainter.gl; e.pickFBO = e.createFramebuffer(); for (var T = 0; T < e.layers.length; T++) { e.layers[T].onInit(i, e.gl) } i.dispatchEvent(new fW("onupdate")) }); i.addEventListener("layer_clear", function (T) { e.iconCache.clear() }) }); e9.extend(iW.prototype, { init: function () { var e = this; this.map.toFormatCoords = function (kE) { var kF = []; for (var kD = 0; kD < kE.length; kD++) { var T = jy.convertLL2MC(new cG(kE[kD][0], kE[kD][1])); var kC = [T.lng - e.base.lng, T.lat - e.base.lat]; kF.push(kC) } return kF }; this.map.indexToRgb = function (kC) { kC++; var T = Math.floor(kC / 65536); kC -= T * 65536; var kE = Math.floor(kC / 256); kC -= kE * 256; var kD = kC; return [kD, kE, T] }; this.pickFBO = this.createFramebuffer(); var i = this; this.map.addEventListener("addnormallayer", function (T) { i.addWebGLLayer(T.target) }); this.map.addEventListener("removenormallayer", function (T) { i.removeWebGLLayer(T.target) }); this.map.addEventListener("onmousemove", this._layerMouseEvent.bind(this)); this.map.addEventListener("onclick", this._layerClickEvent.bind(this)); this.map.addEventListener("onrightclick", this._layerRightClickEvent.bind(this)); this.map.addEventListener("ondblclick", this._layerDBLClickEvent.bind(this)); this.map.on("destroy", function () { i.removeAllLayers(true); i.map.indexToRgb = null; i.map.toFormatCoords = null; i.pickFBO = null; i.preFramebuffer = null }) }, addWebGLLayer: function (T) { var kC = false; for (var e = 0; e < this.layers.length; e++) { if (this.layers[e] === T) { kC = true; break } } if (!kC) { this.layers.push(T); if (this.gl) { T.onInit(this.map, this.gl) } this.map.dispatchEvent(new fW("onupdate")) } }, removeWebGLLayer: function (T) { for (var e = 0; e < this.layers.length; e++) { if (this.layers[e] === T) { this.map._featureMgr.removeLayer(T.zIndex); this.layers.splice(e, 1); T.onDestroy(); this.map.dispatchEvent(new fW("onupdate")); break } } }, removeAllLayers: function (kC) { for (var T = 0; T < this.layers.length; T++) { var e = this.layers[T]; if (e.visible) { this.map._featureMgr.removeLayer(e.zIndex) } if (kC) { e.onKill && e.onKill() } e.onDestroy() } this.layers = []; this.map.dispatchEvent(new fW("onupdate")) }, sortLayer: function () { this.layers.sort(function (i, e) { return i.zIndex - e.zIndex > 0 }) }, _layerMouseEvent: function (i) { this.mouseEventThrottle(i, "onmousemove") }, _layerClickEvent: function (i) { this.pick(i, "onclick") }, _layerDBLClickEvent: function (i) { this.pick(i, "ondblclick") }, _layerRightClickEvent: function (i) { this.pick(i, "onrightclick") }, throttle: function (T, e) { var kC = null; var i = Date.now(); return function () { var kG = Date.now(); var kF = e - (kG - i); var kE = this; var kD = arguments; if (kC) { clearTimeout(kC) } if (kF <= 0) { T.apply(kE, kD); i = Date.now() } else { kC = setTimeout(function () { T.apply(kE, kD) }, kF) } } }, pick: function (kH, kF) { if (!this.layers.length) { return false } var kC = false; var T = false; for (var kE = this.layers.length - 1; kE >= 0; kE--) { var kD = this.layers[kE]; if (kD.doRender() && kD.testEvent(kF)) { T = true; if (kD.pick) { if (kF === "onmousemove" || kD.hasEvent(kF)) { var kG = kD.pick(kH.x, kH.y, kF) } else { continue } if (kG && kG.dataIndex !== -1) { if (kF === "onmousemove") { kC = true } if (kD.hasEvent(kF)) { kD.dispatcher(kH, kG, kF) } if (!kD.popEvent) { break } } else { if (kD.hasEvent(kF)) { kD.dispatcher(kH, kG, kF) } } } } } if (kF === "onmousemove" && T) { this.mousePointerThrottle(kC) } this.map.dispatchEvent(new fW("onupdate")) }, mouseStatus: function (e) { if (e) { this.map.platform.style.cursor = this.map.config.overlayMoveCursor } else { this.map.platform.style.cursor = this.map.config.defaultCursor } }, saveFramebuffer: function () { var e = this.gl; this.preFramebuffer = e.getParameter(e.FRAMEBUFFER_BINDING) }, bindFramebuffer: function (e) { var i = this.gl; if (e) { i.bindFramebuffer(i.FRAMEBUFFER, e) } else { i.bindFramebuffer(i.FRAMEBUFFER, null) } }, clear: function (e) { var i = this.gl; i.clearColor(0, 0, 0, 0); if (e instanceof Array) { i.clearColor(e[0], e[1], e[2], e[3]) } i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT) }, restoreFramebuffer: function () { var i = this.gl; if (this.map && this.map._webglPainter) { var e = this.map._webglPainter.background || [1, 1, 1, 1]; i.clearColor(e[0] / 255, e[1] / 255, e[2] / 255, e[3] / 255) } i.bindFramebuffer(i.FRAMEBUFFER, this.preFramebuffer) }, clearFramebuffer: function () { if (this.pickFBO) { var e = this.gl; e.deleteTexture(this.pickFBO.texture); e.deleteFramebuffer(this.pickFBO) } }, createFramebuffer: function (kC, i) { var kG = this.gl; kC = kC || kG.canvas.width; i = i || kG.canvas.height; var kE = kG.createFramebuffer(); var kD = kG.createTexture(); kG.bindTexture(kG.TEXTURE_2D, kD); kG.texImage2D(kG.TEXTURE_2D, 0, kG.RGBA, kC, i, 0, kG.RGBA, kG.UNSIGNED_BYTE, null); kG.texParameteri(kG.TEXTURE_2D, kG.TEXTURE_MAG_FILTER, kG.LINEAR); kG.texParameteri(kG.TEXTURE_2D, kG.TEXTURE_MIN_FILTER, kG.LINEAR); kG.texParameteri(kG.TEXTURE_2D, kG.TEXTURE_WRAP_S, kG.CLAMP_TO_EDGE); kG.texParameteri(kG.TEXTURE_2D, kG.TEXTURE_WRAP_T, kG.CLAMP_TO_EDGE); kE.texture = kD; var T = kG.createRenderbuffer(); kG.bindRenderbuffer(kG.RENDERBUFFER, T); kG.renderbufferStorage(kG.RENDERBUFFER, kG.DEPTH_STENCIL, kC, i); kE.depthBuffer = T; kG.bindFramebuffer(kG.FRAMEBUFFER, kE); kG.framebufferTexture2D(kG.FRAMEBUFFER, kG.COLOR_ATTACHMENT0, kG.TEXTURE_2D, kD, 0); kG.framebufferRenderbuffer(kG.FRAMEBUFFER, kG.DEPTH_STENCIL_ATTACHMENT, kG.RENDERBUFFER, T); var kF = kG.checkFramebufferStatus(kG.FRAMEBUFFER); if (kG.FRAMEBUFFER_COMPLETE !== kF) { console.log("Frame buffer object is incomplete: " + kF.toString()); this._clearBuffer(kG); return } this._clearBuffer(kG); return kE }, _clearBuffer: function (e) { e.bindFramebuffer(e.FRAMEBUFFER, null); e.bindTexture(e.TEXTURE_2D, null); e.bindRenderbuffer(e.RENDERBUFFER, null) }, loadIconImages: function (kC, kJ) { var kK = kC; var kL = kK.length; var kF = this; var T = 0; var kI = 200; for (var kD = 0; kD < kL; kD++) { var kE = kK[kD]; var e = kE.icon; var kH = e; if (e instanceof HTMLCanvasElement) { kH = e.id; if (!this.iconCache.getData(kH)) { this._addToIconTexture(e); this.iconCache.setData(kH, { loaded: true, image: e }) } continue } T++; if (this.iconCache.getData(kH)) { if (this.iconCache.getData(kH).loaded) { kJ(kC) } continue } var kG = new Image(); kG.id = kH; kG.iconUrl = e; kG.crossOrigin = "anonymous"; kG.onload = function () { if (kF.iconCache.getData(this.id)) { kF.iconCache.getData(this.id).loaded = true; kF._addToIconTexture(this) } if (!kF._iconLoadTimer) { kF._iconLoadTimer = setTimeout(function () { kJ(kC); kF._iconLoadTimer = null }, kI) } this.onload = null }; kG.onerror = function () { if (!kF._iconLoadTimer) { kF._iconLoadTimer = setTimeout(function () { kJ(kC); kF._iconLoadTimer = null }, kI) } kF.iconCache.removeData(this.id); this.onerror = null }; kG.src = e; this.iconCache.setData(kH, { loaded: false, image: kG }) } kJ(kC) }, _addToIconTexture: function (kE) { if (!this.map._webglMapScene) { return } var kG = this.map._webglMapScene._painter; var e = kG._iconTextureAtlas.addTexture(kE); if (e === false) { this.map.fire(new fW("onlayer_clear")); return } if (!e) { return } kG._iconTextureAtlasOffset[kE.id] = e; var kJ = 0 * kE.width / 1024 + e.width; var kD = 0 * kE.height / 1024 + e.height; var kI = kE.width / 1024 + e.width; var kC = kD; var kH = kI; var T = kE.height / 1024 + e.height; var kF = kJ; var i = T; kG._iconTextureAtlasCoords[kE.id] = [kJ, kD, kI, kC, kH, T, kF, i] } }); var hX = (function () { function kI(k9, le, la, lb, lg) { la = la || 2; var lc = le && le.length; var k7 = lc ? le[0] * la : k9.length; var ld = kX(k9, 0, k7, la, true); var k6 = lg || []; if (!ld) { return k6 } var k5; var k4; var k3; var k2; var lh; var lf; var li; lb = lb || 0; if (lc) { ld = kR(k9, le, ld, la) } if (k9.length > 80 * la) { k5 = k3 = k9[0]; k4 = k2 = k9[1]; for (var k8 = la; k8 < k7; k8 += la) { lh = k9[k8]; lf = k9[k8 + 1]; if (lh < k5) { k5 = lh } if (lf < k4) { k4 = lf } if (lh > k3) { k3 = lh } if (lf > k2) { k2 = lf } } li = Math.max(k3 - k5, k2 - k4) } T(ld, k6, la, k5, k4, li, null, lb); return k6 } function kX(k6, k8, k2, k7, k3) { var k4; var k5; if (k3 === (k1(k6, k8, k2, k7) > 0)) { for (k4 = k8; k4 < k2; k4 += k7) { k5 = kF(k4, k6[k4], k6[k4 + 1], k5) } } else { for (k4 = k2 - k7; k4 >= k8; k4 -= k7) { k5 = kF(k4, k6[k4], k6[k4 + 1], k5) } } if (k5 && kL(k5, k5.next)) { kT(k5); k5 = k5.next } return k5 } function kP(k5, k2) { if (!k5) { return k5 } if (!k2) { k2 = k5 } var k4 = k5; var k3; do { k3 = false; if (!k4.steiner && (kL(k4, k4.next) || kV(k4.prev, k4, k4.next) === 0)) { kT(k4); k4 = k2 = k4.prev; if (k4 === k4.next) { return null } k3 = true } else { k4 = k4.next } } while (k3 || k4 !== k2); return k2 } function T(k3, k5, k8, k6, k2, lc, lb, k9) { if (!k3) { return } if (!lb && lc) { kK(k3, k6, k2, lc) } var la = k3; var k4; var k7; while (k3.prev !== k3.next) { k4 = k3.prev; k7 = k3.next; if (lc ? k0(k3, k6, k2, lc) : kS(k3)) { k5.push(k4.i / k8 + k9); k5.push(k3.i / k8 + k9); k5.push(k7.i / k8 + k9); kT(k3); k3 = k7.next; la = k7.next; continue } k3 = k7; if (k3 === la) { if (!lb) { T(kP(k3), k5, k8, k6, k2, lc, 1, k9) } else { if (lb === 1) { k3 = kO(k3, k5, k8, k9); T(k3, k5, k8, k6, k2, lc, 2, k9) } else { if (lb === 2) { kN(k3, k5, k8, k6, k2, lc, k9) } } } break } } } function kS(k4) { var k3 = k4.prev; var k2 = k4; var k6 = k4.next; if (kV(k3, k2, k6) >= 0) { return false } var k5 = k4.next.next; while (k5 !== k4.prev) { if (kM(k3.x, k3.y, k2.x, k2.y, k6.x, k6.y, k5.x, k5.y) && kV(k5.prev, k5, k5.next) >= 0) { return false } k5 = k5.next } return true } function k0(k7, k8, k6, le) { var lb = k7.prev; var la = k7; var k9 = k7.next; if (kV(lb, la, k9) >= 0) { return false } var lf = lb.x < la.x ? (lb.x < k9.x ? lb.x : k9.x) : (la.x < k9.x ? la.x : k9.x); var lc = lb.y < la.y ? (lb.y < k9.y ? lb.y : k9.y) : (la.y < k9.y ? la.y : k9.y); var k5 = lb.x > la.x ? (lb.x > k9.x ? lb.x : k9.x) : (la.x > k9.x ? la.x : k9.x); var k4 = lb.y > la.y ? (lb.y > k9.y ? lb.y : k9.y) : (la.y > k9.y ? la.y : k9.y); var k3 = e(lf, lc, k8, k6, le); var ld = e(k5, k4, k8, k6, le); var k2 = k7.nextZ; while (k2 && k2.z <= ld) { if (k2 !== k7.prev && k2 !== k7.next && kM(lb.x, lb.y, la.x, la.y, k9.x, k9.y, k2.x, k2.y) && kV(k2.prev, k2, k2.next) >= 0) { return false } k2 = k2.nextZ } k2 = k7.prevZ; while (k2 && k2.z >= k3) { if (k2 !== k7.prev && k2 !== k7.next && kM(lb.x, lb.y, la.x, la.y, k9.x, k9.y, k2.x, k2.y) && kV(k2.prev, k2, k2.next) >= 0) { return false } k2 = k2.prevZ } return true } function kO(k8, k4, k7, k6) { var k5 = k8; do { var k3 = k5.prev; var k2 = k5.next.next; if (!kL(k3, k2) && i(k3, k5, k5.next, k2) && kW(k3, k2) && kW(k2, k3)) { k4.push(k3.i / k7 + k6); k4.push(k5.i / k7 + k6); k4.push(k2.i / k7 + k6); kT(k5); kT(k5.next); k5 = k8 = k2 } k5 = k5.next } while (k5 !== k8); return k5 } function kN(k2, k4, k6, k5, k3, lb, k7) { var la = k2; do { var k9 = la.next.next; while (k9 !== la.prev) { if (la.i !== k9.i && kU(la, k9)) { var k8 = kJ(la, k9); la = kP(la, la.next); k8 = kP(k8, k8.next); T(la, k4, k6, k5, k3, lb, null, k7); T(k8, k4, k6, k5, k3, lb, null, k7); return } k9 = k9.next } la = la.next } while (la !== k2) } function kR(k4, lb, k7, k6) { var k8 = []; var k5; var k9; var k2; var k3; var la; for (k5 = 0, k9 = lb.length; k5 < k9; k5++) { k2 = lb[k5] * k6; k3 = k5 < k9 - 1 ? lb[k5 + 1] * k6 : k4.length; la = kX(k4, k2, k3, k6, false); if (la === la.next) { la.steiner = true } k8.push(kG(la)) } k8.sort(kH); for (k5 = 0; k5 < k8.length; k5++) { kE(k8[k5], k7); k7 = kP(k7, k7.next) } return k7 } function kH(k3, k2) { return k3.x - k2.x } function kE(k4, k3) { k3 = kY(k4, k3); if (k3) { var k2 = kJ(k3, k4); kP(k2, k2.next) } } function kY(k2, k6) { var k3 = k6; var k8 = k2.x; var k7 = k2.y; var k5 = -Infinity; var k4; do { if (k7 <= k3.y && k7 >= k3.next.y) { var lb = k3.x + (k7 - k3.y) * (k3.next.x - k3.x) / (k3.next.y - k3.y); if (lb <= k8 && lb > k5) { k5 = lb; if (lb === k8) { if (k7 === k3.y) { return k3 } if (k7 === k3.next.y) { return k3.next } } k4 = k3.x < k3.next.x ? k3 : k3.next } } k3 = k3.next } while (k3 !== k6); if (!k4) { return null } if (k8 === k5) { return k4.prev } var la = k4; var le = k4.x; var lc = k4.y; var ld = Infinity; var k9; k3 = k4.next; while (k3 !== la) { if (k8 >= k3.x && k3.x >= le && kM(k7 < lc ? k8 : k5, k7, le, lc, k7 < lc ? k5 : k8, k7, k3.x, k3.y)) { k9 = Math.abs(k7 - k3.y) / (k8 - k3.x); if ((k9 < ld || (k9 === ld && k3.x > k4.x)) && kW(k3, k2)) { k4 = k3; ld = k9 } } k3 = k3.next } return k4 } function kK(k6, k2, k5, k3) { var k4 = k6; do { if (k4.z === null) { k4.z = e(k4.x, k4.y, k2, k5, k3) } k4.prevZ = k4.prev; k4.nextZ = k4.next; k4 = k4.next } while (k4 !== k6); k4.prevZ.nextZ = null; k4.prevZ = null; kD(k4) } function kD(k8) { var k5; var k4; var k3; var k7; var k9; var k2; var la; var k6; var lb = 1; do { k4 = k8; k8 = null; k9 = null; k2 = 0; while (k4) { k2++; k3 = k4; la = 0; for (k5 = 0; k5 < lb; k5++) { la++; k3 = k3.nextZ; if (!k3) { break } } k6 = lb; while (la > 0 || (k6 > 0 && k3)) { if (la === 0) { k7 = k3; k3 = k3.nextZ; k6-- } else { if (k6 === 0 || !k3) { k7 = k4; k4 = k4.nextZ; la-- } else { if (k4.z <= k3.z) { k7 = k4; k4 = k4.nextZ; la-- } else { k7 = k3; k3 = k3.nextZ; k6-- } } } if (k9) { k9.nextZ = k7 } else { k8 = k7 } k7.prevZ = k9; k9 = k7 } k4 = k3 } k9.nextZ = null; lb *= 2 } while (k2 > 1); return k8 } function e(k3, k6, k2, k5, k4) { k3 = 32767 * (k3 - k2) / k4; k6 = 32767 * (k6 - k5) / k4; k3 = (k3 | (k3 << 8)) & 16711935; k3 = (k3 | (k3 << 4)) & 252645135; k3 = (k3 | (k3 << 2)) & 858993459; k3 = (k3 | (k3 << 1)) & 1431655765; k6 = (k6 | (k6 << 8)) & 16711935; k6 = (k6 | (k6 << 4)) & 252645135; k6 = (k6 | (k6 << 2)) & 858993459; k6 = (k6 | (k6 << 1)) & 1431655765; return k3 | (k6 << 1) } function kG(k4) { var k3 = k4; var k2 = k4; do { if (k3.x < k2.x) { k2 = k3 } k3 = k3.next } while (k3 !== k4); return k2 } function kM(k6, k5, k8, k7, k2, k9, k4, k3) { return (k2 - k4) * (k5 - k3) - (k6 - k4) * (k9 - k3) >= 0 && (k6 - k4) * (k7 - k3) - (k8 - k4) * (k5 - k3) >= 0 && (k8 - k4) * (k9 - k3) - (k2 - k4) * (k7 - k3) >= 0 } function kU(k3, k2) { return k3.next.i !== k2.i && k3.prev.i !== k2.i && !kQ(k3, k2) && kW(k3, k2) && kW(k2, k3) && kC(k3, k2) } function kV(k4, k3, k2) { return (k3.y - k4.y) * (k2.x - k3.x) - (k3.x - k4.x) * (k2.y - k3.y) } function kL(k3, k2) { return k3.x === k2.x && k3.y === k2.y } function i(k4, k2, k3, k5) { if ((kL(k4, k2) && kL(k3, k5)) || (kL(k4, k5) && kL(k3, k2))) { return true } return kV(k4, k2, k3) > 0 !== kV(k4, k2, k5) > 0 && kV(k3, k5, k4) > 0 !== kV(k3, k5, k2) > 0 } function kQ(k3, k2) { var k4 = k3; do { if (k4.i !== k3.i && k4.next.i !== k3.i && k4.i !== k2.i && k4.next.i !== k2.i && i(k4, k4.next, k3, k2)) { return true } k4 = k4.next } while (k4 !== k3); return false } function kW(k3, k2) { return kV(k3.prev, k3, k3.next) < 0 ? kV(k3, k2, k3.next) >= 0 && kV(k3, k3.prev, k2) >= 0 : kV(k3, k2, k3.prev) < 0 || kV(k3, k3.next, k2) < 0 } function kC(k4, k3) { var k7 = k4; var k2 = false; var k6 = (k4.x + k3.x) / 2; var k5 = (k4.y + k3.y) / 2; do { if (((k7.y > k5) !== (k7.next.y > k5)) && (k6 < (k7.next.x - k7.x) * (k5 - k7.y) / (k7.next.y - k7.y) + k7.x)) { k2 = !k2 } k7 = k7.next } while (k7 !== k4); return k2 } function kJ(k4, k3) { var k2 = new kZ(k4.i, k4.x, k4.y); var k5 = new kZ(k3.i, k3.x, k3.y); var k7 = k4.next; var k6 = k3.prev; k4.next = k3; k3.prev = k4; k2.next = k7; k7.prev = k2; k5.next = k2; k2.prev = k5; k6.next = k5; k5.prev = k6; return k5 } function kF(k3, k2, k6, k4) { var k5 = new kZ(k3, k2, k6); if (!k4) { k5.prev = k5; k5.next = k5 } else { k5.next = k4.next; k5.prev = k4; k4.next.prev = k5; k4.next = k5 } return k5 } function kT(k2) { k2.next.prev = k2.prev; k2.prev.next = k2.next; if (k2.prevZ) { k2.prevZ.nextZ = k2.nextZ } if (k2.nextZ) { k2.nextZ.prevZ = k2.prevZ } } function kZ(k3, k2, k4) { this.i = k3; this.x = k2; this.y = k4; this.prev = null; this.next = null; this.z = null; this.prevZ = null; this.nextZ = null; this.steiner = false } kI.deviation = function (k7, lc, k9, k4) { var la = lc && lc.length; var k6 = la ? lc[0] * k9 : k7.length; var k3 = Math.abs(k1(k7, 0, k6, k9)); if (la) { for (var k8 = 0, lb = lc.length; k8 < lb; k8++) { var k2 = lc[k8] * k9; var k5 = k8 < lb - 1 ? lc[k8 + 1] * k9 : k7.length; k3 -= Math.abs(k1(k7, k2, k5, k9)) } } var lg = 0; for (k8 = 0; k8 < k4.length; k8 += 3) { var lf = k4[k8] * k9; var le = k4[k8 + 1] * k9; var ld = k4[k8 + 2] * k9; lg += Math.abs((k7[lf] - k7[ld]) * (k7[le + 1] - k7[lf + 1]) - (k7[lf] - k7[le]) * (k7[ld + 1] - k7[lf + 1])) } return k3 === 0 && lg === 0 ? 0 : Math.abs((lg - k3) / k3) }; function k1(k6, k8, k2, k7) { var k5 = 0; for (var k4 = k8, k3 = k2 - k7; k4 < k2; k4 += k7) { k5 += (k6[k3] - k6[k4]) * (k6[k4 + 1] + k6[k3 + 1]); k3 = k4 } return k5 } kI.flatten = function (k6) { var k7 = k6[0][0].length; var k2 = { vertices: [], holes: [], dimensions: k7 }; var k4 = 0; for (var k5 = 0; k5 < k6.length; k5++) { for (var k3 = 0; k3 < k6[k5].length; k3++) { for (var k8 = 0; k8 < k7; k8++) { k2.vertices.push(k6[k5][k3][k8]) } } if (k5 > 0) { k4 += k6[k5 - 1].length; k2.holes.push(k4) } } return k2 }; return kI })(); function cL(i, e) { this.id = gj(); this.workerPool = i; this.actors = []; this.currentActorIndex = 0; this.ready = false; this.init(e) } cL.prototype.init = function (kE) { const e = this.workerPool.acquire(this.id); for (var kC = 0; kC < e.length; kC++) { const kF = e[kC]; const kD = new jQ(kF, kE, this.id); kD.name = "Worker " + kC; this.actors.push(kD) } var T = this; this.broadcast("hasReady", null, function () { T.ready = true }) }; cL.prototype.broadcast = function (i, T, e) { e = e || function () { }; m(this.actors, function (kD, kC) { kD.send(i, T, kC) }, e) }; cL.prototype.getActor = function () { const e = this.actors.filter(function (i) { return !i.busy })[0]; if (e) { return e } this.currentActorIndex = (this.currentActorIndex + 1) % this.actors.length; return this.actors[this.currentActorIndex] }; cL.prototype.stop = function () { for (var e = 0; e < this.actors.length; e++) { var T = this.actors[e]; T.stop() } }; cL.prototype.remove = function () { for (var e = 0; e < this.actors.length; e++) { var T = this.actors[e]; T.remove() } this.actors.length = 0; this.workerPool.release(this.id) }; function jQ(T, i, e) { this.target = T; this.parent = i; this.mapId = e; this.busy = false; this.taskQueue = []; this.callbacks = {}; this.init() } jQ.prototype.init = function () { this.receive = this.receive.bind(this); this.target.addEventListener("message", this.receive, false) }; jQ.prototype.setBusy = function (e) { this.busy = e; if (!e && this.taskQueue.length) { var i = this.taskQueue.shift(); this.send(i.action, i.data, i.callback, i.targetMapId, i.mustQueue, i.callbackMetadata) } }; jQ.prototype.receive = function (kC) { const kD = kC.data; const kG = kD.id; if (!kG) { return } if (kD.targetMapId && this.mapId !== kD.targetMapId) { return } if (kD.action === "<response>") { this.setBusy(false); const kF = this.callbacks[kG]; delete this.callbacks[kG]; if (kF) { if (kD.error) { kF(ix(kD.error)) } else { kF(null, ix(kD.data)) } } } else { var T = this; const i = []; const e = kD.hasCallback ? function (kH, kI) { T.target.postMessage({ id: kG, action: "<response>", sourceMapId: T.mapId, error: kH ? jR(kH) : null, data: jR(kI, i) }, i) } : function (kH) { }; const kE = ix(kD.data); if (this.parent[kD.action]) { this.parent[kD.action](kD.sourceMapId, kE, e) } } }; jQ.prototype.send = function (i, T, kF, kC, kD, kG) { if (i === "release") { this.releasePendingData(T, kF); return } if (this.busy) { this.taskQueue.push({ action: i, data: T, callback: kF, targetMapId: kC, mustQueue: kD, callbackMetadata: kG }); return } this.setBusy(true); var kE = Math.round((Math.random() * 1000000000000000000)).toString(36).substring(0, 10); const e = this.mapId + "_" + i + "_" + kE; if (kF) { kF.metadata = kG; this.callbacks[e] = kF } const kH = []; this.target.postMessage({ id: e, action: i, hasCallback: !!kF, targetMapId: kC, mustQueue: kD, sourceMapId: this.mapId, data: jR(T, kH) }, kH); return { cancel: function () { if (kF) { delete this.callbacks[e] } this.target.postMessage({ id: e, action: "<cancel>", targetMapId: kC, sourceMapId: this.mapId }) } } }; jQ.prototype.stop = function () { this.taskQueue.length = 0; this.busy = false; this.callbacks = {} }; jQ.prototype.remove = function () { this.taskQueue.length = 0; this.busy = false; this.target.removeEventListener("message", this.receive, false) }; jQ.prototype.releasePendingData = function (e, kF) { var T = []; var kD = this.taskQueue; for (var kC = kD.length - 1; kC >= 0; kC--) { var kE = kD[kC]["data"]; if (!kE || !kE.layerId) { break } if (kE.layerId !== e.layerId) { continue } if (!e["id_" + kE.x + "_" + kE.y + "_" + kE.z]) { kD.splice(kC, 1); T.push(kE) } } kF(null, T) }; var ks; function hF() { if (!ks) { ks = new hL() } return ks } function hL() { this.active = {} } hL.prototype.acquire = function (i) { if (!this.workers) { this.workers = []; var T = (window.location.protocol === "http:" ? "http:" : "https:") + "//api.map.baidu.com/res/webgl/10/worker_mvt_x1f24l.js"; while (this.workers.length < hL.workerCount) { var e = ka(T); this.workers.push(e) } } this.active[i] = true; return this.workers.slice() }; hL.prototype.release = function (T) { delete this.active[T]; if (this.numActive() === 0) { for (var e = 0; e < this.workers.length; e++) { this.workers[e].terminate() } this.workers = null } }; hL.prototype.numActive = function () { return Object.keys(this.active).length }; hL.workerCount = 2; function hM(e) { this._map = e; this._spotsId = {}; this._init() } hM.prototype._init = function () { var i = this._map; var e = this; i.addEventListener("onspotsdataready", function (kC) { var T = kC.spots; if (e._spotsId[kC.index]) { i.removeSpots(e._spotsId[kC.index]) } e._spotsId[kC.index] = i.addSpots(T) }); i.addEventListener("onspotsdataremove", function (T) { if (e._spotsId[T.index]) { i.removeSpots(e._spotsId[T.index]) } }) }; bG.register(function (e) { if (!e.config.enableIconClick) { return } e._mapIcon = new hM(e) }); function dg(e) { this._indoorData = {}; this._map = e; this.currentUid = null; this.currentFloor = null; this._indoorControl = null; this.enterMethod = null; this.showMask = true; this._isMobile = b5(); this._autoEnterZoom = 19; if (this._isMobile) { this._autoEnterZoom = 17 } this._init(e); window._indoorMgr = this } dg.prototype._init = function (i) { var e = this; i.on("indoor_status_changed", function (kF) { var T = kF.uid; var kD = kF.floor; if (T === null) { T = e.currentUid; if (e._indoorData[T]) { kD = e._indoorData[T].defaultFloor } if (e._indoorControl) { e._indoorControl.hide() } e.currentUid = null; e.currentFloor = null; e.enterMethod = null } else { if (e._indoorData[T]) { var kE = e._indoorData[T]; kD = (typeof kD === "number") ? kD : kE.defaultFloor; if (!e._indoorControl) { if ((i.config.showControls || i.config.indoorControl) && i._displayOptions.indoor) { e._indoorControl = new ax(i, kE) } } else { e._indoorControl.setInfo(kE); e._indoorControl.show() } e.currentUid = T; e.currentFloor = kD } } if (!e._indoorData || !e._indoorData[T] || e._indoorData[T].currentFloor === kD) { this.fire(new fW("onrefresh")); return } var kC = new fW("onindoor_data_refresh"); kC.uid = T; kC.floor = kD; kC.tileKey = e._indoorData[T].tileKey; e._indoorData[T].currentFloor = kD; e.currentFloor = kD; this.fire(kC); hQ.sendMessage(a1(4, 3, 4), ["layer", "indoor"]) }); i.on("spotclick", function (kC) { var T = null; if (kC.curAreaSpot && this.areaSpots[kC.curAreaSpot]) { T = this.areaSpots[kC.curAreaSpot].userData.uid } if (T === e.currentUid) { if (kC.curAreaSpot) { e.enterMethod = "byClick" } return } if (T === null) { if (e.currentUid && e.enterMethod === "byClick") { i.showIndoor(null); e.enterMethod = null } } else { e.enterMethod = "byClick"; if (e.currentUid) { i.showIndoor(e.currentUid, e._indoorData[e.currentUid].defaultFloor) } i.showIndoor(T, e._indoorData[T].defaultFloor) } }); i.on("moveend", function () { if (this.getZoom() >= e._autoEnterZoom) { e._checkIndoorByMove() } }); i.on("zoomend", function () { if (this.getZoom() >= e._autoEnterZoom) { e._checkIndoorByMove() } else { if (e.enterMethod !== "byClick" && e.currentUid !== null) { this.showIndoor(null) } } }) }; dg.prototype._checkIndoorByMove = function () { var T = this._map; var kI = T.getSize(); var kN = { x: kI.width / 2, y: kI.height / 2 }; var kM = Math.max(kI.width, kI.height); var kO = []; for (var kJ in this._indoorData) { var e = this._indoorData[kJ].center; var kC = T.pointToPixelIn(new bG.Point(e[0], e[1])); var kF = cr(kN, kC); kO.push({ uid: kJ, distance: kF }) } if (kO.length === 0) { return } kO.sort(function (kP, i) { return kP.distance - i.distance }); var kE = kO[0]; var kK = T.getCenterIn(); var kD = false; for (var kH = 0; kH < this._indoorData[kE.uid].contour.length; kH++) { if (bT([kK.lng, kK.lat], this._indoorData[kE.uid].contour[kH])) { kD = true; break } } if (kD === false && kE.uid === "e96b44200baa3b4082288acc") { var kG = this._indoorData[kE.uid].boundsMin; var kL = this._indoorData[kE.uid].boundsMax; if (kK.lng > kG[0] && kK.lat > kG[1] && kK.lng < kL[0] && kK.lat < kL[1]) { kD = true } } if (kD) { if (this.enterMethod !== "byClick") { if (this.currentUid !== null && this.currentUid !== kE.uid) { this._map.showIndoor(this.currentUid, this._indoorData[this.currentUid].defaultFloor) } if (this.currentUid !== kE.uid) { this._map.showIndoor(kE.uid, this._indoorData[kE.uid].defaultFloor) } this.enterMethod = "byMove" } } else { if (this.enterMethod !== "byClick") { this._map.showIndoor(null) } } }; dg.prototype.setData = function (kC) { if (kC === null) { return } for (var T in kC) { if (T === "tileInfo") { continue } var kD = kC[T].tileKey; if (this._indoorData[T]) { if (!this._indoorData[T][kD]) { this._indoorData[T].tileKeys.push(kD); this._indoorData[T][kD] = true } } else { this._indoorData[T] = kC[T]; this._indoorData[T].tileKeys = [kC[T].tileKey]; this._indoorData[T][kD] = true; for (var e = 0; e < this._indoorData[T].contour.length; e++) { this._map.addAreaSpot(this._indoorData[T].contour[e], { id: T + e, userData: { uid: T } }) } } } if (this._map.getZoom() >= this._autoEnterZoom) { this._checkIndoorByMove() } }; dg.prototype.removeData = function (T, kD) { if (!this._indoorData[T]) { return } var kC = this._indoorData[T]; for (var e = 0; e < kC.tileKeys.length; e++) { if (kC.tileKeys[e] === kD) { kC.tileKeys.splice(e, 1); break } } delete kC[kD]; if (kC.tileKeys.length === 0) { delete this._indoorData[T] } }; dg.prototype.getIndoorData = function (e) { return this._indoorData[e] || null }; dg.prototype.getData = function () { return this._indoorData }; bG.register(function (e) { e._indoorMgr = new dg(e) }); var a3 = (function () { var kC = {}; var kL = {}; var kH = {}; function kJ(kN) { if (Object.prototype.toString.call(kN) === "[object Object]") { for (var kM in kN) { return false } return true } else { return false } } function kI(kT, kU, kX, kQ, kW) { var kM = kM || null; kQ = kQ || kM; var kO; if (kX > 21) { kX = 21 } if (kQ) { kO = kK(kT, kU, kX, kQ) } else { kO = T(kT, kU, kX, kW) } var kS = kO.drawId; var kN = kO.style; var kV = kO.styleUpdate; var kY = []; if (!kS) { return kY } for (var kP = 0; kP < kS.length; kP++) { var kR = kV[kS[kP]] || kN[kS[kP]]; if (kR) { switch (kU) { case "polygon": kR = kD(kR, kT); break; case "line": kR = kG(kR, kT); break; case "pointText": kR = kE(kR, kT); break; case "point": kR = e(kR, kT); break; case "polygon3d": kR = kF(kR, kT); break }if (kR) { kR.did = kS[kP]; kY[kY.length] = kR } } } return kY } function kK(kN, kP, kQ, kM) { var kO = kM[2]; switch (kP) { case "point": kO = kO[0]; break; case "pointText": kO = kO[1]; break; case "line": kO = kO[3]; break; case "polygon": kO = kO[4]; break; case "polygon3d": kO = kO[5]; break }var kS = kQ - 1; if (kP === "line" && kQ === 12) { kS = kQ } var kT = kM[1][kS][0]; var kR = kT[kN]; if (!kR && kQ < 21) { if (kP === "point" || kP === "pointText") { kT = kM[1][kQ][0]; kR = kT[kN] } } return { drawId: kR, style: kO, styleUpdate: [] } } function T(kQ, kR, kU, kT) { if (!kT || !kT.baseFs) { return { drawId: null, style: [], styleUpdate: [] } } var kS; var kO = kT.baseFs; if (kJ(kT.zoomRegion)) { kS = kT.StyleBody || [] } else { kS = kT.zoomStyleBody[kU] || [] } var kN = kO[2]; switch (kR) { case "point": kN = kN[0]; kS = kS[0] || {}; break; case "pointText": kN = kN[1]; kS = kS[1] || {}; break; case "line": kN = kN[3]; kS = kS[3] || {}; break; case "polygon": kN = kN[4]; kS = kS[4] || {}; break; case "polygon3d": kN = kN[5]; kS = kS[5] || {}; break }var kM = kO[1][kU - 1][0]; var kP = kM[kQ]; if (!kP && kU < 21) { if (kR === "point" || kR === "pointText") { kM = kO[1][kU][0]; kP = kM[kQ] } } return { drawId: kP, style: kN, styleUpdate: kS } } function kE(kN, kM) { if (!kN || kN.length === 0) { return null } return { sid: kM, fontRgba: i(kN[0]), haloRgba: i(kN[1]), backRgba: i(kN[2]), fontSize: kN[3], haloSize: kN[4], fontWeight: kN[5], fontStyle: kN[6], density: kN[7] } } function e(kO, kM) { var kN = null; if (kO[kO.length - 1] && kO[kO.length - 1] instanceof Array && kO[kO.length - 1][0] === "openmap") { kN = kO[kO.length - 1][1] ? kO[kO.length - 1][1] : null } return { sid: kM, rank: kO[0], ucflag: kO[1], icon: kO[2], iconType: kO[3], nineGG: kO[4], density: kO[5], zoom: kO[6], hue: kN >>> 0 } } function kG(kO, kM) { var kN = null; if (kO[kO.length - 1] && kO[kO.length - 1] instanceof Array && kO[kO.length - 1][0] === "openmap") { kN = kO[kO.length - 1][1] ? kO[kO.length - 1][1] : null } return { sid: kM, borderRgba: i(kO[0]), fillRgba: i(kO[1]), borderWidth: kO[2], fillWidth: kO[3], borderCap: kO[4], fillCap: kO[5], haveBorderLine: kO[6], haveBorderTexture: kO[7], haveFillTexture: kO[8], isUseBorderRgba: kO[9], isUseFillRgba: kO[10], borderTexture: kO[11], fillTexture: kO[12], borderTextureType: kO[13], fillTextureType: kO[14], isRealWidth: kO[15], haveArrow: kO[16], needRound: kO[17], realBorderWidth: kO[18], hue: i(kN) } } function kD(kO, kM) { var kN = null; var kP = null; if (kO[kO.length - 1] && kO[kO.length - 1] instanceof Array && kO[kO.length - 1][0] === "openmap") { kN = kO[kO.length - 1][1] ? kO[kO.length - 1][1] : null; kP = kO[kO.length - 1][2] ? kO[kO.length - 1][2] : null } return { sid: kM, fillRgba: i(kO[0]), borderRgba: i(kO[1]), borderWidth: kO[2], borderTexture: kO[3], borderTextureType: kO[4], waterStyle: kO[5], haloStyle: kO[6], textureStyle: kO[7], thickRgba: i(kO[8]), fillTexture: kP, hue: i(kN) } } function kF(kN, kM) { return { sid: kM, filter: kN[0], ratio: kN[1], haveBorder: kN[2], borderWidth: kN[3], borderRgba: i(kN[4]), fillTop: i(kN[5]), fillSide: i(kN[6]), polyTexture: kN[7] } } function i(kR) { var kQ = kR; if (kH[kQ]) { return kH[kQ] } kR = kR >>> 0; var kP = (kR) & 255; var kO = (kR >> 8) & 255; var kM = (kR >> 16) & 255; var kN = (kR >> 24) & 255; kH[kQ] = [kP, kO, kM, kN]; return kH[kQ] } return { getStyleFromCache: function (kT, kO, kR, kS, kN, kQ, kM) { kT = kT || "default"; var kP = kT + "-" + kO + "-" + kR + "-" + kS; if (kQ) { kP += "-indoor" } if (kN) { if (!kL[kP]) { kL[kP] = kI(kO, kR, kS, kN) } return kL[kP] } if (!kC[kP]) { kC[kP] = kI(kO, kR, kS, kN, kM) } return kC[kP] }, clearStyleFromCache: function () { kC = {}; kL = {} } } })(); bG.register(function (i) { var e = new iw(i) }); function iw(e) { e.container.appendChild(this.render()); this.bind(e) } iw.prototype.render = function () { var i = document.createElement("div"); i.className = "click-ripple-container"; var e = document.createElement("div"); e.className = "click-ripple"; i.appendChild(e); this._div = i; this._ripple = e; return i }; iw.prototype.bind = function (i) { var e = this; i.addEventListener("spotclick", function (T) { if (!T.spots || T.spots.length === 0) { return } e._div.style.left = T.pixel.x + "px"; e._div.style.top = T.pixel.y + "px"; e9.ac(e._ripple, "ripple-playing") }); i.addEventListener("hotclick", function (T) { if (!T || !T.pixel || !(T.pixel instanceof fv)) { return } e._div.style.left = T.pixel.x + "px"; e._div.style.top = T.pixel.y + "px"; e9.ac(e._ripple, "ripple-playing") }); e9.on(e._ripple, "transitionend", function () { e9.rc(e._ripple, "ripple-playing") }) }; function b4(e) { dh.call(this); if (!e) { return } this._opts = {}; this._map = e; this._maxLat = 84.6; this._minLat = -80.6; this._maxLatMC = jy.convertLL2MC(new cA(this._maxLat, 0)).lat; this._minLatMC = jy.convertLL2MC(new cA(this._minLat, 0)).lat } b4.inherits(dh, "ToolbarItem"); e9.extend(b4.prototype, { open: function () { if (this._isOpen == true) { return true } if (this._map._toolInUse) { return false } this._map._toolInUse = true; this._isOpen = true; return true }, close: function () { if (!this._isOpen) { return } this._map._toolInUse = false; this._isOpen = false }, _checkStr: function (e) { if (!e) { return "" } return e.replace(/</g, "&lt;").replace(/>/g, "&gt;") } }); function co(T, i) { b4.call(this, T); i = i || {}; this._opts = e9.extend(e9.extend(this._opts || {}, { autoClear: false, tips: "测距", followText: "单击确定起点，双击结束绘制", unit: "metric", showResult: true, lineColor: "blue", lineStroke: 2, opacity: 1, lineStyle: "solid", cursor: E.distCursor, styleCodes: { lnCode: 0, spCode: 0, slCode: 0, tlCode: 0 }, enableMassClear: true }), i); if (this._opts.showResult === false) { if (typeof i.tips === "undefined") { this._opts.tips = "绘制折线" } if (!i.cursor) { this._opts.cursor = "crosshair" } } if (this._opts.lineStroke <= 0) { this._opts.lineStroke = 2 } if (this._opts.opacity > 1) { this._opts.opacity = 1 } else { if (this._opts.opacity < 0) { this._opts.opacity = 0 } } if (this._opts.lineStyle !== "solid" && this._opts.lineStyle !== "dashed") { this._opts.lineStyle = "solid" } this._checked = false; this._drawing = null; this.followTitle = null; this._totalDis = {}; this._points = []; this._paths = []; this._dots = []; this._segDistance = []; this._overlays = []; this._units = { metric: { name: "metric", conv: 1, incon: 1000, u1: "米", u2: "公里" }, us: { name: "us", conv: 3.2808, incon: 5279.856, u1: "英尺", u2: "英里" } }; if (!this._units[this._opts.unit]) { this._opts.unit = "metric" } this._dLineColor = "#ff6319"; this._dLineStroke = 3; this._dOpacity = 0.8; this._dLineStyle = "solid"; this._dCursor = E.distCursor; if (this._opts.showResult) { this._opts.followText = "单击确定起点" } this._followTextM = "单击确定地点，双击结束"; this._sectionMarkerTip = "单击可删除此点，拖拽可调整位置"; this._movingTimerId = null; if (this._opts.showResult) { this.text = "测距" } else { this.text = "绘线" } this._isOpen = false; var e = this; hm.load("tools", function () { e._draw() }) } co.inherits(b4, "PolylineTItem"); e9.extend(co.prototype, { setLineColor: function (e) { this._opts.lineColor = e }, setLineStroke: function (e) { if (Math.round(e) > 0) { this._opts.lineStroke = Math.round(e) } }, setOpacity: function (e) { if (e >= 0 && e <= 1) { this._opts.opacity = e } }, setLineStyle: function (e) { if (e === "solid" || e === "dashed") { this._opts.lineStyle = e } }, clear: function () { for (var T = 0, e = this._overlays.length; T < e; T++) { if (this._overlays[T]) { this._map.removeOverlay(this._overlays[T]) } } this._overlays.length = 0; for (var T = 0, e = this._dots.length; T < e; T++) { if (this._dots[T] && this._dots[T].parentNode) { this._dots[T].parentNode.removeChild(this._dots[T]) } } this._dots.length = 0 }, setCursor: function (e) { if (this._opts.showResult === true) { return } this._opts.cursor = e }, getCursor: function () { if (this._opts.showResult === true) { return this._dCursor } var e = this._opts.cursor.match(/^url\((.+)\)(,.*)?/); if (e !== null) { return e[1] } else { return this._opts.cursor } }, showResult: function (e) { this._opts.showResult = !!e } }); function bL() { var kD = 3; var kK = 256; var kC = Math.pow(2, 18 - kD) * kK; var kL = 2; var kJ = (kL + 1) * kC; var T = jy.convertLL2MC(new cG(180, 0)); var kH = T.lng; var kF = kJ - kH; var kI = -3; var e = kI * kC; var kE = jy.convertLL2MC(new cG(-180, 0)); var kG = kE.lng; var i = kG - e; this._validPixels = kH / Math.pow(2, 18 - kD); this._mc180X = kH; this._mcM180X = kG; this._loopOffset = kF + i; this._mcTSpan = kH - kG; this._spaceDistance = kF; this._mSpaceDistance = i } bL.prototype = { calcLoopParam: function (kC, i, kJ) { kJ = kJ || 256; var kG = 0; var kD = 3; var kF = 6; var kE = kF * Math.pow(2, (i - kD)) * 256 / kJ; var kI = kE / 2 - 1; var kH = -kE / 2; while (kC > kI) { kC -= kE; kG -= this._loopOffset } while (kC < kH) { kC += kE; kG += this._loopOffset } var e = kG; kG = Math.round(kG / Math.pow(2, 18 - i)); return { offsetX: kG, geoOffsetX: e, col: kC, T: kE, maxCol: kI, minCol: kH } }, calcLoopCenterPoint: function (i) { var e = i.lng; while (e > this._mc180X) { e -= this._mcTSpan } while (e < this._mcM180X) { e += this._mcTSpan } i.lng = e; return i }, calcLoopMapBounds: function (T, kC) { var i = kC || T.getCenter(); var e = T.sw.lng; var kD = T.ne.lng; while (i.lng > this._mc180X) { i.lng -= this._mcTSpan; e -= this._mcTSpan; kD -= this._mcTSpan } while (i.lng < this._mcM180X) { i.lng += this._mcTSpan; e += this._mcTSpan; kD += this._mcTSpan } T.sw.lng = e; T.ne.lng = kD; if (T.pointBottomLeft) { T.pointBottomLeft = this.calcLoopCenterPoint(T.pointBottomLeft); T.pointTopLeft = this.calcLoopCenterPoint(T.pointTopLeft); T.pointTopRight = this.calcLoopCenterPoint(T.pointTopRight); T.pointBottomRight = this.calcLoopCenterPoint(T.pointBottomRight) } return T }, calcLoopTiles: function (kK, e, kO, kH) { kO = kO || 256; var kD = kH || Math.pow(2, 18 - e) * kO; var kJ = Math.floor(this._mc180X / kD); var kF = Math.floor(this._mcM180X / kD); var kL = Math.floor(this._loopOffset / kD); var kM = []; for (var kG = 0; kG < kK.length; kG++) { var kN = kK[kG]; var kC = kN[0]; var kP = kN[1]; if (kC >= kJ) { var kI = kC + kL; if (this.isTileBlank(kI, e, kO) === true) { continue } var T = "id_" + kI + "_" + kP + "_" + e; if (!kK[T]) { kK[T] = true; kM.push([kI, kP, e, 0]) } } else { if (kC <= kF) { var kI = kC - kL; if (this.isTileBlank(kI, e, kO) === true) { continue } var T = "id_" + kI + "_" + kP + "_" + e; if (!kK[T]) { kK[T] = true; kM.push([kI, kP, e, 0]) } } } } for (var kG = 0, kE = kM.length; kG < kE; kG++) { kK.push(kM[kG]) } for (var kG = kK.length - 1; kG >= 0; kG--) { var kC = kK[kG][0]; if (this.isTileBlank(kC, e, kO)) { kK.splice(kG, 1) } } return kK }, isTileBlank: function (T, kD, e) { var kE = Math.pow(2, kD - 3); var i = Math.round(this._validPixels * kE); var kC = 6 * kE * 256 / e; while (T > kC / 2 - 1) { T -= kC } while (T < -(kC / 2)) { T += kC } if (T > 0 && T * e > i) { return true } if (T < 0 && Math.abs((T + 1) * e) > i) { return true } return false }, isAddWidth: function (e, i) { return e < this._mcM180X || i > this._mc180X }, pixelWidth: function (e, i) { if (e < 0) { e = -e } return Math.abs(e - this._mc180X) / (Math.pow(2, 18 - i)) }, getSpaceDistanceInPixel: function (i) { var e = Math.round((this._spaceDistance + this._mSpaceDistance) / Math.pow(2, 18 - i)); return e } }; var fc = new bL(); function eA() { this._id = undefined; this._type = undefined; this.grid = undefined; this.layerName = undefined; this.geojson = undefined; this._geometry = null; this._properties = {}; this._box = null; this._state = {}; this._style = null; this._visible = true; this.renderData = {}; return this } eA.prototype.serialize = function () { return { id: this.getId(), type: this.getType(), grid: this.grid, layerName: this.layerName, geojson: this.geojson, renderData: this.renderData, geometry: this.getGeometry(), box: this.getBox(), properties: this.getProperties(), state: this.getState(), visible: this._visible } }; eA.prototype.deserialize = function (kD) { this.setId(kD.id); this.setType(kD.type); this.grid = kD.grid; this.layerName = kD.layerName; this.geojson = kD.geojson; this.setProperties(kD.properties); this.setState(kD.state); this._visible = kD.visible || true; this.renderData = kD.renderData; this.setGeometry(kD.geometry); this.setBox(kD.box); if (this.geojson.geometry && this.geojson.geometry["type"] === "MultiPolygon") { for (var T = 0; T < this._geometry.length; T++) { if (this._geometry[T][0] instanceof Array) { for (var e in this.renderData) { var kC = this.renderData[e]; if (kC.fill && kC.fill[T]) { kC.fill[T]["hasMultipleParts"] = true } } } } } if (this.geojson.geometry && this.geojson.geometry["type"] === "Polygon") { for (var T = 0; T < this._geometry.length; T++) { if (this._geometry[T] instanceof Array) { for (var e in this.renderData) { var kC = this.renderData[e]; if (kC.fill && kC.fill[T]) { kC.fill[T]["hasMultipleParts"] = true } } } } } return this }; eA.prototype.getType = function () { return this._type }; eA.prototype.getGeometry = function () { return this._geometry }; eA.prototype.getId = function () { return this._id }; eA.prototype.getProperties = function () { return this._properties }; eA.prototype.getBox = function () { return this._box }; eA.prototype.getState = function () { if (Object.keys(this._state).length > 0) { return this._state } else { return null } }; eA.prototype.getStyle = function () { return this._style }; eA.prototype.getStyleFunction = function () { return this._styleFunction }; eA.prototype.setType = function (e) { return this._type = e }; eA.prototype.setGeometry = function (e) { this._geometry = e }; eA.prototype.setStyle = function (e) { if (!e || Object.keys(e).length === 0) { return } for (var i in e) { this.set(i, e[i], this._style) } }; eA.prototype.setState = function (e) { for (var i in e) { this.set(i, e[i], this._state) } }; eA.prototype.setId = function (e) { this._id = e }; eA.prototype.setProperties = function (e) { for (var i in e) { this.set(i, e[i], this._properties) } }; eA.prototype.setBox = function (e) { return this._box = e }; eA.prototype.isPointInBox = function (e) { return this._pointInBox(e, this._box) }; eA.prototype.getPointGeoJSON = function (kC) { var kL = this.renderData; if (kL) { var kF = kL.active; if (!kL[kF] || !kL[kF]["poi"]) { return null } var kK = []; var kH = kL[kF]["poi"]; for (var kI = 0; kI < kH.length; kI++) { if (kH[kI].bds && kH[kI].bds.length === 4) { var kD = kC.pointToPixelIn(kH[kI].pt); var kG = kD.x - kH[kI].bds[0]; var kE = kD.y - kH[kI].bds[1]; var T = kD.x - kH[kI].bds[2]; var e = kD.y - kH[kI].bds[3]; kK.push([[kG, kE], [T, kE], [T, e], [kG, e], [kG, kE]]) } } if (kK.length === 0) { return null } else { var kJ = "Polygon"; if (kK.length > 0) { kJ = "MultiPolygon" } return { type: "Feature", properties: {}, geometry: { type: kJ, coordinates: [kK] } } } } }; eA.prototype._pointInBox = function (e, i) { if (i[0] > e[0] || i[1] > e[1] || i[2] < e[0] || i[3] < e[1]) { return false } else { return true } }; eA.prototype._pixelPnpoint = function (kD, kH, e) { var kI = false; if (kH) { var kC = kH.active; if (!kH[kC] || !kH[kC]["poi"]) { return kI } var kE = kH[kC]["poi"]; for (var kF = 0; kF < kE.length; kF++) { if (kE[kF].bds && kE[kF].bds.length === 4) { var T = e.pointToPixelIn(kE[kF].pt); if ((kD.x - T.x < kE[kF].bds[2] && kD.x - T.x > kE[kF].bds[0]) && (T.y - kD.y < kE[kF].bds[3] && T.y - kD.y > kE[kF].bds[1])) { if (e.getTilt() > 55) { var kG = e.pointToOverlayPixelIn(kE[kF].pt); if (kG.outOfFrustum) { continue } } kI = true; break } } } } return kI }; eA.prototype._pixelPnpoly = function (kD, kF) { var e = kF.length; var T = 0; var kE = false; for (var kC = 0; kC < e; kC++) { T = (kC === e - 1) ? 0 : T + 1; if ((kF[kC].lat !== kF[T].lat) && (((kD.lat >= kF[kC].lat) && (kD.lat < kF[T].lat)) || ((kD.lat >= kF[T].lat) && (kD.lat < kF[kC].lat))) && (kD.lng < (kF[T].lng - kF[kC].lng) * (kD.lat - kF[kC].lat) / (kF[T].lat - kF[kC].lat) + kF[kC].lng)) { kE = !kE } } return kE }; eA.prototype._getProximity = function (kM, kI) { var T, kC, kL, kG, kF, kK, kJ; var kP = kI.length; if (kP > 1) { for (var kN = 1; kN < kP; kN++) { var kH = kI[kN - 1]; var kT = kI[kN]; if (!kH || !kT) { continue } if (kH.lng != kT.lng) { var kS = (kT.lat - kH.lat) / (kT.lng - kH.lng); var kQ = kT.lat - kS * kT.lng; kJ = Math.abs(kS * kM.lng + kQ - kM.lat) / Math.sqrt(kS * kS + 1) } else { kJ = Math.abs(kM.lng - kT.lng) } var kO = Math.pow(kT.lat - kH.lat, 2) + Math.pow(kT.lng - kH.lng, 2); var kD = Math.pow(kT.lat - kM.lat, 2) + Math.pow(kT.lng - kM.lng, 2); var kR = Math.pow(kH.lat - kM.lat, 2) + Math.pow(kH.lng - kM.lng, 2); var kE = Math.pow(kJ, 2); var e = kD - kE + kR - kE; if (e > kO) { kJ = Math.sqrt(Math.min(kD, kR)) } if ((T == null) || (T > kJ)) { kC = Math.sqrt(kR - kE) / Math.sqrt(kO); kL = Math.sqrt(kD - kE) / Math.sqrt(kO); T = kJ; kK = kN } T = Math.min(T, kJ) } } return { dist: T } }; eA.prototype.isPointInGeometry = function (kH, e) { var kI = false; switch (this._type) { case f3.POINT: kI = this._pixelPnpoint(kH, this.renderData, e); break; case f3.LINE_STRING: var kG = this._getProximity({ lng: kH[0], lat: kH[1] }, this._geometry); var kC = this.renderData[this.renderData.active]; if (!kC || !kC.line || !kC.line[0] || !kC.line[0].width) { var T = 2 } else { var T = this.renderData[this.renderData.active]["line"][0].width; if (this.grid === ek.GridModel.GOOGLEWEB) { T = Math.max(T / 2 * dL.gridScaleFromBDMCTo3857, 2) } else { T = Math.max(T / 2, 2) } } if (kG.dist < T) { kI = true } break; case f3.POLYGON: if (this._geometry[0] instanceof cG) { kI = this._pixelPnpoly({ lng: kH[0], lat: kH[1] }, this._geometry) } else { kI = this._pixelPnpoly({ lng: kH[0], lat: kH[1] }, this._geometry[0]); if (kI) { for (var kE = 1; kE < this._geometry.length; kE++) { var kF = this._pixelPnpoly({ lng: kH[0], lat: kH[1] }, this._geometry[kE]); if (kF) { kI = false; break } } } } break; case f3.MULTI_POLYGON: for (var kE = 0; kE < this._geometry.length; kE++) { if (this._geometry[kE][0] instanceof cG) { kI = this._pixelPnpoly({ lng: kH[0], lat: kH[1] }, this._geometry[kE]) } else { kI = this._pixelPnpoly({ lng: kH[0], lat: kH[1] }, this._geometry[kE][0]); if (kI) { for (var kD = 1; kD < this._geometry[kE].length; kD++) { var kF = this._pixelPnpoly({ lng: kH[0], lat: kH[1] }, this._geometry[kE][kD]); if (kF) { kI = false; break } } } } if (kI) { break } } break; case f3.MULTI_LINE_STRING: var kC = this.renderData[this.renderData.active]; if (!kC || !kC.line || !kC.line[0] || !kC.line[0].width) { var T = 6 } else { var T = this.renderData[this.renderData.active]["line"][0].width; T = Math.max(T / 2 * dL.gridScaleFromBDMCTo3857, 6) } for (var kE = 0; kE < this._geometry.length; kE++) { if (this._geometry[kE][0] instanceof cG) { var kG = this._getProximity({ lng: kH[0], lat: kH[1] }, this._geometry[kE]); if (kG.dist < T) { kI = true; break } } } break; case f3.MULTI_POINT: kI = this._pixelPnpoint(kH, this.renderData, e); break; default: throw new Error("geojson类型错误: " + this._type) }return kI }; eA.prototype.set = function (i, T, kC) { var e = kC || (kC = {}); e[i] = T }; var gO = (function () { function kJ(kP) { var kO = kP ? kP : {}; if (kO.reference) { this.reference = kO.reference } else { this.reference = null } return this } kJ.prototype.readFeatureFromObject = function (kP, kS) { var kO = null; if (kP.type && kP.type.toLowerCase() === "feature") { kO = kP } else { kO = { type: "Feature", geometry: kP, properties: null, } } kS = kS || {}; kS.reference = (kS.reference === undefined ? this.reference : kS.reference); if (kS.isPoints) { kS.onlyGeometry = true } var kT = T(kO.geometry, kS, kO.properties); var kR = e(kE(kO), kS); if (!kT) { return null } if (kS && kS.onlyGeometry && !kS.isPoints) { return { geometry: kT, type: kO.geometry["type"], bBox: kR } } if (kT instanceof Array && !(kT[0] instanceof cG)) { for (var kQ = 0; kQ < kT.length; kQ++) { if (kS.isPoints) { kT[kQ] = { points: kT[kQ], properties: kO.properties, index: kS.__index, brotherIndex: kQ } } else { kT[kQ]["properties"] = kO.properties } } } else { if (kS.isPoints) { kT = { points: kT, properties: kO.properties, index: kS.__index, brotherIndex: -1 } } else { kT.properties = kO.properties } } return kT }; kJ.prototype.readFeaturesFromObject = function (kR, kZ, kO) { var kW = kR; var kP = null; if (kW.type && kW.type.toLowerCase() === "featurecollection") { var kT = kR; kP = []; var kV = kT.features; var kQ = kZ || {}; for (var kU = 0, kX = kV.length; kU < kX; ++kU) { kQ.__index = kU; var kY = this.readFeatureFromObject(kV[kU], kZ); if (kY instanceof Array) { for (var kS = 0; kS < kY.length; kS++) { kO && kO(kY[kS]); kP.push(kY[kS]) } } else { kO && kO(kY); kP.push(kY) } } } else { var kY = this.readFeatureFromObject(kR, kZ); if (kY instanceof Array) { kP = []; for (var kU = 0; kU < kY.length; kU++) { kO && kO(kY[kU]); kP.push(kY[kU]) } } else { kO && kO(kY); kP = [kY] } } return kP }; function T(kO, kQ, kP) { if (!kO) { return null } var kR; switch (kO.type) { case f3.POINT: kR = kG(kO, kQ, kP); break; case f3.LINE_STRING: kR = kC(kO, kQ, kP); break; case f3.POLYGON: kR = kH(kO, kQ, kP); break; case f3.MULTI_POINT: kR = kI(kO, kQ, kP); break; case f3.MULTI_LINE_STRING: kR = kL(kO, kQ, kP); break; case f3.MULTI_POLYGON: kR = kM(kO, kQ, kP); break; default: throw new Error("geojson类型错误: " + kO.type) }return kR } function kG(kP, kS, kQ) { var kT = kP.coordinates; if (kS.reference && kS.reference !== "BD09LL") { kT = gcoord.transform(kT, kS.reference || "WGS84", gcoord.BD09LL) } if (kS && kS.onlyGeometry) { return new cG(kT[0], kT[1]) } var kR = kS; if (kS.markerStyle) { kR = kS.markerStyle; if (kS.markerStyle instanceof Function) { kR = kS.markerStyle(kQ) || {} } } var kO = new u(new cG(kT[0], kT[1]), kR); return kO } function kN(kS, kP) { if (!kS) { return [] } var kR = []; for (var kO = 0; kO < kS.length; kO++) { var kQ = kS[kO]; if (kP.reference && kP.reference !== "BD09LL") { kQ = gcoord.transform(kQ, kP.reference || "WGS84", gcoord.BD09LL) } kR.push(new cG(kQ[0], kQ[1])) } return kR } function kC(kP, kS, kQ) { var kT = kP.coordinates; if (kS && kS.onlyGeometry) { return kN(kT, kS) } var kR = kS; if (kS.polylineStyle) { kR = kS.polylineStyle; if (kS.polylineStyle instanceof Function) { kR = kS.polylineStyle(kQ) || {} } } kR.noCoordTrans = true; var kO = new bu(kN(kT, kS), kR); return kO } function kH(kO, kT, kR) { var kV = kO.coordinates; var kU = []; for (var kQ = 0; kQ < kV.length; kQ++) { kU[kQ] = kN(kV[kQ], kT) } if (kT && kT.onlyGeometry) { return kU.length > 1 ? [kU] : (kU[0] || []) } var kS = kT; if (kT.polygonStyle) { kS = kT.polygonStyle; if (kT.polygonStyle instanceof Function) { kS = kT.polygonStyle(kR) || {} } } var kP = new i3(kU, kS); return kP } function kI(kQ, kW, kT) { var kU = kQ.coordinates; var kO = []; for (var kS = 0; kS < kU.length; kS++) { var kV = kU[kS]; if (kW.reference && kW.reference !== "BD09LL") { kV = gcoord.transform(kV, kW.reference || "WGS84", gcoord.BD09LL) } if (kW && kW.onlyGeometry) { kO.push(new cG(kV[0], kV[1])) } else { var kP = kW; if (kW.markerStyle) { kP = kW.markerStyle; if (kW.markerStyle instanceof Function) { kP = kW.markerStyle(kT) || {} } } var kR = new u(new cG(kV[0], kV[1]), kP); kO.push(kR) } } return kO } function kL(kP, kT, kR) { var kV = kP.coordinates; var kU = []; for (var kQ = 0; kQ < kV.length; kQ++) { if (kT && kT.onlyGeometry) { kU.push(kN(kV[kQ], kT)) } else { var kS = kT; if (kT.polylineStyle) { kS = kT.polylineStyle; if (kT.polylineStyle instanceof Function) { kS = kT.polylineStyle(kR) || {} } } kS.noCoordTrans = true; var kO = new bu(kN(kV[kQ], kT), kS); kU.push(kO) } } return kU } function kM(kR, kY, kV) { var kX = kR.coordinates; var kO = []; for (var kU = 0; kU < kX.length; kU++) { var kZ = []; for (var kS = 0, kQ = kX[kU]; kS < kQ.length; kS++) { var kT = kN(kQ[kS], kY); if (kY && kY.onlyGeometry) { if (kQ.length === 1) { kO.push(kT) } else { kZ.push(kT) } } else { if (kQ.length === 1) { var kP = kY; if (kY.polygonStyle) { kP = kY.polygonStyle; if (kY.polygonStyle instanceof Function) { kP = kY.polygonStyle(kV) || {} } } var kW = new i3(kT, kP); kO.push(kW) } else { kZ.push(kT) } } } if (kQ.length !== 1) { if (kY && kY.onlyGeometry) { kO.push(kZ) } else { var kP = kY; if (kY.polygonStyle) { kP = kY.polygonStyle; if (kY.polygonStyle instanceof Function) { kP = kY.polygonStyle(kV) || {} } } var kW = new i3(kZ, kP); kO.push(kW) } } } return kO } function kD(kO) { } function e(kS, kP) { var kR = []; for (var kO = 0; kO < kS.length; kO += 2) { var kQ = [kS[kO], kS[kO + 1]]; if (kP.reference && kP.reference !== "BD09LL") { kQ = gcoord.transform(kQ, kP.reference || "WGS84", gcoord.BD09LL) } kR.push(kQ[0]); kR.push(kQ[1]) } return kR } function kE(kO) { var kP = [Infinity, Infinity, -Infinity, -Infinity]; kF(kO, function (kQ) { if (kP[0] > kQ[0]) { kP[0] = kQ[0] } if (kP[1] > kQ[1]) { kP[1] = kQ[1] } if (kP[2] < kQ[0]) { kP[2] = kQ[0] } if (kP[3] < kQ[1]) { kP[3] = kQ[1] } }); return kP } function kF(kX, k2) { var kT, kQ, kP, kW, kO, kZ, k1, k0, kS, kV, kR = (kX.type && kX.type.toLowerCase() === "featurecollection"), kU = (kX.type && kX.type.toLowerCase() === "feature"), kY = kR ? kX.features.length : 1; for (kT = 0; kT < kY; kT++) { kS = (kR ? kX.features[kT]["geometry"] : (kU ? kX.geometry : kX)); kV = kS.type === "GeometryCollection"; k1 = kV ? kS.geometries.length : 1; for (kW = 0; kW < k1; kW++) { kZ = kV ? kS.geometries[kW] : kS; k0 = kZ.coordinates; if (kZ.type === "Point") { k2(k0) } else { if (kZ.type === "LineString" || kZ.type === "MultiPoint") { for (kQ = 0; kQ < k0.length; kQ++) { k2(k0[kQ]) } } else { if (kZ.type === "Polygon" || kZ.type === "MultiLineString") { for (kQ = 0; kQ < k0.length; kQ++) { for (kP = 0; kP < k0[kQ].length; kP++) { k2(k0[kQ][kP]) } } } else { if (kZ.type === "MultiPolygon") { for (kQ = 0; kQ < k0.length; kQ++) { for (kP = 0; kP < k0[kQ].length; kP++) { for (kO = 0; kO < k0[kQ][kP].length; kO++) { k2(k0[kQ][kP][kO]) } } } } else { throw new Error("类型错误") } } } } } } } function i(kX, k2) { var kT, kQ, kP, kW, kO, kZ, k1, k0, kS, kV, kR = kX.type === "FeatureCollection", kU = kX.type === "Feature", kY = kR ? kX.features.length : 1; for (kT = 0; kT < kY; kT++) { kS = (kR ? kX.features[kT]["geometry"] : (kU ? kX.geometry : kX)); kV = kS.type === "GeometryCollection"; k1 = kV ? kS.geometries.length : 1; for (kW = 0; kW < k1; kW++) { kZ = kV ? kS.geometries[kW] : kS; k0 = kZ.coordinates; if (kZ.type === "Point") { k0 = k2(k0) } else { if (kZ.type === "LineString" || kZ.type === "MultiPoint") { for (kQ = 0; kQ < k0.length; kQ++) { k0[kQ] = k2(k0[kQ]) } } else { if (kZ.type === "Polygon" || kZ.type === "MultiLineString") { for (kQ = 0; kQ < k0.length; kQ++) { for (kP = 0; kP < k0[kQ].length; kP++) { k0[kQ][kP] = k2(k0[kQ][kP]) } } } else { if (kZ.type === "MultiPolygon") { for (kQ = 0; kQ < k0.length; kQ++) { for (kP = 0; kP < k0[kQ].length; kP++) { for (kO = 0; kO < k0[kQ][kP].length; kO++) { k0[kQ][kP][kO] = k2(k0[kQ][kP][kO]) } } } } else { throw new Error("类型错误") } } } } } } } function kK(kP) { var kO = kP.type === "FeatureCollection"; var kQ = kP.type === "Feature"; var kR = (kO ? kP.features[0]["geometry"] : (kQ ? kP.geometry : kP)); if (kR.type) { return kR.type } else { throw new Error("类型错误") } } kJ.bbox = kE; kJ.coordEachReplace = i; kJ.getType = kK; return kJ })(); const c8 = { point: { symbolPath: { format: "string", defaultValue: "" }, symbolFillColor: { format: "string", defaultValue: "#000" }, symbolFillOpacity: { format: "number", defaultValue: 1 }, symbolScale: { format: "number", defaultValue: 1 }, symbolRotation: { format: "number", defaultValue: 0 }, symbolStrokeColor: { format: "string", defaultValue: "#000" }, symbolStrokeOpacity: { format: "number", defaultValue: 0 }, symbolStrokeWeight: { format: "number", defaultValue: 0 }, icon: { format: "string", defaultValue: "" }, iconSize: { format: "array", defaultValue: [32, 32] }, uid: { format: "string", defaultValue: "custom-vector-0" }, name: { format: "string", defaultValue: "" }, fontSize: { format: "number", defaultValue: 22 }, color: { format: "string", defaultValue: "#0d20c9" }, haloSize: { format: "number", defaultValue: 2 }, strokeColor: { format: "string", defaultValue: "#fff" }, textOnIcon: { format: "string", defaultValue: false }, textOnIconSize: { format: "array", defaultValue: [32, 32] }, textOnIconUrl: { format: "string", defaultValue: "" }, textMargin: { format: "number", defaultValue: 0 }, direction: { format: "number", defaultValue: 0 }, rank: { format: "number", defaultValue: 50000 }, visibility: { format: "boolean", defaultValue: true }, nodeType: { format: "number", defaultValue: 0 }, shapeType: { format: "number", defaultValue: 0 }, anchor: { format: "number", defaultValue: 0 }, size: { format: "number", defaultValue: 32 }, scale: { format: "number", defaultValue: 1 }, offset: { format: "object", defaultValue: [0, 0] }, rotation: { format: "number", defaultValue: 0 }, opacity: { format: "number", defaultValue: 1 }, strokeWeight: { format: "number", defaultValue: 0 } }, polyline: { strokeLineJoin: { format: "string", defaultValue: "miter" }, strokeLineCap: { format: "string", defaultValue: "round" }, strokeColor: { format: "string", defaultValue: "#142655" }, strokeWeight: { format: "number", defaultValue: 2 }, strokeOpacity: { format: "number", defaultValue: 1 }, borderColor: { format: "string", defaultValue: "rgba(27, 142, 236, 1)" }, borderWeight: { format: "number", defaultValue: 0 }, strokeTextureUrl: { format: "string", defaultValue: "" }, strokeTextureWidth: { format: "number", defaultValue: 16 }, strokeTextureHeight: { format: "number", defaultValue: 16 }, strokeStyle: { format: "string", defaultValue: "solid" }, dashArray: { format: "object", defaultValue: [8, 4] }, shapeType: { format: "number", defaultValue: 0 }, visibility: { format: "boolean", defaultValue: true } }, polygon: { fillColor: { format: "string", defaultValue: "#142655" }, fillOpacity: { format: "number", defaultValue: 1 }, patternMapping: { format: "string", defaultValue: "0, 0, 32, 32" }, patternScale: { format: "number", defaultValue: 1 }, patternOffset: { format: "string", defaultValue: "0, 0" }, strokeWeight: { format: "number", defaultValue: 0 }, strokeLineJoin: { format: "string", defaultValue: "bevel" }, strokeLineCap: { format: "string", defaultValue: "round" }, strokeColor: { format: "string", defaultValue: "#dec41b" }, strokeOpacity: { format: "number", defaultValue: 1 }, strokeStyle: { format: "string", defaultValue: "solid" }, dashArray: { format: "object", defaultValue: [8, 4] }, visibility: { format: "boolean", defaultValue: true } } }; const cB = (function (i) { var e = {}; for (var kC in i) { e[kC] = {}; for (var T in i[kC]) { e[kC][T] = i[kC][T].defaultValue } } return e })(c8); const f3 = { POINT: "Point", LINE_STRING: "LineString", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", CIRCLE: "Circle", }; function fT(e) { return e && typeof ArrayBuffer !== "undefined" && (e instanceof ArrayBuffer || (e.constructor && e.constructor.name === "ArrayBuffer")) } function gz(e) { if (self) { if (self.ImageBitmap && e instanceof self.ImageBitmap) { return true } } else { if (window && window.ImageBitmap) { if (e instanceof window.ImageBitmap) { return true } } } return false } const jr = {}; function aJ(i, kC, T) { var e = T || {}; Object.defineProperty(i, "_classRegistryKey", { value: kC, writeable: false }); jr[kC] = { _class: i, escape: e.escape || [] } } aJ(Object, "Object"); aJ(cG, "Point"); function jR(kH, kF) { if (kH === null || kH === undefined || typeof kH === "boolean" || typeof kH === "number" || typeof kH === "string" || kH instanceof Boolean || kH instanceof Number || kH instanceof String || kH instanceof Date || kH instanceof RegExp) { return kH } if (fT(kH)) { if (kF) { kF.push(kH) } return kH } if (gz(kH)) { if (kF) { var kK = kF.filter(function (i) { if (i === kH) { return true } else { return false } }); !kK && kF.push(kH) } return kH } if (ArrayBuffer.isView(kH)) { const kG = kH; if (kF) { kF.push(kG.buffer) } return kG } if (kH instanceof ImageData) { if (kF) { var kK = kF.filter(function (i) { if (i === kH.data.buffer) { return true } else { return false } }); !kK && kF.push(kH.data.buffer) } return kH } if (Array.isArray(kH)) { const T = []; for (var kC = 0; kC < kH.length; kC++) { var kL = kH[kC]; T.push(jR(kL, kF)) } return T } if (typeof kH === "object") { const kD = kH.constructor; const e = kD._classRegistryKey; if (!e) { throw new Error("不能被序列化") } const kE = kD.serialize ? kD.serialize(kH, kF) : {}; if (!kD.serialize) { for (var kJ in kH) { if (!kH.hasOwnProperty(kJ)) { continue } if (jr[e]["escape"].indexOf(kJ) >= 0) { continue } const kI = kH[kJ]; kE[kJ] = jR(kI, kF) } if (kH instanceof Error) { kE.message = kH.message } } if (e !== "Object") { kE["_$name"] = e } return kE } else { if (kH instanceof Function) { return null } } throw new Error("不能被序列化") } function ix(kE) { if (kE === null || kE === undefined || typeof kE === "boolean" || typeof kE === "number" || typeof kE === "string" || kE instanceof Boolean || kE instanceof Number || kE instanceof String || kE instanceof Date || kE instanceof RegExp || fT(kE) || gz(kE) || ArrayBuffer.isView(kE) || kE instanceof ImageData) { return kE } if (Array.isArray(kE)) { var e = kE["_$name"]; if (e) { var kC = jr[e]["_class"]; if (!kC) { throw new Error("不能被反序列化") } if (kC.deserialize) { return kC.deserialize(kE) } } const kD = []; for (var T = 0; T < kE.length; T++) { var kH = kE[T]; kD.push(ix(kH)) } return kD } if (typeof kE === "object") { var e = kE["_$name"] || "Object"; var kC = jr[e]["_class"]; if (!kC) { throw new Error("不能被反序列化") } if (kC.deserialize) { return kC.deserialize(kE) } const kJ = Object.create(kC.prototype); const kI = Object.keys(kE); for (var T = 0; T < kI.length; T++) { const kG = kI[T]; if (kG === "_$name") { continue } const kF = kE[kG]; kJ[kG] = ix(kF) } return kJ } throw new Error("不能被反序列化") } function m(kG, kE, kF) { if (!kG.length) { return kF(null, []) } var kD = kG.length; const kC = new Array(kG.length); var e = null; for (var T = 0; T < kG.length; T++) { kE(kG[T], function (kH, i) { if (kH) { e = kH } kC[T] = i; if (--kD === 0) { kF(e, kC) } }, T) } } function go(kH, kE, kG) { if (!kH.length) { return kG(null, []) } var kD = kH.length; const kC = new Array(kH.length); var e = null; var T = 0; function kF() { kE(kH[T], function (kI, i) { if (kI) { e = kI } kC[T] = i; if (--kD === 0) { kG(e, kC) } else { T++; kF() } }, T) } kF() } var j3 = (function () { var i = true; var kD = 256; var e = true; var kF = kd("ditu", "normalTraffic"); var kC = kF.udt; var kG = "//its.map.baidu.com/traffic/"; var kE = [[2, "79,210,125,1", 3, 2, 0, [], 0, 0], [2, "79,210,125,1", 3, 2, 0, [], 0, 0], [2, "79,210,125,1", 4, 2, 0, [], 0, 0], [2, "79,210,125,1", 5, 2, 0, [], 0, 0], [2, "79,210,125,1", 6, 2, 0, [], 0, 0], [2, "255,208,69,1", 3, 2, 0, [], 0, 0], [2, "255,208,69,1", 3, 2, 0, [], 0, 0], [2, "255,208,69,1", 4, 2, 0, [], 0, 0], [2, "255,208,69,1", 5, 2, 0, [], 0, 0], [2, "255,208,69,1", 6, 2, 0, [], 0, 0], [2, "232,14,14,1", 3, 2, 0, [], 0, 0], [2, "232,14,14,1", 3, 2, 0, [], 0, 0], [2, "232,14,14,1", 4, 2, 0, [], 0, 0], [2, "232,14,14,1", 5, 2, 0, [], 0, 0], [2, "232,14,14,1", 6, 2, 0, [], 0, 0], [2, "181,0,0,1", 3, 2, 0, [], 0, 0], [2, "181,0,0,1", 3, 2, 0, [], 0, 0], [2, "181,0,0,1", 4, 2, 0, [], 0, 0], [2, "181,0,0,1", 5, 2, 0, [], 0, 0], [2, "181,0,0,1", 6, 2, 0, [], 0, 0], [2, "255,255,255,1", 4, 0, 0, [], 0, 0], [2, "255,255,255,1", 5.5, 0, 0, [], 0, 0], [2, "255,255,255,1", 7, 0, 0, [], 0, 0], [2, "255,255,255,1", 8.5, 0, 0, [], 0, 0], [2, "255,255,255,1", 10, 0, 0, [], 0, 0]]; var T = new hP({ transparentPng: true, dataType: 2, cacheSize: 256, clipTile: true, isFlat: true }); T.zIndex = 2; T.getTilesUrl = function (kJ, kK) { if (!kJ || kK < 7) { return null } var kI = kJ.x; var kL = kJ.y; var kH = kG + "TrafficTileService?level=" + kK + "&x=" + kI + "&y=" + kL + "&time=" + (+new Date()); if (this.map.getRenderType() === "webgl") { kH = kG + "?qt=vtraffic&z=" + kK + "&x=" + kI + "&y=" + kL + "&udt=" + kC } return kH }; T.setColors = function (kH) { for (var kK = 0; kK < kE.length; kK++) { var kJ = Math.floor(kK / 5); var kI = kH[kJ]; if (kI) { if (Object.prototype.toString.call(kI) === "[object String]") { kI = hW.parseCSSColor(kI) } kE[kK][1] = [kI[0], kI[1], kI[2], kI[3] / 255].join(",") } } }; T.setEdge = function (kH) { e = !!kH }; T.processData = function (kK) { var kO = kK.content; var kM = 10; if (typeof kK.precision === "number") { kM = kK.precision * 10 } var kV = { road: [[], []] }; if (!kO) { return kV } var kT = kO.tf; if (!kT) { return kV } for (var kL = 0; kL < kT.length; kL++) { var kU = kT[kL][1]; var kS = []; var kQ = 0; var kP = 0; var kR = kE[kT[kL][3]]; for (var kJ = 0, kH = kU.length; kJ < kH / 2; kJ++) { kQ += kU[kJ * 2] / kM; kP += kU[kJ * 2 + 1] / kM; kS.push(kQ, 256 - kP) } var kI = kR[1].split(","); kI[3] = kI[3] * 255; var kN = kR[2] / 2; if (e) { kV.road[0].push([kS, 1, 2, [255, 255, 255, 255], kN + 2]) } kV.road[1].push([kS, 1, 2, kI, kN]) } return kV }; return T })(); function jF() { hQ.sendMessage(a1(4, 3, 3), ["layer", "traffic"]) } jF.prototype = j3; function ea(e) { eM.call(this); e = e || {}; this._opts = {}; this._opts.districts = e.name || ""; this._opts.kind = e.kind || 0; this._config = {}; this._config.strokeColor = e.strokeColor || "#00f"; this._config.strokeOpacity = typeof e.strokeOpacity === "number" ? e.strokeOpacity : 1; ck(this._config.strokeOpacity, 0, 1); this._config.fillColor = e.fillColor || "#ff0"; this._config.fillOpacity = typeof e.fillOpacity === "number" ? e.fillOpacity : 0.6; ck(this._config.fillOpacity, 0, 1); this._config.strokeWeight = e.strokeWeight || 1; this._config.viewport = e.viewport || false; this.disOverlays = []; this.eventAndCallback = {}; hQ.sendMessage(a1(4, 3, 6), ["layer", "district"]); var i = this; hm.load("layer", function () { i._asyncSearch() }) } ea.inherits(dh, "DistrictLayer"); e9.extend(ea.prototype, { initialize: function (e) { this._map = e; this.addDistrict() }, removeDistrict: function (i, e) { this._map = i; this.deleteDistrict(e) }, toString: function () { return "DistrictLayer" } }); function aQ(e, i) { i = i || {}; this.layerName = e || "unknown"; this.reference = i.reference; this.level = i.level || -99; this.visible = (i.visible === undefined ? true : !!i.visible); this.minZoom = i.minZoom || 3; this.maxZoom = i.maxZoom || 21; this.markerStyle = i.markerStyle || {}; this.polylineStyle = i.polylineStyle || {}; this.polygonStyle = i.polygonStyle || {}; this.overlayData = []; this._onMap = false; this.clickDistrict = 5; this.setData(i.dataSource); hQ.sendMessage(a1(4, 3, 12), ["layer", "geojson"]) } aQ.inherits(e9.BaseClass, "GeoJSONLayer"); aQ.prototype.init = function (kF) { if (this.map) { return } this.map = kF; var kD = this; this._onZoomEvent = function () { if (kD.map.getZoom() >= kD.minZoom && kD.map.getZoom() <= kD.maxZoom) { if (!kD._onMap) { kD.addDataToMap(); kD._onMap = true } } else { if (kD._onMap) { kD.removeDataFromMap(); kD._onMap = false } } }; this.map.on("zoomend", this._onZoomEvent); var kD = this; var e = false; var kC = { x: 0, y: 0 }; this._layerMouseEvent = function (kI) { if (!kD.map || !kD._listeners || !kD.visible || !kD._onMap) { return } if (!kD._listeners.onmousemove || Object.keys(kD._listeners.onmousemove).length === 0) { return } var kH = kD.pickOverlays(kI); var i; if (kH && kH.length > 0) { i = new fW("onmousemove"); i.features = kH; kD.map.platform.style.cursor = kD.map.config.overlayMoveCursor; e = true } else { if (!e || !kD._listeners.onmouseout || Object.keys(kD._listeners.onmouseout).length === 0) { return } kD.map.platform.style.cursor = kD.map.config.defaultCursor; i = new fW("onmouseout"); i.features = null; e = false } if (i) { i.point = kI.point; i.pixel = kI.pixel; i.latLng = kI.latlng; kD.dispatchEvent(i) } }; this._layerClickEvent = function (kJ) { if (!kD.map || !kD._listeners || !kD.visible) { return } if ((!kD._listeners.onclick && !kD._listeners.dblclick) || (Object.keys(kD._listeners.onclick || {}).length === 0 && Object.keys(kD._listeners.dblclick || {}).length === 0)) { return } var kH = { x: kJ.clientX, y: kJ.clientY }; if (Math.abs(kH.x - kC.x) > kD.clickDistrict || Math.abs(kH.y - kC.y) > kD.clickDistrict) { return } var kI = kD.pickOverlays(kJ); var i = new fW(kJ.type); i.point = kJ.point; i.pixel = kJ.pixel; i.latLng = kJ.latlng; i.features = kI; kD.dispatchEvent(i) }; this._layerMouseDownEvent = function (i) { kC = { x: i.clientX, y: i.clientY } }; kF.addEventListener("onmousemove", this._layerMouseEvent); kF.addEventListener("onmouseout", this._layerMouseEvent); kF.addEventListener("onmousedown", this._layerMouseDownEvent); var kE = ["onclick"]; for (var T = 0; T < kE.length; T++) { var kG = kE[T]; kF.addEventListener(kG, this._layerClickEvent) } this._onZoomEvent() }; aQ.prototype.remove = function () { if (this.map) { this.removeDataFromMap(); this.map.removeEventListener("onmousemove", this._layerMouseEvent); this.map.removeEventListener("onmouseout", this._layerMouseEvent); this.map.removeEventListener("onclick", this._layerClickEvent); this.map.removeEventListener("onmousedown", this._layerMouseDownEvent); this.map.removeEventListener("onzoomend", this._onZoomEvent) } this.map = null }; aQ.prototype.destroy = function () { if (this.map) { this.clearData(); this.map.removeEventListener("onmousemove", this._layerMouseEvent); this.map.removeEventListener("onmouseout", this._layerMouseEvent); this.map.removeEventListener("onclick", this._layerClickEvent); this.map.removeEventListener("onmousedown", this._layerMouseDownEvent); this.map.removeEventListener("onzoomend", this._onZoomEvent) } this.map = null }; aQ.prototype.setData = function (e) { if (!this.gParse) { this.gParse = new gO({ reference: this.reference }) } if (!e) { return } if (this.dataSource && this.overlayData.length > 0) { this.clearData() } this.dataSource = e; this.overlayData = this.gParse.readFeaturesFromObject(e, { markerStyle: this.markerStyle, polylineStyle: this.polylineStyle, polygonStyle: this.polygonStyle }, this._register.bind(this)); this.addDataToMap() }; aQ.prototype._register = function (e) { e.layerName = this.layerName; e.setZIndex(this.level) }; aQ.prototype.resetStyle = function () { for (var e = 0; e < this.overlayData.length; e++) { if (this.overlayData[e] instanceof u) { var i = this.markerStyle; if (this.markerStyle instanceof Function) { i = this.markerStyle(this.overlayData[e].properties) || {} } } if (this.overlayData[e] instanceof bu) { var i = this.polylineStyle; if (this.polylineStyle instanceof Function) { i = this.polylineStyle(this.overlayData[e].properties) || {} } } if (this.overlayData[e] instanceof i3) { var i = this.polygonStyle; if (this.polygonStyle instanceof Function) { i = this.polygonStyle(this.overlayData[e].properties) || {} } } if (this.overlayData[e] instanceof aX) { var i = this.polygonStyle; if (this.polygonStyle instanceof Function) { i = this.polygonStyle(this.overlayData[e].properties) || {} } } if (i) { this.overlayData[e].setOptions(i) } } }; aQ.prototype.getData = function () { return this.overlayData }; aQ.prototype.addOverlay = function (e) { var kF = e; if (!(e instanceof Array)) { kF = [e] } for (var kC = 0; kC < kF.length; kC++) { var T = kF[kC]; if (T.__proto__ instanceof aU) { this._register(T); this.overlayData.push(T); this.map.addOverlay(T) } else { var kE = this.gParse.readFeaturesFromObject(T, { markerStyle: this.markerStyle, polylineStyle: this.polylineStyle, polygonStyle: this.polygonStyle }, this._register.bind(this)); for (var kD = 0; kD < kE.length; kD++) { this.overlayData.push(kE[kD]); this.map.addOverlay(kE[kD]) } } } }; aQ.prototype.removeOverlay = function (kC) { var kD = kC; if (!(kC instanceof Array)) { kD = [kC] } for (var T = 0; T < kD.length; T++) { var i = kD[T]; var e = this.findItemIndex(i); if (e >= 0) { this.overlayData.splice(e, 1); this.map.removeOverlay(i) } } }; aQ.prototype.findItemIndex = function (T) { var i = -1; for (var e = 0; e < this.overlayData.length; e++) { if (this.overlayData[e].hashCode === T.hashCode) { i = e; break } } return i }; aQ.prototype.addDataToMap = function () { if (this.visible && this.map && this.map.getZoom() >= this.minZoom && this.map.getZoom() <= this.maxZoom) { for (var e = 0; e < this.overlayData.length; e++) { this.map.addOverlay(this.overlayData[e]) } } }; aQ.prototype.removeDataFromMap = function () { if (this.map && this.overlayData.length > 0) { for (var e = 0; e < this.overlayData.length; e++) { this.map.removeOverlay(this.overlayData[e]) } } }; aQ.prototype.clearData = function () { this.dataSource = null; if (this.map && this.overlayData.length > 0) { this.removeDataFromMap() } this.overlayData = [] }; aQ.prototype.pickOverlays = function (kG) { var kF = []; if (!this.visible || !this._onMap) { return null } for (var kD = 0; kD < this.overlayData.length; kD++) { var kE = this.overlayData[kD]; var kC; if (!kE && !kE.isVisible()) { continue } if (kE.toString() === "Marker") { kC = kE._getInPnBox(kG.pixel); if (kC) { kF.push(kE) } continue } if (kE.toString() !== "Polyline") { kC = kE._getInPnpoly(kG.point) } else { kC = kE._getProximity(kG.point) } var T = kC.dist; if (T >= 0 && T < kE._config.mouseOverTolerance) { kF.push(kE) } } return kF.length > 0 ? kF : null }; aQ.prototype.setLevel = function (e) { if (e > -999 && e < 9999) { this.level = e; for (var T = 0; T < this.overlayData.length; T++) { this.overlayData[T].setZIndex(this.level) } if (this.map) { this.map.fire(new BMapGL.Event("onupdate", "line")) } } }; aQ.prototype.setClickDistrict = function (e) { this.clickDistrict = e || 5 }; aQ.prototype.getLevel = function () { return this.level }; aQ.prototype.setVisible = function (i) { var e = !!i; if (this.visible !== e) { this.visible = e; if (e) { this.addDataToMap() } else { this.removeDataFromMap() } } }; aQ.prototype.getVisible = function () { return this.visible }; aQ.prototype.toString = function () { return "GeoJSONLayer" }; function kp(i) { var i = i || {}; var kE = i.transform || { source: "EPSG3857", target: "BD09MC" }; if (!kE.source) { kE.target = "EPSG3857" } if (!kE.target) { kE.target = "BD09MC" } const kC = i.tileUrlTemplate || ""; const kI = i.xTemplate || function (kP, kR, kQ) { return kP }; const kM = i.yTemplate || (i.tms ? function (kP, kR, kQ) { return Math.pow(2, kQ) - kR - 1 } : function (kP, kR, kQ) { return kR }); const kG = i.zTemplate || function (kP, kR, kQ) { return kQ }; const kL = i.bTemplate || function (kP, kS, kR) { const kQ = dL.getTileRangeExtent([kR, kP, kS]); return kQ.minX + "," + kQ.minY + "," + kQ.maxX + "," + kQ.maxY }; const kD = i.wTemplate || function (kP, kR, kQ) { return 512 }; const kH = i.hTemplate || function (kP, kR, kQ) { return 512 }; var kN = i.extent || []; const kF = i.extentCRSIsWGS84 || false; var T = i.minZoom || 0; var kJ = i.maxZoom || 23; var kK = i.spanLevel || 0; if (!i.showRegion || "insideoutside".indexOf(i.showRegion) === -1) { i.showRegion = "inside" } var kO = new hP({ transform: kE, png8: i.png8 || false, height: i.height || 0, retry: i.retry || false, retryTime: i.retryTime || 600, transparentPng: true, dataType: i.dataType || 1, spanLevel: kK, tileTypeName: "xyz", cacheSize: i.cacheSize || 256, customLayer: true, clipTile: false, isTop: i.isTop || false, opacity: i.opacity || 1, isLowText: i.isLowText || false, boundary: i.boundary || false, showRegion: i.showRegion, useThumbData: i.useThumbData || false }); if (i.zIndex) { kO.zIndex = i.zIndex } (kN.length === 4) && kF && (kN = dL.fromEPSG4326(kN)); kO.getTilesUrl = function (kW, kQ, kU) { if (!kW || kQ < 0 || kQ < (T + kK) || kQ > (kJ + kK)) { kO.tileCache.clear(); return null } if (kE.source !== "BD09MC") { kW.x = dL.getTilesLoop(kQ, kW.x) } if (kN.length === 4) { var kV = dL.getTileRangeExtent([kQ, kW.x, kW.y]); var kX = e([kV.minX, kV.minY, kV.maxX, kV.maxY]); if (!kX) { return null } } var kR = ""; if (kC) { kR = kC; var kT = /[^\{}]*\{(.*)\}[^\}]*/; kR.match(kT); var kS = []; if (RegExp.$1) { kS = RegExp.$1.split(",") } var kP = kG(kW.x, kW.y, kQ); if (!kP) { return null } kR = kR.replace(/\{(.*)\}/, kS[(kW.x + kW.y) % kS.length]); kR = kR.replace(/\[x\]/gi, kI(kW.x, kW.y, kQ)); kR = kR.replace(/\[y\]/gi, kM(kW.x, kW.y, kQ)); kR = kR.replace(/\[z\]/gi, kP); kR = kR.replace(/\[b\]/gi, kL(kW.x, kW.y, kQ)); kR = kR.replace(/\[w\]/gi, kD(kW.x, kW.y, kQ)); kR = kR.replace(/\[h\]/gi, kH(kW.x, kW.y, kQ)) } else { return null } return kR }; function e(kP) { if (kN && kN instanceof Array && kN.length === 4) { if ((kN[0] <= kP[2] && kN[1] <= kP[3]) && (kN[2] >= kP[0] && kN[3] >= kP[1])) { return true } else { return false } } return true } hQ.sendMessage(a1(4, 3, 7), ["layer", "xyz"]); return kO } function dB(i) { this.src = dc(); this.tileMaskUvCache = new aC(64, { clearCallback: function (kE) { } }); var kD = 6; if (i.pixelMap) { this.opacity = typeof i.pixelMap.opacity === "number" ? i.pixelMap.opacity : 1; ck(this.opacity, 0, 1); if (this.opacity < 1) { i.useThumbData = false } var kC = i.pixelMap || {}; this.colors = kC.colors || ["#F9F871", "#FFC75F", "#FF9671", "#FF6F91", "#D65DB1", "#845EC2"]; this.positions = kC.positions || [0, 0.2, 0.4, 0.6, 0.8, 1]; this.domain = kC.domain || [0, 255]; this.clamp = kC.clamp || this.domain; this.noData = (kC.noData !== undefined) ? kC.noData : -99999; this.fomularC = kC.fomularC || "float generateValue(vec4 pixel){return pixel.r * 255.;}"; this.fomularJS = kC.fomularJS || function (kE) { return kE.r }; this.maskPng = kC.maskPng || null; if (this.maskPng) { this.loadMaskPng(this.maskPng) } this.maskData = kC.maskData || -1; this.maskCoord = kC.maskCoord || null; this.fHashcode = q({ str: this.fomularC }); var e = this.canPixelMap(); if (e) { this.isPixelMap = true; this.setPixelMap() } kD = i.pixelMap.cacheSize || kD } var T = new kp(i); T.ontology = this; this.layer = T; this.cacheSize = kD; this.tileCache = new aC(this.cacheSize, { clearCallback: function (kE) { } }); this.tileImageDataCache = new aC(this.cacheSize, { clearCallback: function (kE) { } }); hQ.sendMessage(a1(4, 3, 16), ["layer", "pixel"]) } dB.inherits(e9.BaseClass, "PixelLayer"); e9.extend(dB.prototype, { canPixelMap: function () { if (this.colors && this.positions) { return true } return false }, setPixelMap: function () { if (!this.isPixelMap || !this.canPixelMap()) { return } var i = this.colors; var e = this.positions; this.pHashcode = q({ colors: i, positions: e }); this.pixelColorMap = hW.generateColorRamp(i, e) }, setDomain: function (e) { if (e instanceof Array && e.length === 2) { this.domain = e; this.doOnceDraw() } }, setClamp: function (e) { if (e instanceof Array && e.length === 2) { this.clamp = e; this.doOnceDraw() } }, setNoData: function (e) { this.noData = e; this.doOnceDraw() }, setPositions: function (e) { this.positions = e; this.setPixelMap(); this.doOnceDraw() }, setColors: function (e) { this.colors = e; this.setPixelMap(); this.doOnceDraw() }, setFomular: function (e, i) { if (e && i) { this.fomularJS = e; this.fomularC = i; this.fHashcode = q({ str: this.fomularC }); this.doOnceDraw() } }, setOpacity: function (e) { this.opacity = e; this.doOnceDraw() }, setIsPixelMap: function (e) { this.isPixelMap = e; this.doOnceDraw() }, setMaskPng: function (e) { this.maskPng = e; this.loadMaskPng(this.maskPng); this.doOnceDraw() }, setMaskData: function (e) { this.maskData = e; this.doOnceDraw() }, setMaskCoord: function (e) { this.maskCoord = e || null; this.calMaskBox(); this.doOnceDraw() }, setZIndex: function (e) { if (this.layer && parseInt(e) > 0) { this.layer.setZIndex(e) } }, getZIndex: function () { if (this.layer) { return this.layer.zIndex } }, setUpLevel: function () { if (this.layer) { var e = this.layer._getAdjoinZIndex("up"); if (this.layer.zIndex !== e) { this.layer.setZIndex(e) } } }, setDownLevel: function () { if (this.layer) { var e = this.layer._getAdjoinZIndex("down"); if (this.layer.zIndex !== e) { this.layer.setZIndex(e) } } }, setZIndexTop: function () { if (this.layer) { this.layer.setZIndexTop() } }, doOnceDraw: function () { if (this.layer.map) { var e = new fW("onupdate"); this.layer.map.dispatchEvent(e) } }, _getInLayer: function (kK) { if (!this.map) { return null } var kJ = Math.floor(this.map.getZoom()); var kC = dL.transformBDmcPoint(kK, this.layer.transform); var kG = dL.getTileCoordForXYAndZ_(kC[0], kC[1], kJ, false); var T = kG.join("-"); var e = this.tileCache.getData(T); if (e) { return e } var kD = this.layer.zIndex; var kF = this.map._featureMgr.result.bkData; var kH = kF[kD][2]; var kL = null; for (var kE = 0; kE < kH.length; kE++) { var kG = kH[kE]; var kI = kG.tileInfo.zoom + "-" + kG.tileInfo.col + "-" + kG.tileInfo.row; if (T === kI) { kL = kG; break } } this.tileCache.setData(T, kL); return kL }, _initEvent: function (kD) { this.map = kD; var T = this; this._layerMouseEvent = function (kH) { if (!T.map) { return } var kF; var i = kH.point; var kG = T._getInLayer(i); if (kG) { T.prox = kG; kF = new fW("onmousemove"); T.map.platform.style.cursor = T.map.config.overlayMoveCursor } else { T.map.platform.style.cursor = T.map.config.defaultCursor; T.prox = null } if (kF) { kF.point = kH.point; kF.pixel = kH.pixel; kF.latLng = kH.latlng; T.dispatchEvent(kF) } }; this._layerClickEvent = function (kH) { if (!T.map) { return } var kF; var i = kH.point; var kG = T.getImagePixel(i); if (kG) { kF = new fW(kH.type); kF.point = i; kF.pixel = kH.pixel; kF.latLng = kH.latlng; kF.color = kG; kF.value = T.getValue(kF.color); T.dispatchEvent(kF) } }; kD.addEventListener("onmousemove", this._layerMouseEvent); var kC = ["onclick", "dblclick"]; for (var e = 0; e < kC.length; e++) { var kE = kC[e]; kD.addEventListener(kE, this._layerClickEvent) } kD.addEventListener("removetilelayer", function (i) { if (i.target && i.target.ontology) { if (i.target.ontology.src === T.src) { kD.removeEventListener("onmousemove", T._layerMouseEvent); kD.removeEventListener("onclick", T._layerClickEvent); kD.removeEventListener("ondblclick", T._layerClickEvent); T._clearCache() } } }); kD.on("destroy", function () { T._clearCache() }) }, _clearCache: function () { var e = this; e.prox = null; e.tileCache.clear(); e.tileImageDataCache.clear(); e.tileMaskUvCache.clear(); e._layerMouseEvent = null; e._layerClickEvent = null; e.imageMaskObject = null; e.pHashcode = null; e.pixelColorMap = null; e.layer.ontology = null; e.layer = null }, getImagePixel: function (kH) { if (!this.map) { return null } var kC = dL.transformBDmcPoint(kH, this.layer.transform); var kG = this._getInLayer(kH); if (!kG) { return null } if (!this.getImageMaskPixel(kC)) { return null } var kE = [kG.tileInfo.zoom, kG.tileInfo.col, kG.tileInfo.row]; var kF = dL.getTileRangeExtent(kE); var e = this.getImageObject(kG.textureSource, kE.join("-")); var T = Math.floor((kC[0] - kF.minX) / (kF.maxX - kF.minX) * e.width); var i = Math.floor((-kC[1] + kF.maxY) / (kF.maxY - kF.minY) * e.height); var kD = Math.floor((i * e.width + T) * 4); return [e.data.data[kD], e.data.data[kD + 1], e.data.data[kD + 2], e.data.data[kD + 3],] }, getImageObject: function (kD, kC) { var kE = this.tileImageDataCache.getData(kC); if (kE) { return kE } var i = document.createElement("canvas"); i.width = kD.width; i.height = kD.height; var T = i.getContext("2d"); T.drawImage(kD, 0, 0, kD.width, kD.height); var e = { width: kD.width, height: kD.height, data: T.getImageData(0, 0, kD.width, kD.height) }; this.tileImageDataCache.setData(kC, e); T = null; i = null; return e }, getValue: function (i) { if (this.isPixelMap && i && this.fomularJS) { if (!(i instanceof Array)) { i = this.getImagePixel(i.point) } var e = this.fomularJS({ r: i[0], g: i[1], b: i[2], a: i[3] }); if (e >= this.clamp[0] && e <= this.clamp[1]) { return e } } return null }, setMaskImageObject: function (T) { var e = document.createElement("canvas"); e.width = T.width; e.height = T.height; var i = e.getContext("2d"); i.drawImage(T, 0, 0, T.width, T.height); this.imageMaskObject = { width: T.width, height: T.height, data: i.getImageData(0, 0, T.width, T.height) }; i = null; e = null }, getImageMaskPixel: function (e) { if (!this.imageMaskObject || !this.maskBox) { return true } var kC = [e]; var kH = this.maskBox || []; var kE = kH[1][0] - kH[0][0]; var kD = kH[1][1] - kH[0][1]; var T = Math.floor((kC[0][0] - kH[0][0]) / kE * this.imageMaskObject.width); var i = Math.floor((-kC[0][1] + kH[1][1]) / kD * this.imageMaskObject.height); var kG = Math.floor((i * this.imageMaskObject.width + T) * 4); if (T > this.imageMaskObject.width || T < 0) { return null } if (i > this.imageMaskObject.height || i < 0) { return null } var kF = this.imageMaskObject.data.data; if (kG + 3 > kF.length) { return false } if (kF[kG + 3] > 0) { if (this.maskData > -1 && this.maskData !== kF[kG]) { return false } return true } return false }, calMaskBox: function () { var T = this.maskCoord || []; if (this.hasMaskPng && T && T.length === 2) { var e = []; for (var kC = 0; kC < T.length; kC++) { e[kC] = dL.transformBDmcPoint(jy.convertLL2MC(T[kC]), this.layer.transform) } this.maskBox = e; this.tileMaskUvCache.clear() } else { this.maskBox = null } }, buildFillMaskVertex: function (kI, kG, kF) { var kH = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]; if (!this.maskBox) { return kH } var kK = [kI, kG, kF].join("-"); var e = this.tileMaskUvCache.getData(kK); if (e) { return e } if (this.hasMaskPng) { var kN = this.maskBox || []; var kE = [kF, kI, kG]; var kJ = dL.getTileRangeExtent(kE); var kD = kN[1][0] - kN[0][0]; var T = kN[1][1] - kN[0][1]; var kM = (kJ.minX - kN[0][0]) / kD; var kL = (kJ.minY - kN[0][1]) / T; var kC = (kJ.maxX - kN[0][0]) / kD; var i = (kJ.maxY - kN[0][1]) / T; kH = [kM, kL, kC, kL, kC, i, kM, kL, kC, i, kM, i] } this.tileMaskUvCache.setData(kK, kH); return kH }, loadMaskPng: function (T) { var e = this; function i(kD, kC) { e.maskTextureSource = kC ? kD : null; if (kC) { e.hasMaskPng = true; e.setMaskImageObject(kD); e.calMaskBox(); e.doOnceDraw() } else { e.hasMaskPng = false } } this.imageLoad(T, i) }, imageLoad: function (i, kD) { if (!i) { kD && kD(null, false) } var e = new Image(); e.crossOrigin = "anonymous"; e.onload = function kC() { kD && kD(this, true) }; e.onerror = function T() { kD && kD(null, false) }; e.src = i }, toString: function () { return "PixelLayer" } }); function jz(i, e) { this.id = i; this.layerName = e; this.properties = null } function ek(e) { this._opt = e || {}; this._layerId = dc(); this._opt.defaultOrder = (this._opt.defaultOrder === undefined) ? true : this._opt.defaultOrder; this.minZoom = this._opt.minZoom || 3; this.maxZoom = this._opt.maxZoom || 23; this.useThumb = (this._opt.useThumb === undefined) ? true : this._opt.useThumb; this.gridModel = this._opt.gridModel || ek.GridModel.BAIDUWEB; this.noCollision = (this._opt.noCollision === undefined) ? true : this._opt.noCollision; if (this.gridModel === ek.GridModel.BAIDUWEB) { this._opt.reference = "BD09MC" } else { if (!this._opt.transform) { this._opt.transform = { source: "BD09MC", target: "BD09MC" }; this._opt.reference = "BD09MC" } else { this._opt.reference = this._opt.transform.source || "GCJ02"; if (this._opt.reference === "EPSG3857") { this._opt.reference = "WGS84" } } } this.loadModule = false; if (this._opt.useWorker === undefined) { this._opt.useWorker = true } this.upStyle = this._opt.useWorker ? false : "useMain"; this._stateCube = {}; hQ.sendMessage(a1(4, 3, 8), ["layer", "mvt"]); var i = this; hm.load("mvtParse", function () { i._async() }, true); i.init(this._opt) } ek.GridModel = { BAIDUWEB: 0, GOOGLEWEB: 1 }; ek.LayerTypes = { POINT: "point", LINE: "line", FILL: "fill" }; ek.inherits(e9.BaseClass, "MVTLayer"); e9.extend(ek.prototype, { _async: function () { this.loadModule = true; this.mvt = new ek.MVTParse(this._opt); this.resolveStyle(this._opt); if (this.upStyle) { this.doOnceDraw() } }, init: function (i) { var T = b5() ? 64 : 256; i.dataType = 2; i.cacheSize = Math.max(i.cacheSize || T, 16); if (i.spanLevel === undefined || typeof i.spanLevel !== "number") { i.spanLevel = 0 } if (this.gridModel === ek.GridModel.BAIDUWEB) { var e = this.createTileLayer(i); i.spanLevel = 0; this.spanLevel = 0 } else { if (this.gridModel === ek.GridModel.GOOGLEWEB) { var e = new kp(i); this.spanLevel = i.spanLevel } } var kD = { type: "vector", layerId: this._layerId, g: this.gridModel, mc: this._opt.reference === "BD09MC" ? true : false, }; this.layerOption = Object.assign(kD, this._opt); if (i.index && i.index > 0) { e.zIndex = i.index } e.loadTileData = this._loadTile.bind(this); e.ontology = this; this.layer = e; var kC = this; e.addEventListener("ontilesloadstart", function () { kC.dispatchEvent(new fW("ontilesloadstart")) }); e.addEventListener("ontilesloadend", function () { kC.dispatchEvent(new fW("ontilesloadend")) }) }, createTileLayer: function (i) { const kC = i.tileUrlTemplate || ""; const kH = i.xTemplate || function (kO, kQ, kP) { return kO }; const kM = i.yTemplate || function (kO, kQ, kP) { return kQ }; const kF = i.zTemplate || function (kO, kQ, kP) { return kP }; const kL = i.bTemplate || function (kO, kR, kQ) { const kP = jy.tileToBoundRange({ col: kO, row: kR, zoom: kQ, baseTileSize: 256 }); return kP.MC.sw.lng + "," + kP.MC.sw.lat + "," + kP.MC.ne.lng + "," + kP.MC.ne.lat }; var kN = i.extent || []; const kG = i.extentCRSIsWGS84 || false; var T = i.minZoom || 0; var kJ = i.maxZoom || 23; var kK = i.spanLevel || 0; var kI = new hP({ transparentPng: true, dataType: 2, spanLevel: kK, tileTypeName: "web", cacheSize: i.cacheSize || 256, customLayer: true, clipTile: false, boundary: false, useThumbData: i.useThumbData || false }); if (kN.length === 4) { if (kG) { kN = dL.fromEPSG4326(kN) } var kD = dL.transformPointArr([kN[0], kN[1]], "EPSG3857", "BD09MC"); var kE = dL.transformPointArr([kN[2], kN[3]], "EPSG3857", "BD09MC"); kN = [kD[0], kD[1], kE[0], kE[1]] } kI.getTilesUrl = function (kV, kP, kU) { if (!kV || kP < 0 || kP < (T + kK) || kP > (kJ + kK)) { kI.tileCache.clear(); return null } if (kN.length === 4) { const kT = jy.tileToBoundRange({ col: x, row: y, zoom: z, baseTileSize: 256 }); var kW = e([kT.MC.getMin().lng, kT.MC.getMin().lat, kT.MC.getMax().lng, kT.MC.getMax().lat]); if (!kW) { return null } } var kQ = ""; if (kC) { kQ = kC; var kS = /[^\{}]*\{(.*)\}[^\}]*/; kQ.match(kS); var kR = []; if (RegExp.$1) { kR = RegExp.$1.split(",") } var kO = kF(kV.x, kV.y, kP); if (!kO) { return null } kQ = kQ.replace(/\{(.*)\}/, kR[(kV.x + kV.y) % kR.length]); kQ = kQ.replace(/\[x\]/gi, kH(kV.x, kV.y, kP)); kQ = kQ.replace(/\[y\]/gi, kM(kV.x, kV.y, kP)); kQ = kQ.replace(/\[z\]/gi, kF(kV.x, kV.y, kP)); kQ = kQ.replace(/\[b\]/gi, kL(kV.x, kV.y, kP)) } else { return null } return kQ }; function e(kO) { if (kN && kN instanceof Array && kN.length === 4) { if ((kN[0] <= kO[2] && kN[1] <= kO[3]) && (kN[2] >= kO[0] && kN[3] >= kO[1])) { return true } else { return false } } return true } return kI }, compileExpress: function (i, e) { var i = ek.ExpressParse.normalizePropertyExpression(i, e); return i }, resolveStyle: function (kE) { var kC = kE || {}; if (kC.style) { var kD = {}; if (!kC.layers || kC.layers.length === 0) { var kG = ek.LayerTypes.POINT; var i = ek.LayerTypes.LINE; var kF = ek.LayerTypes.FILL; if (kC.style[kG]) { kC.style[kG].type = "point" } if (kC.style[i]) { kC.style[i].type = "polyline" } if (kC.style[kF]) { kC.style[kF].type = "polygon" } } for (var T in kC.style) { if (kC.style.hasOwnProperty(T)) { var e = kC.style[T]; this._styleFormat(e.type, e.painter, T, kD) } } this.styleExpress = kD } }, _styleFormat: function (kD, e, i, kC) { var kF = {}; var kG = c8[kD]; if (!kG) { return } for (var T in e) { if (e.hasOwnProperty(T)) { var kE = this.compileExpress(e[T], kG[T]); kF[T] = kE } } kC[i] = { type: kD, painter: kF } }, evaluateContext: function (e, T, kC) { var i = e + "_" + T.getId(); var kD = this._stateCube[i]; if (kD) { T.setState(kD) } else { T._state = {} } return { properties: function () { return T && T.getProperties() }, featureState: kC === true ? {} : (T && T.getState()) } }, evaluates: function (i, kC, kD) { if (!this.styleExpress || !this.styleExpress.hasOwnProperty(i)) { return null } var kF = this.styleExpress[i].painter; var e = {}; for (var T in kF) { if (kF.hasOwnProperty(T)) { var kE = kF[T].evaluate(this.evaluateContext(i, kC, kD)); e[T] = kE } } return e }, _updateState: function (T, kC, e) { if (T instanceof jz && T.layerName && T.id) { var i = T.layerName + "_" + T.id; if (e) { this._set(kC, this._stateCube, i) } else { this._stateCube[i] = kC } this._stateCube[i].rank = (this._stateCube[i].rank || 0) + 1 } else { if (typeof T === "string") { if (e) { this._set(kC, this._stateCube, T) } else { this._stateCube[T] = kC } this._stateCube[T].rank = (this._stateCube[T].rank || 0) + 1 } } }, updateState: function (kD, kE, e) { var T = JSON.stringify(this._stateCube); if (!(kE && typeof kE === "object" && Object.keys(kE).length > 0)) { return } if (!e) { this._stateCube = {} } if (kD instanceof Array) { for (var kC = 0; kC < kD.length; kC++) { this._updateState(kD[kC], kE, e) } } else { this._updateState(kD, kE, e) } var kF = JSON.stringify(this._stateCube); if (T !== kF) { this.doOnceDraw() } }, replaceAllState: function (e) { var i = JSON.stringify(this._stateCube); this._stateCube = e; var T = JSON.stringify(this._stateCube); if (i !== T) { this.doOnceDraw() } }, getAllState: function () { return this._stateCube }, getStateByLayerName: function () { }, removeState: function (kC) { var e = JSON.stringify(this._stateCube); if (kC instanceof Array) { for (var T = 0; T < kC.length; T++) { if (kC[T] instanceof jz && kC[T].layerName) { delete this._stateCube[kC[T].layerName + "_" + kC[T].id] } else { if (typeof kC[T] === "string") { delete this._stateCube[kC[T]] } } } } else { if (kC instanceof jz && kC.layerName) { delete this._stateCube[kC.layerName + "_" + kC.id] } else { if (typeof kC === "string") { delete this._stateCube[kC] } } } var kD = JSON.stringify(this._stateCube); if (e !== kD) { this.doOnceDraw() } }, clearState: function () { var e = JSON.stringify(this._stateCube); if (e !== "{}") { this._stateCube = {}; this.doOnceDraw() } }, _set: function (i, kD, T) { var kC = kD[T] || (kD[T] = {}); for (var e in i) { kC[e] = i[e] } }, doOnceDraw: function () { if (this.map) { var e = new fW("onupdate"); this.map.dispatchEvent(e) } }, _releaseOutViewTileData: function (e) { if (!this.map || !this.map.dispatcher) { return } var i = this; e.layerId = this._layerId; this.map.dispatcher.broadcast("release", e, function (kE, T) { for (var kD = 0; kD < T.length; kD++) { for (var kC = 0; kC < T[kD].length; kC++) { i.layer.tileCache.removeData(T[kD][kC].tileKey); i.layer._checkLayerTilesLoaded() } } }) }, _loadTile: function (kF, T) { this.curViewTilesInfo = kF; if (!this.loadModule || !this.upStyle) { return } var kQ = this.layer.map; this._releaseOutViewTileData(kF); var kG = kQ.getZoom(); if (kG < this.minZoom || kG > this.maxZoom) { kQ._featureMgr.clearData(this.layer.drawIndex); kQ._featureMgr.clearLabelOverlayData(this.layer.drawIndex); kQ._featureMgr.clearLabelData(this.layer.drawIndex); return } var kH = this.layer.getZoomState(); if (T) { this.thumbCache = {}; var kO = -1; this.layer.tileLabels = []; var kK = kQ._customLabelMgr.virtualTiles["mvt_" + this.layer.drawIndex]; if (kK && kK.label) { this.layer.tileLabels.push(kK.label) } for (var kM = 0, kL = kF.length; kM < kL; kM++) { var kN = kF[kM]; var kD = this.layer.getTileKey(kN); var kP = this.layer.tileCache.getData(kD); kO = kN.zoom; if (this.useThumb) { this._setThumbData(kP, kN, kH) } else { if (kP && kP.status === "ready") { kQ._featureMgr.setData(kP, this.layer.drawIndex, 2); this._loadCacheLabel(kN, kP) } } } this.layer.tileLabels.labelZoom = kO; this.layer.updateLabels(kH); if (!this.noCollision) { var kE = Math.floor(kG); var kJ = kG - kE; var kI = Math.floor(this.layer.LAST_CALC_ZOOM); var e = this.layer.LAST_CALC_ZOOM - kI; var kS = false; if (this.layer.hasZoomChange) { if (Math.abs(kG - this.layer.LAST_CALC_ZOOM) >= 0.5) { kS = true } else { if (kJ < 0.5 && e >= 0.5) { kS = true } else { if (kJ >= 0.5 && e < 0.5) { kS = true } } } if (kS) { this.layer.cacheDataCollideLabels(0) } this.layer.LAST_CALC_ZOOM = kG } else { if (this.layer.tileLabels.length > 0) { this.layer.cacheDataCollideLabels(e9.Browser.ie ? 50 : 30) } } } else { this.layer.cacheDataCollideLabels(0) } return } for (var kM = 0, kL = kF.length; kM < kL; kM++) { var kN = kF[kM]; var kC = this.layer.getTilesUrl(new fv(kN.col, kN.row), kN.zoom, kN); if (!kC) { return } var kD = this.layer.getTileKey(kN); var kP = this.layer.tileCache.getData(kD); if (!kP) { kP = { status: "init", retry: 0 }; this.layer.numTileLoading++ } if (kP.status !== "ignore" && kP.status !== "ready" && kP.status !== "loading") { kP.status = "loading"; this.layer.tileCache.setData(kD, kP); if (this.upStyle === "useMain") { var kR = this; this._loadTileData(kN, function (kT, kU, i) { kR._tileDataCbk(kT, kU, i) }) } else { if (this.upStyle) { this._loadTileDataByWorker(kN) } } } } }, _loadCacheLabel: function (T, i) { var kD = i.tileData.hasChangeLabel(); if (kD) { i.label.status = "init" } if (i.label.status === "ready") { i.label.tileInfo = i.tileInfo; this.layer.tileLabels.push(i.label); if (i.label.textureSources && i.label.textureSources[T.zoom] && this.map._webglMapScene) { var kC = this.map._webglMapScene._painter; var e = i.label.imgKey; if (!kC._labelTextureAtlasOffset[e]) { kC._addToAsyncJob(i.label.textureSources[T.zoom]) } } } else { if (i.label.status !== "processing") { this._processLabelData(i) } } }, getLayerVisible: function (i) { var T = this._opt.style; if (!T || !T[i]) { return true } else { if (T[i].visible === false) { return false } else { var kD = this._opt.style[i].minZoom || 3; var e = this._opt.style[i].maxZoom || 23; var kC = this.map.getZoom(); if (kC < kD || kC > e) { return false } return true } } }, _setThumbData: function (i, e, T) { if (T === 1) { this._dataFitGrid(i, e, 3) } else { if (T === -1) { if (i && i.status === "ready") { this.map._featureMgr.setData(i, this.layer.drawIndex, 2); this._loadCacheLabel(e, i) } else { this._findChildZoomTile(e, 3) } } } }, _findParent: function (kC, kF) { var T = this.minZoom; var e = kC.col; var kI = kC.row; var kH = kC.zoom; for (var kG = 1; kG <= kF; kG++) { var kD = this._getParentTiles(e, kI, kH, T); if (kD === null) { continue } kD.tileSize = kC.tileSize; kD.tileTypeName = kC.tileTypeName; kD.transform = kC.transform; var kJ = this.layer.getTileKey(kD); var kE = this.layer.tileCache.getData(kJ); if (kE && kE.status === "ready") { kE.key = kJ; return kE } e = kD.col; kI = kD.row; kH = kD.zoom } return false }, _findChild: function (i, kF) { var kH = this.maxZoom; var e = i.col; var kI = i.row; var kG = i.zoom; var kD = this._getChildTiles(e, kI, kG, kH, kF); if (!kD) { return false } for (var kC = 0; kC < kD.length; kC++) { var T = this.layer.getTileKey(kD[kC]); var kE = this.layer.tileCache.getData(T); if (this.curViewTilesInfo["id_" + kD[kC].col + "_" + kD[kC].row + "_" + kD[kC].zoom] && (!kE || kE.status !== "ready")) { return false } } return true }, _dataFitGrid: function (T, i, kC) { var e = this._findParent(i, kC); if (e) { if (this.thumbCache[e.key]) { this.map._featureMgr.setData(T, this.layer.drawIndex, 2); this._loadCacheLabel(i, T) } else { if (this.thumbCache[e.key] === undefined) { if (this._findChild(e.tileInfo, i.zoom - e.tileInfo.zoom)) { this.thumbCache[e.key] = true; this.map._featureMgr.setData(T, this.layer.drawIndex, 2); this._loadCacheLabel(i, T) } else { this.thumbCache[e.key] = false; this.layer.map._featureMgr.setData(e, this.layer.drawIndex, 0); this._loadCacheLabel(e.tileInfo, e) } } } } else { if (T && T.status === "ready") { this.map._featureMgr.setData(T, this.layer.drawIndex, 2); this._loadCacheLabel(i, T) } } }, _findChildZoomTile: function (T, kG) { var kJ = this.maxZoom; var e = T.col; var kK = T.row; var kI = T.zoom; for (var kH = 1; kH <= kG; kH++) { var kL = false; var kE = this._getChildTiles(e, kK, kI, kJ, kH); if (!kE) { continue } for (var kD = 0; kD < kE.length; kD++) { var kC = this.layer.getTileKey(kE[kD]); var kF = this.layer.tileCache.getData(kC); if (kF && kF.status === "ready") { this.layer.map._featureMgr.setData(kF, this.layer.drawIndex, 1); this._loadCacheLabel(kE[kD], kF); kL = true } } if (kL) { break } } }, _getParentTiles: function (e, T, i, kC) { if (i - 1 < kC) { return null } return { col: Math.floor(e / 2), row: Math.floor(T / 2), zoom: i - 1, useZoom: i - 1, loopOffsetX: 0 } }, _getChildTiles: function (kC, kL, kK, kJ, kF) { var kM = []; if (kK + kF > kJ) { return null } var kI = Math.pow(2, kF); var e = kC * kI; var kH = kL * kI; var kG = kK + kF; var kM = []; for (var kD = 0; kD < kI; kD++) { var kE = e + kD; for (var T = 0; T < kI; T++) { var i = kH + T; kM.push({ col: kE, row: i, zoom: kG, useZoom: kG, loopOffsetX: 0 }) } } return kM }, _loadTileDataByWorker: function (i) { if (!this.map || !this.map.dispatcher) { return } var kE = this.map.dispatcher.getActor(); if (!kE) { return } var T = i.col; var kJ = i.row; var kI = i.zoom; var e = this.layer.getTilesUrl(new fv(T, kJ), kI, i); if (!e) { return } var kD = this.layer.getTileKey(i); var kG = "id_" + T + "_" + kJ + "_" + kI; var kF = this._opt.header || null; if (this._opt.header instanceof Function) { kF = this._opt.header(e) } if (this._opt.urlCallback instanceof Function) { e = this._opt.urlCallback(e) } var kC = { type: "vector", layerId: this._layerId, x: T, y: kJ, z: kI, tileKey: kD, tileUrl: e, spanLevel: this._opt.spanLevel, header: kF, encrypt: this._opt.encrypt || false }; var kH = this; kE.send("loadTile", kC, function (kM, kL) { if (!kH.layer || !kH.layer.tileCache) { kH.layer._checkLayerTilesLoaded(); return } var kK = kH.layer.tileCache.getData(kD); if (!kK) { kH.layer._checkLayerTilesLoaded(); return } if (kM || !kL) { kK.status = "ignore"; kH.layer._checkLayerTilesLoaded() } else { var kN = new ek.TileFamilyParse(kH.layerOption, kC).deserialize(kL, kH); kK.tileInfo = i; kK.tileData = kN; kH._processLabelData(kK); kH.layer.callbackDataQueue.push([kD, kK, kG]); if (kH.processDataTimer) { return } kH.processDataTimer = setTimeout(function () { while (kH.layer && kH.layer.callbackDataQueue.length > 0) { kH.layer._checkLayerTilesLoaded(); var kP = kH.layer.callbackDataQueue.shift(); kH._setTileData(kP[0], kP[1], kP[2]) } var kO = new fW("onupdate"); kH.map.dispatchEvent(kO); kH.processDataTimer = null }, 0) } }) }, _loadTileData: function (i, e) { var kC = i.col; var kG = i.row; var kD = i.zoom; var T = this.layer.getTilesUrl(new fv(kC, kG), kD, i); if (!T) { return } var kF = this.layer.getTileKey(i); var kE = new XMLHttpRequest(); kE.open("GET", T, true); kE.responseType = "arraybuffer"; kE.timeout = 3000; kE.ontimeout = function () { e && e(null, kF, i) }; kE.onreadystatechange = function (kH) { if (this.readyState === 4) { if (this.status === 200) { e && e(kE.response, kF, i); return } if (this.status >= 400 || this.status === 0) { e && e(null, kF, i) } else { e && e(null, kF, i) } } }; kE.send() }, _tileDataCbk: function (kD, kF, i) { var e = this.layer.tileCache.getData(kF); if (!e) { return } var kE = this.layer.map; var T = this; if (!kD || typeof kD === "string") { e.status = "init"; e.reloadTimer = setTimeout(function () { if (e.retry < 3) { e.retry++; e.status = "loading"; T._loadTileData(i, function (kH, kI, kG) { T._tileDataCbk(kH, kI, kG) }) } else { e.status = "ignore" } }, 3000); return } if (e.reloadTimer) { clearTimeout(e.reloadTimer); e.reloadTimer = null } var kC = (function (kG) { return function () { var kH = i.col; var kK = i.row; var kI = i.zoom; var kJ = "id_" + kH + "_" + kK + "_" + kI; e.tileInfo = i; e.tileData = T.mvt.readFeatures(kG, T, kE, { x: kH, y: kK, z: kI, g: T.gridModel, mc: T._opt.transform && T._opt.transform.source === "BD09MC" ? true : false }); T._processLabelData(e); T.layer.callbackDataQueue.push([kF, e, kJ]); if (T.processDataTimer) { return } T.processDataTimer = setTimeout(function () { while (T.layer.callbackDataQueue.length > 0) { var kL = T.layer.callbackDataQueue.shift(); T._setTileData(kL[0], kL[1], kL[2]) } T.doOnceDraw(); T.processDataTimer = null }, 200) } })(kD); kE.jobScheduler.addJob(kC) }, _setTileData: function (T, e, i) { e.status = "ready"; this.layer.tileCache.setData(T, e); if (this.layer.curViewTilesInfo[i]) { e.dataType = h3 } }, _processLabelData: function (T) { if (!T.tileData) { return } T.label = T.tileData.getTileLabels(); if (!T.label) { return } if (T.label.status === "processing") { return } var i = T.tileInfo; var e = this._getTileTexImgKey(i); T.label.imgKey = e; T.label.status = "processing"; var kC = this; kC.layer.updateAllIconsTextureCoords(T); this.layer.labelProcessor.loadIconImages(T, function (kE) { kC.layer.updateAllIconsTextureCoords(kE) }, true); var kD = this.layer.map.tileMgr.getLabelTextCanvas(); kD.drawCustomLabelsOnCanvas(T.label.fixedLabel, function (kE) { if (kE) { if (!T.label.textureHeights) { T.label.textureHeights = [] } T.label.textureHeights[i.useZoom] = kE.height } kC.layer._doWorkAfterLabelImageLoad(T, kE, null, e) }) }, _getTileTexImgKey: function (i) { var e = "mvt_" + this.layer.drawIndex + "_" + i.col + "_" + i.row + "_" + i.zoom + "_"; e = bG.getGUID(e); return e }, _updateBRushCube: function (kF) { var kH = kF.tileData; for (var T in kH) { if (kH.hasOwnProperty(T)) { var e = kH[T]; for (var kD = 0; kD < e.length; kD++) { var kC = e[kD]; var kE = kC.getBox(); var kG = { minX: kE[0], minY: kE[1], maxX: kE[2], maxY: kE[3], lN: T, f: kC } } } } }, intersectFeatures: function (e) { var kE = this._geojsonToSouceXY(e); var T = this._bboxTile(kE); T = this._intersectTile(kE, T); if (!T) { return null } var kG = this.layer.map._featureMgr.result.bkData[this.layer.drawIndex][2]; var kC = []; var kL = null; for (var kH = 0; kH < kG.length; kH++) { var kD = kG[kH].tileInfo; var kM = kD.zoom + "_" + kD.col + "_" + kD.row; if (T[kM]) { if (!kG[kH].tileData || !kG[kH].tileData.layers) { continue } var kF = kG[kH].tileData.layers; var kK = null; for (var kJ in kF) { var kI = kF[kJ]; if (T[kM][4]) { this._featuresInter(kJ, kI.features, kC) } else { if (kI.layerType === "Point" || kI.layerType === "MultiPoint") { if (!kL) { kL = this._geojsonToScreenXY(e) } this._pointFeaturesInter(kJ, kI.features, kC, kL) } else { if (!kK) { kK = this._geojsonToTileXY(kE, T[kM]) } if (!kK) { continue } this._noPointFeaturesInter(kJ, kI.features, kC, kK) } } } } } return kC.length === 0 ? null : kC }, _featuresInter: function (T, kC, kD) { for (var i in kC) { if (!kC[i]._visible) { continue } if (kD[T + "_" + kC[i].getId()]) { continue } kC[i].layerName = T; var e = new jz(kC[i].getId(), T); e.properties = kC[i].getProperties(); kD.push(e); kD[T + "_" + kC[i].getId()] = true } }, _pointFeaturesInter: function (kD, kE, kF, kC) { for (var T in kE) { if (!kE[T]._visible) { continue } if (kF[kD + "_" + kE[T].getId()]) { continue } var kG = kE[T].getPointGeoJSON(this.layer.map); if (!kG) { continue } var i = ek.booleanDisjoint(kG, kC); if (!i) { kE[T].layerName = kD; var e = new jz(kE[T].getId(), kD); e.properties = kE[T].getProperties(); kF.push(e); kF[kD + "_" + kE[T].getId()] = true } } }, _noPointFeaturesInter: function (kD, kE, kF, kC) { for (var T in kE) { if (!kE[T]._visible) { continue } if (kF[kD + "_" + kE[T].getId()]) { continue } var i = ek.booleanDisjoint(kE[T].geojson, kC); if (!i) { kE[T].layerName = kD; var e = new jz(kE[T].getId(), kD); e.properties = kE[T].getProperties(); kF.push(e); kF[kD + "_" + kE[T].getId()] = true } } }, pickFeatures: function (kP, kD) { if (this.running) { return } var T = Math.floor(this.map.getZoom() + this.spanLevel); if (this.gridModel === ek.GridModel.BAIDUWEB) { var kN = Math.pow(2, 18 - T); var kE = Math.floor(kP.lng / kN / 256); var kH = Math.floor(kP.lat / kN / 256); var kC = kP.lng / kN - kE * 256; var kI = kP.lat / kN - kH * 256; var kG = [kC, kI]; var kV = [T, kE, kH] } else { var kT = dL.transformBDmcPoint(kP, this.layer.transform); var kO = dL.getPointPixelCoor(kP, T, this.layer.transform); var kV = dL.getTileCoordForCoordAndZ(kT, T); var kG = dL.getRelativePixelCoor(kV, kO) } var kW = this.layer.map._featureMgr.result.bkData[this.layer.drawIndex][2]; var kM = kV.join("_"); var kJ = []; for (var kR = 0; kR < kW.length; kR++) { var kS = kW[kR].tileInfo; var kX = kS.zoom + "_" + kS.col + "_" + kS.row; if (kM === kX) { this.running = true; if (!kW[kR].tileData || !kW[kR].tileData.layers) { continue } var kK = kW[kR].tileData.layers; for (var kU in kK) { var kF = kK[kU].features; for (var kQ in kF) { if (!kF[kQ]._visible) { continue } if (kJ[kU + "_" + kF[kQ].getId()]) { continue } if (kF[kQ].getType() === f3.POINT || kF[kQ].getType() === f3.MULTI_POINT) { var e = kF[kQ].isPointInGeometry(kD, this.layer.map) } else { var e = kF[kQ].isPointInBox(kG); if (e) { e = kF[kQ].isPointInGeometry(kG) } } if (e) { kF[kQ].layerName = kU; var kL = new jz(kF[kQ].getId(), kU); kL.properties = kF[kQ].getProperties(); kJ.push(kL); kJ[kU + "_" + kF[kQ].getId()] = true } } } break } } this.running = false; return kJ }, _geojsonToScreenXY: function (T) { var i = JSON.parse(JSON.stringify(T)); var e = this; gO.coordEachReplace(i, function (kE) { var kC = jy.convertLL2MC(new cG(kE[0], kE[1])); var kD = e.map.pointToPixelIn(kC); return [kD.x, kD.y] }); return i }, _geojsonToTileXY: function (T, kD) { if (kD.length < 4) { return null } var i = JSON.parse(JSON.stringify(T)); var kC = Math.floor(this.map.getZoom() + this.spanLevel); if (this.gridModel === ek.GridModel.BAIDUWEB) { var e = Math.pow(2, (18 - kC)) } else { var e = dL.resolutions[kC] } gO.coordEachReplace(i, function (kE) { return [(kE[0] - kD[2]) / e, (kE[1] - kD[3]) / e] }); return i }, _geojsonToSouceXY: function (T) { var i = JSON.parse(JSON.stringify(T)); var e = this; gO.coordEachReplace(i, function (kE) { var kC = jy.convertLL2MC(new cG(kE[0], kE[1])); var kD = [kC.lng, kC.lat]; if (e.gridModel !== ek.GridModel.BAIDUWEB) { kD = dL.transformBDmcPoint(kC, e.layer.transform) } return kD }); return i }, _bboxTile: function (T) { var kF = gO.bbox(T); var kK = Math.floor(this.map.getZoom() + this.spanLevel); if (this.gridModel === ek.GridModel.BAIDUWEB) { var kI = new cG(kF[0], kF[1]); var kL = new cG(kF[2], kF[3]); var kG = Math.pow(2, 18 - kK); var kM = Math.floor(kI.lng / kG / 256); var kE = Math.floor(kI.lat / kG / 256); var kD = Math.floor(kL.lng / kG / 256); var i = Math.floor(kL.lat / kG / 256); return [kK, kM, kE, kD, i] } else { var e = [kF[0], kF[3]]; var kH = [kF[2], kF[1]]; var kJ = dL.getTileCoordForCoordAndZ(e, kK); var kC = dL.getTileCoordForCoordAndZ(kH, kK); return [kJ[0], kJ[1], kJ[2], kC[1], kC[2]] } }, _intersectTile: function (e, kF) { var kM = {}; if (kF.length < 5) { return null } var kI = gO.getType(e); var kN = false; if (e.type === "Feature" && kI === "Polygon") { kN = true } for (var kD = kF[1]; kD <= kF[3]; kD++) { for (var kC = kF[2]; kC <= kF[4]; kC++) { if (this.gridModel === ek.GridModel.BAIDUWEB) { var kH = jy.tileToBoundRange({ col: kD, row: kC, zoom: kF[0], baseTileSize: 256 }); var kE = [kH.MC.sw.lng, kH.MC.sw.lat, kH.MC.ne.lng, kH.MC.ne.lat] } else { var kH = dL.getTileRangeExtent([kF[0], kD, kC]); var kE = [kH.minX, kH.minY, kH.maxX, kH.maxY] } var kG = { type: "Feature" }; kG.bbox = kE; kG.geometry = { type: "Polygon", coordinates: [[[kE[0], kE[1]], [kE[2], kE[1]], [kE[2], kE[3]], [kE[0], kE[3]], [kE[0], kE[1]],]] }; var T = ek.booleanDisjoint(kG, e); if (!T) { var kL = kF[0] + "_" + kD + "_" + kC; var kK = [kD, kC, kE[0], kE[1], false]; if (kN) { var kJ = ek.booleanContains(e, kG); if (kJ) { kK[4] = true } } kM[kL] = kK } } } return Object.keys(kM).length === 0 ? null : kM }, _initEvent: function (kF) { this.map = kF; if (!this.map.dispatcher) { this.map.dispatcher = new cL(hF(), ek) } var kD = this; this.map.dispatcher.broadcast("setLayerStyle", kD.layerOption, function (kH, i) { kD.upStyle = true; if (kD.loadModule) { kD.doOnceDraw() } }); var kC = this; var e = false; this._layerMouseEvent = function (kJ) { if (!kC.map || !kC._listeners) { return } if (!kC._listeners.onmousemove || Object.keys(kC._listeners.onmousemove).length === 0) { return } var kH; var i = kJ.point; var kI = kC.pickFeatures(i, kJ.pixel); if (kI && kI.length > 0) { kH = new fW("onmousemove"); kH.value = kI; kC.map.platform.style.cursor = kC.map.config.overlayMoveCursor; e = true } else { kC.map.platform.style.cursor = kC.map.config.defaultCursor; if (!e || !kC._listeners.onmouseout || Object.keys(kC._listeners.onmouseout).length === 0) { return } kH = new fW("onmouseout"); e = false } if (kH) { kH.point = kJ.point; kH.pixel = kJ.pixel; kH.latLng = kJ.latlng; kC.dispatchEvent(kH) } }; this._layerClickEvent = function (kJ) { if (!kC.map || !kC._listeners) { return } if ((!kC._listeners.onclick && !kC._listeners.dblclick) || (Object.keys(kC._listeners.onclick).length === 0 && Object.keys(kC._listeners.dblclick).length === 0)) { return } var kH; var i = kJ.point; var kI = kC.pickFeatures(i, kJ.pixel); kH = new fW(kJ.type); kH.point = i; kH.pixel = kJ.pixel; kH.latLng = kJ.latlng; kH.value = kI; kC.dispatchEvent(kH) }; kF.addEventListener("onmousemove", this._layerMouseEvent); var kE = ["onclick", "dblclick"]; for (var T = 0; T < kE.length; T++) { var kG = kE[T]; kF.addEventListener(kG, this._layerClickEvent) } kF.addEventListener("removetilelayer", function (i) { if (i.target && i.target.ontology) { if (i.target.ontology === kC) { kC.layer.tileCache.clear(); kC.stateCube = {}; kC.upStyle = false; kF.removeEventListener("onmousemove", kC._layerMouseEvent); kF.removeEventListener("onclick", kC._layerClickEvent); kF.removeEventListener("ondblclick", kC._layerClickEvent); if (kF.dispatcher) { kF.dispatcher.broadcast("removeLayer", kC.layerOption, function (kJ, kH) { var kL = kF.tileMgr.tileLayers; var kI = false; for (var kK = 0; kK < kL.length; kK++) { if (kL[kK].ontology instanceof ek) { kI = true; break } } if (!kI && kF.dispatcher) { kF.dispatcher.remove(); kF.dispatcher = null } }) } } } }); kF.on("destroy", function () { if (kC.map && kC.map.dispatcher) { kC.map.dispatcher.remove(); kC.map.dispatcher = null } kC.layer.ontology = null; kC.layer = null }); this.addEventListener("onmousemove", function () { }) }, setStyle: function (e) { this._opt.style = e; if (!this.map || !this.loadModule) { return } this.resolveStyle(this._opt); var i = this; if (this.upStyle === true) { this.map.dispatcher.stop(); this.map.dispatcher.broadcast("stop", null, function (kC, T) { i.layerOption = Object.assign(i.layerOption, i._opt); i.map.dispatcher.broadcast("setLayerStyle", i.layerOption, function (kE, kD) { i.layer.tileCache.clear(); i.doOnceDraw() }) }) } else { i.layer.tileCache.clear(); i.doOnceDraw() } }, setZIndex: function (e) { if (this.layer && parseInt(e) > 0) { this.layer.setZIndex(e) } }, getZIndex: function () { if (this.layer) { return this.layer.zIndex } }, setZIndexTop: function () { if (this.layer) { this.layer.setZIndexTop() } }, setUpLevel: function () { if (this.layer) { var e = this.layer._getAdjoinZIndex("up"); if (this.layer.zIndex !== e) { this.layer.setZIndex(e) } } }, setDownLevel: function () { if (this.layer) { var e = this.layer._getAdjoinZIndex("down"); if (this.layer.zIndex !== e) { this.layer.setZIndex(e) } } }, toString: function () { return "MVTLayer" } }); ek._generateTexture = function (kF, kE, T) { var kD = document.createElement("canvas"); var e; var kC; if (kE.strokeStyle === "dashed") { e = 16; kC = e * 8 } else { if (kE.strokeStyle === "dotted") { e = 32; kC = e * 2 } } kD.width = e; kD.height = kC; var i = kD.getContext("2d"); i.fillStyle = kE.strokeColor; i.globalAlpha = kE.strokeOpacity; var kG = kE.strokeWeight * 2; if (kE.strokeStyle === "dashed") { kG = ek._drawDashArrayTexture(i, e, kC, kE) } else { if (kE.strokeStyle === "dotted") { kG = ek._drawDottedTexture(i, e, kC, kE.strokeWeight) } } if (window.createImageBitmap && !kE.sync) { createImageBitmap(kD, { imageOrientation: "flipY" }).then(function (kH) { T(null, { totalDashLen: kG, texture: kH, textureSize: [e, kC] }) }) } else { T(null, { totalDashLen: kG, texture: kD.toDataURL(), textureSize: [e, kC] }) } }; ek._drawDashArrayTexture = function (kI, kC, kE, T) { var kG = T.dashArray; if (!kG) { kI.fillRect(0, 0, kC, kE / 2); return T.strokeWeight * 4 } else { var kH = 0; if (kG.length % 2 !== 0) { kG = kG.concat(kG) } for (var kD = 0; kD < kG.length; kD++) { kH += kG[kD] } var e = 0; for (var kD = 0; kD < kG.length; kD++) { var kF = kG[kD] / kH * kE; if (kD % 2 === 0) { kI.fillRect(0, e, kC, kF) } e += kF } return kH } }; ek._drawDottedTexture = function (i, e, T, kC) { i.beginPath(); i.arc(e / 2, e / 2, e / 2, 0, 2 * Math.PI); i.fill(); i.closePath(); return kC * 2 }; var X = function (e) { var e = e || {}; this.inputCRS = e.inputCRS || "EPSG3857"; this.outCRS = e.outCRS || "EPSG3857"; this.minZoom = e.minZoom || 3; this.maxZoom = e.maxZoom || 19; this.retry = e.retry || false; this.retryTime = e.retryTime || 600; this.useThumbData = e.useThumbData || true; this.lastZoom = 3; this.cacheSize = e.cacheSize || 128; this.tileType = il.getInstance("web"); this._mapCenter = {}; this._featureMgr = [[], [], []]; this._gridRefs = { row: {}, col: {} }; this.tileCache = new aC(this.cacheSize, { clearCallback: function (i) { } }) }; X.inherits(dh, "BaiduLayer"); e9.extend(X.prototype, { fetch: function (i, kC, kD) { var kC = Math.ceil(kC) || 3; var i = i || []; if (i.length !== 4 || kC > 19) { kD(null); return } var e = this.getZoomState(kC); var T = this.calCoord(i, kC, e); this.curViewTilesInfo = this.calTilesOrders(T.sw, T.ne, kC); this.clearData(); this.clearRefs(); this.loadLayerData(this.curViewTilesInfo, e, true, kD) }, calCoord: function (T, kC, i) { if (T.length !== 4) { return } var e = gcoord.transform([T[0], T[1]], gcoord[this.inputCRS], gcoord.BD09MC); var kD = gcoord.transform([T[2], T[3]], gcoord[this.inputCRS], gcoord.BD09MC); if (kD[1] > 19505879.362428114 || e[1] < -15949096.637571886) { kD[1] = 19505879.362428114; e[1] = -15949096.637571886 } this._mapCenter[kC] = new cG((e[0] + kD[0]) / 2, (e[1] + kD[1]) / 2); return { sw: e, ne: kD } }, calTilesOrders: function (kH, kN, kJ) { var kK = this.tileType.getMercatorSize(kJ, kJ); var kF = [Math.floor(kH[0] / kK), Math.floor(kH[1] / kK)]; var i = [Math.floor(kN[0] / kK), Math.floor(kN[1] / kK)]; var kG = kF[0] - 1; var kE = i[0] + 2; var kD = kF[1] - 1; var kM = i[1] + 2; var kI = []; for (var kC = kG; kC < kE; kC++) { for (var kL = kD; kL < kM; kL++) { var T = { col: kC, row: kL, zoom: kJ, useZoom: kJ, tileTypeName: "web", loopOffsetX: 0, tileSize: 256, baseTileSize: 256, mercatorSize: kK, combine: false, dataIndex: 256 }; kI.push(T); var e = "id_" + kC + "_" + kL + "_" + kJ; kI[e] = true } } kI.sort((function (kO) { return function (kP, kQ) { return ((0.4 * Math.abs(kP.col - kO[0]) + 0.6 * Math.abs(kP.row - kO[1])) - (0.4 * Math.abs(kQ.col - kO[0]) + 0.6 * Math.abs(kQ.row - kO[1]))) } })([(kG + kE) / 2, (kD + kM) / 2])); kI.zoom = kJ; kI.tileTypeName = "web"; return kI }, getZoomState: function (i) { var e = i - this.lastZoom; if (e > 0) { this.zoomState = 1 } else { if (e < 0) { this.zoomState = -1 } } this.lastZoom = i; return this.zoomState || 0 }, loadLayerData: function (kJ, kC, kD, kI) { this.thumbCache = {}; if (kD) { for (var kG = 0, kE = kJ.length; kG < kE; kG++) { var T = kJ[kG]; var kF = this.getTileKey(T); var e = this.tileCache.getData(kF); if (e && e.status === "ready") { e.key = kF; this.setData(e, 2) } else { if (this.useThumbData) { kC === 1 && this.setThumbData(T.col, T.row, T.zoom, T.useZoom, kC) } } } this.calOutData(kI) } for (var kG = 0, kE = kJ.length; kG < kE; kG++) { var T = kJ[kG]; var kF = this.getTileKey(T); var e = this.tileCache.getData(kF); if (!e) { this.tileCache.setData(kF, {}); var kH = this; this.loadRasterTileData(T, function (i, kK) { kH.rasterTileDataCbk(i, kK, kI) }) } } }, loadRasterTileData: function (i, e) { var T = new Image(); var kD = i.col; var kG = i.row; var kE = i.zoom; var kC = this.getTilesUrl(new fv(kD, kG), kE); if (!kC) { return } var kF = this.getTileKey(i); T = this.loadTileImage(kC, i, kF, e); T.tileInfo = i }, loadTileImage: function (kG, e, T, kE) { var kC = new Image(); kC.crossOrigin = "anonymous"; var kF = this; var kD; function kH() { if (kF.retry) { kD && clearInterval(kD); kD = null } } if (this.retry) { var i = 1; kD = setInterval(function () { if (i > 3) { kH(); return } var kI = kF.getTilesUrl(new fv(e.col, e.row), e.zoom, i); kC.src = kI; i++ }, this.retryTime) } kC.onload = function () { kH(); kE && kE(this, T) }; kC.onerror = function () { kH(); kE && kE(null, T) }; kC.src = kG; return kC }, rasterTileDataCbk: function (kD, kC, kG) { if (!kD || typeof kD === "string") { this.tileCache.removeData(kC); return } var i = kD.tileInfo; var T = i.col; var kI = i.row; var kH = i.zoom; var e = this.tileCache.getData(kC); if (!e) { return } e.textureSource = kD; e.dataType = gX; e.tileInfo = i; e.status = "ready"; this.tileCache.setData(kC, e); var kE = "id_" + T + "_" + kI + "_" + kH; var kF = false; if (this.curViewTilesInfo[kE]) { e.png8 = this.png8 || false; e.key = kC; this.setData(e, 2); kF = true } if (kF) { this.calOutData(kG, e) } }, getTilesUrl: function (kD, kK, i) { var kF = i || 0; var T = kD.x; var kL = kD.y; var kH = kd("ditu", "normal"); var kG = kH.udt; var kJ = ev.B_NORMAL_MAP.tileUrls; var kE = Math.abs(T + kL + kF) % kJ.length; var kI = kJ[kE]; if (T < 0) { T = "M" + (-T) } if (kL < 0) { kL = "M" + (-kL) } var kC = "x=" + T + "&y=" + kL + "&z=" + Math.floor(kK); kC += "&styles=pl&scaler=2&udt=" + kG + "&from=jsapi3_0"; var e = kI + "?qt=vtile&" + kC; return e }, calOutData: function (kI, T) { if (!T) { for (var kF = 0; kF < this._featureMgr.length; kF++) { var e = this._featureMgr[kF]; for (var kD = 0; kD < e.length; kD++) { var kC = e[kD].tileInfo; if (kF === 2) { var kG = e[kD].extent; if (kG) { this.addRefs(kG, kC.col, kC.row) } else { var kH = this.calBoxCoord(kC); if (!kH) { continue } e[kD].extent = this.findRefs(kH, kC.col, kC.row) } } } } kI({ size: this.curViewTilesInfo.length, zoom: this.lastZoom, data: this._featureMgr }) } else { var kE = this.calBoxCoord(T.tileInfo); if (!kE) { return } T.extent = this.findRefs(kE, T.tileInfo.col, T.tileInfo.row); kI({ zoom: this.lastZoom, size: this.curViewTilesInfo.length, data: [[], [], [T]] }) } }, calOutData_back: function (kK, kC) { if (!kC) { var kE; var kL; var kI; for (var kG = 0; kG < this._featureMgr.length; kG++) { var T = this._featureMgr[kG]; for (var kF = 0; kF < T.length; kF++) { var kD = T[kF].tileInfo; if (kG === 2) { if (kF === 0) { var kH = this.calBoxCoord(kD); T[0].extent = kH; kE = T[0]; kL = kH[2] - kH[0]; kI = kH[3] - kH[1] } else { if (kE && kL && kI) { var e = (kD.row - kE.tileInfo.row) * kI; var kJ = (kD.col - kE.tileInfo.col) * kL; var kH = kE.extent; T[kF].extent = [kH[0] + kJ, kH[1] + e, kH[2] + kJ, kH[3] + e] } } } else { var kH = this.calBoxCoord(kD); T[kF].extent = kH } } } kK({ size: this.curViewTilesInfo.length, zoom: this.lastZoom, data: this._featureMgr }) } else { if (this._featureMgr[2].length === 1) { var kH = this.calBoxCoord(kC.tileInfo); kC.extent = kH; this.featureCell = kC; this.cellW = kH[2] - kH[0]; this.cellH = kH[3] - kH[1] } else { var e = (kC.tileInfo.row - this.featureCell.tileInfo.row) * this.cellH; var kJ = (kC.tileInfo.col - this.featureCell.tileInfo.col) * this.cellW; var kH = this.featureCell.extent; kC.extent = [kH[0] + kJ, kH[1] + e, kH[2] + kJ, kH[3] + e] } kK({ zoom: this.lastZoom, size: this.curViewTilesInfo.length, data: [[], [], [kC]] }) } }, calBoxCoord: function (e) { var i = jy.prototype.tileToBound(e, this._mapCenter[e.zoom]).LL; var T = gcoord.transform([i.sw.lng, i.sw.lat], gcoord.BD09LL, gcoord[this.outCRS]); var kC = gcoord.transform([i.ne.lng, i.ne.lat], gcoord.BD09LL, gcoord[this.outCRS]); return [T[0], T[1], kC[0], kC[1]] }, clearData: function () { this._featureMgr = [[], [], []] }, addRefs: function (i, e, T) { this._gridRefs.row[T] = i[1]; this._gridRefs.row[T + 1] = i[3]; this._gridRefs.col[e] = i[0]; this._gridRefs.col[e + 1] = i[2] }, findRefs: function (i, e, kC) { var T = []; this._gridRefs.row[kC] && (T[1] = this._gridRefs.row[kC]); this._gridRefs.row[kC + 1] && (T[3] = this._gridRefs.row[kC + 1]); this._gridRefs.col[e] && (T[0] = this._gridRefs.col[e]); this._gridRefs.col[e + 1] && (T[2] = this._gridRefs.col[e + 1]); !this._gridRefs.row[kC] && (this._gridRefs.row[kC] = i[1]) && (T[1] = i[1]); !this._gridRefs.row[kC + 1] && (this._gridRefs.row[kC + 1] = i[3]) && (T[3] = i[3]); !this._gridRefs.col[e] && (this._gridRefs.col[e] = i[0]) && (T[0] = i[0]); !this._gridRefs.col[e + 1] && (this._gridRefs.col[e + 1] = i[2]) && (T[2] = i[2]); return T }, clearRefs: function () { this._gridRefs = { row: {}, col: {} } }, destroy: function () { this.tileCache.clear(); this.clearData(); this.clearRefs(); this._mapCenter = {} }, setData: function (kD, T) { var e = this._featureMgr[T]; for (var kC = 0; kC < e.length; kC++) { if (e[kC].key && e[kC].key === kD.key) { e[kC] = kD; return } } e.push(kD) }, getTileKey: function (e, kC) { kC = kC || {}; var i = typeof kC.useZoom === "number" ? kC.useZoom : e.useZoom; var T = "default"; return "web_" + T + "_" + e.col + "_" + e.row + "_" + e.zoom + "_" + i }, setThumbData: function (i, kD, kC, e, T) { if (T === 1) { if (this._findParentZoomTile(i, kD, kC, e, 8) === false) { this._findChildZoomTile(i, kD, kC, e, 3) } } else { if (T === -1) { if (this._findChildZoomTile(i, kD, kC, e, 3) === false) { this._findParentZoomTile(i, kD, kC, e, 8) } } } this.sortThumbData() }, _findParentZoomTile: function (kF, kO, kN, kD, kI) { var kE = "web"; var T = 3; var e = kF; var kL = kO; var kJ = kN; var kK = kD; for (var kH = 1; kH <= kI; kH++) { var kC = this.tileType.getParentTile(e, kL, kJ, kK, T); if (kC === null) { continue } var kM = this.getTileKey(kC); var kG = this.tileCache.getData(kM); if (kG && kG.status === "ready") { if (this.thumbCache[kM]) { continue } kG.key = kM; this.setData(kG, 0); this.thumbCache[kM] = true; return true } e = kC.col; kL = kC.row; kJ = kC.zoom; kK = kC.useZoom } return false }, _findChildZoomTile: function (kG, kI, e, kD, kR) { var kP = "web"; var kL = 21; var kF = kG; var kH = kI; var kJ = e; var kC = kD; var kE = true; for (var kO = 1; kO <= kR; kO++) { var kM = false; var T = this.tileType.getChildTiles(kF, kH, kJ, kC, kL, kO); if (!T) { continue } for (var kN = 0; kN < T.length; kN++) { var kK = this.getTileKey(T[kN]); var kQ = this.tileCache.getData(kK); if (kQ && kQ.status === "ready") { if (!this.thumbCache[kK]) { kQ.key = kK; this.setData(kQ, 1); this.thumbCache[kK] = true } kM = true } else { kE = false } } if (kM) { break } } return kE }, sortThumbData: function () { var e = this._featureMgr; if (!e) { return } if (e[0] && e[0].length > 0) { e[0].sort(function (T, i) { return T.tileInfo.useZoom - i.tileInfo.useZoom }) } } }); function dH(T, i) { aU.call(this, i); if (!b0(T)) { throw new Error("createDOM参数类型错误，请检查是否为Function") } var e = i || {}; this.config = {}; this.config.enableMassClear = false; this.config.minZoom = e.minZoom || 3; this.config.maxZoom = e.maxZoom || 21; this.config.zIndex = e.zIndex || 0; this.config.nextTick = e.nextTick || false; this.config.offsetX = e.offsetX || 0; this.config.offsetY = e.offsetY || 0; this.config.fixBottom = e.fixBottom || false; this.config.anchors = e.anchors || [0.5, 1]; this.config.coordinate = e.coordinate || "BD09"; this.config.enableDraggingMap = e.enableDraggingMap || false; this.config.visible = e.visible === undefined ? true : !!e.visible; this.config.useTranslate = e.useTranslate || false; this.sliceRepeat = e.sliceRepeat || false; this.displayType = e.displayType || "normal"; this.clusterAnimation = e.clusterAnimation || {}; this.clusterWait = null; this.clusterStatus = 0; this.createDOM = T; this.data = e.data || null; this.overlaysList = []; this.retainOverlays = []; this._eventList = {}; hQ.sendMessage(a1(4, 3, 13), ["layer", "overlay"]) } dH.inherits(dh, "CustomHtmlLayer"); e9.extend(dH.prototype, { initialize: function (i) { this.map = i; this.addToMap(); this.initEvent(i); var e = this; this.map.on("destory", function () { e._distory() }) }, initEvent: function () { if (!this.overlaysList || !this.map) { return } this._overlayEvent() }, setStyleOptions: function (e) { e = e || {}; Object.assign(this.config, e); this.updateData(this.data) }, addEventListener: function (e, i) { if (!this._eventList[e]) { this._eventList[e] = [i] } else { this._eventList[e].push(i) } this._overlayEvent() }, _overlayEvent: function () { if (!this.overlaysList || !this.map) { return } var kH = this.overlaysList; var e = this.overlaysList.length; var kG = Object.keys(this._eventList); for (var kF = 0; kF < kG.length; kF++) { var kC = kG[kF]; var kE = this._eventList[kC]; for (var kD = 0; kD < kE.length; kD++) { for (var T = 0; T < e; T++) { kH[T].addEventListener(kC, kE[kD]) } } } if (this.sliceRepeat && this.retainOverlays.length > 0) { this.overlaysList = this.overlaysList.concat(this.retainOverlays); this.retainOverlays = [] } }, show: function () { this.config.visible = true; this.updateData(this.data) }, hide: function () { this.config.visible = false; this.updateData(this.data) }, addToMap: function () { if (!this.overlaysList || !this.map) { return } var e = this.overlaysList.length; var kC = this.overlaysList; if (e > 0) { for (var T = 0; T < e; T++) { this.map.addOverlay(kC[T]) } } }, render: function (i) { this.config.enableMassClear = false; this.config.point = i.points; this.config.properties = i.properties; var e = new bU(this.createDOM, this.config); return e }, dataCompare: function (kF) { var kI = kF.features; var e = this.data.features; var kG = []; var kH = []; var kK = []; this.retainOverlays = []; for (var kE = 0; kE < kI.length; kE++) { var kJ = false; for (var kD = 0; kD < e.length; kD++) { if (kI[kE].id === e[kD].id) { kK.push(e[kD].id); kJ = true; break } } if (!kJ) { kH.push(kI[kE]) } } for (var kE = 0; kE < e.length; kE++) { var kJ = false; for (var kD = 0; kD < kI.length; kD++) { if (e[kE].id === kI[kD].id) { kJ = true; break } } if (!kJ) { kG.push(e[kE].id) } } for (var kE = 0; kE < this.overlaysList.length; kE++) { var kC = this.overlaysList[kE]; var T = kC._id; if (kG.indexOf(T) > -1) { this.map.removeOverlay(kC) } else { if (kK.indexOf(T) > -1) { this.retainOverlays.push(kC) } } } if (kH.length > 0) { this.overlaysList = []; return { type: "FeatureCollection", features: kH } } else { if (this.retainOverlays.length > 0) { this.overlaysList = this.retainOverlays; this.retainOverlays = [] } return null } }, setData: function (e) { if (!e.features || e.features.length === 0) { this.removeAllOverlays(); return } if (this.displayType === "cluster") { this._clusterDataReplace(e); return } var kC = []; if (this.sliceRepeat && this.data !== null) { kC = this.dataCompare(e); this.data = e; if (!kC) { return } } else { this.data = e; kC = e; this.removeAllOverlays() } var kD = this; if (!e) { this.data = null; return } var T = gO.getType(kC); if (T.toLowerCase() === "point") { var i = new gO({ reference: this.config.coordinate }); i.readFeaturesFromObject(kC, { isPoints: true }, function (kF) { var kE = kD.render(kF); if (kD.sliceRepeat) { kE._id = (typeof kD.sliceRepeat !== "boolean") ? kF.properties[kD.sliceRepeat] : kF.properties.clusterId } kE.id = "cus_" + parseInt(Math.random() * 1000000, 10); kD.overlaysList.push(kE) }); i = null } this.addToMap(); this.initEvent() }, _clusterDataReplace: function (kY) { if (this.clusterStatus) { this.clusterWait = kY; return } else { this.clusterWait = null } this.clusterStatus = 1; var kC = this.data ? (this.data.features || []) : []; var kM = JSON.parse(JSON.stringify(kY)); var kF = JSON.parse(JSON.stringify(kY.features)); var kO = []; var e = []; var kH = []; var kJ = {}; var T = []; var kQ = []; for (var kU = 0; kU < kC.length; kU++) { var kW = kC[kU]; for (var kT = 0; kT < kF.length; kT++) { var kP = kF[kT]; if (kW.properties.clusterId === kP.properties.clusterId) { kW.properties._status = "retain"; kP.properties._status = "isExist"; T.push(kW.properties.clusterId) } if (kW.properties.clusterId === kP.properties.parentId) { kW.properties._status = "remove_from"; e.push(kW.properties.clusterId); if (!kP._matched) { kP.properties._status = "new_discrete"; kP.properties._movefrom = kW.geometry.coordinates; kP.properties._moveto = kP.geometry.coordinates; kP.geometry.coordinates = kW.geometry.coordinates; kP._matched = 1; kQ.push(kP) } } if (kW.properties.parentId === kP.properties.clusterId) { kW.properties._status = "remove_to"; kJ[kW.properties.clusterId] = kP.geometry.coordinates; kH.push(kW.properties.clusterId); if (!kP._matched) { kP.properties._status = "new_cluster"; kQ.push(kP); kP._matched = 1 } } } if (!kW.properties._status) { kW.properties._status = "remove"; kO.push(kW.properties.clusterId) } } for (var kU = 0; kU < kF.length; kU++) { if (!kF[kU].properties._status) { kF[kU].properties._status = "new"; kQ.push(kF[kU]) } } this.retainOverlays = []; var kE = []; var kG = []; for (var kU = 0; kU < this.overlaysList.length; kU++) { var kV = this.overlaysList[kU]; var kR = kV._id; if (e.indexOf(kR) > -1) { kE.push(kV) } else { if (kH.indexOf(kR) > -1) { kV.properties._movefrom = [kV.getPoint().lng, kV.getPoint().lat]; kV.properties._moveto = kJ[kR]; kG.push(kV) } else { if (T.indexOf(kR) > -1) { this.retainOverlays.push(kV) } else { this.map.removeOverlay(kV) } } } } this.overlaysList = []; this.data = kM; if (kQ.length > 0) { this.overlaysList = []; kQ = { type: "FeatureCollection", features: kQ } } else { if (this.retainOverlays.length > 0) { this.overlaysList = this.retainOverlays; this.retainOverlays = []; this._nextCompare(); return } } var kD = []; var kS = []; var kI = []; var kN = new gO({ reference: this.config.coordinate }); var kX = this; kN.readFeaturesFromObject(kQ, { isPoints: true }, function (kZ) { var i = kX.render(kZ); i._id = (typeof kX.sliceRepeat !== "boolean") ? kZ.properties[kX.sliceRepeat] : kZ.properties.clusterId; switch (i.properties._status) { case "new_discrete": kD.push(i); break; case "new_cluster": kS.push(i); break; default: kI.push(i); break }kX.overlaysList.push(i) }); kN = null; if (this.clusterAnimation.delayRemove) { for (var kU = 0; kU < kE.length; kU++) { var kK = kE[kU]; kK.div.children[0].classList.add(this.clusterAnimation.delayRemove) } } if (this.clusterAnimation.moveRemove) { for (var kU = 0; kU < kG.length; kU++) { var kL = kG[kU]; kL.div.children[0].classList.add(this.clusterAnimation.moveRemove) } } this._clusterAni = new fL({ duration: this.clusterAnimation.duration || 300, delay: this.clusterAnimation.delay || 0, transition: gS.linear, render: function (k2, k1, kZ) { if (k1 === 0) { for (var k0 = 0; k0 < kS.length; k0++) { kX.map.addOverlay(kS[k0]); if (kX.clusterAnimation.delayNew) { kS[k0].div.children[0].className += " " + kX.clusterAnimation.delayNew } } for (var k0 = 0; k0 < kI.length; k0++) { kX.map.addOverlay(kI[k0]); if (kX.clusterAnimation.onlyNew) { kI[k0].div.children[0].className += " " + kX.clusterAnimation.onlyNew } } for (var k0 = 0; k0 < kD.length; k0++) { kX.map.addOverlay(kD[k0]); if (kX.clusterAnimation.moveNew) { kD[k0].div.children[0].className += " " + kX.clusterAnimation.moveNew } } } else { kX._moveTo(kG, k2); kX._moveTo(kD, k2) } }, finish: function (kZ) { kX._clusterAni = null; for (var k0 = 0; k0 < kE.length; k0++) { kX.map.removeOverlay(kE[k0]) } for (var k0 = 0; k0 < kG.length; k0++) { kX.map.removeOverlay(kG[k0]) } kX.initEvent(); kX._nextCompare() } }) }, _nextCompare: function () { this.clusterStatus = 0; if (this.clusterWait) { this._clusterDataReplace(this.clusterWait) } }, _moveTo: function (kG, kF) { for (var kD = 0; kD < kG.length; kD++) { var kE = kG[kD]; if (kE.properties._moveto) { var T = kE.properties._movefrom; var kC = kE.properties._moveto; var e = T[0] + (kC[0] - T[0]) * kF; var kH = T[1] + (kC[1] - T[1]) * kF; kE.setPoint(new cG(e, kH), true) } } }, clearData: function () { this.removeAllOverlays(); this.data = null }, updateData: function (e) { this.removeAllOverlays(); this.data = null; this.setData(e) }, removeLayer: function (T) { if (!(T instanceof dH) || !this.map) { return } var kC = T.overlaysList; for (var e = 0; e < kC.length; e++) { this.map.removeOverlay(kC[e]) } this._distory(T) }, removeAllOverlays: function () { if (!this.map || !this.overlaysList) { return } var T = this.overlaysList; for (var e = 0; e < T.length; e++) { this.map.removeOverlay(T[e]) } this.overlaysList = [] }, removeOverlay: function (T) { if (!this.map || !(this.overlaysList) || this.overlaysList.length <= 0) { return } var e = this.overlaysList.length; var kD = this.overlaysList; if (typeof T === "string") { for (var kC = 0; kC < e; kC++) { if (kD[kC].id === T) { this.map.removeOverlay(kD[kC]); kD.splice(kC, 1) } } } else { if (T instanceof aU) { for (var kC = 0; kC < e; kC++) { if (T === kD[kC]) { this.map.removeOverlay(T); this.overlaysList.splice(kC, 1); return } } } } }, _distory: function () { var T = this.overlaysList; for (var e = 0; e < T.length; e++) { T[e].div = null } this.overlaysList = []; this.createDOM = null; this.config = null; this.data = null }, getCustomOverlays: function () { return this.overlaysList }, toString: function () { return "CustomHtmlLayer" } }); function iH(e) { aU.call(this, e); var e = e || {}; this.options = {}; this.options.callback = e.callback ? e.callback : null; this._auth = false; this._remove = false; this.currentFloor = e.floor || 1; this.currentFloorName = "B1"; this.currentFloorKV = []; this.currentFloorStr = ""; this.currentUid = ""; this.currentCityId = 0; this.floorsCache = []; this.spotFillCache = []; this.spotFillLayer; this.spotFillData = []; this.spotOutFillLayer; this.spotOutFillData = []; this.cusInLabelUids = []; this.cusInBubbleUids = []; this.cusOutLabelUids = []; this.cusOutBubbleUids = []; this.labels = []; this.labelDatas = []; this.outLabels = []; this.outLabelDatas = []; this.bubbleDatas = []; this.jixieDatas = []; this.indoorUids; this.outdoorUids; this.indoorChange = true; this.cityChange = true; hQ.sendMessage(a1(4, 3, 14), ["layer", "parking"]) } iH.inherits(dh, "ParkingSpot"); e9.extend(iH.prototype, { initialize: function (e) { this.map = e; this.map.parking = this; this._verify() }, _verify: function () { var e = this; if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var i = { qt: d4 } } else { var i = { qt: d4, ak: eZ } } kl.request(function (kC) { if (kC && kC.result && !kC.result["error"] && kC.content && !kC.content["errno"]) { var kD = kC.content["data"]; e._auth = true; e.indoorUids = kD.support_indoor; e.outdoorUids = kD.support_outdoor; e._bindCityChange(); e._bindIndoorChange(); setInterval(function () { e.getIndoorDataByUid(e.currentUid, e.currentFloorName) }, 60000); var T = new aK(e.map); if (T && T._getIdByLoc) { T._getIdByLoc(T._loc, function (kE) { e.currentCityId = kE; e.getOutdoorDataByCityId(e.currentCityId); setInterval(function () { e.getOutdoorDataByCityId(e.currentCityId) }, 60000) }) } } else { console.error("你未开通智能停车高级服务！") } }, i) }, _initGraph: function (e) { if (e === "indoor") { this.spotFillLayer = new ed({ crs: "BD09LL", enablePicked: true, autoSelect: true, zIndex: 1, selectedColor: "#e5e7eb", pickWidth: 2, pickHeight: 2, style: { fillColor: ["match", ["get", "state"], 1, "#ffbfbb", 2, "#ddf4d7", "#e5e7eb"], fillOpacity: 1, strokeWeight: 1, strokeColor: "#fff" } }) } else { this.spotOutFillLayer = new ed({ crs: "BD09LL", enablePicked: true, autoSelect: true, zIndex: 1, selectedColor: "#e5e7eb", pickWidth: 2, pickHeight: 2, style: { fillColor: ["match", ["get", "state"], 1, "#ffbfbb", 2, "#ddf4d7", "#e5e7eb"], fillOpacity: 1, strokeWeight: 1, strokeColor: "#fff" } }) } }, _bindCityChange: function () { var e = this; this.map.addEventListener("citychange", function (i) { e.cityChange = true; if (e.currentCityId !== i.code) { e.currentCityId = i.code; e.getOutdoorDataByCityId(i.code) } }) }, _bindIndoorChange: function () { var e = this; var i = function (kG) { var kF = kG._indoorData[e.currentUid] ? kG._indoorData[e.currentUid].floors : []; var kE = []; for (var kD = 0; kD < kF.length; kD++) { if (kF[kD].floorName.charAt(0) === "B" || kF[kD].floorName.charAt(0) === "M") { e.currentFloorKV[kF[kD].floorName] = kD; kE.push(kF[kD].floorName) } } e.currentFloorStr = kE.join(","); e.getDataBefore(e.currentUid, e.currentFloorStr) }; if (e.currentUid || e.map._indoorMgr.currentUid) { var kC = e.map._indoorMgr; e.currentUid = kC.currentUid; e.currentFloor = kC.currentFloor; i(kC); var T = kC.getIndoorData(e.currentUid); e.currentFloorName = T.floors[e.currentFloor] ? T.floors[e.currentFloor].floorName : ""; e.getIndoorDataByUid(e.currentUid, e.currentFloorName, true) } map.on("indoor_status_changed", function (kG) { var kD = kG.uid; var kE = kG.floor; e.indoorChange = true; e.hideLayer("indoor"); var kH = e.map._indoorMgr; if (e.currentUid || e.map._indoorMgr.currentUid) { var kH = e.map._indoorMgr; e.currentUid = kH.currentUid; e.currentFloor = kH.currentFloor; i(kH) } if (!kD) { e.hideLabel() } else { if (this._indoorMgr && this._indoorMgr._indoorData[kD]) { var kF = this._indoorMgr._indoorData[kD]; e.currentUid = kD; e.currentFloor = kE; e.currentFloorName = kF.floors[kE].floorName; if (e.currentFloorName.charAt(0) === "F") { e.hideLabel() } e.getIndoorDataByUid(kD, e.currentFloorName, e.indoorChange) } } }) }, _unzip: function (kD) { if (!kD || typeof kD !== "string") { return } var e = atob(kD); var kE = new Uint8Array(e.length); for (var kC = 0; kC < e.length; kC++) { kE[kC] = e.charCodeAt(kC) } var T = pako.inflate(kE, { to: "string" }); return JSON.parse(T) }, getDataBefore: function (T, kC) { if (!T || !kC || this._remove) { return } var e = this; var i = kC.split(","); if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var kD = { qt: D, building_uid: T, floor: kC } } else { var kD = { qt: D, ak: eZ, building_uid: T, floor: kC } } kl.request(function (kG) { if (kG && kG.result && !kG.result["error"] && kG.content) { var kI = kG.content; if (!kI) { return } for (var kF = 0; kF < i.length; kF++) { if (kI[i[kF]]) { var kH = e._unzip(kI[i[kF]]); var kE = e.currentFloorKV[i[kF]]; e.floorsCache[kE] = kH } } e.spotFillCache[T] = e.floorsCache } else { console.log("获取室内车位数据失败，请检查是否已开通智能停车服务！") } }, kD) }, getOutdoorDataByCityId: function (T) { if (T && typeof T === "number") { T = T.toString() || "131" } if (!this.outdoorUids[T] || this._remove) { return } var e = this; if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var i = { qt: D, city_id: T } } else { var i = { qt: D, ak: eZ, city_id: T } } kl.request(function (kC) { if (kC && kC.result && !kC.result["error"] && kC.content) { var kD = e._unzip(kC.content); if (!kD || !kD.carport_data) { return } e.spotOutFillData = e._parseParkingData(kD); if (e.cityChange) { if (e.cusOutLabelUids) { e.map.removeLabelsFromMapTile(e.cusOutLabelUids) } e._addLabels(kD.carport_data, "outdoor"); e.cityChange = false } if (e.cusOutBubbleUids) { e.map.removeLabelsFromMapTile(e.cusOutBubbleUids) } e._addJixieLabels(kD.bubble_data); if (!e.spotOutFillLayer) { e._addLabels(kD.carport_data, "outdoor"); e._initGraph("outdoor"); e._initEvent("outdoor", e.options.callback); e.addToMap("outdoor") } else { e.spotOutFillLayer.setData(e.spotOutFillData) } } else { console.log("获取室外车位数据失败，请检查是否已开通智能停车服务！") } }, i) }, getIndoorDataByUid: function (kC, kE, i) { if (!kC || !kE || this._remove || !this.indoorUids[this.currentCityId] || (this.indoorUids[this.currentCityId] && !this.indoorUids[this.currentCityId].includes(kC))) { return } var T = this; var kF = function (kH) { if (T.cusInBubbleUids) { T.map.removeLabelsFromMapTile(T.cusInBubbleUids) } if (kH.bubble_data && kH.bubble_data.length > 0) { T._addBubbles(kH.bubble_data) } if (T.cusInLabelUids) { T.map.removeLabelsFromMapTile(T.cusInLabelUids) } T._addLabels(kH.carport_data, "indoor") }; if (this.spotFillCache[kC] && this.spotFillCache[kC][this.currentFloor] && i) { var kD = this.spotFillCache[kC][this.currentFloor]; var e = T._parseParkingData(kD); T.spotFillLayer.setData(e); kF(kD) } if (window._BMapSecurityConfig && window._BMapSecurityConfig["serviceHost"]) { var kG = { qt: D, building_uid: kC, floor: kE } } else { var kG = { qt: D, ak: eZ, building_uid: kC, floor: kE } } kl.request(function (kH) { if (kH && kH.result && !kH.result["error"] && kH.content) { var kI = T._unzip(kH.content[kE]); if (!kI || !kI.carport_data) { return } T.spotFillData = T._parseParkingData(kI); if (kI && kI.carport_data.length > 0) { T.floorsCache[T.currentFloor] = kI; T.spotFillCache[kC] = T.floorsCache } if (!T.spotFillLayer) { T._addLabels(kI.carport_data, "indoor"); T._addBubbles(kI.bubble_data); T._initGraph("indoor"); T._initEvent("indoor", T.options.callback); T.addToMap("indoor") } else { if (kI && kI.carport_data.length > 0) { T.spotFillLayer.setData(T.spotFillData) } } kF(kI) } else { console.log("获取室内车位数据失败，请检查是否已开通智能停车服务！") } }, kG) }, addToMap: function (e) { if (!this.map) { return } if (e === "indoor" && this.spotFillLayer) { this.map.addNormalLayer(this.spotFillLayer); this.spotFillLayer.setData(this.spotFillData) } else { if (this.spotOutFillLayer) { this.map.addNormalLayer(this.spotOutFillLayer); this.spotOutFillLayer.setData(this.spotOutFillData) } } }, _parseParkingData: function (T) { if (!T) { return } var i = T.carport_data; var e = { type: "FeatureCollection", features: [] }; if (!i) { return e } i.forEach(function (kC) { if (kC.geo && typeof kC.geo === "string") { kC.geo = JSON.parse(kC.geo) } var kD = { type: "Feature", properties: { center: [kC.x, kC.y], state: kC.carport_state, type: kC.carport_type, name: kC.carport_name, uid: kC.carport_uid, floor: kC.floor, angle: kC.angle, label: kC.label }, geometry: { type: "Polygon", coordinates: [kC.geo] } }; e.features.push(kD) }); return e }, _initEvent: function (i, T) { if (!this.map) { return } var e = this; if (i === "indoor") { this.spotFillLayer.addEventListener("click", function (kH) { if (kH.value.dataIndex !== -1 && kH.value.dataItem) { var kF = kH.value.dataItem; var kC = kF.properties.center; var kD = kF.properties.bubble_data; var kG = ""; switch (kF.properties.state) { case 1: kG = "占用"; break; case 2: kG = "空闲"; break; case 0: kG = "未知"; break; default: kG = "未知"; break }var kE = { center: kC, state: kG, properties: kF.properties }; T && T(kE) } }) } else { this.spotOutFillLayer.addEventListener("click", function (kH) { if (kH.value.dataIndex !== -1 && kH.value.dataItem) { var kF = kH.value.dataItem; var kC = kF.properties.center; var kD = kF.properties.bubble_data; var kG = ""; switch (kF.properties.state) { case 1: kG = "占用"; break; case 2: kG = "空闲"; break; case 0: kG = "未知"; break; default: kG = "未知"; break }var kE = { center: kC, state: kG, properties: kF.properties }; T && T(kE) } }) } this.map.on("destory", function () { e._distory() }) }, _addBubbles: function (kF) { if (!kF) { return } this.bubbleDatas = []; this.cusInBubbleUids = []; for (var kE = 0; kE < kF.length; kE++) { var e = kF[kE].bubble.name + "：" + kF[kE].bubble.label; var kG = kF[kE].bubble.rank.split("-"); var kC = kF[kE].bubble.color; var kH = jy.convertLL2MC(new cG(kF[kE].x, kF[kE].y)); var kD = "bubble_" + kF[kE].poi_uid + Math.floor(Math.random() * Math.pow(10, 6)); var T = { position: kH, uid: kD, name: e, displayRange: kG, textMargin: 8, direction: 0, rank: 60000, textOnIcon: true, iconSize: [100, 24], noStretch: true, icon: "//bj.bcebos.com/v1/mapopen-pub-jsapigl/assets/images/spot/jixie_bk.png", style: { haloSize: 0, fontSize: 28, color: "#fff", strokeColor: "#fff", padding: [10, 0], } }; this.bubbleDatas.push(T); this.cusInBubbleUids.push(kD) } this.map.addLabelsToMapTile(this.bubbleDatas) }, _addJixieLabels: function (kD) { if (!kD) { return } this.jixieDatas = []; this.cusOutBubbleUids = []; for (var kC = 0; kC < kD.length; kC++) { var kE = jy.convertLL2MC(new cG(kD[kC].x, kD[kC].y)); var T = "out_bubble_" + kD[kC].poi_uid; var e = { position: kE, uid: T, name: kD[kC].poi_name, displayRange: [15, 22], textMargin: 0, direction: 0, rank: 60000, textOnIcon: true, iconSize: [20, 30], icon: "//bj.bcebos.com/v1/mapopen-pub-jsapigl/assets/images/spot/bubble.png", style: { haloSize: 0, fontSize: 22, color: "#fff", strokeColor: "#fff" } }; this.jixieDatas.push(e); this.cusOutBubbleUids.push(T) } this.map.addLabelsToMapTile(this.jixieDatas) }, _addLabels: function (kE, kC) { if (kC === "indoor") { this.labelDatas = []; this.inLabelUids = [] } else { if (kC === "outdoor") { this.outLabelDatas = []; this.outLabelUids = [] } } for (var T = 0; T < kE.length; T++) { var kF = jy.convertLL2MC(new cG(kE[T].x, kE[T].y)); var e = "carspot_lb_" + kC + "_" + kE[T].carport_name; if (kE[T].label) { var kD = { position: kF, uid: e, name: kE[T].carport_name + "\\[" + kE[T].label + "]", displayRange: [3, 22], textMargin: 0, direction: 0, rank: 50000, style: { haloSize: 2, fontSize: 24, color: "#008857", strokeColor: "#fff" } } } else { var kD = { position: kF, uid: e, name: kE[T].carport_name, displayRange: [3, 22], textMargin: 0, direction: 0, rank: 50000, style: { haloSize: 2, fontSize: 22, color: "#657d95", strokeColor: "#fff" } } } if (kC === "indoor") { this.cusInLabelUids.push(e); this.labelDatas.push(kD) } else { if (kC === "outdoor") { this.cusOutLabelUids.push(e); this.outLabelDatas.push(kD) } } } if (kC === "indoor") { this.map.addLabelsToMapTile(this.labelDatas) } else { if (kC === "outdoor") { this.map.addLabelsToMapTile(this.outLabelDatas) } } }, removeParkingSpot: function () { if (this.spotFillLayer) { this.map.removeNormalLayer(this.spotFillLayer); this.spotFillLayer = null; this.spotFillData = [] } if (this.spotOutFillLayer) { this.map.removeNormalLayer(this.spotOutFillLayer); this.spotOutFillLayer = null; this.spotOutFillData = [] } if (this.cusOutLabelUids) { this.map.removeLabelsFromMapTile(this.cusOutLabelUids); this.cusOutLabelUids = [] } if (this.cusOutBubbleUids) { this.map.removeLabelsFromMapTile(this.cusOutBubbleUids); this.cusOutBubbleUids = [] } if (this.cusInLabelUids) { this.map.removeLabelsFromMapTile(this.cusInLabelUids); this.cusInLabelUids = [] } if (this.cusInBubbleUids) { this.map.removeLabelsFromMapTile(this.cusInBubbleUids); this.cusInBubbleUids = [] } this.spotFillCache = []; this.floorsCache = []; this._remove = true }, hideLayer: function (e) { if (e === "indoor" && this.spotFillLayer) { var i = this._parseParkingData([]); this.spotFillLayer.setData(i) } else { if (e === "outdoor" && this.spotOutFillLayer) { var i = this._parseParkingData([]); this.spotOutFillLayer.setData(i) } } }, hideLabel: function () { if (this.cusInLabelUids) { this.map.removeLabelsFromMapTile(this.cusInLabelUids) } if (this.cusInBubbleUids) { this.map.removeLabelsFromMapTile(this.cusInBubbleUids) } }, showLayer: function (e) { if (e === "indoor" && this.spotFillLayer) { var i = this._parseParkingData([]); this.spotFillLayer.setData(i) } else { if (e === "outdoor" && this.spotOutFillLayer) { } } }, searchParkingRoute: function (T, e, i) { if (!this.auth) { return } }, toString: function () { return "ParkingSpot" } }); function cv(e) { e = e || {}; this.visible = (e.visible === undefined ? true : !!e.visible); this.minZoom = e.minZoom || 3; this.maxZoom = e.maxZoom || 21; this.opacity = isNaN(Number(e.opacity)) ? 1 : Math.max(0, Math.min(1, Number(e.opacity))); this.zIndex = e.zIndex || 1; this.enablePicked = e.enablePicked || false; this.supportMouseStyleChange = (e.mouseStyleChange === undefined ? true : !!e.mouseStyleChange); this.autoSelect = e.autoSelect || false; this.popEvent = e.popEvent === undefined ? true : !!e.popEvent; this.autoUpdate = false; this.pickWidth = e.pickWidth || 30; this.pickHeight = e.pickHeight || 30; this.center = e.referCenter || null; this.isTop = e.isTop || false; this.isLowText = e.isLowText || false; this.guid = bG.getGUID("normal_layer_") } cv.inherits(dh, "NormalLayer"); e9.extend(cv.prototype, { onInit: function (kC, kD) { if (this.zIndex > 0) { this.adjustZIndex(kC); kC._normalLayerMgr.sortLayer() } else { var e = kC._featureMgr.result.bkData; this.zIndex = e.length || 1 } var T = { tileTypeName: this.getType ? this.getType() : "custom", dataType: this.toString(), ontology: this }; kC._featureMgr.createLayer(this.zIndex, T); this.map = kC; this.gl = kD; this.onAdd(kC, kD); var i = this; kC.on("destroy", function () { i.onDestroy() }) }, adjustZIndex: function (i) { if (i && i._featureMgr) { var e = i._featureMgr.result.bkData; while (e[this.zIndex]) { this.zIndex += 1 } } }, _getAdjoinZIndex: function (kD) { var T = this.zIndex; if (this.map && this.map._featureMgr) { var e = this.map._featureMgr.result.bkData; if (kD === "up") { for (var kC = this.zIndex + 1; kC < e.length; kC++) { if (e[kC]) { T = kC + 1; break } } } else { for (var kC = this.zIndex - 1; kC > 0; kC--) { if (e[kC]) { T = kC; break } } } } return T }, setTargetZIndex: function (e) { this.zIndex = e; if (this.map) { this.map._normalLayerMgr.sortLayer() } }, setZIndex: function (kG) { kG = Math.abs(Math.floor(kG)) || 1; if (!kG || kG === this.zIndex) { return } var kD = this.map._featureMgr.result.bkData; var kC = this.map.tileMgr.tileLayers; var kI = this.map._normalLayerMgr.layers; function kJ(kO) { var kM = null; var kN = [kC, kI]; for (var kK = 0; kK < kN.length; kK++) { for (var kL = 0; kL < kN[kK].length; kL++) { if (kN[kK][kL].zIndex === kO) { kM = kN[kK][kL]; break } } if (kM) { break } } return kM } var T = []; var kF = []; var kH = this.zIndex; var i = kJ(kG); if (kD[kG] && i) { T.push(i); kF.push(kD[kG]); this.setTargetZIndex(kG); kD[kG] = kD[kH]; kD[kH] = null } else { this.setTargetZIndex(kG); kD[kG] = kD[kH]; kD[kH] = null; this.doOnceDraw(); return } var kE = kG + 1; while (kE) { var e = kJ(kE); if (kD[kE] && e) { T.push(e); kF.push(kD[kE]); T.shift().setTargetZIndex(kE); kD[kE] = kF.shift(); kE += 1 } else { T.shift().setTargetZIndex(kE); kD[kE] = kF.shift(); kE = 0 } } this.doOnceDraw() }, setRefCenter: function (e) { if (e instanceof cG) { this.center = e; this.parseData && this.parseData(e) } }, getRefCenter: function () { return this.center }, setTop: function (e) { this.isTop = !!e; this.doOnceDraw() }, setLowText: function (e) { this.isLowText = !!e; this.doOnceDraw() }, setOpacity: function (e) { if (isNaN(Number(e))) { return } this.opacity = Math.max(0, Math.min(1, Number(e))); this.doOnceDraw() }, getOpacity: function () { return this.opacity }, setZIndexTop: function () { var e = this.map._featureMgr.result.bkData; e[e.length] = e[this.zIndex]; e[this.zIndex] = null; this.setTargetZIndex(e.length - 1); this.doOnceDraw() }, setUpLevel: function () { var e = this._getAdjoinZIndex("up"); if (this.zIndex !== e) { this.setZIndex(e) } }, setDownLevel: function () { var e = this._getAdjoinZIndex("down"); if (this.zIndex !== e) { this.setZIndex(e) } }, onAdd: function (e, i) { throw new Error("用户未实现onAdd方法") }, preRender: function (i, e) { }, rgbToIndex: function (kD) { var kG = kD.length / 4; var kC = Math.floor(kG / 2); const T = function (kI) { return kD[kI] + kD[kI + 1] * 256 + kD[kI + 2] * 65536 - 1 }; for (var kF = 0; ; kF++) { var kE = kC + kF; var kH = kC - kF; if (kE === kH) { var e = T(kE * 4); if (e > -1) { return e } continue } if (kE < kG) { var e = T(kE * 4); if (e > -1) { return e } } if (kH >= 0) { var e = T(kH * 4); if (e > -1) { return e } } if (kE >= kG && kH < 0) { break } } return -1 }, testEvent: function (e) { if (this.autoSelect) { return true } if (this.enablePicked && (this.supportMouseStyleChange || (e !== "onmousemove" && !this.supportMouseStyleChange))) { return true } return false }, pick: function (kG, kF, kC) { var T = this.gl; var kH = this.map.config.ratio; this.map._normalLayerMgr.saveFramebuffer(); this.map._normalLayerMgr.bindFramebuffer(this.map._normalLayerMgr.pickFBO); this.map._normalLayerMgr.clear(); this.map._webglPainter._camera._updatePolyLayerMatrix(this.center); var i = this.map._webglPainter._camera._modelViewMatrixLayer; var kE = mat4.create(Float64Array); mat4.multiply(kE, this.map._webglPainter.projMatrix, i); this.render(T, kE, { isPickRender: true }); var e = new Uint8Array(4 * this.pickWidth * this.pickHeight); T.readPixels(kG * kH - Math.floor(this.pickWidth / 2), T.canvas.height - kF * kH - Math.floor(this.pickHeight / 2), this.pickWidth, this.pickHeight, T.RGBA, T.UNSIGNED_BYTE, e); var kD = this.rgbToIndex(e); if (this.getPickedItem) { var kI = this.getPickedItem(kD, kC) } this.map._normalLayerMgr.restoreFramebuffer(); return kI }, render: function (T, e, i) { throw new Error("用户未实现render方法") }, afterRender: function (i, e) { }, onDestroy: function (e, i) { }, onHide: function (e, i) { }, onShow: function (e, i) { }, doOnceDraw: function () { if (this.map) { var e = new fW("onupdate"); this.map.dispatchEvent(e) } }, doRender: function () { if (!this.map) { return false } var e = this.map.getZoom(); if (this.visible) { if (e >= this.minZoom && e <= this.maxZoom) { if (!this._status) { this.onShow(this.map, this.gl); this._status = 1 } return true } } if (this._status) { this.onHide(this.map, this.gl); this._status = 0 } return false }, getZIndex: function () { if (this.zIndex === undefined) { throw new Error("图层未添加到地图") } return this.zIndex }, getVisible: function () { return this.visible }, setVisible: function (e) { this.visible = e; this.doOnceDraw() }, getMinZoom: function () { return this.minZoom }, setMinZoom: function (e) { if (e <= this.maxZoom) { this.minZoom = e } }, getMaxZoom: function () { return this.maxZoom }, setMaxZoom: function (e) { if (e >= this.minZoom) { this.maxZoom = e } }, dispatcher: function (kD, kC, T) { var i = new fW(T); i.pixel = kD.pixel; i.latLng = kD.latlng; i.value = kC; this.dispatchEvent(i) }, hasEvent: function (e) { if (this.enablePicked) { if (e.substr(0, 2) !== "on") { e += "on" } if (this._listeners && this._listeners[e] && Object.keys(this._listeners[e]).length > 0) { return true } return false } return false }, toString: function () { return "normal" } }); function g7(i) { i = i || {}; const e = { alpha: false, antialias: false }; this.options = Object.assign({}, e, i); if (!window.THREE) { throw new Error("ThreeLayer requires THREE") } this._unsetlist = []; cv.call(this, this.options); hQ.sendMessage(a1(4, 3, 18), ["layer", "threejs"]) } g7.inherits(cv, "ThreeLayer"); e9.extend(g7.prototype, { onAdd: function (kC, T) { if (!this.options) { throw new Error("ThreeLayer requires reCreate") } const e = this.map = kC; const kI = this; e.addEventListener("update", function (i) { if (i.changedStatus && i.changedStatus.onsize_changed) { kI._updateProjectionMatrix(kI.renderer) } }); this._state = d5.WebGLState.get(T, e._webGLStateId); this.customCoords = e.toFormatCoords; const kG = new THREE.WebGLRenderer({ context: T, alpha: this.options.alpha, antialias: this.options.antialias }); this._updateProjectionMatrix(kG); kG.autoClear = false; var kJ = e._webglMapScene._painter.background || [245, 245, 245, 255]; var kH = "rgb(" + kJ.slice(0, 3).join(",") + ")"; kG.setClearColor(kH, kJ[3] / 255); const kF = new THREE.Scene(); this.scene = kF; this.renderer = kG; const kD = new THREE.AmbientLight(16777215, 1); kF.add(kD); if (this._unsetlist.length) { for (var kE = 0; kE < this._unsetlist.length; kE++) { kF.add(this._unsetlist[kE]) } this._unsetlist = [] } if (this.options.onInit) { this.options.onInit.bind(this)(kG, kF, this.camera) } this.animate() }, _rgbToHex: function (T) { var kD = T[0]; var kC = T[1]; var e = T[2]; kD = Math.min(0, Math.max(255, kD)); kC = Math.min(0, Math.max(255, kC)); e = Math.min(0, Math.max(255, e)); const i = function (kF) { const kE = kF.toString(16); return kE.length === 1 ? "0" + kE : kE }; return "0x" + i(kD) + i(kC) + i(e) }, _updateProjectionMatrix: function (kD) { const i = this.map.getContainer(); const kC = i.offsetWidth; const e = i.offsetHeight; const T = new THREE.PerspectiveCamera(35, kC / e, 10, 4000); T.matrixAutoUpdate = false; this.camera = T; kD && kD.setSize(kC, e) }, preRender: function (i, e) { if (!this.options) { throw new Error("ThreeLayer requires reCreate") } if (this.options.preRender) { this.options.preRender.bind(this)(this.renderer, this.scene, this.camera) } }, afterRender: function (i, e) { if (!this.options) { throw new Error("ThreeLayer requires reCreate") } if (this.options.afterRender) { this.options.afterRender.bind(this)(this.renderer, this.scene, this.camera) } }, render: function (kD, i, T) { if (!this.options) { throw new Error("ThreeLayer requires reCreate") } this.statesForange = this._state.getRealState(); this.renderer.resetState(); var e = this.map._webglMapCamera._updatePolyLayerMatrix(); var kC = new THREE.Matrix4().fromArray(e); this.camera.matrixWorld = kC.invert(); if (this.options.onRender) { this.options.onRender.bind(this)(this.renderer, this.scene, this.camera) } else { this.renderer.render(this.scene, this.camera) } this._state.setState(this.statesForange) }, triggerRepaint: function () { this.needsUpdate = true; this.animate() }, triggerStop: function () { this.needsUpdate = false }, animate: function () { if (this.needsUpdate) { this.doOnceDraw() } else { return } var e = this; this.frameTimer = requestAnimationFrame(function () { e.animate() }) }, refreshMap: function () { if (this.map) { this.doOnceDraw() } }, convertLngLat: function (e) { this.customCoords.setCenter(this.center); const i = this.customCoords.lngLatsToCoords([e]); return i[0] }, add: function (e) { if (!this.scene) { this._unsetlist.push(e); return } this.scene.add(e); this.refreshMap() }, remove: function (e) { this.scene.remove(e); this.refreshMap() }, getScene: function () { return this.scene }, getCamera: function () { return this.camera }, getRender: function () { return this.renderer }, onDestroy: function () { if (this.options.onDestroy) { this.options.onDestroy.bind(this)(this.renderer, this.scene, this.camera) } cancelAnimationFrame(this.frameTimer); this.customCoords = null; this._clearScene(this.scene); this.scene = undefined; this.camera = undefined; this.renderer.dispose(); this.renderer = undefined; this.map = null; THREE.Cache.clear(); this.options = null }, onHide: function () { if (this.options.onHide) { this.options.onHide.bind(this)(this.renderer, this.scene, this.camera) } }, onShow: function () { if (this.options.onShow) { this.options.onShow.bind(this)(this.renderer, this.scene, this.camera) } }, getMap: function () { if (this.map) { return this.map } return null }, pick: function (kG, kF, e) { if (!this.map) { return null } var kE = new THREE.Raycaster(); var kD = new THREE.Vector2(); var i = this.getScene().children; kD.x = (kG / this.map.width) * 2 - 1; kD.y = -(kF / this.map.height) * 2 + 1; kE.setFromCamera(kD, this.camera); var kH = []; var T = kE.intersectObjects(i, true); if (T.length) { var kC = this.getScene().uuid; T.forEach(function (kI) { var kJ = kI.object; while (kJ.parent.uuid !== kC) { kJ = kJ.parent } kH.push(kJ) }) } return kH.length ? kH : null }, _clearScene: function (i) { var e = this; i.traverse(function (T) { e._clearGroup(T) }) }, _clearGroup: function (T) { const e = function (kC) { if (kC.geometry) { kC.geometry.dispose() } if (kC.material && kC.material.dispose) { kC.material.dispose() } if (kC.material.texture && kC.material.texture.dispose) { kC.material.texture.dispose() } }; const i = function (kC) { var kD = kC.children.filter(function (kE) { return kE }); kD.forEach(function (kE) { if (kE.children.length) { i(kE) } else { if (kE.isMesh) { e(kE) } } }); kD = null }; i(T) } }); function ee(e) { e = e || {}; cv.call(this, e); this.base_opt = { idKey: "id", crs: "BD09LL", isFlat: true, drawPart: 1, selectedIndex: -1, selectedColor: "rgba(20, 20, 200, 1.0)", enableChangeSelectIndexByPick: true, }; this.setBaseOptions(e); this.loadModule = false; this._stateCube = {}; this.def = []; this.DEL_COUNT = 20; this.delIndexs = []; var i = this; hm.load("mvtParse", function () { i._async() }, true); this.select_color = this.getColorStyleForGL(this.base_opt.selectedColor); var T = new Int8Array(4); this.int32View = new Int32Array(T.buffer, 0, 1); this.float32View = new Float32Array(T.buffer, 0, 1) } ee.inherits(cv, "FeatureLayer"); e9.extend(ee.prototype, { _async: function () { this.loadModule = true; this.resolveStyle(); this.parseData() }, compileExpress: function (i, e) { var i = ek.ExpressParse.normalizePropertyExpression(i, e); return i }, resolveStyle: function () { if (!ek.ExpressParse) { return } var e = this.style_opt || {}; var kC = c8[this.type]; if (this._appendStyle) { kC = JSON.parse(JSON.stringify(kC)); Object.assign(kC, this._appendStyle) } if (e && this.type && kC) { var T = {}; for (var i in e) { var kE = kC[i]; if (e.hasOwnProperty(i) && kE !== undefined) { var kD = this.compileExpress(e[i], kE); T[i] = kD } } this.styleExpress = T } }, evaluateContext: function (e, T) { var i = T.id || e; var kC = this._stateCube[i]; return { properties: function () { return T && T.properties }, featureState: kC || {} } }, evaluates: function (i, kC) { if (!this.styleExpress) { return null } var kE = this.styleExpress; var e = {}; for (var T in kE) { if (kE.hasOwnProperty(T)) { var kD = kE[T].evaluate(this.evaluateContext(i, kC)); e[T] = kD } } return e }, _updateState: function (T, i, e) { if (e) { this._set(i, this._stateCube, T) } else { this._stateCube[T] = i } }, _set: function (i, kD, T) { var kC = kD[T] || (kD[T] = {}); for (var e in i) { kC[e] = i[e] } }, updateState: function (kD, kE, e) { var T = JSON.stringify(this._stateCube); if (!(kE && typeof kE === "object" && Object.keys(kE).length > 0)) { return } if (!e) { this._stateCube = {} } if (kD instanceof Array) { for (var kC = 0; kC < kD.length; kC++) { this._updateState(kD[kC], kE, e) } } else { this._updateState(kD, kE, e) } var kF = JSON.stringify(this._stateCube); if (T !== kF) { this.parseData() } if (this.attach) { this.attach.updateState(kD, kE, e) } }, replaceAllState: function (e) { var i = JSON.stringify(this._stateCube); this._stateCube = e; var T = JSON.stringify(this._stateCube); if (i !== T) { this.parseData() } }, getAllState: function () { return this._stateCube }, removeState: function (kC) { var e = JSON.stringify(this._stateCube); if (kC instanceof Array) { for (var T = 0; T < kC.length; T++) { delete this._stateCube[kC[T]] } } else { delete this._stateCube[kC] } var kD = JSON.stringify(this._stateCube); if (e !== kD) { this.parseData() } }, clearState: function () { var e = JSON.stringify(this._stateCube); if (e !== "{}") { this._stateCube = {}; this.parseData() } }, getType: function () { return "feature" }, setData: function (T, kC) { if (T.length <= 0) { return } this.params = kC = kC || {}; this.data = T; this.delIndexs = []; this._stateCube = {}; if (kC.changeCenter && T && T.features && T.features[0]) { var e = T.features[0]; var kD = null; if (e.geometry && e.geometry.type === "Point") { kD = e.geometry.coordinates } if (e.geometry && (e.geometry.type === "LineString" || e.geometry.type === "MultiLineString" || e.geometry.type === "Polygon")) { var i = e.geometry.coordinates[0]; if (i && i[0]) { kD = i[0] } } if (kD) { if (this.base_opt.crs === "BD09LL") { this.center = new cG(kD[0], kD[1]) } else { kD = gcoord.transform(kD, this.base_opt.crs, gcoord.BD09LL); this.center = new cG(kD[0], kD[1]) } } } this.parseData && this.parseData(this.center) }, getData: function () { return this.data }, clearData: function () { this.data = null; this.buffer = null; if (this.attach) { this.attach.clearData() } this.doOnceDraw() }, addDelIndex: function (T) { if (this.delIndexs.length >= this.DEL_COUNT) { new Error("超出" + this.DEL_COUNT + "个限制") } var e = false; for (var kC = 0; kC < this.delIndexs.length; kC++) { if (this.delIndexs[kC] === T) { e = true; break } } if (!e) { this.delIndexs.push(T); this.doOnceDraw() } if (this.attach) { this.attach.addDelIndex(T) } }, removeDelIndex: function (e) { for (var T = 0; T < this.delIndexs.length; T++) { if (this.delIndexs[T] === e) { this.delIndexs.splice(T, 1); this.doOnceDraw(); break } } if (this.attach) { this.attach.removeDelIndex(e) } }, clearDelIndex: function () { this.delIndexs = []; this.doOnceDraw(); if (this.attach) { this.attach.clearDelIndex() } }, setBaseOptions: function (i) { i = i || {}; var e = Object.assign({}, this.getBaseOptions()); Object.assign(this.base_opt, i); this.onOptionsChanged && this.onOptionsChanged(this.getBaseOptions(), e); if (i.data) { this.setData(i.data); delete i.data } }, setStyleOptions: function (i) { i = i || {}; var e = Object.assign({}, this.getStyleOptions()); Object.assign(this.style_opt, i); this.onOptionsChanged && this.onOptionsChanged(this.getStyleOptions(), e); if (i.data) { this.setData(i.data); delete i.data } else { if (i.autoRender !== false) { } } }, getBaseOptions: function () { var e = this.base_opt || {}; switch (BMapGL.coordType) { case 2: this.base_opt.crs = "GCJ02"; break; case 5: this.base_opt.crs = "WGS84"; break; default: this.base_opt.crs = "BD09LL"; break }return e }, getStyleOptions: function () { return this.style_opt || {} }, getProperty: function (e, kC, T) { if (Object.prototype.toString.call(kC) === "[object Function]") { return kC(T) } else { var i = T[e] || kC; if ("properties" in T && e in T.properties) { i = T.properties[e] } return i } }, getPickedItem: function (i, e) { if (this.autoSelect) { if (e === "onmousemove") { this.selectedIndex = i } else { this.selectedIndex = -1 } } if (e === "onclick" && this.enablePicked && this.base_opt.enableChangeSelectIndexByPick) { this.selectedIndex = i } var T = this.dataset ? this.dataset.normal : []; return { dataIndex: i, dataItem: T[i] } }, formatData: function (T) { var i = new gO({ reference: this.base_opt.crs }); var kD = i.readFeaturesFromObject(T, { isPoints: true }); var e = null; var kC = this; if (this.base_opt.nodeStrict) { e = JSON.parse(JSON.stringify(T)); gO.coordEachReplace(e, function (kE) { return [kE[0].toFixed(kC.base_opt.nodeJoin), kE[1].toFixed(kC.base_opt.nodeJoin)] }) } return { normal: T.features, inner: kD, join: e ? e.features : null } }, _pointGeoFilter: function (kP) { var k5 = []; for (var k6 = 0; k6 < kP.features.length; k6++) { var kK = kP.features[k6]; if (kK.geometry.type !== "LineString") { continue } var kE = kK.geometry.coordinates; var kN = kK.properties || {}; if (kE.length < 2) { continue } var kH = k5.length; if (this.base_opt.nodeBreakpoint || this.base_opt.nodeMiddleShow) { var kQ; var kU = 0; for (var k3 = 0; k3 < kE.length; k3++) { var kV = jy.convertLL2MC(new cG(kE[k3][0], kE[k3][1])); if (kQ && kQ.similar(kV)) { continue } if (k3 > 0) { var kX = k5[k5.length - 1]; var kI = kX.geometry.coordinates; var kZ = bj(kV.lat - kI[1], kV.lng - kI[0]); k5[k5.length - 1].properties.endPoint = kV.lng + "," + kV.lat; k5[k5.length - 1].properties.rotation = kZ; if (k3 > 1) { var kR = k5[k5.length - 2]; var kS = kR.geometry.coordinates; kZ = g5(kS, kI, [kV.lng, kV.lat]); k5[k5.length - 1].properties.rotationPlus = Math.abs(kZ) } } var kW = JSON.parse(JSON.stringify(kN)); kW.index = k6; kW.line_node_type = k3 === 0 ? 1 : 3; kW.startPoint = k3 === 0 ? "" : kQ.lng + "," + kQ.lat; kW.endPoint = ""; kW.rotationPlus = 0; k5.push({ type: "Feature", properties: kW, geometry: { coordinates: [kV.lng, kV.lat], type: "Point" } }); kQ = kV; kU++ } if (kU === 1) { k5.splice(k5.length - 1, 1) } if (kU >= 2 && k5[k5.length - 1].properties.endPoint === "") { var kG = k5[k5.length - 2]; var T = kG.geometry.coordinates; var kF = k5[k5.length - 1]; var e = kF.geometry.coordinates; var kZ = bj(e[1] - T[1], e[0] - T[0]); kW.rotation = kZ; kW.line_node_type = 2 } } else { var kG = kE[0]; var k4 = jy.convertLL2MC(new cG(kG[0], kG[1])); var kM = kE[1]; var k2 = jy.convertLL2MC(new cG(kM[0], kM[1])); var kF = kE[kE.length - 1]; var k8 = jy.convertLL2MC(new cG(kF[0], kF[1])); var kT = kE[kE.length - 2]; var kJ = jy.convertLL2MC(new cG(kT[0], kT[1])); var kY = [[k2, k4], [k8, kJ]]; for (var k3 = 0; k3 < 2; k3++) { var k7 = [kY[k3][0].lng, kY[k3][0].lat]; var kO = [kY[k3][1].lng, kY[k3][1].lat]; var kW = JSON.parse(JSON.stringify(kN)); kW.index = k6; var kZ = bj(k7[1] - kO[1], k7[0] - kO[0]); kW.rotation = kZ; kW.line_node_type = k3 === 0 ? 1 : 2; kW.startPoint = k3 === 0 ? "" : k7.join(","); kW.endPoint = k3 === 0 ? kO.join(",") : ""; kW.rotationPlus = 0; k5.push({ type: "Feature", properties: kW, geometry: { coordinates: k3 === 0 ? kO : k7, type: "Point" } }) } } if (this.base_opt.nodeMiddleShow && kH + 1 <= k5.length) { var kD = k5.length; for (var k1 = kH + 1; k1 < kD; k1++) { var kL = JSON.parse(JSON.stringify(k5[k1])); var kC = k5[k1].geometry.coordinates; kL.properties.line_node_type = 4; kL.properties.startPoint = ""; kL.properties.endPoint = ""; kL.properties.rotationPlus = 0; kL.properties.rotation = k5[k1 - 1].properties.rotation; var k0 = k5[k1 - 1].geometry.coordinates; kL.geometry.coordinates = [(kC[0] + k0[0]) / 2, (kC[1] + k0[1]) / 2]; k5.push(kL) } } } return { type: "FeatureCollection", features: k5 } }, _toFormatPointGeometry: function (e, i) { if (!i) { var kC = jy.convertLL2MC(e) } else { var kC = e } var kD = this.map._normalLayerMgr.base; var T = [kC.lng - kD.lng, kC.lat - kD.lat]; return T }, _formatArrayBuffer: function (kC, i) { var e; if (i) { e = new Int32Array(this.DEL_COUNT) } else { e = new Int16Array(this.DEL_COUNT) } if (kC && kC.length) { var T = 0; for (; T < kC.length && T < this.DEL_COUNT; T++) { e[T] = parseInt(kC[T]) } if (T < this.DEL_COUNT) { e[T] = -1 } } else { e[0] = -1 } return e }, getColorStyleForGL: function (kC, e, T) { var i = hW.formatColorCssToRgbaArray(kC, e, T); return i }, drawLinearTexture: function (T) { if (!T || !(T instanceof Array)) { return null } var kC = document.createElement("canvas"); kC.width = Math.pow(2, 9); kC.height = 2; var e = kC.getContext("2d"); var kE = e.createLinearGradient(0, 0, kC.width, 0); for (var kD = 0; kD < T.length; kD++) { kE.addColorStop(T[kD][0], T[kD][1]) } e.fillStyle = kE; e.fillRect(0, 0, kC.width, kC.height); return kC }, getColorByValue: function (kD) { var i = kD + 1; var e = Math.floor(i / 65536); i = i - e * 65536; var kC = Math.floor(i / 256); i = i - kC * 256; var T = i; return [T, kC, e, 0] }, getValueToColor: function (kC) { var e = 4; var T = parseFloat(Math.max(0, Math.min(kC, 1)).toFixed(e)); var i = T * Math.pow(10, e); return this.getColorByValue(i) }, rgb2value: function (e) { e[0] = e[0] === 255 ? e[0] - 1 : e[0]; e[1] = e[1] === 255 ? e[1] - 1 : e[1]; e[2] = e[2] === 255 ? e[2] - 1 : e[2]; return e[0] + e[1] * 256 + e[2] * 65536 - 1 + 256 * 0.00001 }, int8ArrayToFloat: function (e) { var i = (e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0]); this.int32View[0] = i & 4294967295; return this.float32View[0] }, _toFormatPolGeometry: function (kD, e) { var kC = []; if (!e) { kC[0] = this._toFormatCoords(kD) } else { for (var T = 0; T < kD.length; T++) { kC.push(this._toFormatCoords(kD[T])) } } return kC }, _toFormatCoords: function (kI) { var kH = []; var kE = []; kH.pointsArray = kE; var kJ = jy.convertLL2MC(kI[0]); if (this.center) { var e = jy.convertLL2MC(this.center) } else { var e = this.map._normalLayerMgr.base } var kG = [kJ.lng - e.lng, kJ.lat - e.lat]; kH.push(kG); kE.push(kG[0], kG[1]); for (var kD = 1, kC = 1, T = kI.length; kD < T; kD++) { kJ = jy.convertLL2MC(kI[kD]); var kF = [kJ.lng - e.lng, kJ.lat - e.lat]; if (kF[0] !== kH[kC - 1][0] || kF[1] !== kH[kC - 1][1]) { kH.push(kF); kE.push(kF[0], kF[1]); kC++ } } return kH }, onDestroy: function () { this.data = null; this.params = {}; this._stateCube = {}; this.delIndexs.length = 0 }, toString: function () { return "FeatureLayer" } }); function b1(e) { e = e || {}; this.type = "polyline"; this.style_opt = { sequence: false, marginLength: 16, traceControl: null, traceColor: [], traceDisappear: false, traceStart: true, linksLine: false, strokeColorControl: null, verticesValueControl: null, arrowColor: "rgba(255, 255, 255, 1)", strokeColor: "rgba(25, 25, 250, 1)", strokeWeight: 2, borderCovered: true, borderColor: "rgba(27, 142, 236, 1)", borderWeight: 0, borderMask: true, strokeOpacity: 1, strokeLineJoin: "round", strokeLineCap: "square", strokeTextureUrl: "", strokeTextureWidth: 16, strokeTextureHeight: 16, strokeStyle: "solid", dashArray: [8, 4], height: 0 }; this._appendStyle = { height: { format: "number", defaultValue: 0 }, }; this.setStyleOptions(e.style || {}); this._bufferArray = []; this._texture = {}; this._length = {}; this.linearTexture = null; e.isLinear = e.isLinear === undefined ? false : e.isLinear; e.linearTexture = e.linearTexture === undefined ? null : e.linearTexture; e.nodeShow = e.nodeShow === undefined ? false : e.nodeShow; e.linkLine = e.linkLine === undefined ? true : e.linkLine; e.nodeMask = e.nodeMask === undefined ? false : e.nodeMask; e.nodeStrict = e.nodeStrict === undefined ? false : e.nodeStrict; e.nodeJoin = e.nodeJoin === undefined ? 5 : e.nodeJoin; e.nodeBreakpoint = e.nodeBreakpoint === undefined ? false : e.nodeBreakpoint; e.nodeMiddleShow = e.nodeMiddleShow === undefined ? false : e.nodeMiddleShow; e.nodeMinZoom = (!e.nodeMinZoom || e.nodeMinZoom < 3 || e.nodeMinZoom > 25) ? 6 : e.nodeMinZoom; this.arrow_color = this.getColorStyleForGL(this.style_opt.arrowColor, null, false); ee.call(this, e); if (e.nodeShow) { var i = JSON.parse(JSON.stringify(e)); i = Object.assign(i, { enablePicked: false, autoSelect: false, coorSysMc: true }); this.attachNode = new aZ(i) } hQ.sendMessage(a1(4, 3, 10), ["layer", "line"]) } b1.Segment = { START_POINT: 1, END_POINT: 2, BREAK_POINT: 3, MIDDLE_POINT: 4, 1: 1, 2: 2, 3: 3, 4: 4 }; b1.inherits(ee, "LineLayer"); e9.extend(b1.prototype, { onAdd: function (T, kC) { if (this.attachNode) { this.attachNode.onAdd(T, kC) } if (!this.map) { this.map = T; this.gl = kC } if (this.base_opt.isLinear && this.base_opt.linearTexture) { var i = this.drawLinearTexture(this.base_opt.linearTexture); if (i instanceof HTMLCanvasElement || (window.ImageBitmap && textureName instanceof window.ImageBitmap)) { if (!this.linearTexture) { var e = d5.utils.createTexture(kC, i, { flipY: false, wrap: kC.CLAMP_TO_EDGE, mipmap: true, unpackAlpha: true }); this.linearTexture = e } } } if (!this.buffer) { this.parseData() } }, parseData: function (e) { if (!this.loadModule || !this.styleExpress || !this.map || !this.map._normalLayerMgr) { return } var T = this.getData(); if (!T) { return } var kC = this.dataset = this.formatData(T); this.dispatchEvent(new fW("ondataparsed")); var i = this.linesParse(kC.inner); this.lines = this.combineLine(i); if (!this.base_opt.nodeStrict) { this.buffer = this.createBufferData(this.lines) } else { this.buffer = this.createBufferArrData(this.lines[0]) } this.doOnceDraw() }, linesParse: function (kQ) { var kH = [[], []]; var kE = 0; var kM = -1; for (var kX = 0; kX < kQ.length; kX++) { var k0 = kQ[kX].points; var kF = false; if (!(k0[0] instanceof cG)) { kF = true } var kK = kQ[kX].properties || {}; var kC = kK.hasOwnProperty(this.base_opt.idKey) ? kK[this.base_opt.idKey] : false; var kI = kX; var kO = -1; if (kQ[kX].index !== undefined) { kI = kQ[kX].index } if (kQ[kX].brotherIndex !== undefined) { kO = kQ[kX].brotherIndex } if (kM !== kI) { kM = kI; kE = 0 } var kY = this.evaluates(kI, { properties: kK, id: kC }); var kR = JSON.parse(JSON.stringify(cB[this.type])); if (this._appendStyle) { for (var kZ in this._appendStyle) { kR[kZ] = this._appendStyle[kZ].defaultValue } } kY = Object.assign(kR, kY || {}); if (this.base_opt.nodeStrict) { kK.line_node_type = 1; var kG = this.styleExpress.shapeType.evaluate(this.evaluateContext(kI, { properties: kK, id: kC })); kK.line_node_type = 2; var kD = this.styleExpress.shapeType.evaluate(this.evaluateContext(kI, { properties: kK, id: kC })) } if (kY.borderWeight !== 0) { var e = this.getColorStyleForGL(kY.borderColor, undefined, false); if (kY.borderWeight < 0) { this.style_opt.borderMask = false } var kL = kY.strokeWeight / 2 + kY.borderWeight; if (kL > 0) { var kW = this.buildLineVertex(kY, kQ[kX], kF, kL, e, kE); kH[0][kH[0].length] = { border: true, index: kI, styleData: kW, textureKey: -1, texture: null, textureSize: null, zoomWithMap: true, start: aZ.hasMask(kG), end: aZ.hasMask(kD), overlay: { _height: kY.height, _config: { textureRepeat: true }, _totalDashLen: null, } } } } var kT = kY.strokeWeight / 2; var kU = this.getColorStyleForGL(kY.strokeColor, kY.strokeOpacity, false); if (!this.base_opt.isLinear && kO > -1 && this.style_opt.linksLine && this.style_opt.strokeColorControl instanceof Function) { var kN = this.style_opt.strokeColorControl.bind(this)(kI, kO); kU = this.getColorStyleForGL(kN, undefined, false) } if (this.base_opt.isLinear && this.style_opt.linksLine && this.style_opt.verticesValueControl instanceof Function) { var kS = this.style_opt.verticesValueControl.bind(this)(kI, kO) || []; var kJ = []; for (var kV = 0; kV < kS.length; kV++) { kJ.push(this.getValueToColor(kS[kV])) } kU = kJ.length > 0 ? kJ : kU } var kW = this.buildLineVertex(kY, kQ[kX], kF, kT, kU, kE); var kN = this._generateTexture(kY) || {}; var kP = kN.value || null; var T = { index: kI, styleData: kW, textureKey: kN.key || -1, texture: kP ? kP.texture : null, textureSize: kP ? kP.textureSize : null, zoomWithMap: true, start: this.base_opt.nodeMask && aZ.hasMask(kG), end: this.base_opt.nodeMask && aZ.hasMask(kD), overlay: { _height: kY.height, _config: { textureRepeat: true }, _totalDashLen: kP ? kP.totalDashLen : null, } }; if (this.style_opt.borderCovered && !this.base_opt.nodeStrict) { kH[1][kH[1].length] = T } else { kH[0][kH[0].length] = T } if (kW[0] && kW[0][0] instanceof Array) { kE = kW[0][0][kW[0][0].length - 1] / 10 || 0 } this._length[kM] = kE } return kH }, combineLine: function (kE) { var kK = []; var kC = []; var kQ = []; for (var kG = 0; kG < kE.length; kG++) { var kM = {}; var kF = kE[kG]; var T = -1; for (var kH = 0; kH < kF.length; kH++) { if (!this.base_opt.nodeStrict) { if (!kM[kF[kH].textureKey]) { kM[kF[kH].textureKey] = [{ style: [], styleData: [[], []], index: [] }] } this._mergeOnePolylineData(kM[kF[kH].textureKey], kF[kH]) } else { var kP = kF[kH]; if (T !== kF[kH].index) { T = kF[kH].index; var kO = this.dataset.join[kP.index]; if (!kO.properties) { kO.properties = {} } kO.properties.__index = kF[kH].index; this._onLine(kO, kC, kP.start, kP.end) } } } kK.push(kM) } if (kC.length > 0) { var kM = {}; for (var kH = 0; kH < kC.length; kH++) { var kF = kC[kH]; if (!kM[kH + 1]) { kM[kH + 1] = {} } var kD = []; for (var kG = 0; kG < kF.length; kG++) { var kI = kF[kG].properties.__index; kD.push(kI); var kJ = this._findLineIndex(kI, kE[0]); if (kJ >= 0) { var kO = kE[0][kJ]; if (!kM[kH + 1][kO.textureKey]) { kM[kH + 1][kO.textureKey] = [{ style: [], styleData: [[], []], index: [] }] } this._mergeOnePolylineData(kM[kH + 1][kO.textureKey], kO); var e = kE[0][kJ + 1]; if (e && e.index === kI) { if (!kM[kH + 1][e.textureKey]) { kM[kH + 1][e.textureKey] = [{ style: [], styleData: [[], []], index: [] }] } this._mergeOnePolylineData(kM[kH + 1][e.textureKey], e) } } } kQ.push(kD) } kK[0] = kM } if (this.attachNode) { var kN = this._pointGeoFilter(this.getData()); var kL = JSON.parse(JSON.stringify(this.params || {})); kL.nodeStrictIndex = kQ; this.attachNode.setData(kN, kL) } return kK }, _findLineIndex: function (e, kC) { for (var T = 0; T < kC.length; T++) { if (kC[T].index === e) { return T } } return -1 }, _pointOnLine: function (kG, kF, e, kE) { var kH = e[kE]; if (kG.length > 0) { for (var kD = 0; kD < kH.length; kD++) { var kI = kH[kD]; for (var kC = 0; kC < kG.length; kC++) { var T = ek.booleanDisjoint({ type: "Feature", geometry: { coordinates: kG[kC], type: "Point", } }, kI); if (!T) { return true } } } } for (var kD = 0; kD < kH.length; kD++) { var kI = kH[kD]; var kG = kI.properties.__nodes || []; if (kG.length > 0) { for (var kC = 0; kC < kG.length; kC++) { var T = ek.booleanDisjoint({ type: "Feature", geometry: { coordinates: kG[kC], type: "Point", } }, kF); if (!T) { return true } } } } return false }, _onLine: function (kC, e, kH, T) { if (kC.geometry.type !== "LineString") { return -1 } var kG = kC.geometry.coordinates; var kF = []; if (kH) { kF.push(kG[0]) } if (T) { kF.push(kG[kG.length - 1]) } kC.properties.__nodes = kF; var kE = false; for (var kD = 0; kD < e.length; kD++) { kE = this._pointOnLine(kF, kC, e, kD); if (!kE) { e[kD].push(kC); return kD } } e.push([kC]); return e.length - 1 }, _mergeOnePolylineData: function (kT, kG) { var i = kT.length - 1; var kR = kT[i]; var kE = kT[i]["styleData"][0]; var kD = kT[i]["styleData"][1]; var kS = 10; var kC = 65534; for (var kN = 0; kN < kG.styleData.length; kN++) { var kK = kG.styleData[kN]; var kJ = kK[0]; var kH = kK[1]; var kU = kJ.length / (kS - 1); var T = Math.ceil(kU / kC); for (var kM = 0; kM < T; kM++) { var kF = kE.length / kS; var kQ = (kM === T - 1) ? (kU - kC * kM) : kC; if (kF + kQ > kC) { i++; kR = kT[i] = { style: [], styleData: [[], []], index: [], texture: null, textureSize: null, zoomWithMap: null, overlay: null }; kE = kR.styleData[0]; kD = kR.styleData[1]; kF = 0 } if (kR.styleData[0].length === 0) { kR.texture = kG.texture; kR.textureSize = kG.textureSize; kR.zoomWithMap = kG.zoomWithMap; kR.overlay = kG.overlay } kR.index[kR.index.length] = kG.index; var kP = kM > 0 ? -2 : 0; for (; kP < kQ; kP++) { kE[kE.length] = kJ[(kM * kC + kP) * (kS - 1)]; kE[kE.length] = kJ[(kM * kC + kP) * (kS - 1) + 1]; kE[kE.length] = kJ[(kM * kC + kP) * (kS - 1) + 2]; kE[kE.length] = kJ[(kM * kC + kP) * (kS - 1) + 3]; kE[kE.length] = kJ[(kM * kC + kP) * (kS - 1) + 4]; kE[kE.length] = kJ[(kM * kC + kP) * (kS - 1) + 5]; kE[kE.length] = kG.overlay["_height"]; if (!this.base_opt.isLinear || kG.border) { kE[kE.length] = kJ[(kM * kC + kP) * (kS - 1) + 7] } else { kE[kE.length] = this._length[kG.index] } kE[kE.length] = kJ[(kM * kC + kP) * (kS - 1) + 8]; kE[kE.length] = kG.index } var kI = kM > 0 ? ((kC * (kM + 1) - 2) * 3) : (kQ - 2) * 3; var kL = kM > 0 ? (kC * kM - 2) * 3 : 0; var e = kM > 0 ? kC * kM - 2 : 0; for (var kO = kL; kO < kI && kO < kH.length; kO++) { kD[kD.length] = kH[kO] - e + kF } } } }, buildLineVertex: function (T, kP, kC, kD, kG, kF) { var kI = []; var kM = []; var kO = []; var kJ = kP.points; var kN = T.strokeLineCap; var e = T.strokeLineJoin; var kE = iV.JOININDEX[e]; var kL = iV.CAPINDEX[kN]; var kK = this._toFormatPolGeometry(kJ, kC); for (var kH = 0; kH < kK.length; kH++) { if (kK[kH].length < 2) { continue } if (kI.length / 6 + gE.getVertexCount(kK[kH].length) > 65536) { kO.push([kI, kM]); kI = []; kM = [] } gE.buildData(kK[kH], kE, kL, kI, kM, kG, kD, undefined, kF) } kO.push([kI, kM]); return kO }, createBuffer: function (i) { var T = 13; var e = [{ name: "a_pos", components: 2, offset: 0, type: "Float32" }, { name: "a_normal", components: 2, offset: 8, type: "Float32" }, { name: "a_color", components: 4, offset: 16, type: "Uint8", normalize: true }, { name: "a_data", components: 4, offset: 20, type: "Float32" }, { name: "a_id", components: 1, offset: 36, type: "Float32" }]; return new B(i, { components: T, members: e }, B.BufferType.VERTEX) }, createBufferArrData: function (kM) { var kJ = []; var kK = 0; for (var kP in kM) { if (!kM.hasOwnProperty(kP)) { continue } var kE = kM[kP]; var kO = []; for (var kC in kE) { if (!kE.hasOwnProperty(kC)) { continue } var kI = kE[kC]; var kL = []; for (var kH = 0; kH < kI.length; kH++) { var kD = kI[kH].styleData[0]; var kF = kI[kH].styleData[1]; if (!kD || !kD.length) { continue } if (!this._bufferArray[kL.length + kK]) { this._bufferArray[kL.length + kK] = { vertex: null, element1: null, vao1: null } } var kN = this._bufferArray[kL.length + kK]; kN.textureKey = kC; kN.index = kI[kH].index; var T = new Float32Array(kD.length); T.set(kD); if (!kN.vertex) { kN.vertex = this.createBuffer(T) } var e = new Uint16Array(kF.length); e.set(kF); if (!kN.element1) { kN.element1 = new B(e, { components: 1 }, B.BufferType.ELEMENT, kF.length) } if (!kN.vao1) { kN.vao1 = new dY(); if (this.map._webglPainter) { var kG = this.map._webglPainter.programMgr.useProgram("linelayer", { def: this.def }); kN.vao1.bind(this.gl, kG, kN.vertex, kN.element1) } } kN.vao1.update(this.gl, kN.vertex, T, kD.length, kN.element1, e, kF.length); kL.push(kN) } kO.push(kL); kK += kL.length } kJ.push(kO) } return kJ }, createBufferData: function (kL) { var kI = []; var kJ = 0; for (var kE = 0; kE < kL.length; kE++) { var kM = kL[kE]; var kK = []; for (var kO in kM) { if (!kM.hasOwnProperty(kO)) { continue } var kH = kM[kO]; for (var kG = 0; kG < kH.length; kG++) { var kC = kH[kG].styleData[0]; var kD = kH[kG].styleData[1]; if (!kC || !kC.length) { continue } if (!this._bufferArray[kK.length + kJ]) { this._bufferArray[kK.length + kJ] = { vertex: null, element1: null, vao1: null } } var kN = this._bufferArray[kK.length + kJ]; kN.textureKey = kO; kN.index = kH[kG].index; var T = new Float32Array(kC.length); T.set(kC); if (!kN.vertex) { kN.vertex = this.createBuffer(T) } var e = new Uint16Array(kD.length); e.set(kD); if (!kN.element1) { kN.element1 = new B(e, { components: 1 }, B.BufferType.ELEMENT, kD.length) } if (!kN.vao1) { kN.vao1 = new dY(); if (this.map._webglPainter) { var kF = this.map._webglPainter.programMgr.useProgram("linelayer", { def: this.def }); kN.vao1.bind(this.gl, kF, kN.vertex, kN.element1) } } kN.vao1.update(this.gl, kN.vertex, T, kC.length, kN.element1, e, kD.length); kK.push(kN) } } kJ += kK.length; kI.push(kK) } return kI }, _generateTexture: function (kC) { if (kC.strokeTextureUrl) { var kD = kC.strokeTextureUrl + "_" + kC.strokeWeight; if (this._texture[kD]) { return { key: kD, value: this._texture[kD] } } var kF = kC.strokeTextureUrl; var kE = kC.strokeTextureWidth || 16; var i = kC.strokeTextureHeight || 16; var kG = kC.strokeWeight * Math.round(i / kE); var e = { totalDashLen: kG, texture: kF, textureSize: [kE, i] }; this._texture[kD] = e; return { key: kD, value: e } } if (kC.strokeStyle === "dashed" || kC.strokeStyle === "dotted") { var kD = [kC.strokeStyle, kC.strokeWeight, kC.strokeColor, kC.strokeOpacity, kC.dashArray.join(",")]; kD = kD.join("-"); if (this._texture[kD]) { return { key: kD, value: this._texture[kD] } } kC.sync = true; var T = this; ek._generateTexture(null, kC, function (kI, kH) { T._texture[kD] = kH }); return { key: kD, value: this._texture[kD] } } return null }, preRender: function (T, i, e) { }, render: function (kG, kC, kF) { if (!this.buffer) { return } kF = kF || {}; this.pickModel = kF.isPickRender || false; var T = this.map._webglPainter; var e = T._state; if (this.base_opt.nodeShow && this.attachNode) { if (this.base_opt.nodeStrict) { for (var kE = 0; kE < this.buffer.length; kE++) { kF.renderIndex = kE; for (var kD = 0; kD < this.buffer[kE].length; kD++) { this._renderItem(kG, T, this.buffer[kE][kD], kC, kF) } } } else { if (this.map.getZoom() > this.base_opt.nodeMinZoom && this.base_opt.nodeMask) { kG.clear(kG.STENCIL_BUFFER_BIT); kG.stencilFunc(kG.ALWAYS, 1, 255); e.stencilOp(kG.KEEP, kG.KEEP, kG.REPLACE); kG.stencilMask(255); e.colorMask(false, false, false, false); kF.isMask = true; this.attachNode.render(kG, kC, kF); kG.stencilFunc(kG.NOTEQUAL, 1, 255); kG.stencilMask(0); e.stencilOp(kG.KEEP, kG.KEEP, kG.KEEP); e.colorMask(true, true, true, true) } for (var kE = 0; kE < this.buffer[0].length; kE++) { this.drawLine(T, this.buffer[0][kE], false) } for (var kE = 0; kE < this.buffer[1].length; kE++) { this.drawLine(T, this.buffer[1][kE], false) } if (this.map.getZoom() > this.base_opt.nodeMinZoom) { kG.clear(kG.STENCIL_BUFFER_BIT); kG.stencilMask(255); kG.stencilFunc(kG.ALWAYS, 1, 255); kF.isMask = false; this.attachNode.render(kG, kC, kF) } } return } if (this.buffer[0].length > 0) { if (this.style_opt.borderMask && this.style_opt.borderCovered) { kG.clear(kG.STENCIL_BUFFER_BIT); kG.stencilFunc(kG.ALWAYS, 1, 255); e.stencilOp(kG.KEEP, kG.KEEP, kG.REPLACE); kG.stencilMask(255); e.colorMask(false, false, false, false); for (var kE = 0; kE < this.buffer[1].length; kE++) { this.drawLine(T, this.buffer[1][kE], true) } kG.stencilFunc(kG.NOTEQUAL, 1, 255); kG.stencilMask(0); e.stencilOp(kG.KEEP, kG.KEEP, kG.KEEP); e.colorMask(true, true, true, true); for (var kE = 0; kE < this.buffer[0].length; kE++) { this.drawLine(T, this.buffer[0][kE], false) } kG.clear(kG.STENCIL_BUFFER_BIT); kG.stencilMask(255); kG.stencilFunc(kG.ALWAYS, 1, 255); for (var kE = 0; kE < this.buffer[1].length; kE++) { this.drawLine(T, this.buffer[1][kE], false, true) } return } else { for (var kE = 0; kE < this.buffer[0].length; kE++) { this.drawLine(T, this.buffer[0][kE], false) } } } for (var kE = 0; kE < this.buffer[1].length; kE++) { this.drawLine(T, this.buffer[1][kE], false) } }, _renderItem: function (kF, i, kE, T, kD) { var e = i._state; if (this.map.getZoom() > this.base_opt.nodeMinZoom && this.base_opt.nodeMask) { kF.clear(kF.STENCIL_BUFFER_BIT); kF.stencilFunc(kF.ALWAYS, 1, 255); e.stencilOp(kF.KEEP, kF.KEEP, kF.REPLACE); kF.stencilMask(255); e.colorMask(false, false, false, false); kD.isMask = true; this.attachNode.render(kF, T, kD); kF.stencilFunc(kF.NOTEQUAL, 1, 255); kF.stencilMask(0); e.stencilOp(kF.KEEP, kF.KEEP, kF.KEEP); e.colorMask(true, true, true, true) } for (var kC = 0; kC < kE.length; kC++) { this.drawLine(i, kE[kC], false) } if (this.map.getZoom() > this.base_opt.nodeMinZoom) { kF.clear(kF.STENCIL_BUFFER_BIT); kF.stencilMask(255); kF.stencilFunc(kF.ALWAYS, 1, 255); kD.isMask = false; this.attachNode.render(kF, T, kD) } }, traceControl: function (i) { if (this.style_opt.traceControl instanceof Function) { var e = this.style_opt.traceControl.bind(this)(i); if (e instanceof Array && e.length === i.length) { return e } } return [] }, drawLine: function (kU, kO, kR, kW) { if (!kO.element1 || (kO.element1 && kO.element1.length === 0)) { return } var kS = kU.gl; var kD = kU.programMgr.useProgram("linelayer", { def: this.def }); var kI = this._texture[kO.textureKey]; var kJ = null; var kV = 0; var kL = this.map.getZoom(); var kK = this; if (kI) { var kM = kI.texture; if (kM instanceof HTMLCanvasElement || (window.ImageBitmap && kM instanceof window.ImageBitmap)) { if (!kI.glTexture) { kI.glTexture = d5.utils.createTexture(kS, kM, { flipY: false, wrap: this.style_opt.sequence ? kS.CLAMP_TO_EDGE : kS.REPEAT, unpackAlpha: true }) } kJ = kI.glTexture } else { if (!kI.glTexture) { kI.glTexture = { status: "init" }; var kY = new Image(); kY.crossOrigin = "anonymous"; kY.onload = function () { kI.glTexture.texture = d5.utils.createTexture(kS, this, { flipY: false, wrap: kK.style_opt.sequence ? kS.CLAMP_TO_EDGE : kS.REPEAT, unpackAlpha: true }); kI.glTexture.status = "done"; kK.doOnceDraw() }; kY.src = kM } if (kI.glTexture.status !== "done") { return } kJ = kI.glTexture.texture } kU._state.activeTexture(kS.TEXTURE4); kS.bindTexture(kS.TEXTURE_2D, kJ); if (kD.uniforms.lastSampler !== 4) { kS.uniform1i(kD.uniforms.u_image, 4); kD.uniforms.lastSampler = 4 } kV = kI.totalDashLen } if (this.base_opt.isLinear && this.linearTexture) { kU._state.activeTexture(kS.TEXTURE5); kS.bindTexture(kS.TEXTURE_2D, this.linearTexture); if (kD.uniforms.lastSampler !== 5) { kS.uniform1i(kD.uniforms.u_linear_image, 5); kD.uniforms.lastSampler = 5 } } var T = this.opacity; if (kD.lastState.opacity !== T) { kS.uniform1f(kD.uniforms.u_opacity, T); kD.lastState.opacity = T } var kE = this.style_opt.sequence; if (kD.lastState.sequence !== kE) { kS.uniform1i(kD.uniforms.u_sequence, kE); kD.lastState.sequence = kE } var i = this.style_opt.marginLength; if (kD.lastState.marginLength !== i) { kS.uniform1f(kD.uniforms.u_margin_length, i); kD.lastState.marginLength = i } if (kD.lastState.dash !== kV) { kS.uniform1f(kD.uniforms.u_dash_length, kV); kD.lastState.dash = kV } if (kD.lastState.mapZoom !== kL) { kS.uniform1f(kD.uniforms.u_map_zoom, kL); kD.lastState.mapZoom = kL } var kP = kU._camera._modelViewMatrixLayer; if (!kD.lastState.projMatrix) { kS.uniformMatrix4fv(kD.uniforms.u_proj_matrix, false, kU.projMatrix); kD.lastState.projMatrix = true } kS.uniformMatrix4fv(kD.uniforms.u_mv_matrix, false, kP); var kX = Math.pow(2, 18 - this.map.getZoom()); if (kD.lastState.scale !== kX) { kS.uniform1f(kD.uniforms.u_scale, kX); kD.lastState.scale = kX } var kH = this.base_opt.isFlat; if (kD.lastState.isFlat !== kH) { kS.uniform1i(kD.uniforms.u_flat, kH); kD.lastState.isFlat = kH } var kQ = this.base_opt.drawPart || 1; if (kD.lastState.drawPart !== kQ) { kS.uniform1i(kD.uniforms.u_draw_part, kQ); kD.lastState.drawPart = kQ } var kF = kU._camera._far || 4000; if (kD.lastState.cameraFar !== kF) { kS.uniform1f(kD.uniforms.u_camera_far, kF); kD.lastState.cameraFar = kF } kS.uniform1i(kD.uniforms.u_no_gradual, kW || false); var kN; if (!(this.style_opt.traceColor instanceof Array) || this.style_opt.traceColor.length < 3) { kN = [153, 153, 153] } else { kN = this.style_opt.traceColor.slice(0, 3) } kS.uniform3fv(kD.uniforms.u_trace_color, kN); kS.uniform1i(kD.uniforms.u_trace_disappear, this.style_opt.traceDisappear || false); kS.uniform1i(kD.uniforms.u_trace_start, !!this.style_opt.traceStart); kS.uniform1i(kD.uniforms.u_pick_model, kR || this.pickModel); kS.uniform1i(kD.uniforms.u_is_linear, !!this.base_opt.isLinear); kS.uniform4fv(kD.uniforms.u_arrow_color, this.arrow_color); if (kD.lastState.selectColor !== this.select_color) { kS.uniform4fv(kD.uniforms.u_pick_color, this.select_color); kD.lastState.selectColor = this.select_color } if (kD.lastState.pickTag !== this.selectedIndex) { kS.uniform1i(kD.uniforms.u_pick_tag, this.selectedIndex + 1); kD.lastState.pickTag = this.selectedIndex } var kT = this._formatArrayBuffer(this.delIndexs); kS.uniform1iv(kD.uniforms["u_del_tags[0]"], kT); var kC = this._formatArrayBuffer(kO.index); kS.uniform1iv(kD.uniforms["u_trace_index[0]"], kC); var e = this.traceControl(kO.index); var kG = this._formatArrayBuffer(e, true); kS.uniform1iv(kD.uniforms["u_trace_len[0]"], kG); kO.vao1.bind(kS, kD, kO.vertex, kO.element1); kS.drawElements(kS.TRIANGLES, kO.element1.length, kS.UNSIGNED_SHORT, 0); tags = null }, onDestroy: function (e, i) { this.lines = null; this.buffer = null; this._bufferArray = []; this._texture = {}; ee.prototype.onDestroy.call(this); if (this.attachNode) { this.attachNode.onDestroy() } }, toString: function () { return "LineLayer" } }); function ed(e) { e = e || {}; this.type = "polygon"; this.style_opt = { fillColor: "#142655", fillOpacity: 1, pattern: false, patternMask: true, patternUrl: "", patternMapping: "0, 0, 32, 32", patternScale: 1, patternOffset: "0, 0", height: 0 }; this._appendStyle = { height: { format: "number", defaultValue: 0 }, }; this.setStyleOptions(e.style || {}); this._bufferArray = []; this._texture = null; ee.call(this, e); e.border = e.border === undefined ? true : e.border; if (e.border) { var i = JSON.parse(JSON.stringify(e)); i = Object.assign(i, { enablePicked: false, autoSelect: false }); this.attach = new b1(i) } hQ.sendMessage(a1(4, 3, 11), ["layer", "fill"]) } ed.inherits(ee, "FillLayer"); e9.extend(ed.prototype, { onAdd: function (e, i) { if (this.attach) { this.attach.onAdd(e, i) } if (!this.map) { this.map = e; this.gl = i } if (!this.buffer) { this.parseData() } }, parseData: function (e) { if (!this.loadModule || !this.styleExpress || !this.map || !this.map._normalLayerMgr) { return } var T = this.getData(); if (!T) { return } if (this.attach) { if (e && e instanceof cG) { this.attach.center = e } this.attach.setData(T, this.params) } var kC = this.dataset = this.formatData(T); this.dispatchEvent(new fW("ondataparsed")); var i = this.fillsParse(kC.inner); this.fills = this.combineFill(i); this.buffer = this.createBufferData(this.fills); this.doOnceDraw() }, fillsParse: function (kH) { var kQ = []; for (var kM = 0; kM < kH.length; kM++) { var kS = kH[kM].points; var kC = false; if (!(kS[0] instanceof cG)) { kC = true } var kF = kH[kM].properties || {}; var e = kF.hasOwnProperty(this.base_opt.idKey) ? kF[this.base_opt.idKey] : false; var kD = kM; if (kH[kM].index !== undefined) { kD = kH[kM].index } var kO = this.evaluates(kD, { properties: kF, id: e }); var kJ = JSON.parse(JSON.stringify(cB[this.type])); if (this._appendStyle) { for (var kR in this._appendStyle) { kJ[kR] = this._appendStyle[kR].defaultValue } } kO = Object.assign(kJ, kO || {}); _height = kO.height || 0; var kL = this.getColorStyleForGL(kO.fillColor, kO.fillOpacity, true).join(","); var kP = []; if (this.style_opt.pattern && this.style_opt.patternUrl) { kP = [kO.patternMapping.split(","), kO.patternScale, kO.patternOffset.split(",")] } var kG = this.buildFillVertex(kS, kC); var kN = kG[0].length / 2 * 4; var T = new Float32Array(kN); var kE = 0; for (var kK = 0; kK < kG[0].length; kK++) { T[kE] = kG[0][kK]; kE++; if ((kK + 1) % 2 === 0) { T[kE] = _height; T[kE + 1] = kD; kE += 2 } } var kI = [kL, T, kG[1], kP]; kI.hasMultipleParts = kC; kQ.push(kI) } return kQ }, buildFillVertex: function (kC, e) { var kI = this._toFormatPolGeometry(kC, e); var kJ = []; var kF; var kG = []; var kE = 0; for (var kD = 0; kD < kI.length; kD++) { if (kD > 0) { kE += kI[kD - 1].length } kF = hX(kI[kD].pointsArray, null, null, kE); for (var T = 0, kH = kF.length; T < kH; T += 3) { kJ.push(kF[T], kF[T + 1], kF[T + 2]) } kG = kG.concat(kI[kD].pointsArray) } var kK = [new Float32Array(kG), new Uint16Array(kJ)]; return kK }, combineFill: function (T) { var kH = {}; var e = []; for (var kE = 0; kE < T.length; kE++) { var kG = this._cloneFill(T[kE]); if (kG.hasMultipleParts) { e.push(kG) } else { var kD = kG[0] + "_" + kG[3].join("-"); if (kH[kD]) { if ((kH[kD][1].length + kG[1].length) / 4 < 65536) { this.mergeDataItem(kH[kD], kG, kH[kD][1].length / 4) } else { e.push(this._cloneFill(kH[kD])); kH[kD] = kG } } else { kH[kD] = kG } } } var kF = Object.keys(kH); for (var kC = 0; kC < kF.length; kC++) { e.push(kH[kF[kC]]) } return e }, _cloneFill: function (kD) { var kC = kD[1].constructor; var i = new kC(kD[1].length); i.set(kD[1], 0); var kE = kD[2].constructor; var T = new kE(kD[2].length); T.set(kD[2], 0); var e = [kD[0], i, T, kD[3]]; if (kD.hasMultipleParts) { e.hasMultipleParts = kD.hasMultipleParts } return e }, mergeDataItem: function (e, kE, T) { var i = e[1]; var kD = kE[1]; var kC = e[2]; var kF = kE[2]; e[1] = this.concatTypedArray(i, kD); e[2] = this.concatTypedArray(kC, kF, T); return e }, concatTypedArray: function (e, kF, kE) { if (e.constructor === ArrayBuffer) { var kC = new Uint8Array(e.byteLength + kF.byteLength); kC.set(new Uint8Array(e), 0); kC.set(new Uint8Array(kF), e.byteLength); return kC.buffer } else { var kD = e.constructor; var kC = new kD(e.length + kF.length); kC.set(e, 0); if (kE) { for (var T = 0; T < kF.length; T++) { kF[T] += kE } } kC.set(kF, e.length); return kC } }, createBuffer: function (i) { var T = 4; var e = [{ name: "a_pos", components: 3, offset: 0, type: "Float32" }, { name: "a_id", components: 1, offset: 12, type: "Float32" }]; return new B(i, { components: T, members: e }, B.BufferType.VERTEX) }, createBufferData: function (kF) { var kG = []; for (var kC = 0; kC < kF.length; kC++) { var kE = kF[kC][1]; var T = kF[kC][2]; if (!kE || !kE.length) { continue } if (!this._bufferArray[kG.length]) { this._bufferArray[kG.length] = { vertex: null, element1: null, vao1: null }; var kD = this._bufferArray[kG.length]; kD.vertex = this.createBuffer(kE); kD.element1 = new B(T, { components: 1 }, B.BufferType.ELEMENT, T.length); kD.vao1 = new dY(); if (this.map._webglPainter) { var e = this.map._webglPainter.programMgr.useProgram("filllayer", { def: this.def }); kD.vao1.bind(this.gl, e, kD.vertex, kD.element1) } } else { var kD = this._bufferArray[kG.length]; kD.vao1.update(this.gl, kD.vertex, kE, kE.length, kD.element1, T, T.length) } kG.push(kD) } return kG }, preRender: function (T, i, e) { }, render: function (kE, kG, e) { if (!this.buffer) { return } e = e || {}; if (this.style_opt.pattern && this.style_opt.patternUrl) { if (!this._texture) { this._texture = { status: "init" }; var kI = this; var kD = new Image(); kD.crossOrigin = "anonymous"; kD.onload = function () { kI._texture = d5.utils.createTexture(kE, this, { flipY: true, wrap: kE.REPEAT, mipmap: false, unpackAlpha: true }); kI._texture.size = [this.width, this.height]; kI._texture.status = "done"; kI.doOnceDraw() }; kD.src = this.style_opt.patternUrl } if (this._texture.status !== "done") { return } } this.pickModel = e.isPickRender || false; var kH = this.map._webglPainter; var kJ = kH._state; for (var kC = 0; kC < this.buffer.length; kC++) { var T = this.fills[kC][0]; T = T.split(","); T = [T[0] / 255, T[1] / 255, T[2] / 255, parseFloat(T[3])]; var kF = this.fills[kC][3]; if (this.fills[kC].hasMultipleParts) { kE.clear(kE.STENCIL_BUFFER_BIT); kE.stencilFunc(kE.NEVER, 0, 255); kJ.stencilOp(kE.INVERT, kE.INVERT, kE.INVERT); kE.stencilMask(255); kJ.colorMask(false, false, false, false); this.drawFill(kH, this.buffer[kC], T, kF); kE.stencilFunc(kE.EQUAL, 255, 255); kE.stencilMask(0); kJ.stencilOp(kE.KEEP, kE.KEEP, kE.KEEP); kJ.colorMask(true, true, true, true); this.drawFill(kH, this.buffer[kC], T, kF); kE.clear(kE.STENCIL_BUFFER_BIT); kE.stencilMask(255); kE.stencilFunc(kE.ALWAYS, 1, 255) } else { this.drawFill(kH, this.buffer[kC], T, kF) } } if (this.attach && !this.pickModel) { this.attach.render(kE, kG, e) } }, drawFill: function (kQ, kJ, kK, kO) { if (kJ.element1 && kJ.element1.length === 0) { return } var kN = kQ.gl; var kD = kQ.programMgr.useProgram("filllayer", { def: this.def }); var kL = kQ._camera._modelViewMatrixLayer; if (!kD.lastState.projMatrix) { kN.uniformMatrix4fv(kD.uniforms.u_proj_matrix, false, kQ.projMatrix); kD.lastState.projMatrix = true } kN.uniformMatrix4fv(kD.uniforms.u_mv_matrix, false, kL); kN.uniform4fv(kD.uniforms.u_color, kK); var i = this.opacity; if (kD.lastState.opacity !== i) { kN.uniform1f(kD.uniforms.u_opacity, i); kD.lastState.opacity = i } var kE = this.style_opt.pattern; if (kE && this._texture) { kQ._state.activeTexture(kN.TEXTURE5); kN.bindTexture(kN.TEXTURE_2D, this._texture); if (kD.uniforms.lastSampler !== 5) { kN.uniform1i(kD.uniforms.u_image, 5); kD.uniforms.lastSampler = 5 } var kH = this._texture.size; if (kD.lastState.size !== kH) { kN.uniform2fv(kD.uniforms.u_size, kH); kD.lastState.size = kH } } if (kD.lastState.pattern !== kE) { kN.uniform1i(kD.uniforms.u_pattern, kE); kD.lastState.pattern = kE } var T = this.style_opt.patternMask; if (kD.lastState.patternMask !== T) { kN.uniform1i(kD.uniforms.u_pattern_mask, T); kD.lastState.patternMask = T } var kI = this.map.getZoom(); if (kD.lastState.mapZoom !== kI) { kN.uniform1f(kD.uniforms.u_map_zoom, kI); kD.lastState.mapZoom = kI } var e = kO.length >= 3 ? kO[0] : [0, 0, 0, 0]; if (kD.lastState.bound !== e) { kN.uniform4fv(kD.uniforms.u_bound, e); kD.lastState.bound = e } var kR = kO.length >= 3 ? kO[1] : 0; if (kD.lastState.scale !== kR) { kN.uniform1f(kD.uniforms.u_scale, kR); kD.lastState.scale = kR } var kC = kO.length >= 3 ? kO[2] : [0, 0]; if (kD.lastState.offset !== kC) { kN.uniform2fv(kD.uniforms.u_offset, kC); kD.lastState.offset = kC } var kG = this.base_opt.isFlat; if (kD.lastState.isFlat !== kG) { kN.uniform1i(kD.uniforms.u_flat, kG); kD.lastState.isFlat = kG } var kM = this.base_opt.drawPart || 1; if (kD.lastState.drawPart !== kM) { kN.uniform1i(kD.uniforms.u_draw_part, kM); kD.lastState.drawPart = kM } var kF = kQ._camera._far || 4000; if (kD.lastState.cameraFar !== kF) { kN.uniform1f(kD.uniforms.u_camera_far, kF); kD.lastState.cameraFar = kF } kN.uniform1i(kD.uniforms.u_pick_model, this.pickModel); if (kD.lastState.selectColor !== this.select_color) { kN.uniform4fv(kD.uniforms.u_pick_color, this.select_color); kD.lastState.selectColor = this.select_color } if (kD.lastState.pickTag !== this.selectedIndex) { kN.uniform1i(kD.uniforms.u_pick_tag, this.selectedIndex + 1); kD.lastState.pickTag = this.selectedIndex } var kP = this._formatArrayBuffer(this.delIndexs); kN.uniform1iv(kD.uniforms["u_del_tags[0]"], kP); kJ.vao1.bind(kN, kD, kJ.vertex, kJ.element1); kN.drawElements(kN.TRIANGLES, kJ.element1.length, kN.UNSIGNED_SHORT, 0); tags = null }, onDestroy: function (e, i) { this.fills = null; this.buffer = null; this._bufferArray = []; this._texture = null; ee.prototype.onDestroy.call(this); if (this.attach) { this.attach.onDestroy() } }, toString: function () { return "FillLayer" } }); function aZ(e) { e = e || {}; this.type = "point"; this.style_opt = { visibility: true, nodeType: aZ.NodeType.SHAPE, shapeType: aZ.ShapeType.TRIANGLE, anchor: aZ.Anchor.CENTER, size: 32, scale: 1, rotation: 0, offset: [0, 0], color: "green", opacity: 1, strokeColor: "red", strokeWeight: 0 }; this.setStyleOptions(e.style || {}); this._bufferArray = []; e.isFlat = e.isFlat === undefined ? true : e.isFlat; ee.call(this, e); hQ.sendMessage(a1(4, 3, 9, 2), ["layer", "point", "shape"]) } aZ.Anchor = { CENTER: 0, TOP_LEFT: 1, TOP_CENTER: 2, TOP_RIGHT: 3, RIGHT_CENTER: 4, BOTTOM_RIGHT: 5, BOTTOM_CENTER: 6, BOTTOM_LEFT: 7, LEFT_CENTER: 8, 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8 }; aZ.NodeType = { ICON: 1, SHAPE: 2 }; aZ.ShapeType = { CIRCLE: 0, TRIANGLE: 2, CROSS: 4, ARROW: 5, ARROW_TAIL: 6, 0: 0, 2: 2, 4: 4, 5: 5, 6: 6 }; aZ.inherits(ee, "PointShapeLayer"); aZ.hasMask = function (e) { if (e === aZ.ShapeType.TRIANGLE || e === aZ.ShapeType.ARROW) { return true } else { return false } }; e9.extend(aZ.prototype, { onAdd: function (e, i) { if (!this.map) { this.map = e; this.gl = i } if (!this.buffer) { this.parseData() } }, parseData: function () { if (!this.loadModule || !this.styleExpress || !this.map || !this.map._normalLayerMgr) { return } var kD = this.getData(); if (!kD) { return } var kE = this.dataset = this.formatData(kD); this.dispatchEvent(new fW("ondataparsed")); var kF = this.pointsParse(kE); this.buffer = []; var e = 0; for (var T = 0; T < kF.length; T++) { var kC = this.combineVertex(kF[T]); this.buffer.push(this.createBufferData(kC, e)); e += kC.length } this.doOnceDraw() }, preRender: function (T, i, e) { }, pointsParse: function (kG) { var kN = kG.inner; var kI = []; var kO = this.params.nodeStrictIndex || []; for (var kH = 0; kH < kN.length; kH++) { var kM = kN[kH]; var kJ = kM.properties || {}; var kL = kJ.hasOwnProperty(this.base_opt.idKey) ? kJ[this.base_opt.idKey] : false; var kD = this.evaluates(kM.properties.index, { properties: kJ, id: kL }); kD = Object.assign(JSON.parse(JSON.stringify(cB[this.type])), kD || {}); if (this.base_opt.nodeBreakpoint === false && kJ.line_node_type === 3) { continue } if (!kD.visibility) { continue } var e = this._toFormatPointGeometry(kM.points, this.base_opt.coorSysMc); kD.position = e; kD.index = isNaN(kJ.index) ? kH : kJ.index; kD.id = isNaN(kL) || kL === false ? kH : kL; kD.anchor = aZ.Anchor[kD.anchor] === undefined ? "center" : kD.anchor; kD.shapeType = aZ.ShapeType[kD.shapeType] === undefined ? 0 : kD.shapeType; if (kJ.line_node_type === 1 && this.base_opt.linkLine) { kD.rotation -= 180 } kD.lineNodeType = kJ.line_node_type || 9; if (kJ.startPoint) { var kF = kJ.startPoint.split(","); if (kF.length == 2) { var kC = new cG(parseFloat(kF[0]), parseFloat(kF[1])); var kE = this._toFormatPointGeometry(kC, this.base_opt.coorSysMc); kD.startPoint = kE } } if (kJ.endPoint) { var kF = kJ.endPoint.split(","); if (kF.length == 2) { var kC = new cG(parseFloat(kF[0]), parseFloat(kF[1])); var kK = this._toFormatPointGeometry(kC, this.base_opt.coorSysMc); kD.endPoint = kK } } if (kO.length === 0) { if (!kI[0]) { kI[0] = [] } kI[0].push(kD) } else { var T = this._findTargetGroup(kD.index, kO); if (T >= 0) { if (!kI[T]) { kI[T] = [] } kI[T].push(kD) } } } return kI }, _findTargetGroup: function (T, kD) { for (var kC = 0; kC < kD.length; kC++) { for (var e = 0; e < kD[kC].length; e++) { if (kD[kC][e] === T) { return kC } } } return -1 }, combineVertex: function (kI) { var kL = [{ vertex: [], indices: [] }]; var kG = kL[kL.length - 1].vertex; var kJ = kL[kL.length - 1].indices; for (var kF = 0, kH = kI.length; kF < kH; kF++) { var T = kI[kF]; if ((kG.length + 16 * 4) > 65536) { kL.push({ vertex: [], indices: [] }); kG = kL[kL.length - 1].vertex; kJ = kL[kL.length - 1].indices } for (var kE = 0; kE < 4; kE++) { kG.push(T.position[0], T.position[1]); var kC = this.int8ArrayToFloat([T.anchor, kE, T.shapeType, T.lineNodeType]); kG.push(kC); kG.push(T.size, T.scale, T.rotation * Math.PI / 180); kG.push(T.offset[0], T.offset[1]); var e = this.getColorStyleForGL(T.color, undefined, true); var kK = this.getColorStyleForGL(T.strokeColor, undefined, true); kG.push(this.rgb2value(e), T.opacity, this.rgb2value(kK), T.strokeWeight); if (T.startPoint) { kG.push(T.startPoint[0], T.startPoint[1]) } else { kG.push(0.1, 0.1) } if (T.endPoint) { kG.push(T.endPoint[0], T.endPoint[1]) } else { kG.push(0.1, 0.1) } kG.push(T.id) } var kD = (kJ.length / 6) * 4; kJ.push(kD, kD + 2, kD + 1, kD, kD + 3, kD + 2) } return kL }, createBuffer: function (i) { var T = 17; var e = [{ name: "a_pos", components: 2, offset: 0, type: "Float32" }, { name: "a_shape", components: 4, offset: 8, type: "Uint8" }, { name: "a_transform", components: 3, offset: 12, type: "Float32" }, { name: "a_offset", components: 2, offset: 24, type: "Float32" }, { name: "a_data", components: 4, offset: 32, type: "Float32" }, { name: "a_start", components: 2, offset: 48, type: "Float32" }, { name: "a_end", components: 2, offset: 56, type: "Float32" }, { name: "a_id", components: 1, offset: 64, type: "Float32" }]; return new B(i, { components: T, members: e }, B.BufferType.VERTEX) }, createBufferData: function (kF, e) { var kG = []; e = e || 0; for (var kC = 0; kC < kF.length; kC++) { var kE = new Float32Array(kF[kC].vertex.length); kE.set(kF[kC].vertex); var T = new Uint16Array(kF[kC].indices.length); T.set(kF[kC].indices); if (!kE || !kE.length) { continue } if (!this._bufferArray[kG.length + e]) { this._bufferArray[kG.length + e] = { vertex: null, element1: null, vao1: null }; var kD = this._bufferArray[kG.length + e]; kD.vertex = this.createBuffer(kE); kD.element1 = new B(T, { components: 1 }, B.BufferType.ELEMENT, T.length); kD.vao1 = new dY() } else { var kD = this._bufferArray[kG.length + e]; kD.vao1.update(this.gl, kD.vertex, kE, kE.length, kD.element1, T, T.length) } kG.push(kD) } return kG }, render: function (kG, kC, kF) { if (!this.buffer) { return } kF = kF || {}; this.pickModel = kF.isPickRender || false; var T = kF.isMask === undefined ? false : kF.isMask; var e = this.map._webglPainter; if (kF.renderIndex !== undefined && this.buffer.length > kF.renderIndex) { for (var kD = 0; kD < this.buffer[kF.renderIndex].length; kD++) { this.drawPointShape(e, this.buffer[kF.renderIndex][kD], T) } } else { for (var kE = 0; kE < this.buffer.length; kE++) { for (var kD = 0; kD < this.buffer[kE].length; kD++) { this.drawPointShape(e, this.buffer[kE][kD], T) } } } }, drawPointShape: function (kI, e, kD) { if (e.element1 && e.element1.length === 0) { return } var T = kI.gl; var i = kI.programMgr.useProgram("pointshapelayer", { def: this.def }); var kH = kI._camera._modelViewMatrixLayer; if (!i.lastState.projMatrix) { T.uniformMatrix4fv(i.uniforms.u_proj_matrix, false, kI.projMatrix); i.lastState.projMatrix = true } T.uniformMatrix4fv(i.uniforms.u_mv_matrix, false, kH); var kC = this.map.getZoom(); if (i.lastState.mapZoom !== kC) { T.uniform1f(i.uniforms.u_map_zoom, kC); i.lastState.mapZoom = kC } var kG = kI._camera._far || 4000; if (i.lastState.cameraFar !== kG) { T.uniform1f(i.uniforms.u_camera_far, kG); i.lastState.cameraFar = kG } if (i.lastState.isMask !== kD) { T.uniform1i(i.uniforms.u_mask, kD); i.lastState.isMask = kD } T.uniform1i(i.uniforms.u_pick_model, this.pickModel || false); var kF = [2 / this.map.width, 2 / this.map.height]; if (i.lastState.resolutionRatio !== kF) { T.uniform2fv(i.uniforms.u_resolution_ratio, kF); i.lastState.resolutionRatio = kF } var kE = this.base_opt.isFlat; if (i.lastState.isFlat !== kE) { T.uniform1i(i.uniforms.u_flat, kE); i.lastState.isFlat = kE } if (i.lastState.selectColor !== this.select_color) { T.uniform4fv(i.uniforms.u_pick_color, this.select_color); i.lastState.selectColor = this.select_color } if (i.lastState.pickTag !== this.selectedIndex) { T.uniform1i(i.uniforms.u_pick_tag, this.selectedIndex + 1); i.lastState.pickTag = this.selectedIndex } e.vao1.bind(T, i, e.vertex, e.element1); T.drawElements(T.TRIANGLES, e.element1.length, T.UNSIGNED_SHORT, 0) }, onDestroy: function (e, i) { this.buffer = null; this._bufferArray = []; ee.prototype.onDestroy.call(this) }, toString: function () { return "PointShapeLayer" } }); function gp(e) { e = e || {}; this.type = "point"; this.style_opt = { visibility: true, nodeType: gp.NodeType.ICON, icon: "", iconObj: null, userSizes: true, anchors: [0, 0], sizes: [32, 32], scale: 1, rotation: 0, offset: [0, 0], opacity: 1, width: 0, height: 0, }; this._appendStyle = { anchors: { format: "object", defaultValue: [0, 0] }, sizes: { format: "object", defaultValue: [32, 32] }, width: { format: "number", defaultValue: 32 }, height: { format: "number", defaultValue: 32 }, }; this.setStyleOptions(e.style || {}); this._bufferArray = []; e.isFlat = e.isFlat === undefined ? true : e.isFlat; e.isFixed = e.isFixed === undefined ? true : e.isFixed; e.refLevel = e.refLevel === undefined ? 18 : e.refLevel; ee.call(this, e); hQ.sendMessage(a1(4, 3, 9, 1), ["layer", "point", "icon"]) } gp.NodeType = { ICON: 1, SHAPE: 2 }; gp.inherits(ee, "PointIconLayer"); e9.extend(gp.prototype, { onAdd: function (i, T) { if (!this.map) { this.map = i; this.gl = T } if (!this.buffer) { this.parseData() } var e = this; i.addEventListener("oniconupdate", function (kC) { e.updateVertex() }) }, parseData: function () { if (!this.loadModule || !this.styleExpress || !this.map || !this.map._normalLayerMgr) { return } var e = this.getData(); if (!e) { return } this.dataset = this.formatData(e); this.dispatchEvent(new fW("ondataparsed")); this.updateVertex() }, updateVertex: function () { if (!this.dataset) { return } var i = this.pointsParse(this.dataset); if (!i || i.length == 0) { return } this.updateAllIconsTextureCoords(i[0]); var e = this; this.map._normalLayerMgr.loadIconImages(i[0], function (T) { e.updateAllIconsTextureCoords(i[0]) }, true) }, updateAllIconsTextureCoords: function (kE) { var kG = []; for (var kC = 0; kC < kE.length; kC++) { var kF = kE[kC]; if (this.map._webglMapScene) { var T = this.map._webglMapScene._painter; if (kF.icon instanceof HTMLCanvasElement) { var kD = kF.icon.id } else { var kD = kF.icon } if (T._iconTextureAtlasCoords[kD]) { kF.texcoord = T._iconTextureAtlasCoords[kD]; kG.push(kF) } } } this.buffer = []; var e = [{ vertex: [], indices: [] }]; for (var kC = 0; kC < kG.length; kC++) { this.combineVertex(kG[kC], e) } this.buffer.push(this.createBufferData(e)); this.doOnceDraw() }, preRender: function (T, i, e) { }, pointsParse: function (kC) { var kJ = kC.inner; var kE = []; for (var kD = 0; kD < kJ.length; kD++) { var kH = kJ[kD]; var kF = kH.properties || {}; var kG = kF.hasOwnProperty(this.base_opt.idKey) ? kF[this.base_opt.idKey] : false; var T = this.evaluates(kH.properties.index, { properties: kF, id: kG }); var kL = JSON.parse(JSON.stringify(cB[this.type])); if (this._appendStyle) { for (var kI in this._appendStyle) { kL[kI] = this._appendStyle[kI].defaultValue } } T = Object.assign(kL, T || {}); if (this.base_opt.nodeBreakpoint === false && kF.line_node_type === 3) { continue } if (!T.visibility) { continue } var e = this._toFormatPointGeometry(kH.points, this.base_opt.coorSysMc); T.position = e; T.index = isNaN(kF.index) ? kD : kF.index; T.id = isNaN(kG) || kG === false ? kD : kG; if (!T.icon && this.style_opt.iconObj && this.style_opt.iconObj instanceof Function) { var kK = this.style_opt.iconObj(T, kF); T.icon = kK.canvas; if (kK.id !== undefined) { T.icon.id = this.guid + "_" + kK.id } else { T.icon.id = this.guid + "_" + T.id } } if (!kE[0]) { kE[0] = [] } kE[0].push(T) } return kE }, combineVertex: function (kD, e) { var kC = e[e.length - 1].vertex; var kE = e[e.length - 1].indices; if ((kC.length + 14 * 4) > 65536) { e.push({ vertex: [], indices: [] }); kC = e[e.length - 1].vertex; kE = e[e.length - 1].indices } for (var T = 3; T >= 0; T--) { kC.push(kD.position[0], kD.position[1]); if (this.style_opt.userSizes) { kC.push(kD.sizes[0], kD.sizes[1], kD.anchors[0], kD.anchors[1]) } else { kC.push(kD.width, kD.height, kD.anchors[0], kD.anchors[1]) } kC.push(kD.scale, kD.rotation * Math.PI / 180, 4 - T, kD.opacity); kC.push(kD.offset[0], kD.offset[1], kD.texcoord[T * 2], kD.texcoord[T * 2 + 1]); kC.push(kD.id) } var i = (kE.length / 6) * 4; kE.push(i, i + 2, i + 1, i, i + 3, i + 2) }, createBuffer: function (i) { var T = 13; var e = [{ name: "a_pos", components: 2, offset: 0, type: "Float32" }, { name: "a_shape", components: 4, offset: 8, type: "Float32" }, { name: "a_style", components: 4, offset: 24, type: "Float32" }, { name: "a_data", components: 4, offset: 40, type: "Float32" }, { name: "a_id", components: 1, offset: 56, type: "Float32" }]; return new B(i, { components: T, members: e }, B.BufferType.VERTEX) }, createBufferData: function (kE) { var kF = []; for (var T = 0; T < kE.length; T++) { var kD = new Float32Array(kE[T].vertex.length); kD.set(kE[T].vertex); var e = new Uint16Array(kE[T].indices.length); e.set(kE[T].indices); if (!kD || !kD.length) { continue } if (!this._bufferArray[kF.length]) { this._bufferArray[kF.length] = { vertex: null, element1: null, vao1: null }; var kC = this._bufferArray[kF.length]; kC.vertex = this.createBuffer(kD); kC.element1 = new B(e, { components: 1 }, B.BufferType.ELEMENT, e.length); kC.vao1 = new dY() } else { var kC = this._bufferArray[kF.length]; kC.vao1.update(this.gl, kC.vertex, kD, kD.length, kC.element1, e, e.length) } kF.push(kC) } return kF }, render: function (kG, kC, kF) { if (!this.buffer) { return } kF = kF || {}; this.pickModel = kF.isPickRender || false; var T = kF.isMask === undefined ? false : kF.isMask; var e = this.map._webglPainter; if (kF.renderIndex !== undefined && this.buffer.length > kF.renderIndex) { for (var kD = 0; kD < this.buffer[kF.renderIndex].length; kD++) { this.drawPointIcon(e, this.buffer[kF.renderIndex][kD], T) } } else { for (var kE = 0; kE < this.buffer.length; kE++) { for (var kD = 0; kD < this.buffer[kE].length; kD++) { this.drawPointIcon(e, this.buffer[kE][kD], T) } } } }, drawPointIcon: function (kL, i, kF) { if (i.element1 && i.element1.length === 0) { return } var kD = kL.gl; var kC = kL.programMgr.useProgram("pointiconlayer", { def: this.def }); var kK = kL._camera._modelViewMatrixLayer; if (!kC.lastState.projMatrix) { kD.uniformMatrix4fv(kC.uniforms.u_proj_matrix, false, kL.projMatrix); kC.lastState.projMatrix = true } kD.uniformMatrix4fv(kC.uniforms.u_mv_matrix, false, kK); var kE = this.map.getZoom(); if (kC.lastState.mapZoom !== kE) { kD.uniform1f(kC.uniforms.u_map_zoom, kE); kC.lastState.mapZoom = kE } var kJ = kL._camera._far || 4000; if (kC.lastState.cameraFar !== kJ) { kD.uniform1f(kC.uniforms.u_camera_far, kJ); kC.lastState.cameraFar = kJ } kD.uniform1i(kC.uniforms.u_pick_model, this.pickModel || false); var kI = [2 / this.map.width, 2 / this.map.height]; if (kC.lastState.resolutionRatio !== kI) { kD.uniform2fv(kC.uniforms.u_resolution_ratio, kI); kC.lastState.resolutionRatio = kI } var kH = this.base_opt.isFlat; if (kC.lastState.isFlat !== kH) { kD.uniform1i(kC.uniforms.u_flat, kH); kC.lastState.isFlat = kH } var e = this.base_opt.isFixed; if (kC.lastState.isFixed !== e) { kD.uniform1i(kC.uniforms.u_fixed, e); kC.lastState.isFixed = e } var T = this.base_opt.refLevel; if (kC.lastState.refLevel !== T) { kD.uniform1f(kC.uniforms.u_ref_level, T); kC.lastState.isFlat = T } if (kC.lastState.selectColor !== this.select_color) { kD.uniform4fv(kC.uniforms.u_pick_color, this.select_color); kC.lastState.selectColor = this.select_color } if (kC.lastState.pickTag !== this.selectedIndex) { kD.uniform1i(kC.uniforms.u_pick_tag, this.selectedIndex + 1); kC.lastState.pickTag = this.selectedIndex } var kG = kL._iconTextureAtlas.getTexture(); kL._state.activeTexture(kD.TEXTURE5); kD.bindTexture(kD.TEXTURE_2D, kG); if (kC.uniforms.lastSamper !== 5) { kD.uniform1i(kC.uniforms.u_sampler, 5); kC.uniforms.lastSamper = 5 } i.vao1.bind(kD, kC, i.vertex, i.element1); kD.drawElements(kD.TRIANGLES, i.element1.length, kD.UNSIGNED_SHORT, 0) }, onDestroy: function (e, i) { this.buffer = null; this._bufferArray = []; ee.prototype.onDestroy.call(this) }, toString: function () { return "PointIconLayer" } }); var hj = null; bG.register(function (i) { if (i.config && i.config.isOverviewMap) { return } if (i.isLoaded()) { M(i); hj = jI(i) } else { i.addEventListener("load", function () { M(this); hj = jI(this) }) } i.cityName = "中国"; i.cCode = "1"; var e = {}; e.enableRequest = true; e.request = function () { if (e.enableRequest) { e.enableRequest = false; setTimeout(function () { e._request() }, 500) } }; e._request = function () { var kC = i.getBoundsIn(); if (!kC) { return } var kE = i.getZoom(); var T = kC.getSouthWest(); var kD = kC.getNorthEast(); kl.request(function (kI) { if (kI.current_city["code"] >= 9000 && kI.current_city["code"] <= 9378) { kI.current_city["name"] = "台湾省" } if (kI.current_city["code"] >= 20000 && kI.current_city["code"] <= 20499) { kI.current_city["name"] = "新加坡" } if (kI.current_city["code"] >= 20500 && kI.current_city["code"] <= 25999) { kI.current_city["name"] = "泰国" } if (kI.current_city["code"] >= 26000 && kI.current_city["code"] <= 29999) { kI.current_city["name"] = "日本" } if (kI.current_city["code"] >= 30000 && kI.current_city["code"] <= 30999) { kI.current_city["name"] = "韩国" } if (kI.current_city["code"] >= 31000 && kI.current_city["code"] <= 37000) { kI.current_city["name"] = "亚太" } if (kI.current_city["code"] >= 46609 && kI.current_city["code"] <= 52505) { kI.current_city["name"] = "欧洲" } if (kI.current_city["code"] >= 39509 && kI.current_city["code"] <= 53500) { kI.current_city["name"] = "南美洲" } if (kI.current_city["code"] >= 54000 && kI.current_city["code"] <= 70000) { kI.current_city["name"] = "北美洲" } if (kI.current_city["code"] === 54003 && kI.current_city["code"] >= 60731 && kI.current_city["code"] <= 61123) { kI.current_city["name"] = "美国" } if (kI.current_city["code"] === 54015 || kI.current_city["code"] >= 57970 && kI.current_city["code"] <= 60223) { kI.current_city["name"] = "加拿大" } if (kI.current_city["code"] === 54025 || kI.current_city["code"] >= 54338 && kI.current_city["code"] <= 57374) { kI.current_city["name"] = "墨西哥" } e.enableRequest = true; if (kI && kI.current_city) { var kH = kI.current_city["name"]; var kG = kI.current_city["code"]; if (kG !== i.cCode) { var kF = new fW("oncitychange"); kF.name = kH; kF.code = kG; i.dispatchEvent(kF) } i.cityName = kH; i.cCode = kG; if (!b5()) { da(i) } } }, { qt: "cen", b: T.lng + "," + T.lat + ";" + kD.lng + "," + kD.lat, l: kE }, "", "", true) }; i.addEventListener("load", function (T) { e.request() }); i.addEventListener("moveend", function (T) { e.request() }); i.addEventListener("zoomend", function (T) { e.request() }); e.request() }); function jI(T) { var e = {}; var i = new kj(e); T.addControl(i); return i } function M(i) { if (i.temp.copyadded) { return } i.temp.copyadded = true; if (!i.cpyCtrl) { var kC = new jo(2, 2); i.config.cpyCtrlOffset = kC; if (b5()) { kC.width = 72; kC.height = 0 } var T = new gn({ offset: kC, printable: true }); i.cpyCtrl = T } if (!b5()) { da(i); i.addEventListener("maptypechange", function () { da(i) }) } i.addControl(T); var e = new bJ(); e._opts = { printable: true }; i.logoCtrl = e; i.addControl(e); i.addEventListener("resize", function () { if (this.getSize().width >= 300 && i.getSize().height >= 100) { e.show(); T && T.setOffset(i.config.cpyCtrlOffset) } else { e.hide(); T && T.setOffset(new jo(4, 2)) } }); if (i.getSize().width >= 300 && i.getSize().height >= 100) { e.show() } else { e.hide(); T.setOffset(new jo(4, 2)) } i.addEventListener("oncopyrightoffsetchange", function (kD) { i.logoCtrl.setOffset(kD.target.logo); i.cpyCtrl.setOffset(kD.target.cpy) }); i.dispatchEvent(new fW("oncopyrightaddend")) } function da(kR) { if (!kR.cpyCtrl) { var kZ = new jo(2, 2); if (b5()) { kZ.width = 72; kZ.height = 0 } var kU = new gn({ offset: kZ, printable: true }); kR.cpyCtrl = kU } var k8 = kR.cityName || "中国"; var kS = kR.getMapType(); var kT = ["常州市", "南昌市", "乌鲁木齐市", "无锡市", "福州市", "泉州市", "珠海市", "贵阳市"]; var kL = ["北京市", "上海市", "广州市", "深圳市", "宁波市", "石家庄市", "沈阳市", "长春市", "青岛市", "温州市", "台州市", "金华市", "佛山市", "中山市", "昆明市", "南宁市", "苏州市", "西安市", "济南市", "郑州市", "合肥市", "呼和浩特市", "杭州市", "成都市", "武汉市", "长沙市", "天津市", "南京市", "重庆市", "大连市", "东莞市", "厦门市"]; var kN = ["香港特别行政区"]; var kH = ["台湾省"]; var k0 = ["日本"]; var k6 = ["韩国"]; var kV = ["泰国"]; var kY = ["亚太"]; var kI = ["新加坡"]; var k7 = ["欧洲"]; var kC = ["南美洲"]; var k3 = ["北美洲"]; var T = ["美国"]; var kX = ["墨西哥"]; var kF = ["加拿大"]; for (var k4 in kT) { if (kT[k4] === k8) { var kO = true; break } } for (var k4 in kL) { if (kL[k4] === k8) { var kD = true; break } } for (var k4 in kN) { if (kN[k4] === k8) { var la = true; break } } if (kH[0] === k8) { var k2 = true } if (kI[0] === k8) { var i = true } if (k0[0] === k8) { var kK = true } if (k6[0] === k8) { var kQ = true } if (kV[0] === k8) { var kP = true } if (kY[0] === k8) { var kG = true } if (k7[0] === k8) { var kM = true } if (kC[0] === k8) { var kJ = true } if (k3[0] === k8) { var e = true } if (T[0] === k8) { var k5 = true } if (kF[0] === k8) { var k1 = true } if (kX[0] === k8) { var kE = true } var k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "]; var kW = "rgba(255, 255, 255, 0.701961)"; if (kR.getZoom() <= 9) { k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "] } else { if (k2) { k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "] } else { if (kK || kQ) { k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "] } else { if (i || kP) { k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "] } else { if (kG) { k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "] } else { if (kM) { k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "] } else { if (kJ) { k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "] } else { if (e) { k9 = ["&copy;&nbsp;2025 Baidu - GS(2023)3206号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "] } } } } } } } } if (kR.getZoom() <= 9) { k9.push("百度智图"); k9.push(' &amp; <a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>'); k9.push(' &amp; <a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>'); if (kS === BMAP_SATELLITE_MAP || kS === BMAP_HYBRID_MAP) { k9.push(' &amp; <a target="_blank" href="http://www.eso.org/public/">ESO</a>'); kW = "rgba(0,0,0,.7)" } } else { if (kK || kQ) { k9.push('<a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>') } else { if (i || kP) { k9.push('<a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>') } else { if (kG) { k9.push('<a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>'); k9.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>') } else { if (kM) { k9.push('<a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>'); k9.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>') } else { if (kJ) { k9.push('<a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>'); k9.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>') } else { if (k5 || kE || k1) { k9.push('<a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>'); k9.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>') } else { if (e) { k9.push('<a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>'); k9.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>') } else { k9.push("百度智图"); if (kO) { k9.push(' &amp; <a target="_blank" href="http://www.palmcity.cn/palmcity/">PalmCity</a>') } if (la) { k9.push(' &amp; <a target="_blank" href="http://www.mapking.com/HongKong/eng/home/MapKing_Webmap.html">MapKing</a>') } if (k2) { k9.push(' &amp; <a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>'); k9.push(' &amp; <a target="_blank" href="http://www.localking.com.tw/about/localking.aspx">樂客LocalKing</a>') } if (kS === BMAP_SATELLITE_MAP || kS === BMAP_HYBRID_MAP) { kW = "rgba(0,0,0,.7)" } } } } } } } } } k9.unshift('<span style="background: ' + kW + ';padding: 0px 1px;line-height: 16px;display: inline;height: 16px;">'); k9.push("</span>"); k9 = k9.join(""); kR.cpyCtrl.addCopyright({ id: 1, content: k9 }) } function kj(e) { this["defaultAnchor"] = BMAP_ANCHOR_TOP_RIGHT; this["defaultOffset"] = e.defaultOffset || new jo(90, 6); this._cZIndex = 9999; this._visible = false } kj.prototype = new gZ(); kj.prototype.initialize = function (kD) { this._map = kD; var kC = this; var e = b6("div"); var i = e.style; i.left = i.top = "50%"; i.display = "none"; i.padding = "24px"; i.overflow = "visible"; i.position = "absolute"; i.width = "50%"; i.maxWidth = "360px"; i.transform = "translate(-50% , -50%)"; i.zIndex = "9999"; i.background = "#fff"; i.userSelect = "none"; var kE = b6("span", { style: "margin-top: 12px;\n    margin-bottom: -12px;\n    margin-left: calc(100% - 48px);\n    width: 56px;\n    height: 32px;\n    font-size: 14px;\n    text-align: center;\n    line-height: 32px;\n    display: block;\n    cursor: pointer;\n    background: #3894FF;\n    border: solid 1px #3f51b53b;\n    color: #fff;\n    border-radius: 3px;" }); kE.innerText = "确定"; kE.addEventListener("click", function () { kC.hide() }); var T = b6("div"); var kF = T.style; kF.position = "relative"; kF.width = "100%"; kF.height = "100%"; kF.color = "#000"; kF.fontSize = "14px"; kF.wordBreak = "break-all"; e.appendChild(T); e.appendChild(kE); kD.getContainer().appendChild(e); return e }; kj.prototype._setPosition = function () { }; kj.prototype.update = function (e) { if (!this.isVisible()) { this._container.firstChild.innerText = e; this.show() } }; window.BMAP_STATUS_SUCCESS = 0; window.BMAP_STATUS_CITY_LIST = 1; window.BMAP_STATUS_UNKNOWN_LOCATION = 2; window.BMAP_STATUS_UNKNOWN_ROUTE = 3; window.BMAP_STATUS_INVALID_KEY = 4; window.BMAP_STATUS_INVALID_REQUEST = 5; window.BMAP_STATUS_PERMISSION_DENIED = 6; window.BMAP_STATUS_SERVICE_UNAVAILABLE = 7; window.BMAP_STATUS_TIMEOUT = 8; window.BMAP_ROUTE_TYPE_WALKING = 2; window.BMAP_ROUTE_TYPE_DRIVING = 3; window.BMAP_ROUTE_TYPE_RIDING = 6; window.BMAP_ROUTE_STATUS_NORMAL = 0; window.BMAP_ROUTE_STATUS_EMPTY = 1; window.BMAP_ROUTE_STATUS_ADDRESS = 2; var D = "carport_list"; var d4 = "carport_auth"; var dn = "cur"; var ac = "cen"; var L = "s"; var dG = "con"; var dy = "bd"; var c0 = "nb"; var hi = "bt"; var aR = "nav"; var iv = "walk"; var f5 = "gc"; var d7 = "rgc"; var N = "dec"; var iM = "iploc"; var g0 = "bse"; var gv = "nse"; var dk = "s"; var ez = "bsl"; var f2 = "bda"; var ew = "sa"; var be = "nba"; var iC = "drag"; var jp = "ext"; var j4 = "exts"; var j7 = "hip"; var hU = "ride"; var ki = "drct"; var ca = "ldt"; var fB = 2; var bn = 4; var gd = 7; var iD = 11; var ch = 12; var e4 = 14; var cX = 15; var en = 18; var aD = 20; var bd = 21; var K = 19; var a = 23; var iZ = 26; var aF = 28; var gw = 31; var fg = 35; var iN = 44; var bl = 45; var aA = 46; var j2 = 47; var gB = -1; var bh = 0; var bF = 1; var jv = 2; var dW = 3; window.BMAP_POI_TYPE_NORMAL = 0; var cK = 1; var iF = 2; BMapGL.I = e9.I; var bP = {}; bP.removeHtml = function (e) { e = e.replace(/<\/?[^>]*>/g, ""); e = e.replace(/[ | ]* /g, " "); return e }; bP.parseGeoExtReg1 = function (e) { return e.replace(/([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0|[1-9]\d*),([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0|[1-9]\d*)(,)/g, "$1,$2;") }; bP.parseGeoExtReg2 = function (i, e) { var T = new RegExp("(((-?\\d+)(\\.\\d+)?),((-?\\d+)(\\.\\d+)?);)(((-?\\d+)(\\.\\d+)?),((-?\\d+)(\\.\\d+)?);){" + e + "}", "ig"); return i.replace(T, "$1") }; var dO = 0; var dm = 1; var W = 2; bP.unique = function (T) { var kE = false; var kD = []; var kF = {}; for (var kC = 0, e = T.length; kC < e; kC++) { if (!kF[T[kC]]) { kF[T[kC]] = true; kD.push(T[kC]) } } return kD }; bP.getBestLevel = function (T, i) { if (i) { var e = Math.min(i.width / 1100, i.height / 660); T = Math.round(T + (Math.log(e) / Math.log(2))) } if (T < 1) { T = 1 } if (T > 21) { T = 21 } return T }; bP.parseGeo = function (kF, kI) { if (typeof kF != "string" || !kF) { return } var kK = kF.split("|"); var e; var kD; var T; if (kK.length == 1) { e = cb(kF) } else { e = cb(kK[2]); kD = cb(kK[0]); T = cb(kK[1]); if (!kI) { return e } } var kG = { type: e.geoType }; if (kI) { switch (kG.type) { case W: var kH = new cG(e.geo[0][0], e.geo[0][1]); var kJ = jy.convertMC2LL(kH); kG.point = kJ; kG.points = [kJ]; break; case dm: kG.points = []; var kL = e.geo[0]; for (var kE = 0, kC = kL.length - 1; kE < kC; kE += 2) { var kM = new cG(kL[kE], kL[kE + 1]); kM = jy.convertMC2LL(kM); kG.points.push(kM) } kD = new cG(kD.geo[0][0], kD.geo[0][1]); T = new cG(T.geo[0][0], T.geo[0][1]); kD = jy.convertMC2LL(kD); T = jy.convertMC2LL(T); kG.bounds = new ik(kD, T); break; default: break } } return kG }; bP.parseGeoExt = function (kV, kM) { if (!kM) { kM = 0 } else { if (kM < 0.25) { kM = 0 } else { if (kM > 0.25 && kM < 1) { kM = 1 } else { if (kM > 32) { kM = 32 } } } } var kH = kV.split("|"); if (kH.length == 1) { var kC = cb(kH[0]); return { type: kC.type, bound: "", points: kC.geo.join(",") } } else { if (kH.length > 1) { var kN = kV.split(";.="); var kJ = []; var kD = []; var kO = 0; var kS = kN.length; for (var kP = 0; kP < kS; kP++) { var kU = kN[kP]; if (kS > 1) { if (kP == 0) { kU = kU + ";" } if (kP > 0 && kP < kS - 1) { kU = ".=" + kU + ";" } if (kP == kS - 1) { kU = ".=" + kU } } var kE = kU.split("|"); var kR = cb(kE[0]); var kQ = cb(kE[1]); kJ.push(kR.geo.join(",")); kJ.push(kQ.geo.join(",")); var kC = cb(kE[2]); kO = kC.type; var kT = kC.geo.join(","); kT = bP.parseGeoExtReg1(kT); if (kM > 0) { kT = bP.parseGeoExtReg2(kT, kM) } kD.push(kT) } if (kS <= 1) { kD = kD.join(";") } if (kS == 2) { var T = kD[0] + ";" + kD[1]; var kF = T.split(";"); var e = []; for (var kP = 0; kP < kF.length; kP++) { var kI = kF[kP].split(",")[0]; var kG = kF[kP].split(",")[1]; var kK = new cG(kI, kG); var kL = jy.convertMC2LL(kK); e.push(kL) } kD = e } return { type: kO, bound: kJ.join(";"), points: kD } } } }; bP.getPoiPoint = function (e) { var T = []; var i = null; if (e.toString() == "Point") { i = e } else { if (typeof e == "string") { T = e9.trim(e).split(","); if (T.length < 2) { return } T[0] = parseFloat(e9.trim(T[0])); T[1] = parseFloat(e9.trim(T[1])) } else { T = e.slice(0); if (T.length < 2) { return } } i = new BMap.Point(T[0], T[1]) } return i }; bP.parseGeoStr = function (T) { var i = T.split(","); var e = new cG(i[0], i[1]); return jy.convertMC2LL(e) }; bP.level = { country: 4, province: 11, city: 12, area: 13 }; var hw = ["=", ".", "-", "*"]; var di = 1 << 23; function cb(kI) { var kH = ig(kI.charAt(0)); var T = kI.substr(1); var kK = 0; var e = T.length; var kL = []; var kF = []; var kG = []; while (kK < e) { if (T.charAt(kK) == hw[0]) { if ((e - kK) < 13) { return 0 } kG = em(T.substr(kK, 13), kL); if (kG < 0) { return 0 } kK += 13 } else { if (T.charAt(kK) == ";") { kF.push(kL.slice(0)); kL.length = 0; ++kK } else { if ((e - kK) < 8) { return 0 } kG = cn(T.substr(kK, 8), kL); if (kG < 0) { return 0 } kK += 8 } } } for (var kE = 0, kC = kF.length; kE < kC; kE++) { for (var kD = 0, kJ = kF[kE].length; kD < kJ; kD++) { kF[kE][kD] /= 100 } } return { geoType: kH, geo: kF } } function ig(i) { var e = -1; if (i == hw[1]) { e = W } else { if (i == hw[2]) { e = dm } else { if (i == hw[3]) { e = dO } } } return e } function em(kD, T) { var e = 0; var kF = 0; var kE = 0; for (var kC = 0; kC < 6; kC++) { kE = dF(kD.substr(1 + kC, 1)); if (kE < 0) { return -1 - kC } e += kE << (6 * kC); kE = dF(kD.substr(7 + kC, 1)); if (kE < 0) { return -7 - kC } kF += kE << (6 * kC) } T.push(e); T.push(kF); return 0 } function cn(kE, kC) { var T = kC.length; if (T < 2) { return -1 } var e = 0; var kG = 0; var kF = 0; for (var kD = 0; kD < 4; kD++) { kF = dF(kE.substr(kD, 1)); if (kF < 0) { return -1 - kD } e += kF << (6 * kD); kF = dF(kE.substr(4 + kD, 1)); if (kF < 0) { return -5 - kD } kG += kF << (6 * kD) } if (e > di) { e = di - e } if (kG > di) { kG = di - kG } kC.push(kC[T - 2] + e); kC.push(kC[T - 1] + kG); return 0 } function dF(i) { var e = i.charCodeAt(0); if (i >= "A" && i <= "Z") { return e - "A".charCodeAt(0) } else { if (i >= "a" && i <= "z") { return (26 + e - "a".charCodeAt(0)) } else { if (i >= "0" && i <= "9") { return (52 + e - "0".charCodeAt(0)) } else { if (i == "+") { return 62 } else { if (i == "/") { return 63 } } } } } return -1 } bP.pathToPoints = function (kE) { var kC = []; if (typeof kE !== "string") { return kC } else { var kD = kE.split(";"); for (var T = 0; T < kD.length; T++) { var e = kD[T].split(","); kC.push(new cG(e[0], e[1])) } } return kC }; bP.pointsToString = function (kD) { var kC = ""; if (typeof kD !== "object") { return kD } else { for (var T = 0; T < kD.length; T++) { var e = kD[T].lat + "," + kD[T].lng; if (T !== kD.length - 1) { kC = kC + e + "|" } else { kC = kC + e } } } return kC }; bP.stringToPoints = function (kE) { var kC = []; if (typeof kE !== "string" || !kE) { return kC } else { var kD = kE.split("|"); for (var T = 0; T < kD.length; T++) { var e = kD[T].split(","); kC.push(new cG(e[1], e[0])) } } return kC }; window.BMAP_POI_TYPE_NORMAL = 0; window.BMAP_POI_TYPE_BUSSTOP = 1; window.BMAP_POI_TYPE_BUSLINE = 2; window.BMAP_POI_TYPE_SUBSTOP = 3; window.BMAP_POI_TYPE_SUBLINE = 4; var U = 0; var hZ = 1; var fQ = {}; window.APIPack = fQ; function aK(i, e) { dh.call(this); this._loc = {}; this.setLocation(i); e = e || {}; e.renderOptions = e.renderOptions || {}; this._opts = { renderOptions: { panel: e.renderOptions.panel || null, map: e.renderOptions.map || null, autoViewport: e.renderOptions.autoViewport || true, selectFirstResult: e.renderOptions.selectFirstResult, highlightMode: e.renderOptions.highlightMode, enableDragging: e.renderOptions.enableDragging || false, lineLayerStyle: e.renderOptions.lineLayerStyle || {}, isTop: e.renderOptions.isTop || false, }, onSearchComplete: e.onSearchComplete || function () { }, onMarkersSet: e.onMarkersSet || function () { }, onInfoHtmlSet: e.onInfoHtmlSet || function () { }, onResultsHtmlSet: e.onResultsHtmlSet || function () { }, onGetBusListComplete: e.onGetBusListComplete || function () { }, onGetBusLineComplete: e.onGetBusLineComplete || function () { }, onBusListHtmlSet: e.onBusListHtmlSet || function () { }, onBusLineHtmlSet: e.onBusLineHtmlSet || function () { }, onPolylinesSet: e.onPolylinesSet || function () { }, reqFrom: e.reqFrom || "" }; if (typeof e != "undefined" && typeof e.renderOptions != "undefined" && typeof e.renderOptions["autoViewport"] != "undefined") { this._opts.renderOptions.autoViewport = e.renderOptions["autoViewport"] } else { this._opts.renderOptions.autoViewport = true } this._opts.renderOptions.panel = e9.G(this._opts.renderOptions.panel) } aK.inherits(dh, "BaseSearch"); e9.extend(aK.prototype, { getResults: function () { if (!this._isMultiKey) { return this._results } else { return this._arrResults } }, enableAutoViewport: function () { this._opts.renderOptions.autoViewport = true }, disableAutoViewport: function () { this._opts.renderOptions.autoViewport = false }, setLocation: function (e) { if (!e) { return } this._loc.src = e }, setSearchCompleteCallback: function (e) { this._opts.onSearchComplete = e || function () { } }, setMarkersSetCallback: function (e) { this._opts.onMarkersSet = e || function () { } }, setPolylinesSetCallback: function (e) { this._opts.onPolylinesSet = e || function () { } }, setInfoHtmlSetCallback: function (e) { this._opts.onInfoHtmlSet = e || function () { } }, setResultsHtmlSetCallback: function (e) { this._opts.onResultsHtmlSet = e || function () { } }, getStatus: function () { return this._status } }); var cJ = function (kC, i) { aK.call(this, kC, i); i = i || {}; i.renderOptions = i.renderOptions || {}; this.setPageCapacity(i.pageCapacity); if (typeof i.renderOptions["selectFirstResult"] != "undefined" && !i.renderOptions["selectFirstResult"]) { this.disableFirstResultSelection() } else { this.enableFirstResultSelection() } this._overlays = []; this._arrPois = []; this._curIndex = -1; this._queryList = []; var e = this; hm.load("localSearch", function () { e._check() }, true); if (i.renderOptions["map"]) { var T = i.renderOptions["map"]; T.on("destroy", function () { delete e }) } }; cJ.inherits(aK, "LocalSearch"); cJ.DEFAULT_PAGE_CAPACITY = 10; cJ.MIN_PAGE_CAPACITY = 1; cJ.MAX_PAGE_CAPACITY = 100; cJ.DEFAULT_RADIUS = 2000; cJ.MAX_RADIUS = 100000; e9.extend(cJ.prototype, { search: function (e, i) { this._queryList.push({ method: "search", arguments: [e, i] }); hQ.sendMessage(a1(4, 4, 6, 1), ["service", "poi", "normal"]) }, searchInBounds: function (e, T, i) { this._queryList.push({ method: "searchInBounds", arguments: [e, T, i] }); hQ.sendMessage(a1(4, 4, 6, 2), ["service", "poi", "bound"]) }, searchNearby: function (T, i, e, kC) { this._queryList.push({ method: "searchNearby", arguments: [T, i, e, kC] }); hQ.sendMessage(a1(4, 4, 6, 3), ["service", "poi", "circle"]) }, clearResults: function () { delete this._json; delete this._status; delete this._results; delete this._ud; this._curIndex = -1; this._setStatus(); if (this._opts.renderOptions.panel) { this._opts.renderOptions.panel.innerHTML = "" } }, gotoPage: function () { }, enableFirstResultSelection: function () { this._opts.renderOptions.selectFirstResult = true }, disableFirstResultSelection: function () { this._opts.renderOptions.selectFirstResult = false }, setPageCapacity: function (e) { if (typeof e == "number" && !isNaN(e)) { this._opts.pageCapacity = e < 1 ? cJ.DEFAULT_PAGE_CAPACITY : (e > cJ.MAX_PAGE_CAPACITY ? cJ.DEFAULT_PAGE_CAPACITY : e) } else { this._opts.pageCapacity = cJ.DEFAULT_PAGE_CAPACITY } }, getPageCapacity: function () { return this._opts.pageCapacity }, toString: function () { return "LocalSearch" } }); function bo(i) { this._opts = {}; e9.extend(this._opts, i); this._queryList = []; var e = this; hm.load("otherSearch", function () { e._asyncSearch() }) } bo.inherits(dh, "Geocoder"); e9.extend(bo.prototype, { getPoint: function (e, T, i) { this._queryList.push({ method: "getPoint", arguments: [e, T, i] }) }, getLocation: function (e, T, i) { this._queryList.push({ method: "getLocation", arguments: [e, T, i] }) }, toString: function () { return "Geocoder" } }); function c5(e) { e = e || {}; this.config = { timeout: e.timeout || 1000 * 10, maximumAge: e.maximumAge || 0, enableHighAccuracy: e.enableHighAccuracy === undefined ? true : e.enableHighAccuracy, SDKLocation: e.SDKLocation || false }; this._pendingCalls = []; var i = this; hm.load("otherSearch", function () { var T = i._pendingCalls.length; for (var kC = 0; kC < T; kC++) { var kD = i._pendingCalls[kC]; i[kD.method].apply(i, kD.arguments) } }) } e9.extend(c5.prototype, { getCurrentPosition: function (e, i) { this._pendingCalls.push({ method: "getCurrentPosition", arguments: arguments }) }, getStatus: function () { return BMAP_STATUS_UNKNOWN_LOCATION }, enableSDKLocation: function () { if (b5()) { this.config.SDKLocation = true } }, disableSDKLocation: function () { this.config.SDKLocation = false } }); function fx() { this._queryList = []; var e = this; hm.load("otherSearch", function () { e._asyncSearch() }) } fx.inherits(dh, "Boundary"); e9.extend(fx.prototype, { get: function (i, e) { this._queryList.push({ method: "get", arguments: [i, e] }) }, toString: function () { return "Boundary" }, parsebdStr: function (i, e) { this._queryList.push({ method: "parsebdStr", arguments: [i, e] }) } }); function fq(i) { i = i || {}; i.renderOptions = i.renderOptions || {}; this._opts = { renderOptions: { map: i.renderOptions.map || null } }; this._queryList = []; var e = this; hm.load("otherSearch", function () { e._asyncSearch() }) } fq.inherits(dh, "LocalCity"); e9.extend(fq.prototype, { get: function (e) { this._queryList.push({ method: "get", arguments: [e] }) }, toString: function () { return "LocalCity" } }); function hz(e, T) { dh.call(this); this.markersList = []; this.destList = []; this.pointsList = []; this._opts = T; this.json = e; this.map = this._opts.renderOptions.map || null; this.sType = this._opts.sType; this.infoWindow = null; this.curPointIndex = 0; this.startName = ""; this.endIndex = 1; this.endName = ""; this.resCity = [0, 0, 0, 0, 0, 0, 0]; this.locPois = []; this.curPageIndex = [1, 1, 1, 1, 1, 1, 1]; this.totalPage = [1, 1, 1, 1, 1, 1, 1]; this.resCount = [0, 0, 0, 0, 0, 0, 0]; this.resType = [0, 0, 0, 0, 0, 0, 0]; this.qInfo = [{ n: "", c: 0, u: 0, x: 0, y: 0, t: -1 }, { n: "", c: 0, u: 0, x: 0, y: 0, t: -1 }, { n: "", c: 0, u: 0, x: 0, y: 0, t: -1 }, { n: "", c: 0, u: 0, x: 0, y: 0, t: -1 }, { n: "", c: 0, u: 0, x: 0, y: 0, t: -1 }, { n: "", c: 0, u: 0, x: 0, y: 0, t: -1 }, { n: "", c: 0, u: 0, x: 0, y: 0, t: -1 }]; this.curSelectedIndex = -1; this.tpList = []; this.tpListInMap = []; var i = this; hm.load("route", function () { }) } hz.inherits(dh, "RouteAddr"); function eJ(T, i) { aK.call(this, T, i); this.QUERY_TYPE_BUSLIST = dk; this.RETURN_TYPE_BUSLIST = cX; this.QUERY_TYPE_BUSLINE = ez; this.RETURN_TYPE_BUSLINE = en; this._queryList = []; var e = this; hm.load("buslineSearch", function () { e._asyncSearch() }) } var fO = E.staticHost + "/wolfman/static/common/images/"; eJ._iconOpen = E.apiIMG + "/iw_plus.gif"; eJ._iconClose = E.apiIMG + "/iw_minus.gif"; eJ._stopUrl = fO + "new/bus-stop-1x_ddd4723.png"; eJ.inherits(aK, "BusLineSearch"); e9.extend(eJ.prototype, { getBusList: function (e) { this._queryList.push({ method: "getBusList", arguments: [e] }) }, getBusLine: function (e) { this._queryList.push({ method: "getBusLine", arguments: [e] }) }, setGetBusListCompleteCallback: function (e) { this._opts.onGetBusListComplete = e || function () { } }, setGetBusLineCompleteCallback: function (e) { this._opts.onGetBusLineComplete = e || function () { } }, setBusListHtmlSetCallback: function (e) { this._opts.onBusListHtmlSet = e || function () { } }, setBusLineHtmlSetCallback: function (e) { this._opts.onBusLineHtmlSet = e || function () { } }, setPolylinesSetCallback: function (e) { this._opts.onPolylinesSet = e || function () { } } }); function jq(i) { aK.call(this, i); i = i || {}; this._options = { input: i.input || null, showSuggestion: i.showSuggestion === undefined ? true : i.showSuggestion, baseDom: i.baseDom || null, types: i.types || [], onSearchComplete: i.onSearchComplete || function () { } }; this._loc.src = i.location || "全国"; this._word = ""; this._show = false; this._suggestion = null; this._inputValue = ""; this._initialize(); var e = this; hm.load("autocomplete", function () { e._asyncSearch() }, true) } jq.inherits(aK, "Autocomplete"); e9.extend(jq.prototype, { _initialize: function () { }, show: function () { this._show = true }, hide: function () { this._show = false }, setTypes: function (e) { this._options.types = e }, setLocation: function (e) { this._loc.src = e }, search: function (e) { this._word = e }, setInputValue: function (e) { this._inputValue = e }, setSearchCompleteCallback: function (e) { this._options.onSearchComplete = e } }); var j9 = function (i, e) { aK.call(this, i, e) }; e9.inherit(j9, aK, "BaseRoute"); e9.extend(j9.prototype, { clearResults: function () { } }); window.BMAP_TRANSIT_POLICY_RECOMMEND = 0; window.BMAP_TRANSIT_POLICY_LEAST_TIME = 4; window.BMAP_TRANSIT_POLICY_LEAST_TRANSFER = 1; window.BMAP_TRANSIT_POLICY_LEAST_WALKING = 2; window.BMAP_TRANSIT_POLICY_AVOID_SUBWAYS = 3; window.BMAP_TRANSIT_POLICY_FIRST_SUBWAYS = 5; window.BMAP_LINE_TYPE_BUS = 0; window.BMAP_LINE_TYPE_SUBWAY = 1; window.BMAP_LINE_TYPE_FERRY = 2; window.BMAP_LINE_TYPE_TRAIN = 3; window.BMAP_LINE_TYPE_AIRPLANE = 4; window.BMAP_LINE_TYPE_COACH = 5; var iG = 3; var el = 4; var aj = 1; var iE = 2; var a0 = 5; var cZ = 6; window.BMAP_TRANSIT_TYPE_IN_CITY = 0; window.BMAP_TRANSIT_TYPE_CROSS_CITY = 1; window.BMAP_TRANSIT_PLAN_TYPE_ROUTE = 0; window.BMAP_TRANSIT_PLAN_TYPE_LINE = 1; window.BMAP_TRANSIT_TYPE_POLICY_TRAIN = 0; window.BMAP_TRANSIT_TYPE_POLICY_AIRPLANE = 1; window.BMAP_TRANSIT_TYPE_POLICY_COACH = 2; window.BMAP_INTERCITY_POLICY_LEAST_TIME = 0; window.BMAP_INTERCITY_POLICY_EARLY_START = 1; window.BMAP_INTERCITY_POLICY_CHEAP_PRICE = 2; function eY(T, i) { j9.call(this, T, i); i = i || {}; this.setPolicy(i.policy); this.setIntercityPolicy(i.intercityPolicy); this.setTransitTypePolicy(i.transitTypePolicy); this.setPageCapacity(i.pageCapacity); this.QUERY_TYPE = hi; this.RETURN_TYPE = e4; this.ROUTE_TYPE = hZ; this._overlays = []; this._curIndex = -1; this._opts._enableTraffic = i.enableTraffic || false; this._queryList = []; var e = this; hm.load("route", function () { e._asyncSearch() }, true) } eY.MAX_PAGE_CAPACITY = 100; eY.LINE_TYPE_MAPPING = [0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1]; eY.LINE_TYPE_MAPPING_CROSS_CITY = [0, 3, 4, 0, 0, 0, 5]; e9.inherit(eY, j9, "TransitRoute"); e9.extend(eY.prototype, { setPolicy: function (e) { if (e >= BMAP_TRANSIT_POLICY_RECOMMEND && e <= BMAP_TRANSIT_POLICY_FIRST_SUBWAYS) { this._opts.policy = e } else { this._opts.policy = BMAP_TRANSIT_POLICY_RECOMMEND } }, setIntercityPolicy: function (e) { if (e >= BMAP_INTERCITY_POLICY_LEAST_TIME && e <= BMAP_INTERCITY_POLICY_CHEAP_PRICE) { this._opts.intercityPolicy = e } else { this._opts.intercityPolicy = BMAP_INTERCITY_POLICY_LEAST_TIME } }, setTransitTypePolicy: function (e) { if (e >= BMAP_TRANSIT_TYPE_POLICY_TRAIN && e <= BMAP_TRANSIT_TYPE_POLICY_COACH) { this._opts.transitTypePolicy = e } else { this._opts.transitTypePolicy = BMAP_TRANSIT_TYPE_POLICY_TRAIN } }, _internalSearch: function (i, e) { this._queryList.push({ method: "_internalSearch", arguments: [i, e] }) }, search: function (i, e) { this._queryList.push({ method: "search", arguments: [i, e] }) }, setPageCapacity: function (e) { if (typeof e === "string") { e = parseInt(e, 10); if (isNaN(e)) { this._opts.pageCapacity = eY.MAX_PAGE_CAPACITY; return } } if (typeof e !== "number") { this._opts.pageCapacity = eY.MAX_PAGE_CAPACITY; return } if (e >= 1 && e <= eY.MAX_PAGE_CAPACITY) { this._opts.pageCapacity = Math.round(e) } else { this._opts.pageCapacity = eY.MAX_PAGE_CAPACITY } }, toString: function () { return "TransitRoute" }, _shortTitle: function (e) { return e.replace(/\(.*\)/, "") } }); window.BMAP_HIGHLIGHT_STEP = 1; window.BMAP_HIGHLIGHT_ROUTE = 2; var cO = function (e, kC) { j9.call(this, e, kC); this._overlays = []; this._curIndex = -1; this._queryList = []; var T = this; var i = this._opts.renderOptions; if (i.highlightMode !== BMAP_HIGHLIGHT_STEP && i.highlightMode !== BMAP_HIGHLIGHT_ROUTE) { i.highlightMode = BMAP_HIGHLIGHT_STEP } this._enableDragging = this._opts.renderOptions.enableDragging ? true : false; hm.load("route", function () { T._asyncSearch() }, true); if (this.init_d) { this.init_d() } }; cO.ROAD_TYPE = ["", "环岛", "无属性道路", "主路", "高速连接路", "交叉点内路段", "连接道路", "停车场内部道路", "服务区内部道路", "桥", "步行街", "辅路", "匝道", "全封闭道路", "未定义交通区域", "POI连接路", "隧道", "步行道", "公交专用道", "提前右转道"]; e9.inherit(cO, j9, "DWRoute"); e9.extend(cO.prototype, { search: function (T, e, i) { this._queryList.push({ method: "search", arguments: [T, e, i] }) } }); var i7 = function (e, T) { j9.call(this, e, T); this._overlays = []; this._queryList = []; var i = this; this.map = T.renderOptions.map; this._enableDragging = this._opts.renderOptions.enableDragging ? true : false; this._lineLayerStyle = { lineLayerColor: this._opts.renderOptions.lineLayerStyle.lineLayerColor || { color: "#0089ff", opacity: 1 }, isTop: this._opts.renderOptions.isTop || false, showTraffic: this._opts.renderOptions.lineLayerStyle.showTraffic || false, sequence: this._opts.renderOptions.sequence || true, marginLength: this._opts.renderOptions.marginLength || 32, borderColor: this._opts.renderOptions.lineLayerStyle.borderColor || "#0089ff", borderMask: this._opts.renderOptions.lineLayerStyle.borderMask || false, borderWeight: this._opts.renderOptions.lineLayerStyle.borderWeight || 2, strokeWeight: this._opts.renderOptions.lineLayerStyle.strokeWeight || 6, strokeLineJoin: this._opts.renderOptions.lineLayerStyle.strokeLineJoin || "round", strokeLineCap: this._opts.renderOptions.lineLayerStyle.strokeLineCap || "round", strokeTextureUrl: E.bosPath + "up-to.png", strokeTextureWidth: this._opts.renderOptions.lineLayerStyle.strokeTextureWidth || 32, strokeTextureHeight: this._opts.renderOptions.lineLayerStyle.strokeTextureHeight || 64, }; if (this._opts.renderOptions.lineLayerStyle.strokeTextureUrl) { this._lineLayerStyle.strokeTextureUrl = this._opts.renderOptions.lineLayerStyle.strokeTextureUrl } else { if (this._opts.renderOptions.lineLayerStyle.strokeTextureUrl === null) { delete this._lineLayerStyle.strokeTextureUrl } } this._menu = new BMapGL.ContextMenu(); this._menu.addItem(new ii("删除该点", function (kE, kD, kC) { i._deleteVia(kC.curNo - 1) }, 60)); this.map.addContextMenu(this._menu, true); hm.load("route", function () { i._asyncSearch() }, true); if (this.init_d) { this.init_d() } }; e9.inherit(i7, j9, "LineLayerRoute"); e9.extend(i7.prototype, { search: function (T, e, i) { this._queryList.push({ method: "search", arguments: [T, e, i] }) } }); window.BMAP_DRIVING_POLICY_DEFAULT = 0; window.BMAP_DRIVING_POLICY_DESTANCE = 2; window.BMAP_DRIVING_POLICY_AVOID_HIGHWAYS = 3; window.BMAP_DRIVING_POLICY_FIRST_HIGHWAYS = 4; window.BMAP_DRIVING_POLICY_AVOID_CONGESTION = 5; window.BMAP_DRIVING_POLICY_AVOID_PAY = 6; window.BMAP_DRIVING_POLICY_HIGHWAYS_AVOID_CONGESTION = 7; window.BMAP_DRIVING_POLICY_AVOID_HIGHWAYS_CONGESTION = 8; window.BMAP_DRIVING_POLICY_AVOID_CONGESTION_PAY = 9; window.BMAP_DRIVING_POLICY_AVOID_HIGHWAYS_CONGESTION_PAY = 10; window.BMAP_DRIVING_POLICY_AVOID_HIGHWAYS_PAY = 11; window.BMAP_TRAFFICE_STATUS_NONE = 0; window.BMAP_TRAFFICE_STATUS_NORMAL = 1; window.BMAP_TRAFFICE_STATUS_SLOW = 2; window.BMAP_TRAFFICE_STATUS_JAM = 3; function cz(e, i) { cO.call(this, e, i); i = i || {}; this._opts._enableTraffic = i.enableTraffic || false; this.setPolicy(i.policy); this.alternatives = i.alternatives || 0; this.QUERY_TYPE = aR; this.RETURN_TYPE = aD; this.ROUTE_TYPE = BMAP_ROUTE_TYPE_DRIVING; hQ.sendMessage(a1(4, 4, 1, 1), ["service", "drive", "overlay"]) } function gf(e, i) { i7.call(this, e, i); i = i || {}; this.setPolicy(i.policy); this.alternatives = i.alternatives || 0; this.QUERY_TYPE = aR; hQ.sendMessage(a1(4, 4, 1, 2), ["service", "drive", "layer"]) } e9.inherit(gf, i7, "DrivingRouteLine"); e9.inherit(cz, cO, "DrivingRoute"); cz.prototype.setPolicy = function (e) { if (e >= BMAP_DRIVING_POLICY_DEFAULT && e <= BMAP_DRIVING_POLICY_AVOID_HIGHWAYS_PAY) { this._opts.policy = e } else { this._opts.policy = BMAP_DRIVING_POLICY_DEFAULT } }; gf.prototype.setPolicy = function (e) { if (e >= BMAP_DRIVING_POLICY_DEFAULT && e <= BMAP_DRIVING_POLICY_AVOID_HIGHWAYS_PAY) { this._opts.policy = e } else { this._opts.policy = BMAP_DRIVING_POLICY_DEFAULT } }; function fC(e, i) { cO.call(this, e, i); this.QUERY_TYPE = iv; this.RETURN_TYPE = gw; this.ROUTE_TYPE = BMAP_ROUTE_TYPE_WALKING; this._enableDragging = false; hQ.sendMessage(a1(4, 4, 4), ["service", "walk"]) } e9.inherit(fC, cO, "WalkingRoute"); function dd(e, i) { cO.call(this, e, i); this.QUERY_TYPE = hU; this.ROUTE_TYPE = BMAP_ROUTE_TYPE_RIDING; this._enableDragging = false; hQ.sendMessage(a1(4, 4, 3), ["service", "ride"]) } e9.inherit(dd, cO, "RidingRoute"); function Z(e, i) { i7.call(this, e, i); i = i || {}; this.QUERY_TYPE = ca; this.setPolicy(i.policy); hQ.sendMessage(a1(4, 4, 2), ["service", "truck"]) } e9.inherit(Z, i7, "TruckRoute"); Z.prototype.setPolicy = function (e) { if (e >= BMAP_DRIVING_POLICY_DEFAULT && e <= BMAP_DRIVING_POLICY_AVOID_CONGESTION) { this._opts.policy = e } else { this._opts.policy = BMAP_DRIVING_POLICY_DEFAULT } }; window.BMAP_MODE_DRIVING = "driving"; window.BMAP_MODE_TRANSIT = "transit"; window.BMAP_MODE_WALKING = "walking"; window.BMAP_MODE_NAVIGATION = "navigation"; var a8 = { web: "//api.map.baidu.com/direction?", android: "bdapp://map/direction?", ios: "baidumap://map/direction?" }; function i4(e) { this.opts = e || {} } e9.extend(i4.prototype, { routeCall: function (kC, e, T) { var i = this; hm.load("route", function () { i._asyncSearch(kC, e, T) }) } }); function ej() { return Pano.getStreetViewCoverageLayer(bG) } function e0() { Pano.PanoramaService.call(this) } e9.inherit(e0, Pano.PanoramaService, "PanoramaService"); e9.extend(e0.prototype, { getPanoramaById: function (T, i) { var e = this; this.getPanoById(T, function (kC) { i && i(e._makeData(kC)) }) }, getPanoramaByLocation: function (e, T) { e = jy.convertLL2MC(e); var i = this; this.getPanoByLocation(e, 50, function (kC) { T && T(i._makeData(kC)) }) }, _makeData: function (T) { if (!T) { return null } var i = {}; var e = T.content[0]; i.description = e.Rname || e.Info || ""; i.id = e.ID; i.pointX = e.X / 100; i.pointY = e.Y / 100; i.position = jy.convertMC2LL(new cG(i.pointX, i.pointY)); return i } }); function fs() { if (window.PANORAMA_URL) { return Pano.getPanoControl(bG, { imgPath: E.imgPath, tileBaseUrl: E.panoTilePath, }) } return Pano.getPanoControl(bG) } function R(T, e) { if (!e) { return } this.content = T; if (e.position && !Array.isArray(e.position)) { e.position = jy.convertLL2MC(e.position); this.position = e.position; this.hideDistance = !!e.hideDistance } else { this.hideDistance = true } var i = this._createDom(); Pano.PanoOverlay.call(this, e.position, { dom: i, altitude: e.altitude, }) } e9.inherit(R, Pano.PanoOverlay, "PanoramaLabel"); e9.extend(R.prototype, { init: function (e) { var i = this; this._pano = e; this.updatedDistance(); Pano.PanoOverlay.prototype.init.call(this, e); this._pano.on("dataload", function (T) { i.updatedDistance() }) }, _createDom: function () { var kC = this.content; var kF = document.createElement("div"); var i = kF.style; i.position = "absolute"; i.backgroundColor = "rgba(29, 29, 29, 0.8)"; i.padding = "7px 0"; i.height = "19px"; i.font = "16px arial"; i.color = "white"; i.whiteSpace = "nowrap"; i.borderRadius = "4px"; var e = document.createElement("div"); e.style["float"] = "left"; e.style["lineHeight"] = "19px"; kF.appendChild(e); var T = document.createElement("span"); T.style.margin = "0 14px"; T.innerText = kC; e.appendChild(T); if (!this.hideDistance) { var kE = document.createElement("span"); kE.style.color = "color:rgba(255,255,255,0.3)"; kE.innerText = "|"; e.appendChild(kE); var kD = document.createElement("span"); kD.style.margin = "0 8px"; kD.style.color = "#60c7fa"; kD.style.fontSize = "12px"; kD.innerText = "0米"; e.appendChild(kD); this._distanceDom = kD } this._dom = kF; this._titleDom = T; return kF }, updatedDistance: function () { if (this.hideDistance) { return } var T = 0; if (this._pano) { var i = this._pano.position; var e = this.position; if (i && !i.equals(e)) { T = jy.getDistanceByMC(i, e) } } if (T > 100) { T = T / 1000; T = T < 100 ? T.toFixed(2) : T.toFixed(0); T += "公里" } else { T = T < 100 ? T.toFixed(2) : T.toFixed(0); T += "米" } this._distanceDom.innerText = T }, }); function f(i, kE) { if (typeof i === "string" && /^(?!#)(\w)*/.test(i)) { i = "#" + i } var kC = {}; if (window.PANORAMA_URL) { kC.imgPath = E.imgPath; kC.tileBaseUrls = [E.panoTilePath] } var e = Pano.init(i, kC); var T = e.setPosition; e.setPosition = function (kF) { var kG = jy.convertLL2MC(kF); T.call(e, kG) }; var kD = e.addEventListener; e.addEventListener = function (kF, kG) { if (kF === "position_changed") { kD.call(e, kF, function (kH) { var kI = jy.convertMC2LL(kH); kG(kI) }) } else { kD.call(e, kF, kG) } }; if (kE) { kE.on("destroy", function () { e.destroy() }) } hQ.sendMessage(a1(4, 3, 5), ["layer", "pano"]); return e } bG.MapConfig = E; bG.Map = h5; bG.MapType = ev; bG.Point = cG; bG.Pixel = fv; bG.Size = jo; bG.Bounds = ik; bG.PrivateRegionDataModel = cV; bG.TileLayer = hP; bG.Copyright = o; bG.Projection = bG.Project = jy; bG.XYZProjection = bG.XYZProject = dL; bG.Convertor = f7; bG.RenderTypeUtils = df; bG.Overlay = aU; bG.Label = ic; bG.Marker = u; bG.Symbol = ft; bG.SVGSymbol = dU; bG.Icon = jS; bG.Polyline = bu; bG.BezierCurve = cQ; bG.PolylineMultipart = ex; bG.Polygon = i3; bG.MapMask = ko; bG.Prism = bA; bG.Marker3D = eo; bG.GroundOverlay = ge; bG.GroundPoint = dZ; bG.CustomOverlay = bU; bG.CustomHtmlLayer = dH; bG.ParkingSpot = iH; bG.InfoWindow = ef; bG.SimpleInfoWindow = io; bG.Circle = aX; bG.Control = gZ; bG.NavigationControl = j6; bG.IndoorManager = dg; bG.NavigationControl3D = fb; bG.CopyrightControl = gn; bG.ScaleControl = kB; bG.CityListControl = bB; bG.MapTypeControl = A; bG.ZoomControl = jB; bG.LocationControl = gF; bG.LogoControl = bJ; bG.DistanceTool = co; bG.ContextMenu = hG; bG.MenuItem = ii; bG.OperationMask = am; bG.Animation = fL; bG.ViewAnimation = s; bG.Transitions = gS; bG.Event = fW; bG.trafficLayer = j3; bG.TrafficLayer = jF; bG.GeoJSONLayer = aQ; bG.XYZLayer = kp; bG.PixelLayer = dB; bG.GeoJSONParse = gO; bG.NormalLayer = cv; bG.ThreeLayer = g7; bG.LineLayer = b1; bG.FillLayer = ed; bG.PointShapeLayer = aZ; bG.PointIconLayer = gp; bG.Entity = jz; bG.MVTLayer = ek; bG.BaiduLayer = X; bG.Geolocation = c5; bG.Geocoder = bo; bG.Boundary = fx; bG.DistrictLayer = ea; bG.LocalCity = fq; bG.LocalSearch = cJ; bG.Autocomplete = jq; bG.BusLineSearch = eJ; bG.WalkingRoute = fC; bG.RidingRoute = dd; bG.DrivingRoute = cz; bG.DrivingRouteLine = gf; bG.TransitRoute = eY; bG.RouteSearch = i4; bG.TruckRoute = Z; bG.PanoramaCoverageLayer = ej; bG.PanoramaControl = fs; bG.PanoramaService = e0; bG.PanoramaLabel = R; bG.Panorama = f; function hx(e, i) { for (var T in i) { e[T] = i[T] } } bG.fetchDebug && bG.fetchDebug.init(); bG.verify(); bG.apiLoad(); bG.frequency(); bG.getSeckeyCid(); window._layer = 1; e9.extend(ea.prototype, { _asyncSearch: function () { for (var T = 0, e = this._queryList.length; T < e; T++) { var kC = this._queryList[T]; this[kC.method].apply(this, kC.arguments) } delete this._queryList }, addDistrict: function () { if (this._opts.districts) { var e = this._opts.districts; if (typeof e === "string") { this.getDistrictData(e) } else { if (Object.prototype.toString.call(e) === "[object Array]") { var i = this.parseArrayParams(e); this.getDistrictData(i) } } } }, parseArrayParams: function (e) { var kD = ""; for (var kC = 0; kC < e.length; kC++) { if (e[kC] instanceof Array) { kD += "("; for (var T = 0; T < e.length; T++) { kD += e[T] } kD += ")" } else { kD += "(" + e[kC] + ")" } } return kD }, getDistrictData: function (e) { var i = this; kl.request(function (kC) { var T = i._parseGeoData(kC); i._drawToMap(i, T) }, { qt: j4, adnames: e, level: i._opts.kind }) }, _drawToMap: function (kL, kH) { var kK = kH.boundaries.length; if (kK === 0) { alert("未能获取当前输入行政区域"); return } var kM = this._config.fillColor; var kE = this._config.fillOpacity; var T = this._config.strokeColor; var e = this._config.strokeOpacity; var kI = this._config.strokeWeight; if (typeof kM === "string") { var kC = kM; var kN = []; for (var kG = 0; kG < kK; kG++) { var kJ = new BMapGL.Polygon(kH.boundaries[kG], { strokeWeight: kI, strokeColor: T, strokeOpacity: e, fillColor: kC, fillOpacity: kE }); kJ.style = { strokeWeight: kI, strokecolor: T, strokeOpacity: e, fillColor: kC, fillOpacity: kE }; this.disOverlays.push(kJ); this.addEventListenerIn(); kL._map.addOverlay(kJ); kN = kN.concat(kJ.getPath()) } if (this._config.viewport) { kL._map.setViewport(kN) } } else { if (Object.prototype.toString.call(kM) === "[object Array]") { var kN = []; var kF = kM.length; if (kF < kK) { for (var kG = 0, kD = 0; kG < kK - kF; kG++) { if (kD < kF - 1) { kM.push(kM[kD++]) } else { kM.push(kM[0]) } } } for (var kG = 0; kG < kK; kG++) { var kC = kM[kG]; var kJ = new BMapGL.Polygon(kH.boundaries[kG], { strokeWeight: kI, strokeColor: T, strokeOpacity: e, fillColor: kC, fillOpacity: kE }); kJ.style = { strokeWeight: kI, strokecolor: T, strokeOpacity: e, fillColor: kC, fillOpacity: kE }; this.disOverlays.push(kJ); this.addEventListenerIn(); kL._map.addOverlay(kJ); kN = kN.concat(kJ.getPath()) } if (this._config.viewport) { kL._map.setViewport(kN) } } } }, _parseGeoData: function (kL) { var kO = {}; kO.boundaries = []; if (kL && kL.content && kL.content["geo"]) { for (var kT = 0; kT < kL.content["geo"].length; kT++) { var kC = bP.parseGeo(kL.content["geo"][kT], false); if (kC.geo && kC.geo.length && kC.geo.length > 0) { var kR = kC.geo.length; for (jN = 0; jN < kR; jN++) { var T = kC.geo[jN]; if (T && T.length && T.length > 0) { var kJ = T.length - 1; var kQ = []; var kI = false; var kP = 0; var kN = 0; for (var kS = 0; kS < kJ; kS += 2) { var kG = T[kS]; var kE = T[kS + 1]; var kM = new cG(kG, kE); kM = jy.convertMC2LL(kM); if (kS < kJ - 3) { var i = T[kS + 2]; var e = T[kS + 3]; var kK = new cG(i, e); kK = jy.convertMC2LL(kK) } kQ.push(kM.lng + ", " + kM.lat) } if (kI === true) { if (kP > kN) { var kU = kP; kP = kN; kN = kU } var kH = kQ; var kF = kQ.splice(kP + 1); var kD = kF.splice(kN - kP); kH = kH.concat(kD); kO.boundaries.push(kH.join(";")); kO.boundaries.push(kF.join(";")); kI = false; continue } if (kQ.length !== 0) { kO.boundaries.push(kQ.join(";")) } } } } } } return kO }, deleteDistrict: function (kC) { var T = kC.disOverlays; for (var e = 0; e < T.length; e++) { this._map.removeOverlay(T[e]) } }, addEventListener: function (e, i) { this.eventAndCallback[e] = i }, addEventListenerIn: function () { var kC = this; var kE = Object.keys(kC.eventAndCallback); if (kE.length > 0) { for (var T = 0; T < kE.length; T++) { var kD = kC.eventAndCallback[kE[T]]; for (var e = 0; e < kC.disOverlays.length; e++) { kC.disOverlays[e].addEventListener(kE[T], kD) } } } }, searchBoundary: function (i, kD) { i = i || {}; var e = i.name || ""; var T = i.kind || 0; var kC = this; kl.request(function (kF) { var kE = kC._parseGeoData(kF); kD && kD(kE) }, { qt: j4, adnames: e, level: T }) } }); window._layer = 2; })(BMapGL, "BMapGL");